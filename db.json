{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/alipay.jpg","path":"images/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/wechatpay.jpg","path":"images/wechatpay.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/post/message/webrtc_messaging.svg","path":"post/message/webrtc_messaging.svg","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/post/iOS/Objective-C/default_1.png","path":"post/iOS/Objective-C/default_1.png","modified":1,"renderable":1},{"_id":"themes/next/source/post/iOS/Objective-C/default_2.png","path":"post/iOS/Objective-C/default_2.png","modified":1,"renderable":1},{"_id":"themes/next/source/post/iOS/Objective-C/file_preview_1.png","path":"post/iOS/Objective-C/file_preview_1.png","modified":1,"renderable":1},{"_id":"themes/next/source/post/iOS/Objective-C/file_preview_2.png","path":"post/iOS/Objective-C/file_preview_2.png","modified":1,"renderable":1},{"_id":"themes/next/source/post/iOS/Objective-C/file_preview_3.png","path":"post/iOS/Objective-C/file_preview_3.png","modified":1,"renderable":1},{"_id":"themes/next/source/post/iOS/Objective-C/process_2.png","path":"post/iOS/Objective-C/process_2.png","modified":1,"renderable":1},{"_id":"themes/next/source/post/iOS/Objective-C/process_3.png","path":"post/iOS/Objective-C/process_3.png","modified":1,"renderable":1},{"_id":"themes/next/source/post/iOS/Objective-C/process_4.png","path":"post/iOS/Objective-C/process_4.png","modified":1,"renderable":1},{"_id":"themes/next/source/post/iOS/Objective-C/process_6.png","path":"post/iOS/Objective-C/process_6.png","modified":1,"renderable":1},{"_id":"themes/next/source/post/iOS/Objective-C/rendering.gif","path":"post/iOS/Objective-C/rendering.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/post/iOS/iBeacon/uuid_major_minor.png","path":"post/iOS/iBeacon/uuid_major_minor.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/post/bluetooth/location_maximum_likelihood.jpg","path":"post/bluetooth/location_maximum_likelihood.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/post/share/github_pod_create_1.png","path":"post/share/github_pod_create_1.png","modified":1,"renderable":1},{"_id":"themes/next/source/post/bluetooth/location_maximum_likelihood_log.jpg","path":"post/bluetooth/location_maximum_likelihood_log.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/post/share/github_pod_create_2.png","path":"post/share/github_pod_create_2.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/next/source/post/iOS/Other/Introduction-MyFramework-1.png","path":"post/iOS/Other/Introduction-MyFramework-1.png","modified":1,"renderable":1},{"_id":"themes/next/source/post/share/github_pod_update_1.png","path":"post/share/github_pod_update_1.png","modified":1,"renderable":1},{"_id":"themes/next/source/post/share/github_pod_update_2.png","path":"post/share/github_pod_update_2.png","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"340cec882ca9890bc17db3da63debc3fef68bac7","modified":1511520215000},{"_id":"themes/next/.DS_Store","hash":"e9c5e6272d0f332f0a99eb3a207d0611b4d893cb","modified":1511252441000},{"_id":"themes/next/.gitignore","hash":"32ea93f21d8693d5d8fa4eef1c51a21ad0670047","modified":1507891449000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1507891449000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1507891449000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1507891449000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1507891449000},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1507891449000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1507891449000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1507891449000},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1507891449000},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1507891449000},{"_id":"themes/next/README.cn.md","hash":"6d9177e7dad87e6129760e4b559bd3f7a15429d7","modified":1507891449000},{"_id":"themes/next/README.md","hash":"529d53dfa97678f8ce4c95620b26e61154162a29","modified":1509410788000},{"_id":"themes/next/_config.yml","hash":"5bac0ebd35592dce6412770a4c23ec2f27b3ca8c","modified":1511252881000},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1507891449000},{"_id":"themes/next/bower.json","hash":"6d6ae7531cf3fedc97c58cdad664f5793eb3cc88","modified":1507891449000},{"_id":"themes/next/package.json","hash":"93a74dbc0fe3a1208a02e9cec3c15c2375339cc1","modified":1507891449000},{"_id":"source/_posts/algorithm_location_maximum_likelihood.md","hash":"a35a650c3fe5bca0d3a78fe3af2e84fb408acfc6","modified":1507891449000},{"_id":"source/_posts/algorithm_search_binary.md","hash":"a8bfe0d2e0b737f9237e9a1bfbec7e944f73f751","modified":1507891449000},{"_id":"source/_posts/algorithm_sort_count.md","hash":"b727096ce5d127a9d6442009b6ad5db3d048d118","modified":1507891449000},{"_id":"source/_posts/algorithm_sort_insert.md","hash":"ad00f6c9cc17da4f30f01034b48a75ade25d956a","modified":1507891449000},{"_id":"source/_posts/algorithm_sort_merge.md","hash":"da55947eeb9eb449a817587c3a1b0b259fa57977","modified":1507891449000},{"_id":"source/_posts/algorithm_sort_quick.md","hash":"5740c1950e301cc7dbfdc0148bf01ba4078f99a3","modified":1507891449000},{"_id":"source/_posts/bluetooth_central.md","hash":"4be3e4b512e30888db85e71502fe72d5f5b1fce5","modified":1507891449000},{"_id":"source/_posts/bluetooth_central_level.md","hash":"50f0b57ed5540a3a940b9cf5aba9ee0a79539b31","modified":1507891449000},{"_id":"source/_posts/bluetooth_iBeacon2.md","hash":"3584916eddd0f3c418d411a6e59ed553b9a33013","modified":1507891449000},{"_id":"source/_posts/bluetooth_iBeacon1.md","hash":"72be5bb4fd0191eb11d8d7ef187b7b0e6f4539fa","modified":1507891449000},{"_id":"source/_posts/algorithm_sort_radix.md","hash":"ce7d3821c45aed373dc33ca459b951e71536a512","modified":1507891449000},{"_id":"source/_posts/bluetooth_location_maximum_likelihood.md","hash":"3c298398a6f6fa77c10c5680a527a387f9681f1d","modified":1507891449000},{"_id":"source/_posts/bluetooth_peripheral.md","hash":"d291e26997d16d2a51a0018beffa60863aff32f5","modified":1507891449000},{"_id":"source/_posts/database_sqlite3_fmdb.md","hash":"c3063a426638d20fa446d56c6690d2d6d950c33b","modified":1507891449000},{"_id":"source/_posts/iOS_ObjC_LTxMenu_v2.0.0.md","hash":"10a45518d30ebb62298ee98bebbaa2197202b7b2","modified":1507891449000},{"_id":"source/_posts/iOS_ObjC_LTxMenu_v1.0.0.md","hash":"bfe8cc6ae962272499df31b0099dc9921b81af7c","modified":1507891449000},{"_id":"source/_posts/iOS_ObjC_SearchBar.md","hash":"f87e047c88565f3e863ea07c00810c64c230f72f","modified":1507891449000},{"_id":"source/_posts/iOS_ObjC_file_preview.md","hash":"54ac45bfbad157c6eb5c72c9f3f6e7aca5b8c91c","modified":1507891449000},{"_id":"source/_posts/iOS_Swift_language_note_Access-Control.md","hash":"b74533d2a4b9fa8d69d3704e6461489ba516337b","modified":1507891449000},{"_id":"source/_posts/iOS_Swift_language_note_ARC.md","hash":"96a4dd672c2cf5a386d863437399d69d0fc84897","modified":1507891449000},{"_id":"source/_posts/iOS_Swift_language_note_Basic-Operators.md","hash":"1cac03973bf45f4bad09334ce4b330ed23132dce","modified":1507891449000},{"_id":"source/_posts/iOS_Swift_language_note_Classes and Structures.md","hash":"1738fccfae3d3b98a9f36291f5b05de58cef67a3","modified":1507891449000},{"_id":"source/_posts/iOS_Swift_language_note_Closures.md","hash":"8c2ee4821227e77a3b8fcb414fb0dfdbf9e29f63","modified":1507891449000},{"_id":"source/_posts/iOS_Swift_language_note_Collection-Types.md","hash":"b834f4c13214ec0259358b46a58ca8bae649ba39","modified":1507891449000},{"_id":"source/_posts/iOS_Swift_language_note_Control-Flow.md","hash":"019b56afe248867eb57a418686ffaad169d84715","modified":1507891449000},{"_id":"source/_posts/iOS_Swift_language_note_Deinitialization.md","hash":"fa4fcac31737dd88b639719e9651a872792e1e86","modified":1507891449000},{"_id":"source/_posts/iOS_Swift_language_note_Enumerations.md","hash":"866d1e9495c583fbf1bbdcf14afe3828336bf73d","modified":1507891449000},{"_id":"source/_posts/iOS_Swift_language_note_Error-Handling.md","hash":"38106d5991faa60ffcb4cfacf46e86e3f42fe9ef","modified":1507891449000},{"_id":"source/_posts/iOS_Swift_language_note_Extensions.md","hash":"9ffd97e378b69cce071afa758a983e055a4145fb","modified":1507891449000},{"_id":"source/_posts/iOS_Swift_language_note_Functions.md","hash":"13caddfb12d9f2e840079af28d57356c26944c39","modified":1507891449000},{"_id":"source/_posts/iOS_Swift_language_note_Generics.md","hash":"fae20b2f14f1dafe9ec4f31726f9cd5d2c36cdf3","modified":1507891449000},{"_id":"source/_posts/iOS_Swift_language_note_Inheritance.md","hash":"48c1661593474f94affacb7dfb56eff82ccd6c46","modified":1507891449000},{"_id":"source/_posts/iOS_Swift_language_note_Initialization.md","hash":"542fe34f5e899726c157657c7f88042e6235a8f5","modified":1507891449000},{"_id":"source/_posts/iOS_Swift_language_note_Methods.md","hash":"c3849c202c84c45e6237028aa6bb948e1d108d83","modified":1507891449000},{"_id":"source/_posts/iOS_Swift_language_note_Nested-Types.md","hash":"04a18c75d84ab45aaa04c8b17324207c454311de","modified":1507891449000},{"_id":"source/_posts/iOS_Swift_language_note_Optional-Chaining.md","hash":"7581a79e344c0286dc1c9dff7d0aa3779e97d4df","modified":1507891449000},{"_id":"source/_posts/iOS_Swift_language_note_Properties.md","hash":"88f962f37159ca4e1f3a81a8d8aabfc1d79f437d","modified":1507891449000},{"_id":"source/_posts/iOS_Swift_language_note_String-and-Characters.md","hash":"d29ad2f72444d58cac794b8e6b3dd0273ebdd281","modified":1507891449000},{"_id":"source/_posts/iOS_Swift_language_note_Protocols.md","hash":"ba567898095b214c26544ac5482b3890a0354fb8","modified":1507891449000},{"_id":"source/_posts/iOS_develop_ObjC_basic.md","hash":"02936f9acd515ed29737706bf2ccff33790b3c4b","modified":1507891449000},{"_id":"source/_posts/iOS_develop_note_status_bar_style.md","hash":"bf8f768b908b661b29c601ea3b2b54c5d67abd17","modified":1511771329000},{"_id":"source/_posts/iOS_Swift_language_note_Subscripts.md","hash":"51aba8b6f203ff728640a945251116f47be157a5","modified":1507891449000},{"_id":"source/_posts/iOS_Swift_language_note_The-Basics.md","hash":"bb8daccef6898af5a7a6c46fddd7c815bd3b2dda","modified":1507891449000},{"_id":"source/_posts/iOS_Swift_language_note_Type-Casting.md","hash":"126697be507b36cec3a275d41a8f86032652be7b","modified":1507891449000},{"_id":"source/_posts/iOS_develop_overview_framework_1.md","hash":"9c3a646e68e6ad33f3c8de535a5a0236f91c0434","modified":1507891449000},{"_id":"source/_posts/iOS_develop_overview_framework_2.md","hash":"149691d3d6bbf81c2fd3cd4ea27469056c99cb84","modified":1507891449000},{"_id":"source/_posts/iOS_develop_problem_xcode9__tableview.md","hash":"b78252bae302073f1526b7c9ba42ea602f2385cb","modified":1511403103000},{"_id":"source/_posts/iOS_develop_viewController_life_circle.md","hash":"0ad805b7083a0f917f8470fbe0bbeb633594e5b5","modified":1507891449000},{"_id":"source/_posts/ios_instance_message_webrtc_message.md","hash":"15b5bbdce1aa3df4687e9a26a589a1025e6d9388","modified":1511252647000},{"_id":"source/_posts/iOS_develop_problem_xcode9_ios11.md","hash":"a126ca3eb1e578198932fff5151197f84c201e1b","modified":1511399554000},{"_id":"source/_posts/ios_instance_message_xmpp_sign.md","hash":"a97e439e8b910c5c93c4941d1354fe3aee15b44c","modified":1507891449000},{"_id":"source/_posts/ios_instance_message_xmpp_roster.md","hash":"c49912ca0d7ede02380fd05d62691cf7a1ae1b32","modified":1507891449000},{"_id":"themes/next/package-lock.json","hash":"12a3557021ecf4570f4ae6f6ce603177a2d1044e","modified":1507891449000},{"_id":"source/_posts/os_shell_authority_chmod.md","hash":"31b306791d8609f345f29a5a8e85e00109311126","modified":1507891449000},{"_id":"source/_posts/os_shell_authority_chown.md","hash":"4dc6e153ff061d8620a9af21796d207c1d9d210b","modified":1507891449000},{"_id":"source/_posts/os_shell_std_in_out_error_redirect.md","hash":"54fdaa84fe139cb1d626677cdf311bfae54a086b","modified":1507891449000},{"_id":"source/_posts/share_github_blog_hexo.md","hash":"8fdd8ecaec287a892c5ab6a1515fbfdc00a9c8bf","modified":1507891449000},{"_id":"source/_posts/share_github_blog_jekyll.md","hash":"dfff6ef1be888bad5b2d912479bb47897c5f85b8","modified":1507891449000},{"_id":"source/_posts/share_github_pod_usage.md","hash":"a7ab2b5c31ffb1e7a0c6c10af8912386305fb187","modified":1510306716000},{"_id":"source/about/index.md","hash":"325b2ae857a0e53942dcebe74d86149578bdab20","modified":1511161380000},{"_id":"source/categories/index.md","hash":"e9146120a00b805d382563383fe969a0b33feef5","modified":1507891449000},{"_id":"source/schedule/index.md","hash":"63764905bed9aab058b534d00d89c91291beeb09","modified":1507891449000},{"_id":"source/about/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1511147406000},{"_id":"source/tags/index.md","hash":"1129de4f6435b24d2c74d4747fed30eaaa868963","modified":1507891449000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1507891449000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"213d0f6c9c7ed9b035d84486b540a57e24869909","modified":1507891449000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"5d34ae00d5478526664969d0f1fd2cd5d5556e64","modified":1507891449000},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1507891449000},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1507891449000},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1507891449000},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1507891449000},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1507891449000},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1507891449000},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1507891449000},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1507891449000},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1507891449000},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1509410788000},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1507891449000},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1507891449000},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1507891449000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1507891449000},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1507891449000},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1507891449000},{"_id":"themes/next/layout/_layout.swig","hash":"26bd9be87576eaab53aaf178b5ddd84d8bb4cabf","modified":1507891449000},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1507891449000},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1507891449000},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1507891449000},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1507891449000},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1507891449000},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1507891449000},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1507891449000},{"_id":"themes/next/scripts/merge-configs.js","hash":"cb617ddf692f56e6b6129564d52e302f50b28243","modified":1507891449000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1507891449000},{"_id":"themes/next/source/.DS_Store","hash":"08a0241ebe6bc50679bc55214723d703f8e0cfcd","modified":1511252447000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1507891449000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1507891449000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1507891449000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507891449000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1507891449000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1507891449000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1507891449000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1507891449000},{"_id":"themes/next/layout/_macro/post.swig","hash":"7a64914a0a3c893c1aaa8b5349b85898f95af314","modified":1507891449000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1507891449000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"9efc455894921a66bbc074055d3b39c8a34a48a4","modified":1507891449000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1507891449000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"044bc872d7b59655e46f6fb1cf14f767e31a4dfa","modified":1507891449000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1507891449000},{"_id":"themes/next/layout/_partials/head.swig","hash":"4ad10d9b5f689ded7fe3a39fa747136aff3d2442","modified":1507891449000},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1507891449000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1507891449000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1507891449000},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1507891449000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1507891449000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1507891449000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1509410788000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1507891449000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1507891449000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1507891449000},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1507891449000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1507891449000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1507891449000},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1507891449000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1507891449000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1507891449000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1507891449000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1507891449000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1507891449000},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1507891449000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1507891449000},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1507891449000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1507891449000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1507891449000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1507891449000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"a79ca0a4309a433c7650f747a5b60172c1e48f63","modified":1507891449000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1507891449000},{"_id":"themes/next/source/images/avatar.jpg","hash":"88d9568df7d7758a407bf1c80803fba15f8b4f06","modified":1507891449000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1507891449000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1507891449000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1507891449000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1507891449000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1507891449000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1507891449000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1507891449000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"cf9bfaff90ef36191e52beda024e61a76e01945a","modified":1507891449000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"ffb6ed8a52ed33ab6c533c6bff78f1405f9f9687","modified":1507891449000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1507891449000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1507891449000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1507891449000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1507891449000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1507891449000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1507891449000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507891449000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507891449000},{"_id":"themes/next/source/post/.DS_Store","hash":"c2c1ce3a1b9fcd8987b020f79bc9854bf72c442b","modified":1511252435000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507891449000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507891449000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507891449000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507891449000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1507891449000},{"_id":"themes/next/source/images/alipay.jpg","hash":"b4aa64ece89dfb58e4b33d3bb17f3a675231d968","modified":1507891449000},{"_id":"themes/next/source/images/wechatpay.jpg","hash":"9667ad26ddcf60594cb8bf9c466c2788df072de1","modified":1507891449000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1507891449000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1507891449000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1507891449000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1507891449000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1507891449000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1507891449000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1507891449000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1507891449000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1507891449000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1507891449000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1507891449000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1507891449000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1507891449000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1507891449000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1507891449000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1507891449000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1507891449000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1507891449000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1507891449000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1507891449000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1507891449000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1507891449000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1507891449000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1507891449000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1507891449000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1507891449000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1507891449000},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1509410788000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1507891449000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1507891449000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1507891449000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"f780973e0f8c2e52a70ac5e927af845d7b547b71","modified":1509410788000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1507891449000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1507891449000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1507891449000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1507891449000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1507891449000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1507891449000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1507891449000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1507891449000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1507891449000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1507891449000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1507891449000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1507891449000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1507891449000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1507891449000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1507891449000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1507891449000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1507891449000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1507891449000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1507891449000},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1507891449000},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1507891449000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1507891449000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1507891449000},{"_id":"themes/next/source/js/src/utils.js","hash":"dbdc3d1300eec7da9632608ebc0e5b697779dad7","modified":1507891449000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1507891449000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1507891449000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"7fd2f3e2773555392ef40df40cae3bedb884f17a","modified":1507891449000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1507891449000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1507891449000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1507891449000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1507891449000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1507891449000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1507891449000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1507891449000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1507891449000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1507891449000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1507891449000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1507891449000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1507891449000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1507891449000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1507891449000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1507891449000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1507891449000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1507891449000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1507891449000},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1507891449000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1507891449000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1507891449000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1507891449000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1507891449000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1507891449000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1507891449000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1507891449000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1507891449000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1507891449000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1507891449000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1507891449000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1507891449000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1507891449000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1507891449000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1507891449000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1507891449000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1507891449000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1507891449000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1507891449000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1507891449000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1507891449000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1507891449000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1507891449000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1507891449000},{"_id":"themes/next/source/post/iOS/.DS_Store","hash":"a27bbf0b1801655aecaf64cb2bfb351b4470a630","modified":1511252208000},{"_id":"themes/next/source/post/message/webrtc_messaging.svg","hash":"2a0c3eebf131781593d213d3f0404a1d391f320b","modified":1511249776000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1507891449000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1507891449000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1507891449000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1507891449000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1507891449000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1507891449000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1507891449000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1507891449000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1507891449000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1507891449000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1507891449000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1507891449000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1507891449000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1507891449000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1507891449000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1507891449000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1507891449000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1507891449000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1507891449000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1507891449000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"02fb8fa6b6c252b6bed469539cd057716606a787","modified":1509410788000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1507891449000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1507891449000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1507891449000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1507891449000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1507891449000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1507891449000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1507891449000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"bcf52192942c0afc410c74a0fb458e7936ddc3d5","modified":1507891449000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1507891449000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1507891449000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1507891449000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1507891449000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1507891449000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1507891449000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1507891449000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1507891449000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1507891449000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1507891449000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1507891449000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1507891449000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1507891449000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1507891449000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1507891449000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1507891449000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1507891449000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1507891449000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1507891449000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1507891449000},{"_id":"themes/next/source/post/iOS/Objective-C/default_1.png","hash":"208623b74f44baefa5e4952c576ee8cb63512bc8","modified":1507891449000},{"_id":"themes/next/source/post/iOS/Objective-C/default_2.png","hash":"179681b3763b3069df5e514ffd055f7770089d83","modified":1507891449000},{"_id":"themes/next/source/post/iOS/Objective-C/file_preview_1.png","hash":"72ddadaf15f302b19d6e7821d333cd9ddb99ca2f","modified":1507891449000},{"_id":"themes/next/source/post/iOS/Objective-C/file_preview_2.png","hash":"3cf6ff9f63fd1a520bf3c365de9c0c75138c6598","modified":1507891449000},{"_id":"themes/next/source/post/iOS/Objective-C/file_preview_3.png","hash":"139d2f411efdd2e5bec2cdaa949edd7bd295d7ce","modified":1507891449000},{"_id":"themes/next/source/post/iOS/Objective-C/process_2.png","hash":"04b4e182957c1c94334fe7c8d069c3b1f892787d","modified":1507891449000},{"_id":"themes/next/source/post/iOS/Objective-C/process_3.png","hash":"3fbd1feda2101b980f10dba230a817c23a102877","modified":1507891449000},{"_id":"themes/next/source/post/iOS/Objective-C/process_4.png","hash":"c4a17051adcce704e497226df5d70dcd8d6278d5","modified":1507891449000},{"_id":"themes/next/source/post/iOS/Objective-C/process_6.png","hash":"bf339a827cd5945441c27e7c408ec68254a832ad","modified":1507891449000},{"_id":"themes/next/source/post/iOS/Objective-C/rendering.gif","hash":"8b7745f3a9c3dcc0e3e1ef97f4e21d8a8a6b62ce","modified":1507891449000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1507891449000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1507891449000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1507891449000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1507891449000},{"_id":"themes/next/source/post/iOS/iBeacon/uuid_major_minor.png","hash":"92143b6f118abab0edd9ca3668ed1cf7755b6624","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"77c92a449ce84d558d26d052681f2e0dd77c70c9","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1507891449000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1507891449000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1507891449000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1507891449000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1507891449000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1507891449000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1507891449000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1507891449000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1507891449000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1507891449000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1507891449000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1507891449000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1507891449000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1507891449000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1507891449000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1507891449000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1507891449000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1507891449000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1507891449000},{"_id":"themes/next/source/post/bluetooth/location_maximum_likelihood.jpg","hash":"e895e750a7b3afb880b955e2ca084ab9529256de","modified":1507891449000},{"_id":"themes/next/source/post/share/github_pod_create_1.png","hash":"cb55ae6716d791758280d1f7c4ba81683bc3363f","modified":1508125267000},{"_id":"themes/next/source/post/bluetooth/location_maximum_likelihood_log.jpg","hash":"70a1b5bfece76623c8c7c6c60df74aec969b1f94","modified":1507891449000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1507891449000},{"_id":"themes/next/source/post/share/github_pod_create_2.png","hash":"a0092604f576d82e594ef73f14fd1ae670a45c71","modified":1508141412000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1507891449000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1507891449000},{"_id":"themes/next/source/post/iOS/Other/Introduction-MyFramework-1.png","hash":"e2c30ca1acef7cb7c7fb08df91696a635e83eb9c","modified":1507891449000},{"_id":"themes/next/source/post/share/github_pod_update_1.png","hash":"2eb2e1578ee585ac189497a4b796bc3ebbc7bf94","modified":1508484735000},{"_id":"themes/next/source/post/share/github_pod_update_2.png","hash":"99e364150dde5926767ee60943590c99dcf2c118","modified":1508484766000},{"_id":"public/baidusitemap.xml","hash":"e4b879129a8cf5775629adf0063950b84c77e8fa","modified":1511771428398},{"_id":"public/search.xml","hash":"62419a54817f0c1085c37331079edf71bc1ca8d2","modified":1511771428465},{"_id":"public/sitemap.xml","hash":"bbe4944ac8e175042dd8c7de60fc2b5177d3ed2d","modified":1511771428466},{"_id":"public/about/index.html","hash":"fb38dcbbdf3e13d0baa8fb2289b450e8ce691819","modified":1511771428488},{"_id":"public/categories/index.html","hash":"38b32dc6aca686bad9b1dfc17957ca087818fe02","modified":1511771428488},{"_id":"public/schedule/index.html","hash":"0f90537a9e2c1c61195ddfab3685a7e63a3964c0","modified":1511771428488},{"_id":"public/tags/index.html","hash":"e7a5a89854fdb253318aa077c3b440ea6db93560","modified":1511771428488},{"_id":"public/2017/11/27/iOS_develop_note_status_bar_style/index.html","hash":"208549b523f47e2d138a6fbc1f61e0fe74304a2c","modified":1511771428488},{"_id":"public/2017/11/22/iOS_develop_problem_xcode9_ios11/index.html","hash":"50a0fb4369eef1b52b71f83aec52a9f73dc38d62","modified":1511771428489},{"_id":"public/2017/11/21/ios_instance_message_webrtc_message/index.html","hash":"cc1dbee32bf1fab004a282c2903b793ca3134bff","modified":1511771428489},{"_id":"public/2017/11/01/iOS_develop_problem_xcode9__tableview/index.html","hash":"ce34ba028ac26208c33d4ce5c56bdad9d2122c6b","modified":1511771428489},{"_id":"public/2017/10/16/share_github_pod_usage/index.html","hash":"1afa9f88a0f7d9a2fd47e86f5ab7618af29a2f69","modified":1511771428489},{"_id":"public/2017/10/12/ios_instance_message_xmpp_roster/index.html","hash":"b91176352fd5558bc2c24ac313d90c4867a5214c","modified":1511771428489},{"_id":"public/2017/09/22/ios_instance_message_xmpp_sign/index.html","hash":"8e0ffcd8d4b3f693ed9d932a3c5cc2bb948053fd","modified":1511771428489},{"_id":"public/2017/08/29/os_shell_std_in_out_error_redirect/index.html","hash":"2b6a3e45b621b646b7fe1c0f47c7baa9ede87f7e","modified":1511771428489},{"_id":"public/2017/08/28/os_shell_authority_chown/index.html","hash":"aa2237098990250ce9dc725de9cac4d0ea9d2658","modified":1511771428489},{"_id":"public/2017/08/24/bluetooth_central_level/index.html","hash":"048c431c87900f4add55825988b6641815dce59b","modified":1511771428489},{"_id":"public/2017/08/23/bluetooth_location_maximum_likelihood/index.html","hash":"e7090fb75c8efb275e0d7191aea36420adb9dcc7","modified":1511771428490},{"_id":"public/2017/08/23/algorithm_location_maximum_likelihood/index.html","hash":"a963ead1d97db80b999c97702c34ad42634a5755","modified":1511771428490},{"_id":"public/2017/08/17/os_shell_authority_chmod/index.html","hash":"6cb12ffcb0cb3104d6deaead85b00fd5a4f7ea53","modified":1511771428490},{"_id":"public/2017/08/08/bluetooth_peripheral/index.html","hash":"136a709f257df15624a584f147b4aa6517cda92d","modified":1511771428490},{"_id":"public/2017/08/07/share_github_blog_jekyll/index.html","hash":"f2b4dd99dfc0fbaf12e854d319efd5effa4de7a1","modified":1511771428490},{"_id":"public/2017/08/04/share_github_blog_hexo/index.html","hash":"8243f01b1b32911cf019415a4ad27e93ea3e80ee","modified":1511771428490},{"_id":"public/2017/07/27/bluetooth_central/index.html","hash":"ea874d8d4e8141b1cf8927a44b314850df88d5d0","modified":1511771428490},{"_id":"public/2017/06/19/iOS_ObjC_file_preview/index.html","hash":"875f90ac6f978e97a630ac0cd8a54be15c847278","modified":1511771428490},{"_id":"public/2017/06/13/algorithm_sort_radix/index.html","hash":"5bca2b538312ededf7873bfd9e86e9eb576d8515","modified":1511771428490},{"_id":"public/2017/05/19/iOS_ObjC_LTxMenu_v2.0.0/index.html","hash":"4cb6bdcf529ceda33f114726d865aea00def9470","modified":1511771428490},{"_id":"public/2017/05/18/algorithm_sort_count/index.html","hash":"0e8ff75447d225901162c7b3ecb8ec0a23dc770d","modified":1511771428490},{"_id":"public/2017/05/11/algorithm_sort_quick/index.html","hash":"fbae74039e26dab21b0d299065f42b0cebce8bb2","modified":1511771428490},{"_id":"public/2017/04/27/database_sqlite3_fmdb/index.html","hash":"6349ad925f1448ea89290d41d19291cd5e77859d","modified":1511771428491},{"_id":"public/2017/04/27/algorithm_search_binary/index.html","hash":"de013b1a81b3068925ead1afbba75a1f831969f6","modified":1511771428491},{"_id":"public/2017/04/26/algorithm_sort_merge/index.html","hash":"e384ddeefea52764e6f4fb112e3b216f1e4c363b","modified":1511771428491},{"_id":"public/2017/04/25/algorithm_sort_insert/index.html","hash":"ef9ed3a1ba7d3bc422eceb415b148abe7e33df54","modified":1511771428491},{"_id":"public/2017/03/13/bluetooth_iBeacon2/index.html","hash":"0b1dd7e7749c5835ead50ded98776a33498ca4f1","modified":1511771428491},{"_id":"public/2017/02/11/bluetooth_iBeacon1/index.html","hash":"d1a27ed5a0009f38bb2307b975529643b7d73af9","modified":1511771428491},{"_id":"public/2016/12/21/iOS_develop_overview_framework_2/index.html","hash":"a88c215bf5f8599d6ab28d4d57d5b16aa7def6c7","modified":1511771428491},{"_id":"public/2016/12/05/iOS_Swift_language_note_Access-Control/index.html","hash":"e666974b3089c6206dc2a2f6ffe89edf4854c411","modified":1511771428491},{"_id":"public/2016/12/02/iOS_Swift_language_note_Generics/index.html","hash":"2670abdd0a32a3a8b55037aa2386157e47449f36","modified":1511771428491},{"_id":"public/2016/12/02/iOS_Swift_language_note_Protocols/index.html","hash":"98ea94435ceed86b3a65c2c14d1c58733f398d60","modified":1511771428491},{"_id":"public/2016/12/01/iOS_Swift_language_note_Extensions/index.html","hash":"df54fe70144d7aba0babfb5f659deca50f0c98c1","modified":1511771428491},{"_id":"public/2016/12/01/iOS_Swift_language_note_Nested-Types/index.html","hash":"ab2b08e8aea5d52c836f0e2ccb2cf6f6a271ae32","modified":1511771428491},{"_id":"public/2016/11/30/iOS_Swift_language_note_Error-Handling/index.html","hash":"eb647a38e5b640b804a749874dcdb63cde81bf62","modified":1511771428491},{"_id":"public/2016/11/30/iOS_Swift_language_note_Type-Casting/index.html","hash":"b7eab69d1aeeda2a077ab75fe0d053df507fb63d","modified":1511771428491},{"_id":"public/2016/11/30/iOS_Swift_language_note_Optional-Chaining/index.html","hash":"defa9a7f35bf1802a0055bf0b6580f160852898f","modified":1511771428491},{"_id":"public/2016/11/29/iOS_Swift_language_note_ARC/index.html","hash":"7b62e2557843a728d796a75e282f52ce4a3724b5","modified":1511771428492},{"_id":"public/2016/11/28/iOS_Swift_language_note_Deinitialization/index.html","hash":"20e5a31db4f2091d35232bc1f055082e79305f67","modified":1511771428492},{"_id":"public/2016/11/27/iOS_Swift_language_note_Initialization/index.html","hash":"e92944711eb39f2c624f582ce4224e063264f751","modified":1511771428492},{"_id":"public/2016/11/26/iOS_Swift_language_note_Subscripts/index.html","hash":"a930b3c4dca56641f40f6f3bee1c5327427ca019","modified":1511771428492},{"_id":"public/2016/11/26/iOS_Swift_language_note_Inheritance/index.html","hash":"53618c884f5f0ad47f5ed3d7754fb0d8a4958bb6","modified":1511771428492},{"_id":"public/2016/11/25/iOS_Swift_language_note_Methods/index.html","hash":"e5fb896c22d2997b82dbb3c3a13619637c6b138b","modified":1511771428492},{"_id":"public/2016/11/25/iOS_Swift_language_note_Properties/index.html","hash":"a085541ce96e1653ccb62196421a81ef07802980","modified":1511771428492},{"_id":"public/2016/11/24/iOS_Swift_language_note_Classes and Structures/index.html","hash":"254c0f693ab68db9146b45fe93f0dc2cb88fca29","modified":1511771428492},{"_id":"public/2016/11/23/iOS_Swift_language_note_Enumerations/index.html","hash":"d7616ccf845c55c5b57955c412b0fe38508c42d1","modified":1511771428492},{"_id":"public/2016/11/22/iOS_Swift_language_note_Closures/index.html","hash":"3aa75155a0ecb7c5e45c5e7604f2079d236d66b5","modified":1511771428492},{"_id":"public/2016/11/20/iOS_Swift_language_note_Functions/index.html","hash":"f1487c93485d53e1c43699f805040220d4ad8257","modified":1511771428492},{"_id":"public/2016/11/17/iOS_Swift_language_note_Control-Flow/index.html","hash":"de73b9ce63a3a6a5a34bb8dc0a81c99ec6247389","modified":1511771428492},{"_id":"public/2016/11/06/iOS_Swift_language_note_Collection-Types/index.html","hash":"2de91134a43236e16a4390e4be3761a82f14929c","modified":1511771428492},{"_id":"public/2016/11/05/iOS_Swift_language_note_String-and-Characters/index.html","hash":"079650121b1ff85ac2cc40c0c41aab1108c99f54","modified":1511771428492},{"_id":"public/2016/11/04/iOS_Swift_language_note_Basic-Operators/index.html","hash":"dfa8266814ac9aa59e93e9a0b5a821ecc213624f","modified":1511771428493},{"_id":"public/2016/11/02/iOS_Swift_language_note_The-Basics/index.html","hash":"3e0f12363b38f4a3e32729d660497b78bada3263","modified":1511771428493},{"_id":"public/2016/10/30/iOS_develop_ObjC_basic/index.html","hash":"2c5634fd48d116074842821d1d567f5b27dbb344","modified":1511771428493},{"_id":"public/2016/10/25/iOS_develop_viewController_life_circle/index.html","hash":"401b37b4e5c598a70d9917cc85dee51c89463ef8","modified":1511771428493},{"_id":"public/2016/10/21/iOS_develop_overview_framework_1/index.html","hash":"542056316c17e977e7f1abe67b2cd045e136a0c5","modified":1511771428493},{"_id":"public/2016/10/20/iOS_ObjC_LTxMenu_v1.0.0/index.html","hash":"0689e4f0d5516677d469e27bea1c003728b203b0","modified":1511771428493},{"_id":"public/2016/10/19/iOS_ObjC_SearchBar/index.html","hash":"6aa1ec0d7f04aa477b130c641800101f9beefd5e","modified":1511771428493},{"_id":"public/archives/index.html","hash":"61c018c55493bba8135ea58f7e78c4f0b4c16b61","modified":1511771428493},{"_id":"public/archives/page/2/index.html","hash":"5850d92a9fcc2c7066151058297bcd449d0e382d","modified":1511771428493},{"_id":"public/archives/page/3/index.html","hash":"1fd6445e88054a70afed16aa2724fba7ed31275c","modified":1511771428493},{"_id":"public/archives/page/4/index.html","hash":"e9d8555065cdf3890879b089e6329b1b6f200593","modified":1511771428493},{"_id":"public/archives/page/5/index.html","hash":"7bc0f51ef17a98cdc95c4ec50ae1da3d562f9718","modified":1511771428493},{"_id":"public/archives/page/6/index.html","hash":"be99c955da9dd9761811aa77679dfaf0405c7798","modified":1511771428493},{"_id":"public/archives/2016/index.html","hash":"581fd089445d825d80351205feab813f96069f5a","modified":1511771428493},{"_id":"public/archives/2016/page/2/index.html","hash":"df877d153e042b60c21d50d97e35a5f1a799ed09","modified":1511771428493},{"_id":"public/archives/2016/page/3/index.html","hash":"bdb8f9a26b83f48bcba02c75f8aecd8534f93211","modified":1511771428493},{"_id":"public/archives/2016/10/index.html","hash":"d953df7b6209c4c8ef8b2b6258749666bc3bfe5d","modified":1511771428493},{"_id":"public/archives/2016/11/index.html","hash":"cb7e5012c30a4f9244e94f26c35c5d1d94891fc0","modified":1511771428494},{"_id":"public/archives/2016/11/page/2/index.html","hash":"0ccb9e5f459027275756a62ccfccba5bbb00c129","modified":1511771428494},{"_id":"public/archives/2016/12/index.html","hash":"19aeaf52a1ef94e748f85a3e4d0d7f0cbce8b3d6","modified":1511771428494},{"_id":"public/archives/2017/index.html","hash":"cc379048dc6402dc32281990c4cf8a6ea9267e46","modified":1511771428494},{"_id":"public/archives/2017/page/2/index.html","hash":"734513b029031418af8c9788e1d70452c195461f","modified":1511771428494},{"_id":"public/archives/2017/page/3/index.html","hash":"6cef13a4e4529850e2f7351d8fb56c15c8293e2a","modified":1511771428494},{"_id":"public/archives/2017/02/index.html","hash":"5457bf2a2c18f571abe3cea184fc243f558d5461","modified":1511771428494},{"_id":"public/archives/2017/03/index.html","hash":"f7fcee96e125c49129a2d0f4d46afe53bd587f60","modified":1511771428494},{"_id":"public/archives/2017/04/index.html","hash":"4648a078f6f2490bc1c5d6f1cd36b67e39c84e55","modified":1511771428494},{"_id":"public/archives/2017/05/index.html","hash":"c2315a258db6b4bd45f9fe0fa21534b68acc4cc5","modified":1511771428494},{"_id":"public/archives/2017/06/index.html","hash":"bf946ed5f23d8a0c06c178ecaa319eaf3439d34d","modified":1511771428494},{"_id":"public/archives/2017/07/index.html","hash":"8f2213bcd3a3814509a780e56bdc619cd8a6bf1b","modified":1511771428494},{"_id":"public/archives/2017/08/index.html","hash":"fb690e085dd5d11a2d92829cddd95bc47d590931","modified":1511771428494},{"_id":"public/archives/2017/09/index.html","hash":"7a20a51fd1ec4a71b8e02777ce379d8c472620c9","modified":1511771428494},{"_id":"public/archives/2017/10/index.html","hash":"4c2886b4f5c2139b29a720bffe6e1b052c622492","modified":1511771428494},{"_id":"public/archives/2017/11/index.html","hash":"8b3cbb5ef64978e2dac5b37e1f1a119d1cf9cf70","modified":1511771428494},{"_id":"public/categories/Algorithm/index.html","hash":"88ebf101d82e7df57e33bbf5a74d4886fbf33fc1","modified":1511771428494},{"_id":"public/categories/蓝牙/index.html","hash":"74ed6b53694f49ef712d281211285216fd3a6a1c","modified":1511771428494},{"_id":"public/categories/Database/index.html","hash":"ab9e5522a434349b107e7f04e59f0148af8bdae1","modified":1511771428495},{"_id":"public/categories/iOS/index.html","hash":"3b87a96f6448bdc45bab8cede1883c13f42f20e9","modified":1511771428495},{"_id":"public/categories/iOS/page/2/index.html","hash":"ed24058bd733bf965a50d0ac647f34e1bf98151c","modified":1511771428495},{"_id":"public/categories/iOS/page/3/index.html","hash":"c1bb4096692fcd9e73398f4a71a7634dd8c6deb6","modified":1511771428495},{"_id":"public/categories/iOS/page/4/index.html","hash":"a8f446cd8f4720e229411eee43722a4e4a2443aa","modified":1511771428495},{"_id":"public/categories/即时通讯/index.html","hash":"5de5b11907de71654d0ad33065f369ce73b551ce","modified":1511771428495},{"_id":"public/categories/操作系统/index.html","hash":"8b3b755c762d01ac06d476a5a50da2583762c085","modified":1511771428495},{"_id":"public/categories/技术分享/index.html","hash":"a9c1b6ca963e5357d33f017eb687fdd9f817480e","modified":1511771428495},{"_id":"public/index.html","hash":"b39175390a075c793765b0d115f3422cf4533516","modified":1511771428495},{"_id":"public/page/2/index.html","hash":"91c32fb8bf45f06bde3748815fc7ce80d8974975","modified":1511771428495},{"_id":"public/page/3/index.html","hash":"81c48759552acbd8460185e4585ca9f0ab23dee0","modified":1511771428495},{"_id":"public/page/4/index.html","hash":"edd7c5126c929cd8efd93771a7565a25e3e746bb","modified":1511771428495},{"_id":"public/page/5/index.html","hash":"3e6a257bbbe7fdf759e2ad4e9d6ab3472a811260","modified":1511771428495},{"_id":"public/page/6/index.html","hash":"f13ee5a365731cc2e71c7cb51aaa9162794afd54","modified":1511771428495},{"_id":"public/page/7/index.html","hash":"b566a5a52dd316081a854efb8d53a7e7c1d3674a","modified":1511771428495},{"_id":"public/page/8/index.html","hash":"bf892e6a67aa941fa67af629f085814457e22a16","modified":1511771428495},{"_id":"public/page/9/index.html","hash":"f5cab4969662c967a903851569c0e25e6b449728","modified":1511771428495},{"_id":"public/page/10/index.html","hash":"5bd0993ee0590826901cbc72700c2534725230cc","modified":1511771428495},{"_id":"public/page/11/index.html","hash":"529fc3e0c9700c42f8918ce3abe78092b5f2c030","modified":1511771428495},{"_id":"public/page/12/index.html","hash":"4e51803476be505b2daf302e4792c48d1f8cb2d7","modified":1511771428495},{"_id":"public/page/13/index.html","hash":"70dab910eb6ca3e15a3e884121b2b98768569894","modified":1511771428496},{"_id":"public/page/14/index.html","hash":"eb730ce8cd07708fd0bccc7e3f75f659e91c0465","modified":1511771428496},{"_id":"public/page/15/index.html","hash":"5aa55a81c48896e36c51add206691e3f8d681ee4","modified":1511771428496},{"_id":"public/page/16/index.html","hash":"f680c87e3acc3467cf5d68d5c3ca9189e580c61f","modified":1511771428496},{"_id":"public/page/17/index.html","hash":"288b7cb09fd4c0dc2d1190930bfc857ac8de072c","modified":1511771428496},{"_id":"public/page/18/index.html","hash":"9807d94cf4269ef08856bf5cb0888c284d7e475a","modified":1511771428496},{"_id":"public/page/19/index.html","hash":"1a695679120e6e0252c8e967eb745b2469d646ca","modified":1511771428496},{"_id":"public/page/20/index.html","hash":"fefc0390d7af8d770dfd802ceb37da5e6475fd26","modified":1511771428496},{"_id":"public/tags/位置/index.html","hash":"e9f92a49eaf0c28027fee847ea5fcac7eecd03d9","modified":1511771428496},{"_id":"public/tags/Search/index.html","hash":"b5d693b76a0c57c9e601f184c4189c4ed4588c84","modified":1511771428496},{"_id":"public/tags/Sort/index.html","hash":"e3ec248ff8f9be301ceef366a084a40cea4e5016","modified":1511771428496},{"_id":"public/tags/Bluetooth/index.html","hash":"da3cb95c6d39329b5437bd2f76e75f5a83997cfb","modified":1511771428496},{"_id":"public/tags/iBeacon/index.html","hash":"a5fe15bfa3d526e734c23d06ea76a643d1445aae","modified":1511771428496},{"_id":"public/tags/SQLite3/index.html","hash":"059d349e65f0896fc67a49de42a6fca00d27aeee","modified":1511771428496},{"_id":"public/tags/Menu/index.html","hash":"f46cf24ba362d2735e5e4ec4073373b42e0a2280","modified":1511771428496},{"_id":"public/tags/Note/index.html","hash":"422eddccad5f5d7cf88337a9e0d64def1d08df87","modified":1511771428496},{"_id":"public/tags/Swift/index.html","hash":"a741e4e7b5351c3c31365f0dceff58b82bd83a10","modified":1511771428496},{"_id":"public/tags/Swift/page/2/index.html","hash":"68dde7fe0d73346d1605cb8b541b284a2c8d5e5c","modified":1511771428496},{"_id":"public/tags/Swift/page/3/index.html","hash":"41a3bd7abe71881a236a9123eaacd81084889fe6","modified":1511771428496},{"_id":"public/tags/随笔/index.html","hash":"05196b5048779c63cbef14343e5369645fd6ff83","modified":1511771428497},{"_id":"public/tags/问题记录/index.html","hash":"e1addf87e434f8d8dc5d6637c32b2ae69a4e76e6","modified":1511771428498},{"_id":"public/tags/WebRTC/index.html","hash":"a81efb2dccdf67deec3db8828e7f05c9989d68c9","modified":1511771428498},{"_id":"public/tags/xmpp/index.html","hash":"43a0e2bdeaacdf7f0f18b3d7fa46c743c5c043d7","modified":1511771428498},{"_id":"public/tags/shell/index.html","hash":"450b672572ab1d12e6fbe83a2bc41258e8de68b8","modified":1511771428498},{"_id":"public/tags/GitHub/index.html","hash":"910b15de5a4d27cec25f12e544f249ffb0e0f31e","modified":1511771428498},{"_id":"public/tags/GitHub-CocoaPods/index.html","hash":"7a461fefa78e44860945a6e5facedabd0ff1ab62","modified":1511771428498},{"_id":"public/images/apple-touch-icon-next.png","hash":"a79ca0a4309a433c7650f747a5b60172c1e48f63","modified":1511771428510},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1511771428510},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1511771428510},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1511771428510},{"_id":"public/images/avatar.jpg","hash":"88d9568df7d7758a407bf1c80803fba15f8b4f06","modified":1511771428510},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1511771428510},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1511771428510},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1511771428510},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1511771428510},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1511771428510},{"_id":"public/images/favicon-32x32-next.png","hash":"ffb6ed8a52ed33ab6c533c6bff78f1405f9f9687","modified":1511771428510},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1511771428510},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1511771428511},{"_id":"public/images/favicon-16x16-next.png","hash":"cf9bfaff90ef36191e52beda024e61a76e01945a","modified":1511771428511},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1511771428511},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1511771428511},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1511771428511},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1511771428511},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1511771428511},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1511771428511},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1511771428511},{"_id":"public/post/message/webrtc_messaging.svg","hash":"2a0c3eebf131781593d213d3f0404a1d391f320b","modified":1511771428511},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1511771428511},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1511771428511},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1511771428511},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1511771428511},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1511771428511},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1511771428511},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1511771428511},{"_id":"public/post/iOS/Objective-C/default_1.png","hash":"208623b74f44baefa5e4952c576ee8cb63512bc8","modified":1511771428511},{"_id":"public/post/iOS/Objective-C/default_2.png","hash":"179681b3763b3069df5e514ffd055f7770089d83","modified":1511771428511},{"_id":"public/post/iOS/Objective-C/file_preview_2.png","hash":"3cf6ff9f63fd1a520bf3c365de9c0c75138c6598","modified":1511771428511},{"_id":"public/post/iOS/Objective-C/file_preview_1.png","hash":"72ddadaf15f302b19d6e7821d333cd9ddb99ca2f","modified":1511771428511},{"_id":"public/post/iOS/Objective-C/process_2.png","hash":"04b4e182957c1c94334fe7c8d069c3b1f892787d","modified":1511771428511},{"_id":"public/post/iOS/Objective-C/process_3.png","hash":"3fbd1feda2101b980f10dba230a817c23a102877","modified":1511771428511},{"_id":"public/post/iOS/Objective-C/file_preview_3.png","hash":"139d2f411efdd2e5bec2cdaa949edd7bd295d7ce","modified":1511771428511},{"_id":"public/post/iOS/Objective-C/process_4.png","hash":"c4a17051adcce704e497226df5d70dcd8d6278d5","modified":1511771428511},{"_id":"public/post/iOS/Objective-C/process_6.png","hash":"bf339a827cd5945441c27e7c408ec68254a832ad","modified":1511771428511},{"_id":"public/post/iOS/Objective-C/rendering.gif","hash":"8b7745f3a9c3dcc0e3e1ef97f4e21d8a8a6b62ce","modified":1511771428511},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1511771428511},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1511771428511},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1511771428511},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1511771428511},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1511771428511},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1511771428511},{"_id":"public/images/alipay.jpg","hash":"b4aa64ece89dfb58e4b33d3bb17f3a675231d968","modified":1511771429926},{"_id":"public/images/wechatpay.jpg","hash":"9667ad26ddcf60594cb8bf9c466c2788df072de1","modified":1511771429928},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1511771429938},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1511771429938},{"_id":"public/post/iOS/iBeacon/uuid_major_minor.png","hash":"92143b6f118abab0edd9ca3668ed1cf7755b6624","modified":1511771429938},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1511771429947},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1511771429947},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1511771429947},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1511771429947},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1511771429947},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1511771429947},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1511771429947},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1511771429947},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1511771429947},{"_id":"public/js/src/utils.js","hash":"dbdc3d1300eec7da9632608ebc0e5b697779dad7","modified":1511771429947},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1511771429947},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1511771429947},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1511771429947},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"7fd2f3e2773555392ef40df40cae3bedb884f17a","modified":1511771429947},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1511771429947},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1511771429947},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1511771429947},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1511771429947},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1511771429947},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1511771429947},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1511771429947},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1511771429947},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1511771429947},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1511771429947},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1511771429947},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1511771429947},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1511771429947},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1511771429947},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1511771429947},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1511771429947},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1511771429947},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1511771429947},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1511771429947},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1511771429947},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1511771429947},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1511771429947},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1511771429947},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1511771429947},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1511771429947},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1511771429947},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1511771429948},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1511771429948},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1511771429948},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1511771429948},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1511771429948},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1511771429948},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1511771429948},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1511771429948},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1511771429948},{"_id":"public/css/main.css","hash":"3680ea535a3f691841aaa68beac39e417d784913","modified":1511771429948},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1511771429948},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1511771429948},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1511771429948},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1511771429948},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1511771429948},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1511771429948},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1511771429948},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1511771429948},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1511771429948},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1511771429948},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1511771429948},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1511771429948},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1511771429948},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1511771429948},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1511771429948},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1511771429948},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1511771429948},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1511771429948},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1511771429949},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1511771429949},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1511771429949},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1511771429949},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1511771429949},{"_id":"public/post/bluetooth/location_maximum_likelihood_log.jpg","hash":"70a1b5bfece76623c8c7c6c60df74aec969b1f94","modified":1511771429962},{"_id":"public/post/share/github_pod_create_1.png","hash":"cb55ae6716d791758280d1f7c4ba81683bc3363f","modified":1511771429962},{"_id":"public/post/bluetooth/location_maximum_likelihood.jpg","hash":"e895e750a7b3afb880b955e2ca084ab9529256de","modified":1511771429963},{"_id":"public/post/share/github_pod_create_2.png","hash":"a0092604f576d82e594ef73f14fd1ae670a45c71","modified":1511771429963},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1511771429969},{"_id":"public/post/iOS/Other/Introduction-MyFramework-1.png","hash":"e2c30ca1acef7cb7c7fb08df91696a635e83eb9c","modified":1511771429969},{"_id":"public/post/share/github_pod_update_1.png","hash":"2eb2e1578ee585ac189497a4b796bc3ebbc7bf94","modified":1511771430006},{"_id":"public/post/share/github_pod_update_2.png","hash":"99e364150dde5926767ee60943590c99dcf2c118","modified":1511771430008}],"Category":[{"name":"Algorithm","_id":"cjahxo4rl0002oko8u1ips845"},{"name":"蓝牙","_id":"cjahxo4s4000koko86xbiuhil"},{"name":"Database","_id":"cjahxo4sf0018oko8fule36y4"},{"name":"iOS","_id":"cjahxo4sg001doko8cju6m1b9"},{"name":"即时通讯","_id":"cjahxo4v7004uoko8u9bksv4f"},{"name":"操作系统","_id":"cjahxo4vc005boko85qapyann"},{"name":"技术分享","_id":"cjahxo4vh005soko8ah1atv6o"}],"Data":[],"Page":[{"title":"关于","date":"2017-08-04T00:39:10.000Z","_content":"\n​\t\n\n​\t\n## 联系方式\n\n - 手机／微信：13253511601\n - Email：l900416@163.com\n - QQ：860969446\n\n---\n\n## 个人信息\n\n - 梁通 ／ 男 ／ 1990\n - 本科 ／ 郑州大学信息工程学院 ／ 软件工程 ／ 普招\n - 工作年限：5年\n - 技术博客：https://l900416.github.io\n - 职位：iOS软件工程师\n - 所在城市：郑州\n\n---\n\n## 工作经历\n\n### [中机六院](http://sippr.cn/) (2014/04 ~ 至今)\n\n#### 道(路)桥系列\n\n道(路)桥系列应用包括： **道(路)桥在线** 、 **项目在线** 、 **地下工程建设** 、 **BIM+** 、 **EPC助手** 、 **监理助手** 、 **高新科技园区** 、 **BIM+(西安)** 等 ，独立负责该项目iOS移动端程序的开发、维护等工作。该系列项目自2015年启动后处于持续开发维护阶段。由郑州市农业路高架桥建设，推广到黄河桥项目，之后持续开发推广到了房屋建设等方面。功能包括进度、问题、地图、建设资料、图纸、隐蔽工程、物料进场、现场巡检、消息、项目报表、实时监控、日志、审批、蓝牙测量等多种功能。从初版做成到后续持续更新，该项目的架构经过了MVC -> MVVM -> MVMCV变种，代码结构逐步清晰，为开发和维护等工作提供了便捷。[路桥安装试用](http://121.40.49.148/eepm)\n\n#### 六院系列\n\n六院系列包括： **效率助手** 、 **知识库** ，，负责该系列项目iOS移动端程序的开发、维护等工作。效率助手定位是企业办公助手，她与企业办公联动，实时推送包括经营、生产、项目等相关报表信息，提供：公文处理、公文阅读、合同评审、报销审批、工作日志、考勤管理、会议管理、用印申请、经营跟踪、计划变更／确认、银行保函等多种业务处理能力。知识库为归档的企业知识文档提供便捷的查阅能力，便于内部人员学习交流。其中效率助手于2015年获得 **河南省优秀工程勘察设计一等奖** 、 **郑州市优秀工程勘察设计行业奖一等奖** 。[效率助手安装试用](http://eepm.sippr.cn/Assistant.html)\n\n#### 位置服务\n\nALE(位置服务平台)是基于Wi-Fi、iBeacon技术。除了满足室内精确定位功能，还将自身定位结果同建筑BIM等数据打通并提供包括室内(园区)SVG地图的展示、导览、定位、导航；BIM组件的展示；蓝牙、Wi-Fi自定义策略等能力。在此基础上，为 **上烟园区服务** 、 **GBIM位置服务** 项目定制开发了导览、定位、访客、巡更、蓝牙、监控等功能，涉及技术包括SVG、iBeacon、ZMQ、BIM等。独立负责该项目iOS移动端程序的开发、维护等工作。[查看详情](http://125.46.29.147:8860/ccs)\n\n#### 学源\n\n一个仿慕课的在线教育平台。额外定制开发了企业文库、线下培训(蓝牙签到)、任务卡等多种功能。独立负责该项目iOS移动端程序的开发、维护等工作。[更多详情](http://emooc.sippr.cn/)\n\n\n#### 其他\n\n###### 工程勘察\n\n河南省勘察质量监督管理平台，地勘外业备案流程化管理、现场见证与飞行检查联动机制。[更多详情](http://hnkczl.hnjs.gov.cn/)\n\n###### 标准验证\n\n智能制造标准体系结构验证平台，互联网+众验平台。[安装试用](http://125.46.29.147:8801/eepm/sv)\n\n###### EEP数据采集\n\n对所有设备进行编码，可离线进行验收工作，同时可查阅各类设备信息等。为业主提供了进场／系统验收、数据离线／同步、设备信息、在线查询等简单能力。\n\n###### ALE_RES基础资源管理\n\n基于ACE框架，使用Spring+Struct+Hibernate开发的Web基础资源管理平台。主要包括SVG地图资源展示、上传、解析、变更等管理；CP数据管理；指纹数据生成等。从SQL语句编写到前台统计报表展示等。\n\n###### 效率助手后台管理\n\n使用Struct2框架，编写的效率助手后台Web管理系统。\n\n\n### [东软集团（大连）有限公司](http://www.neusoft.com/cn/) (2012/07 ~ 2014/02)\n\n#### 车载导航系统Multimedia（Telematics）机能\n\n受株式会社电装DENSO公司委托，为英菲尼迪（Infiniti）汽车对应包括NAM、EUR、KOR、PRC、JPN、GOM等地区开发导航系统。Telematics只是其中的一个机能，其主要应用就是通过无线网络，随时给行车中的人们提供驾驶、生活所必需的各种信息。期间负责Telema-HMIAPP的SET、OPR、EMC机能开发；同时负责团队的Release工作。[查看详情](http://www.infiniti.com.cn/)\n\n\n---\n\n## 技能清单\n\n- 开发语言\n    - 移动前端：Objective-C/Swift\n    - 嵌入式：C/C++\n    - 服务后端：Java/C#\n- 数据库：MySQL/SQLite\n\n---\n\n","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2017-08-04 08:39:10\n---\n\n​\t\n\n​\t\n## 联系方式\n\n - 手机／微信：13253511601\n - Email：l900416@163.com\n - QQ：860969446\n\n---\n\n## 个人信息\n\n - 梁通 ／ 男 ／ 1990\n - 本科 ／ 郑州大学信息工程学院 ／ 软件工程 ／ 普招\n - 工作年限：5年\n - 技术博客：https://l900416.github.io\n - 职位：iOS软件工程师\n - 所在城市：郑州\n\n---\n\n## 工作经历\n\n### [中机六院](http://sippr.cn/) (2014/04 ~ 至今)\n\n#### 道(路)桥系列\n\n道(路)桥系列应用包括： **道(路)桥在线** 、 **项目在线** 、 **地下工程建设** 、 **BIM+** 、 **EPC助手** 、 **监理助手** 、 **高新科技园区** 、 **BIM+(西安)** 等 ，独立负责该项目iOS移动端程序的开发、维护等工作。该系列项目自2015年启动后处于持续开发维护阶段。由郑州市农业路高架桥建设，推广到黄河桥项目，之后持续开发推广到了房屋建设等方面。功能包括进度、问题、地图、建设资料、图纸、隐蔽工程、物料进场、现场巡检、消息、项目报表、实时监控、日志、审批、蓝牙测量等多种功能。从初版做成到后续持续更新，该项目的架构经过了MVC -> MVVM -> MVMCV变种，代码结构逐步清晰，为开发和维护等工作提供了便捷。[路桥安装试用](http://121.40.49.148/eepm)\n\n#### 六院系列\n\n六院系列包括： **效率助手** 、 **知识库** ，，负责该系列项目iOS移动端程序的开发、维护等工作。效率助手定位是企业办公助手，她与企业办公联动，实时推送包括经营、生产、项目等相关报表信息，提供：公文处理、公文阅读、合同评审、报销审批、工作日志、考勤管理、会议管理、用印申请、经营跟踪、计划变更／确认、银行保函等多种业务处理能力。知识库为归档的企业知识文档提供便捷的查阅能力，便于内部人员学习交流。其中效率助手于2015年获得 **河南省优秀工程勘察设计一等奖** 、 **郑州市优秀工程勘察设计行业奖一等奖** 。[效率助手安装试用](http://eepm.sippr.cn/Assistant.html)\n\n#### 位置服务\n\nALE(位置服务平台)是基于Wi-Fi、iBeacon技术。除了满足室内精确定位功能，还将自身定位结果同建筑BIM等数据打通并提供包括室内(园区)SVG地图的展示、导览、定位、导航；BIM组件的展示；蓝牙、Wi-Fi自定义策略等能力。在此基础上，为 **上烟园区服务** 、 **GBIM位置服务** 项目定制开发了导览、定位、访客、巡更、蓝牙、监控等功能，涉及技术包括SVG、iBeacon、ZMQ、BIM等。独立负责该项目iOS移动端程序的开发、维护等工作。[查看详情](http://125.46.29.147:8860/ccs)\n\n#### 学源\n\n一个仿慕课的在线教育平台。额外定制开发了企业文库、线下培训(蓝牙签到)、任务卡等多种功能。独立负责该项目iOS移动端程序的开发、维护等工作。[更多详情](http://emooc.sippr.cn/)\n\n\n#### 其他\n\n###### 工程勘察\n\n河南省勘察质量监督管理平台，地勘外业备案流程化管理、现场见证与飞行检查联动机制。[更多详情](http://hnkczl.hnjs.gov.cn/)\n\n###### 标准验证\n\n智能制造标准体系结构验证平台，互联网+众验平台。[安装试用](http://125.46.29.147:8801/eepm/sv)\n\n###### EEP数据采集\n\n对所有设备进行编码，可离线进行验收工作，同时可查阅各类设备信息等。为业主提供了进场／系统验收、数据离线／同步、设备信息、在线查询等简单能力。\n\n###### ALE_RES基础资源管理\n\n基于ACE框架，使用Spring+Struct+Hibernate开发的Web基础资源管理平台。主要包括SVG地图资源展示、上传、解析、变更等管理；CP数据管理；指纹数据生成等。从SQL语句编写到前台统计报表展示等。\n\n###### 效率助手后台管理\n\n使用Struct2框架，编写的效率助手后台Web管理系统。\n\n\n### [东软集团（大连）有限公司](http://www.neusoft.com/cn/) (2012/07 ~ 2014/02)\n\n#### 车载导航系统Multimedia（Telematics）机能\n\n受株式会社电装DENSO公司委托，为英菲尼迪（Infiniti）汽车对应包括NAM、EUR、KOR、PRC、JPN、GOM等地区开发导航系统。Telematics只是其中的一个机能，其主要应用就是通过无线网络，随时给行车中的人们提供驾驶、生活所必需的各种信息。期间负责Telema-HMIAPP的SET、OPR、EMC机能开发；同时负责团队的Release工作。[查看详情](http://www.infiniti.com.cn/)\n\n\n---\n\n## 技能清单\n\n- 开发语言\n    - 移动前端：Objective-C/Swift\n    - 嵌入式：C/C++\n    - 服务后端：Java/C#\n- 数据库：MySQL/SQLite\n\n---\n\n","updated":"2017-11-20T07:03:00.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjahxo4tq001voko89946pkfl","content":"<p>​    </p>\n<p>​    </p>\n<h2 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h2><ul>\n<li>手机／微信：13253511601</li>\n<li>Email：l900416@163.com</li>\n<li>QQ：860969446</li>\n</ul>\n<hr>\n<h2 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a>个人信息</h2><ul>\n<li>梁通 ／ 男 ／ 1990</li>\n<li>本科 ／ 郑州大学信息工程学院 ／ 软件工程 ／ 普招</li>\n<li>工作年限：5年</li>\n<li>技术博客：<a href=\"https://l900416.github.io\">https://l900416.github.io</a></li>\n<li>职位：iOS软件工程师</li>\n<li>所在城市：郑州</li>\n</ul>\n<hr>\n<h2 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h2><h3 id=\"中机六院-2014-04-至今\"><a href=\"#中机六院-2014-04-至今\" class=\"headerlink\" title=\"中机六院 (2014/04 ~ 至今)\"></a><a href=\"http://sippr.cn/\" target=\"_blank\" rel=\"external\">中机六院</a> (2014/04 ~ 至今)</h3><h4 id=\"道-路-桥系列\"><a href=\"#道-路-桥系列\" class=\"headerlink\" title=\"道(路)桥系列\"></a>道(路)桥系列</h4><p>道(路)桥系列应用包括： <strong>道(路)桥在线</strong> 、 <strong>项目在线</strong> 、 <strong>地下工程建设</strong> 、 <strong>BIM+</strong> 、 <strong>EPC助手</strong> 、 <strong>监理助手</strong> 、 <strong>高新科技园区</strong> 、 <strong>BIM+(西安)</strong> 等 ，独立负责该项目iOS移动端程序的开发、维护等工作。该系列项目自2015年启动后处于持续开发维护阶段。由郑州市农业路高架桥建设，推广到黄河桥项目，之后持续开发推广到了房屋建设等方面。功能包括进度、问题、地图、建设资料、图纸、隐蔽工程、物料进场、现场巡检、消息、项目报表、实时监控、日志、审批、蓝牙测量等多种功能。从初版做成到后续持续更新，该项目的架构经过了MVC -&gt; MVVM -&gt; MVMCV变种，代码结构逐步清晰，为开发和维护等工作提供了便捷。<a href=\"http://121.40.49.148/eepm\" target=\"_blank\" rel=\"external\">路桥安装试用</a></p>\n<h4 id=\"六院系列\"><a href=\"#六院系列\" class=\"headerlink\" title=\"六院系列\"></a>六院系列</h4><p>六院系列包括： <strong>效率助手</strong> 、 <strong>知识库</strong> ，，负责该系列项目iOS移动端程序的开发、维护等工作。效率助手定位是企业办公助手，她与企业办公联动，实时推送包括经营、生产、项目等相关报表信息，提供：公文处理、公文阅读、合同评审、报销审批、工作日志、考勤管理、会议管理、用印申请、经营跟踪、计划变更／确认、银行保函等多种业务处理能力。知识库为归档的企业知识文档提供便捷的查阅能力，便于内部人员学习交流。其中效率助手于2015年获得 <strong>河南省优秀工程勘察设计一等奖</strong> 、 <strong>郑州市优秀工程勘察设计行业奖一等奖</strong> 。<a href=\"http://eepm.sippr.cn/Assistant.html\" target=\"_blank\" rel=\"external\">效率助手安装试用</a></p>\n<h4 id=\"位置服务\"><a href=\"#位置服务\" class=\"headerlink\" title=\"位置服务\"></a>位置服务</h4><p>ALE(位置服务平台)是基于Wi-Fi、iBeacon技术。除了满足室内精确定位功能，还将自身定位结果同建筑BIM等数据打通并提供包括室内(园区)SVG地图的展示、导览、定位、导航；BIM组件的展示；蓝牙、Wi-Fi自定义策略等能力。在此基础上，为 <strong>上烟园区服务</strong> 、 <strong>GBIM位置服务</strong> 项目定制开发了导览、定位、访客、巡更、蓝牙、监控等功能，涉及技术包括SVG、iBeacon、ZMQ、BIM等。独立负责该项目iOS移动端程序的开发、维护等工作。<a href=\"http://125.46.29.147:8860/ccs\" target=\"_blank\" rel=\"external\">查看详情</a></p>\n<h4 id=\"学源\"><a href=\"#学源\" class=\"headerlink\" title=\"学源\"></a>学源</h4><p>一个仿慕课的在线教育平台。额外定制开发了企业文库、线下培训(蓝牙签到)、任务卡等多种功能。独立负责该项目iOS移动端程序的开发、维护等工作。<a href=\"http://emooc.sippr.cn/\" target=\"_blank\" rel=\"external\">更多详情</a></p>\n<h4 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h4><h6 id=\"工程勘察\"><a href=\"#工程勘察\" class=\"headerlink\" title=\"工程勘察\"></a>工程勘察</h6><p>河南省勘察质量监督管理平台，地勘外业备案流程化管理、现场见证与飞行检查联动机制。<a href=\"http://hnkczl.hnjs.gov.cn/\" target=\"_blank\" rel=\"external\">更多详情</a></p>\n<h6 id=\"标准验证\"><a href=\"#标准验证\" class=\"headerlink\" title=\"标准验证\"></a>标准验证</h6><p>智能制造标准体系结构验证平台，互联网+众验平台。<a href=\"http://125.46.29.147:8801/eepm/sv\" target=\"_blank\" rel=\"external\">安装试用</a></p>\n<h6 id=\"EEP数据采集\"><a href=\"#EEP数据采集\" class=\"headerlink\" title=\"EEP数据采集\"></a>EEP数据采集</h6><p>对所有设备进行编码，可离线进行验收工作，同时可查阅各类设备信息等。为业主提供了进场／系统验收、数据离线／同步、设备信息、在线查询等简单能力。</p>\n<h6 id=\"ALE-RES基础资源管理\"><a href=\"#ALE-RES基础资源管理\" class=\"headerlink\" title=\"ALE_RES基础资源管理\"></a>ALE_RES基础资源管理</h6><p>基于ACE框架，使用Spring+Struct+Hibernate开发的Web基础资源管理平台。主要包括SVG地图资源展示、上传、解析、变更等管理；CP数据管理；指纹数据生成等。从SQL语句编写到前台统计报表展示等。</p>\n<h6 id=\"效率助手后台管理\"><a href=\"#效率助手后台管理\" class=\"headerlink\" title=\"效率助手后台管理\"></a>效率助手后台管理</h6><p>使用Struct2框架，编写的效率助手后台Web管理系统。</p>\n<h3 id=\"东软集团（大连）有限公司-2012-07-2014-02\"><a href=\"#东软集团（大连）有限公司-2012-07-2014-02\" class=\"headerlink\" title=\"东软集团（大连）有限公司 (2012/07 ~ 2014/02)\"></a><a href=\"http://www.neusoft.com/cn/\" target=\"_blank\" rel=\"external\">东软集团（大连）有限公司</a> (2012/07 ~ 2014/02)</h3><h4 id=\"车载导航系统Multimedia（Telematics）机能\"><a href=\"#车载导航系统Multimedia（Telematics）机能\" class=\"headerlink\" title=\"车载导航系统Multimedia（Telematics）机能\"></a>车载导航系统Multimedia（Telematics）机能</h4><p>受株式会社电装DENSO公司委托，为英菲尼迪（Infiniti）汽车对应包括NAM、EUR、KOR、PRC、JPN、GOM等地区开发导航系统。Telematics只是其中的一个机能，其主要应用就是通过无线网络，随时给行车中的人们提供驾驶、生活所必需的各种信息。期间负责Telema-HMIAPP的SET、OPR、EMC机能开发；同时负责团队的Release工作。<a href=\"http://www.infiniti.com.cn/\" target=\"_blank\" rel=\"external\">查看详情</a></p>\n<hr>\n<h2 id=\"技能清单\"><a href=\"#技能清单\" class=\"headerlink\" title=\"技能清单\"></a>技能清单</h2><ul>\n<li>开发语言<ul>\n<li>移动前端：Objective-C/Swift</li>\n<li>嵌入式：C/C++</li>\n<li>服务后端：Java/C#</li>\n</ul>\n</li>\n<li>数据库：MySQL/SQLite</li>\n</ul>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<p>​    </p>\n<p>​    </p>\n<h2 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h2><ul>\n<li>手机／微信：13253511601</li>\n<li>Email：l900416@163.com</li>\n<li>QQ：860969446</li>\n</ul>\n<hr>\n<h2 id=\"个人信息\"><a href=\"#个人信息\" class=\"headerlink\" title=\"个人信息\"></a>个人信息</h2><ul>\n<li>梁通 ／ 男 ／ 1990</li>\n<li>本科 ／ 郑州大学信息工程学院 ／ 软件工程 ／ 普招</li>\n<li>工作年限：5年</li>\n<li>技术博客：<a href=\"https://l900416.github.io\">https://l900416.github.io</a></li>\n<li>职位：iOS软件工程师</li>\n<li>所在城市：郑州</li>\n</ul>\n<hr>\n<h2 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h2><h3 id=\"中机六院-2014-04-至今\"><a href=\"#中机六院-2014-04-至今\" class=\"headerlink\" title=\"中机六院 (2014/04 ~ 至今)\"></a><a href=\"http://sippr.cn/\" target=\"_blank\" rel=\"external\">中机六院</a> (2014/04 ~ 至今)</h3><h4 id=\"道-路-桥系列\"><a href=\"#道-路-桥系列\" class=\"headerlink\" title=\"道(路)桥系列\"></a>道(路)桥系列</h4><p>道(路)桥系列应用包括： <strong>道(路)桥在线</strong> 、 <strong>项目在线</strong> 、 <strong>地下工程建设</strong> 、 <strong>BIM+</strong> 、 <strong>EPC助手</strong> 、 <strong>监理助手</strong> 、 <strong>高新科技园区</strong> 、 <strong>BIM+(西安)</strong> 等 ，独立负责该项目iOS移动端程序的开发、维护等工作。该系列项目自2015年启动后处于持续开发维护阶段。由郑州市农业路高架桥建设，推广到黄河桥项目，之后持续开发推广到了房屋建设等方面。功能包括进度、问题、地图、建设资料、图纸、隐蔽工程、物料进场、现场巡检、消息、项目报表、实时监控、日志、审批、蓝牙测量等多种功能。从初版做成到后续持续更新，该项目的架构经过了MVC -&gt; MVVM -&gt; MVMCV变种，代码结构逐步清晰，为开发和维护等工作提供了便捷。<a href=\"http://121.40.49.148/eepm\" target=\"_blank\" rel=\"external\">路桥安装试用</a></p>\n<h4 id=\"六院系列\"><a href=\"#六院系列\" class=\"headerlink\" title=\"六院系列\"></a>六院系列</h4><p>六院系列包括： <strong>效率助手</strong> 、 <strong>知识库</strong> ，，负责该系列项目iOS移动端程序的开发、维护等工作。效率助手定位是企业办公助手，她与企业办公联动，实时推送包括经营、生产、项目等相关报表信息，提供：公文处理、公文阅读、合同评审、报销审批、工作日志、考勤管理、会议管理、用印申请、经营跟踪、计划变更／确认、银行保函等多种业务处理能力。知识库为归档的企业知识文档提供便捷的查阅能力，便于内部人员学习交流。其中效率助手于2015年获得 <strong>河南省优秀工程勘察设计一等奖</strong> 、 <strong>郑州市优秀工程勘察设计行业奖一等奖</strong> 。<a href=\"http://eepm.sippr.cn/Assistant.html\" target=\"_blank\" rel=\"external\">效率助手安装试用</a></p>\n<h4 id=\"位置服务\"><a href=\"#位置服务\" class=\"headerlink\" title=\"位置服务\"></a>位置服务</h4><p>ALE(位置服务平台)是基于Wi-Fi、iBeacon技术。除了满足室内精确定位功能，还将自身定位结果同建筑BIM等数据打通并提供包括室内(园区)SVG地图的展示、导览、定位、导航；BIM组件的展示；蓝牙、Wi-Fi自定义策略等能力。在此基础上，为 <strong>上烟园区服务</strong> 、 <strong>GBIM位置服务</strong> 项目定制开发了导览、定位、访客、巡更、蓝牙、监控等功能，涉及技术包括SVG、iBeacon、ZMQ、BIM等。独立负责该项目iOS移动端程序的开发、维护等工作。<a href=\"http://125.46.29.147:8860/ccs\" target=\"_blank\" rel=\"external\">查看详情</a></p>\n<h4 id=\"学源\"><a href=\"#学源\" class=\"headerlink\" title=\"学源\"></a>学源</h4><p>一个仿慕课的在线教育平台。额外定制开发了企业文库、线下培训(蓝牙签到)、任务卡等多种功能。独立负责该项目iOS移动端程序的开发、维护等工作。<a href=\"http://emooc.sippr.cn/\" target=\"_blank\" rel=\"external\">更多详情</a></p>\n<h4 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h4><h6 id=\"工程勘察\"><a href=\"#工程勘察\" class=\"headerlink\" title=\"工程勘察\"></a>工程勘察</h6><p>河南省勘察质量监督管理平台，地勘外业备案流程化管理、现场见证与飞行检查联动机制。<a href=\"http://hnkczl.hnjs.gov.cn/\" target=\"_blank\" rel=\"external\">更多详情</a></p>\n<h6 id=\"标准验证\"><a href=\"#标准验证\" class=\"headerlink\" title=\"标准验证\"></a>标准验证</h6><p>智能制造标准体系结构验证平台，互联网+众验平台。<a href=\"http://125.46.29.147:8801/eepm/sv\" target=\"_blank\" rel=\"external\">安装试用</a></p>\n<h6 id=\"EEP数据采集\"><a href=\"#EEP数据采集\" class=\"headerlink\" title=\"EEP数据采集\"></a>EEP数据采集</h6><p>对所有设备进行编码，可离线进行验收工作，同时可查阅各类设备信息等。为业主提供了进场／系统验收、数据离线／同步、设备信息、在线查询等简单能力。</p>\n<h6 id=\"ALE-RES基础资源管理\"><a href=\"#ALE-RES基础资源管理\" class=\"headerlink\" title=\"ALE_RES基础资源管理\"></a>ALE_RES基础资源管理</h6><p>基于ACE框架，使用Spring+Struct+Hibernate开发的Web基础资源管理平台。主要包括SVG地图资源展示、上传、解析、变更等管理；CP数据管理；指纹数据生成等。从SQL语句编写到前台统计报表展示等。</p>\n<h6 id=\"效率助手后台管理\"><a href=\"#效率助手后台管理\" class=\"headerlink\" title=\"效率助手后台管理\"></a>效率助手后台管理</h6><p>使用Struct2框架，编写的效率助手后台Web管理系统。</p>\n<h3 id=\"东软集团（大连）有限公司-2012-07-2014-02\"><a href=\"#东软集团（大连）有限公司-2012-07-2014-02\" class=\"headerlink\" title=\"东软集团（大连）有限公司 (2012/07 ~ 2014/02)\"></a><a href=\"http://www.neusoft.com/cn/\" target=\"_blank\" rel=\"external\">东软集团（大连）有限公司</a> (2012/07 ~ 2014/02)</h3><h4 id=\"车载导航系统Multimedia（Telematics）机能\"><a href=\"#车载导航系统Multimedia（Telematics）机能\" class=\"headerlink\" title=\"车载导航系统Multimedia（Telematics）机能\"></a>车载导航系统Multimedia（Telematics）机能</h4><p>受株式会社电装DENSO公司委托，为英菲尼迪（Infiniti）汽车对应包括NAM、EUR、KOR、PRC、JPN、GOM等地区开发导航系统。Telematics只是其中的一个机能，其主要应用就是通过无线网络，随时给行车中的人们提供驾驶、生活所必需的各种信息。期间负责Telema-HMIAPP的SET、OPR、EMC机能开发；同时负责团队的Release工作。<a href=\"http://www.infiniti.com.cn/\" target=\"_blank\" rel=\"external\">查看详情</a></p>\n<hr>\n<h2 id=\"技能清单\"><a href=\"#技能清单\" class=\"headerlink\" title=\"技能清单\"></a>技能清单</h2><ul>\n<li>开发语言<ul>\n<li>移动前端：Objective-C/Swift</li>\n<li>嵌入式：C/C++</li>\n<li>服务后端：Java/C#</li>\n</ul>\n</li>\n<li>数据库：MySQL/SQLite</li>\n</ul>\n<hr>\n"},{"title":"分类","date":"2017-08-03T10:31:50.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2017-08-03 18:31:50\ntype: \"categories\"\ncomments: false\n---\n","updated":"2017-10-13T10:44:09.000Z","path":"categories/index.html","layout":"page","_id":"cjahxo4ts001xoko8v38e0pu7","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"日程","date":"2017-08-31T09:52:58.000Z","type":"schedule","comments":0,"_content":"","source":"schedule/index.md","raw":"---\ntitle: 日程\ndate: 2017-08-31 17:52:58\ntype: \"schedule\"\ncomments: false\n---\n","updated":"2017-10-13T10:44:09.000Z","path":"schedule/index.html","layout":"page","_id":"cjahxo4tu0020oko8rpc7r85v","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2017-08-03T10:27:21.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2017-08-03 18:27:21\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-10-13T10:44:09.000Z","path":"tags/index.html","layout":"page","_id":"cjahxo4tw0024oko84vxapvwn","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"layout":"post","title":"基于二维空间的极大似然估计算法","date":"2017-08-23T08:41:27.000Z","author":"liangtong","catalog":true,"_content":"\n  基于距离的极大似然估计法利用多个已知节点的位置及节点与目标点位置的距离来计算出目标点的位置。\n\n#### 极大似然估算法   \n\n极大似然估算法定位原理：假设定位区域目标点，n个已知位置和距离目标点距离的节点，可得到目标点与n个节点之间的距离方程。\n设节点的坐标为(x<sub>1</sub>,y<sub>1</sub>) , (x<sub>2</sub>,y<sub>2</sub>) , ... , (x<sub>n</sub>,y<sub>n</sub>)，目标点坐标 (x,y)，各节点到目标点的距离d<sub>1</sub> , d<sub>2</sub>,..., d<sub>n</sub>，则可的方程组 ( x<sub>i</sub> - x )²  + (y<sub>i</sub> -y)² = d<sub>i</sub>² , 其中I∈[1,n]。\n对方程组进行求解，可得x，y坐标\n\n<!-- more -->\n\n#### 代码实现\n\n用于运算的节点简单二维空间节点对象，主要包含坐标及距离，用于极大似然算法估算。\n\n```Objective-C\n/**\n  * 节点对象，包含坐标点和距离属性\n **/\n@interface LikelihoodNode : NSObject\n@property (nonatomic , assign) CGPoint point;\n@property (nonatomic , assign) float distance\n-(id)initWithX:(float)x Y:(CGFloat)y distance:(float)distance;\n@end\n\n@implementation LikelihoodNode\n-(id)initWithX:(float)x Y:(CGFloat)y distance:(float)distance{\n    self = [super init];\n    if (self != nil) {\n        self.point = CGPointMake(x, y);\n        self.distance = distance;\n    }\n    return self;\n}\n@end\n\n```\n\n极大似然算法，对已知节点进行计算，得到目标节点\n\n```Objective-C\n\n/**\n  * 极大似然估算，输入多个点数组，计算出目标点坐标\n **/\n@interface MaximumLikelihood : NSObject\n+ (CGPoint) maximumLikelihoodPointFromArray:(NSArray*)array;\n@end\n\n@implementation MaximumLikelihood\n\n+ (CGPoint) maximumLikelihoodPointFromArray:(NSArray*)array{\n    CGPoint retPoint = CGPointZero;\n    if (array.count > 2) {//至少3个点来计算极大似然数\n        long double segmaDeletaX = 0.0;\n        long double segmaDeletaY = 0.0;\n        long double segmaDeletaX_Y = 0.0;\n        \n        LikelihoodNode* lastNode = [array lastObject];\n        \n        /**\n         * segma deleta x 2\n         * segma deleta y 2\n         * segma deleta x * delta y\n         **/\n        for (int i = 0; i < array.count - 1; ++i) {\n            LikelihoodNode* node = [array objectAtIndex:i];\n            long double deltaX = [MaximumLikelihood deltaXiWithNode:node and:lastNode];\n            long double deltaY = [MaximumLikelihood deltaYiWithNode:node and:lastNode];\n            segmaDeletaX += pow(deltaX,2);\n            segmaDeletaY += pow(deltaY,2);\n            segmaDeletaX_Y += deltaX * deltaY;\n        }\n        \n        long double preNumber = 0.0;\n        long double temp = segmaDeletaX * segmaDeletaY - pow(segmaDeletaX_Y, 2);\n        \n        if (temp != 0) {\n            preNumber = (2 / temp) / 4;\n        }\n        \n        long double maximumLikehoodX = 0.0;\n        long double maximumLikehoodY = 0.0;\n        for (int i = 0; i < array.count - 1; ++i) {\n            LikelihoodNode* node = [array objectAtIndex:i];\n            long double deltaX = [MaximumLikelihood deltaXiWithNode:node and:lastNode];\n            long double deltaY = [MaximumLikelihood deltaYiWithNode:node and:lastNode];\n            long double fDi = [MaximumLikelihood getFr_xFrom:node and:lastNode];\n            maximumLikehoodX += (segmaDeletaY * deltaX - segmaDeletaX_Y * deltaY) * fDi;\n            maximumLikehoodY += (segmaDeletaX * deltaY - segmaDeletaX_Y * deltaX) * fDi;\n        }\n        \n        retPoint.x = maximumLikehoodX * preNumber;\n        retPoint.y = maximumLikehoodY * preNumber;\n    }\n    \n    return retPoint;\n}\n\n//deltaX\n+(long double)deltaXiWithNode:(LikelihoodNode*)node and:(LikelihoodNode*)lastNode{\n    long double ans = 0.0;\n    ans = node.point.x - lastNode.point.x;\n    return ans;\n}\n\n//deltaY\n+(long double)deltaYiWithNode:(LikelihoodNode*)node and:(LikelihoodNode*)lastNode{\n    long double ans = 0.0;\n    ans = node.point.y - lastNode.point.y;\n    return ans;\n}\n\n//f(di)\n+(float)getFr_xFrom:(LikelihoodNode*)node and:(LikelihoodNode*)lastNode{\n    double ans = 0.0;\n    ans = (node.point.x * node.point.x) - (lastNode.point.x * lastNode.point.x) + (node.point.y * node.point.y) - (lastNode.point.y * lastNode.point.y) - (node.distance * node.distance) + (lastNode.distance * lastNode.distance);\n    \n    return ans;\n}\n\n```\n\n考虑到实际情况下，节点与目标点会随距离的增大导致误差变大，故可以通过节点吸附对目标点坐标进行校正。\n在参与节点与目标点满足情况的前提下，校正步骤如下：\n + 判断目标点距离最近节点nNode的距离distance\n + 若disatance小于吸附临界值(比如：1m)\n   + 根据像素与实际地理米转换关系计算出极大似然估算法节点mNode与nNode的距离distancePointToNearest\n   + 若distancePointToNearest不大于distance，则不需要进行校正\n   + 否则计算出mNode与nNode位置之间连线与distnace处交点的坐标，即为校正后的坐标\n + 否则不进行吸附校正\n\n```Objective-C\n\n/**\n * 校正、吸附算法。\n * 假设参与计算的节点按照距目标点距离递增的顺序排列\n * 此处仅在计算结果与最近节点距离小于1米的情况下进行校正。\n **/\n+ (CGPoint) maximumLikelihoodPointFromArray:(NSArray*)array mToPxScale:(CGFloat)mToPxScale{\n    CGPoint retPoint = [MaximumLikelihood maximumLikelihoodPointFromArray:array];\n    //根据像素与米的转换关系，判断若最近的小于1米，且计算坐标在最近区域外时，取交点坐标为最终结果坐标\n    if (array.count > 2) {\n        LikelihoodNode* nearest = [array firstObject];\n        if (nearest.distance <= 1.0) {\n            CGFloat xDist = (retPoint.x - nearest.point.x) * mToPxScale;\n            CGFloat yDist = (retPoint.y - nearest.point.y) * mToPxScale;\n            CGFloat distancePointToNearest = sqrt((xDist * xDist) + (yDist * yDist));\n            if (distancePointToNearest > nearest.distance) {\n                CGFloat λ = nearest.distance / (distancePointToNearest - nearest.distance);\n                CGFloat x =  (nearest.point.x + λ * retPoint.x) / (1 + λ);\n                CGFloat y =  (nearest.point.y + λ * retPoint.y) / (1 + λ);\n                retPoint = CGPointMake(x, y);\n            }\n        }\n    }\n    return retPoint;\n}\n```\n\n\n\n#### 参考文档\n\nhttps://wenku.baidu.com/view/1db9c08a71fe910ef12df8df.html\nhttps://wenku.baidu.com/view/3dba1baef524ccbff12184af.html?re=view\nhttp://www.doc88.com/p-6037723035623.html\n","source":"_posts/algorithm_location_maximum_likelihood.md","raw":"---\nlayout:     post\ntitle:      基于二维空间的极大似然估计算法\ndate:       2017-08-23 16:41:27\nauthor:     liangtong\ncatalog: true\ncategories: Algorithm\ntags: 位置\n\n---\n\n  基于距离的极大似然估计法利用多个已知节点的位置及节点与目标点位置的距离来计算出目标点的位置。\n\n#### 极大似然估算法   \n\n极大似然估算法定位原理：假设定位区域目标点，n个已知位置和距离目标点距离的节点，可得到目标点与n个节点之间的距离方程。\n设节点的坐标为(x<sub>1</sub>,y<sub>1</sub>) , (x<sub>2</sub>,y<sub>2</sub>) , ... , (x<sub>n</sub>,y<sub>n</sub>)，目标点坐标 (x,y)，各节点到目标点的距离d<sub>1</sub> , d<sub>2</sub>,..., d<sub>n</sub>，则可的方程组 ( x<sub>i</sub> - x )²  + (y<sub>i</sub> -y)² = d<sub>i</sub>² , 其中I∈[1,n]。\n对方程组进行求解，可得x，y坐标\n\n<!-- more -->\n\n#### 代码实现\n\n用于运算的节点简单二维空间节点对象，主要包含坐标及距离，用于极大似然算法估算。\n\n```Objective-C\n/**\n  * 节点对象，包含坐标点和距离属性\n **/\n@interface LikelihoodNode : NSObject\n@property (nonatomic , assign) CGPoint point;\n@property (nonatomic , assign) float distance\n-(id)initWithX:(float)x Y:(CGFloat)y distance:(float)distance;\n@end\n\n@implementation LikelihoodNode\n-(id)initWithX:(float)x Y:(CGFloat)y distance:(float)distance{\n    self = [super init];\n    if (self != nil) {\n        self.point = CGPointMake(x, y);\n        self.distance = distance;\n    }\n    return self;\n}\n@end\n\n```\n\n极大似然算法，对已知节点进行计算，得到目标节点\n\n```Objective-C\n\n/**\n  * 极大似然估算，输入多个点数组，计算出目标点坐标\n **/\n@interface MaximumLikelihood : NSObject\n+ (CGPoint) maximumLikelihoodPointFromArray:(NSArray*)array;\n@end\n\n@implementation MaximumLikelihood\n\n+ (CGPoint) maximumLikelihoodPointFromArray:(NSArray*)array{\n    CGPoint retPoint = CGPointZero;\n    if (array.count > 2) {//至少3个点来计算极大似然数\n        long double segmaDeletaX = 0.0;\n        long double segmaDeletaY = 0.0;\n        long double segmaDeletaX_Y = 0.0;\n        \n        LikelihoodNode* lastNode = [array lastObject];\n        \n        /**\n         * segma deleta x 2\n         * segma deleta y 2\n         * segma deleta x * delta y\n         **/\n        for (int i = 0; i < array.count - 1; ++i) {\n            LikelihoodNode* node = [array objectAtIndex:i];\n            long double deltaX = [MaximumLikelihood deltaXiWithNode:node and:lastNode];\n            long double deltaY = [MaximumLikelihood deltaYiWithNode:node and:lastNode];\n            segmaDeletaX += pow(deltaX,2);\n            segmaDeletaY += pow(deltaY,2);\n            segmaDeletaX_Y += deltaX * deltaY;\n        }\n        \n        long double preNumber = 0.0;\n        long double temp = segmaDeletaX * segmaDeletaY - pow(segmaDeletaX_Y, 2);\n        \n        if (temp != 0) {\n            preNumber = (2 / temp) / 4;\n        }\n        \n        long double maximumLikehoodX = 0.0;\n        long double maximumLikehoodY = 0.0;\n        for (int i = 0; i < array.count - 1; ++i) {\n            LikelihoodNode* node = [array objectAtIndex:i];\n            long double deltaX = [MaximumLikelihood deltaXiWithNode:node and:lastNode];\n            long double deltaY = [MaximumLikelihood deltaYiWithNode:node and:lastNode];\n            long double fDi = [MaximumLikelihood getFr_xFrom:node and:lastNode];\n            maximumLikehoodX += (segmaDeletaY * deltaX - segmaDeletaX_Y * deltaY) * fDi;\n            maximumLikehoodY += (segmaDeletaX * deltaY - segmaDeletaX_Y * deltaX) * fDi;\n        }\n        \n        retPoint.x = maximumLikehoodX * preNumber;\n        retPoint.y = maximumLikehoodY * preNumber;\n    }\n    \n    return retPoint;\n}\n\n//deltaX\n+(long double)deltaXiWithNode:(LikelihoodNode*)node and:(LikelihoodNode*)lastNode{\n    long double ans = 0.0;\n    ans = node.point.x - lastNode.point.x;\n    return ans;\n}\n\n//deltaY\n+(long double)deltaYiWithNode:(LikelihoodNode*)node and:(LikelihoodNode*)lastNode{\n    long double ans = 0.0;\n    ans = node.point.y - lastNode.point.y;\n    return ans;\n}\n\n//f(di)\n+(float)getFr_xFrom:(LikelihoodNode*)node and:(LikelihoodNode*)lastNode{\n    double ans = 0.0;\n    ans = (node.point.x * node.point.x) - (lastNode.point.x * lastNode.point.x) + (node.point.y * node.point.y) - (lastNode.point.y * lastNode.point.y) - (node.distance * node.distance) + (lastNode.distance * lastNode.distance);\n    \n    return ans;\n}\n\n```\n\n考虑到实际情况下，节点与目标点会随距离的增大导致误差变大，故可以通过节点吸附对目标点坐标进行校正。\n在参与节点与目标点满足情况的前提下，校正步骤如下：\n + 判断目标点距离最近节点nNode的距离distance\n + 若disatance小于吸附临界值(比如：1m)\n   + 根据像素与实际地理米转换关系计算出极大似然估算法节点mNode与nNode的距离distancePointToNearest\n   + 若distancePointToNearest不大于distance，则不需要进行校正\n   + 否则计算出mNode与nNode位置之间连线与distnace处交点的坐标，即为校正后的坐标\n + 否则不进行吸附校正\n\n```Objective-C\n\n/**\n * 校正、吸附算法。\n * 假设参与计算的节点按照距目标点距离递增的顺序排列\n * 此处仅在计算结果与最近节点距离小于1米的情况下进行校正。\n **/\n+ (CGPoint) maximumLikelihoodPointFromArray:(NSArray*)array mToPxScale:(CGFloat)mToPxScale{\n    CGPoint retPoint = [MaximumLikelihood maximumLikelihoodPointFromArray:array];\n    //根据像素与米的转换关系，判断若最近的小于1米，且计算坐标在最近区域外时，取交点坐标为最终结果坐标\n    if (array.count > 2) {\n        LikelihoodNode* nearest = [array firstObject];\n        if (nearest.distance <= 1.0) {\n            CGFloat xDist = (retPoint.x - nearest.point.x) * mToPxScale;\n            CGFloat yDist = (retPoint.y - nearest.point.y) * mToPxScale;\n            CGFloat distancePointToNearest = sqrt((xDist * xDist) + (yDist * yDist));\n            if (distancePointToNearest > nearest.distance) {\n                CGFloat λ = nearest.distance / (distancePointToNearest - nearest.distance);\n                CGFloat x =  (nearest.point.x + λ * retPoint.x) / (1 + λ);\n                CGFloat y =  (nearest.point.y + λ * retPoint.y) / (1 + λ);\n                retPoint = CGPointMake(x, y);\n            }\n        }\n    }\n    return retPoint;\n}\n```\n\n\n\n#### 参考文档\n\nhttps://wenku.baidu.com/view/1db9c08a71fe910ef12df8df.html\nhttps://wenku.baidu.com/view/3dba1baef524ccbff12184af.html?re=view\nhttp://www.doc88.com/p-6037723035623.html\n","slug":"algorithm_location_maximum_likelihood","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4rg0000oko85uwhbv00","content":"<p>  基于距离的极大似然估计法利用多个已知节点的位置及节点与目标点位置的距离来计算出目标点的位置。</p>\n<h4 id=\"极大似然估算法\"><a href=\"#极大似然估算法\" class=\"headerlink\" title=\"极大似然估算法\"></a>极大似然估算法</h4><p>极大似然估算法定位原理：假设定位区域目标点，n个已知位置和距离目标点距离的节点，可得到目标点与n个节点之间的距离方程。<br>设节点的坐标为(x<sub>1</sub>,y<sub>1</sub>) , (x<sub>2</sub>,y<sub>2</sub>) , … , (x<sub>n</sub>,y<sub>n</sub>)，目标点坐标 (x,y)，各节点到目标点的距离d<sub>1</sub> , d<sub>2</sub>,…, d<sub>n</sub>，则可的方程组 ( x<sub>i</sub> - x )²  + (y<sub>i</sub> -y)² = d<sub>i</sub>² , 其中I∈[1,n]。<br>对方程组进行求解，可得x，y坐标</p>\n<a id=\"more\"></a>\n<h4 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><p>用于运算的节点简单二维空间节点对象，主要包含坐标及距离，用于极大似然算法估算。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">  * 节点对象，包含坐标点和距离属性</div><div class=\"line\"> **/</div><div class=\"line\">@interface LikelihoodNode : NSObject</div><div class=\"line\">@property (nonatomic , assign) CGPoint point;</div><div class=\"line\">@property (nonatomic , assign) float distance</div><div class=\"line\">-(id)initWithX:(float)x Y:(CGFloat)y distance:(float)distance;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation LikelihoodNode</div><div class=\"line\">-(id)initWithX:(float)x Y:(CGFloat)y distance:(float)distance&#123;</div><div class=\"line\">    self = [super init];</div><div class=\"line\">    if (self != nil) &#123;</div><div class=\"line\">        self.point = CGPointMake(x, y);</div><div class=\"line\">        self.distance = distance;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>极大似然算法，对已知节点进行计算，得到目标节点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">  * 极大似然估算，输入多个点数组，计算出目标点坐标</div><div class=\"line\"> **/</div><div class=\"line\">@interface MaximumLikelihood : NSObject</div><div class=\"line\">+ (CGPoint) maximumLikelihoodPointFromArray:(NSArray*)array;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation MaximumLikelihood</div><div class=\"line\"></div><div class=\"line\">+ (CGPoint) maximumLikelihoodPointFromArray:(NSArray*)array&#123;</div><div class=\"line\">    CGPoint retPoint = CGPointZero;</div><div class=\"line\">    if (array.count &gt; 2) &#123;//至少3个点来计算极大似然数</div><div class=\"line\">        long double segmaDeletaX = 0.0;</div><div class=\"line\">        long double segmaDeletaY = 0.0;</div><div class=\"line\">        long double segmaDeletaX_Y = 0.0;</div><div class=\"line\">        </div><div class=\"line\">        LikelihoodNode* lastNode = [array lastObject];</div><div class=\"line\">        </div><div class=\"line\">        /**</div><div class=\"line\">         * segma deleta x 2</div><div class=\"line\">         * segma deleta y 2</div><div class=\"line\">         * segma deleta x * delta y</div><div class=\"line\">         **/</div><div class=\"line\">        for (int i = 0; i &lt; array.count - 1; ++i) &#123;</div><div class=\"line\">            LikelihoodNode* node = [array objectAtIndex:i];</div><div class=\"line\">            long double deltaX = [MaximumLikelihood deltaXiWithNode:node and:lastNode];</div><div class=\"line\">            long double deltaY = [MaximumLikelihood deltaYiWithNode:node and:lastNode];</div><div class=\"line\">            segmaDeletaX += pow(deltaX,2);</div><div class=\"line\">            segmaDeletaY += pow(deltaY,2);</div><div class=\"line\">            segmaDeletaX_Y += deltaX * deltaY;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        long double preNumber = 0.0;</div><div class=\"line\">        long double temp = segmaDeletaX * segmaDeletaY - pow(segmaDeletaX_Y, 2);</div><div class=\"line\">        </div><div class=\"line\">        if (temp != 0) &#123;</div><div class=\"line\">            preNumber = (2 / temp) / 4;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        long double maximumLikehoodX = 0.0;</div><div class=\"line\">        long double maximumLikehoodY = 0.0;</div><div class=\"line\">        for (int i = 0; i &lt; array.count - 1; ++i) &#123;</div><div class=\"line\">            LikelihoodNode* node = [array objectAtIndex:i];</div><div class=\"line\">            long double deltaX = [MaximumLikelihood deltaXiWithNode:node and:lastNode];</div><div class=\"line\">            long double deltaY = [MaximumLikelihood deltaYiWithNode:node and:lastNode];</div><div class=\"line\">            long double fDi = [MaximumLikelihood getFr_xFrom:node and:lastNode];</div><div class=\"line\">            maximumLikehoodX += (segmaDeletaY * deltaX - segmaDeletaX_Y * deltaY) * fDi;</div><div class=\"line\">            maximumLikehoodY += (segmaDeletaX * deltaY - segmaDeletaX_Y * deltaX) * fDi;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        retPoint.x = maximumLikehoodX * preNumber;</div><div class=\"line\">        retPoint.y = maximumLikehoodY * preNumber;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    return retPoint;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//deltaX</div><div class=\"line\">+(long double)deltaXiWithNode:(LikelihoodNode*)node and:(LikelihoodNode*)lastNode&#123;</div><div class=\"line\">    long double ans = 0.0;</div><div class=\"line\">    ans = node.point.x - lastNode.point.x;</div><div class=\"line\">    return ans;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//deltaY</div><div class=\"line\">+(long double)deltaYiWithNode:(LikelihoodNode*)node and:(LikelihoodNode*)lastNode&#123;</div><div class=\"line\">    long double ans = 0.0;</div><div class=\"line\">    ans = node.point.y - lastNode.point.y;</div><div class=\"line\">    return ans;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//f(di)</div><div class=\"line\">+(float)getFr_xFrom:(LikelihoodNode*)node and:(LikelihoodNode*)lastNode&#123;</div><div class=\"line\">    double ans = 0.0;</div><div class=\"line\">    ans = (node.point.x * node.point.x) - (lastNode.point.x * lastNode.point.x) + (node.point.y * node.point.y) - (lastNode.point.y * lastNode.point.y) - (node.distance * node.distance) + (lastNode.distance * lastNode.distance);</div><div class=\"line\">    </div><div class=\"line\">    return ans;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>考虑到实际情况下，节点与目标点会随距离的增大导致误差变大，故可以通过节点吸附对目标点坐标进行校正。<br>在参与节点与目标点满足情况的前提下，校正步骤如下：</p>\n<ul>\n<li>判断目标点距离最近节点nNode的距离distance</li>\n<li>若disatance小于吸附临界值(比如：1m)<ul>\n<li>根据像素与实际地理米转换关系计算出极大似然估算法节点mNode与nNode的距离distancePointToNearest</li>\n<li>若distancePointToNearest不大于distance，则不需要进行校正</li>\n<li>否则计算出mNode与nNode位置之间连线与distnace处交点的坐标，即为校正后的坐标</li>\n</ul>\n</li>\n<li>否则不进行吸附校正</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * 校正、吸附算法。</div><div class=\"line\"> * 假设参与计算的节点按照距目标点距离递增的顺序排列</div><div class=\"line\"> * 此处仅在计算结果与最近节点距离小于1米的情况下进行校正。</div><div class=\"line\"> **/</div><div class=\"line\">+ (CGPoint) maximumLikelihoodPointFromArray:(NSArray*)array mToPxScale:(CGFloat)mToPxScale&#123;</div><div class=\"line\">    CGPoint retPoint = [MaximumLikelihood maximumLikelihoodPointFromArray:array];</div><div class=\"line\">    //根据像素与米的转换关系，判断若最近的小于1米，且计算坐标在最近区域外时，取交点坐标为最终结果坐标</div><div class=\"line\">    if (array.count &gt; 2) &#123;</div><div class=\"line\">        LikelihoodNode* nearest = [array firstObject];</div><div class=\"line\">        if (nearest.distance &lt;= 1.0) &#123;</div><div class=\"line\">            CGFloat xDist = (retPoint.x - nearest.point.x) * mToPxScale;</div><div class=\"line\">            CGFloat yDist = (retPoint.y - nearest.point.y) * mToPxScale;</div><div class=\"line\">            CGFloat distancePointToNearest = sqrt((xDist * xDist) + (yDist * yDist));</div><div class=\"line\">            if (distancePointToNearest &gt; nearest.distance) &#123;</div><div class=\"line\">                CGFloat λ = nearest.distance / (distancePointToNearest - nearest.distance);</div><div class=\"line\">                CGFloat x =  (nearest.point.x + λ * retPoint.x) / (1 + λ);</div><div class=\"line\">                CGFloat y =  (nearest.point.y + λ * retPoint.y) / (1 + λ);</div><div class=\"line\">                retPoint = CGPointMake(x, y);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return retPoint;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h4><p><a href=\"https://wenku.baidu.com/view/1db9c08a71fe910ef12df8df.html\" target=\"_blank\" rel=\"external\">https://wenku.baidu.com/view/1db9c08a71fe910ef12df8df.html</a><br><a href=\"https://wenku.baidu.com/view/3dba1baef524ccbff12184af.html?re=view\" target=\"_blank\" rel=\"external\">https://wenku.baidu.com/view/3dba1baef524ccbff12184af.html?re=view</a><br><a href=\"http://www.doc88.com/p-6037723035623.html\" target=\"_blank\" rel=\"external\">http://www.doc88.com/p-6037723035623.html</a></p>\n","site":{"data":{}},"excerpt":"<p>  基于距离的极大似然估计法利用多个已知节点的位置及节点与目标点位置的距离来计算出目标点的位置。</p>\n<h4 id=\"极大似然估算法\"><a href=\"#极大似然估算法\" class=\"headerlink\" title=\"极大似然估算法\"></a>极大似然估算法</h4><p>极大似然估算法定位原理：假设定位区域目标点，n个已知位置和距离目标点距离的节点，可得到目标点与n个节点之间的距离方程。<br>设节点的坐标为(x<sub>1</sub>,y<sub>1</sub>) , (x<sub>2</sub>,y<sub>2</sub>) , … , (x<sub>n</sub>,y<sub>n</sub>)，目标点坐标 (x,y)，各节点到目标点的距离d<sub>1</sub> , d<sub>2</sub>,…, d<sub>n</sub>，则可的方程组 ( x<sub>i</sub> - x )²  + (y<sub>i</sub> -y)² = d<sub>i</sub>² , 其中I∈[1,n]。<br>对方程组进行求解，可得x，y坐标</p>","more":"<h4 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><p>用于运算的节点简单二维空间节点对象，主要包含坐标及距离，用于极大似然算法估算。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">  * 节点对象，包含坐标点和距离属性</div><div class=\"line\"> **/</div><div class=\"line\">@interface LikelihoodNode : NSObject</div><div class=\"line\">@property (nonatomic , assign) CGPoint point;</div><div class=\"line\">@property (nonatomic , assign) float distance</div><div class=\"line\">-(id)initWithX:(float)x Y:(CGFloat)y distance:(float)distance;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation LikelihoodNode</div><div class=\"line\">-(id)initWithX:(float)x Y:(CGFloat)y distance:(float)distance&#123;</div><div class=\"line\">    self = [super init];</div><div class=\"line\">    if (self != nil) &#123;</div><div class=\"line\">        self.point = CGPointMake(x, y);</div><div class=\"line\">        self.distance = distance;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return self;</div><div class=\"line\">&#125;</div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<p>极大似然算法，对已知节点进行计算，得到目标节点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">  * 极大似然估算，输入多个点数组，计算出目标点坐标</div><div class=\"line\"> **/</div><div class=\"line\">@interface MaximumLikelihood : NSObject</div><div class=\"line\">+ (CGPoint) maximumLikelihoodPointFromArray:(NSArray*)array;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation MaximumLikelihood</div><div class=\"line\"></div><div class=\"line\">+ (CGPoint) maximumLikelihoodPointFromArray:(NSArray*)array&#123;</div><div class=\"line\">    CGPoint retPoint = CGPointZero;</div><div class=\"line\">    if (array.count &gt; 2) &#123;//至少3个点来计算极大似然数</div><div class=\"line\">        long double segmaDeletaX = 0.0;</div><div class=\"line\">        long double segmaDeletaY = 0.0;</div><div class=\"line\">        long double segmaDeletaX_Y = 0.0;</div><div class=\"line\">        </div><div class=\"line\">        LikelihoodNode* lastNode = [array lastObject];</div><div class=\"line\">        </div><div class=\"line\">        /**</div><div class=\"line\">         * segma deleta x 2</div><div class=\"line\">         * segma deleta y 2</div><div class=\"line\">         * segma deleta x * delta y</div><div class=\"line\">         **/</div><div class=\"line\">        for (int i = 0; i &lt; array.count - 1; ++i) &#123;</div><div class=\"line\">            LikelihoodNode* node = [array objectAtIndex:i];</div><div class=\"line\">            long double deltaX = [MaximumLikelihood deltaXiWithNode:node and:lastNode];</div><div class=\"line\">            long double deltaY = [MaximumLikelihood deltaYiWithNode:node and:lastNode];</div><div class=\"line\">            segmaDeletaX += pow(deltaX,2);</div><div class=\"line\">            segmaDeletaY += pow(deltaY,2);</div><div class=\"line\">            segmaDeletaX_Y += deltaX * deltaY;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        long double preNumber = 0.0;</div><div class=\"line\">        long double temp = segmaDeletaX * segmaDeletaY - pow(segmaDeletaX_Y, 2);</div><div class=\"line\">        </div><div class=\"line\">        if (temp != 0) &#123;</div><div class=\"line\">            preNumber = (2 / temp) / 4;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        long double maximumLikehoodX = 0.0;</div><div class=\"line\">        long double maximumLikehoodY = 0.0;</div><div class=\"line\">        for (int i = 0; i &lt; array.count - 1; ++i) &#123;</div><div class=\"line\">            LikelihoodNode* node = [array objectAtIndex:i];</div><div class=\"line\">            long double deltaX = [MaximumLikelihood deltaXiWithNode:node and:lastNode];</div><div class=\"line\">            long double deltaY = [MaximumLikelihood deltaYiWithNode:node and:lastNode];</div><div class=\"line\">            long double fDi = [MaximumLikelihood getFr_xFrom:node and:lastNode];</div><div class=\"line\">            maximumLikehoodX += (segmaDeletaY * deltaX - segmaDeletaX_Y * deltaY) * fDi;</div><div class=\"line\">            maximumLikehoodY += (segmaDeletaX * deltaY - segmaDeletaX_Y * deltaX) * fDi;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        retPoint.x = maximumLikehoodX * preNumber;</div><div class=\"line\">        retPoint.y = maximumLikehoodY * preNumber;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    return retPoint;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//deltaX</div><div class=\"line\">+(long double)deltaXiWithNode:(LikelihoodNode*)node and:(LikelihoodNode*)lastNode&#123;</div><div class=\"line\">    long double ans = 0.0;</div><div class=\"line\">    ans = node.point.x - lastNode.point.x;</div><div class=\"line\">    return ans;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//deltaY</div><div class=\"line\">+(long double)deltaYiWithNode:(LikelihoodNode*)node and:(LikelihoodNode*)lastNode&#123;</div><div class=\"line\">    long double ans = 0.0;</div><div class=\"line\">    ans = node.point.y - lastNode.point.y;</div><div class=\"line\">    return ans;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//f(di)</div><div class=\"line\">+(float)getFr_xFrom:(LikelihoodNode*)node and:(LikelihoodNode*)lastNode&#123;</div><div class=\"line\">    double ans = 0.0;</div><div class=\"line\">    ans = (node.point.x * node.point.x) - (lastNode.point.x * lastNode.point.x) + (node.point.y * node.point.y) - (lastNode.point.y * lastNode.point.y) - (node.distance * node.distance) + (lastNode.distance * lastNode.distance);</div><div class=\"line\">    </div><div class=\"line\">    return ans;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>考虑到实际情况下，节点与目标点会随距离的增大导致误差变大，故可以通过节点吸附对目标点坐标进行校正。<br>在参与节点与目标点满足情况的前提下，校正步骤如下：</p>\n<ul>\n<li>判断目标点距离最近节点nNode的距离distance</li>\n<li>若disatance小于吸附临界值(比如：1m)<ul>\n<li>根据像素与实际地理米转换关系计算出极大似然估算法节点mNode与nNode的距离distancePointToNearest</li>\n<li>若distancePointToNearest不大于distance，则不需要进行校正</li>\n<li>否则计算出mNode与nNode位置之间连线与distnace处交点的坐标，即为校正后的坐标</li>\n</ul>\n</li>\n<li>否则不进行吸附校正</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\"> * 校正、吸附算法。</div><div class=\"line\"> * 假设参与计算的节点按照距目标点距离递增的顺序排列</div><div class=\"line\"> * 此处仅在计算结果与最近节点距离小于1米的情况下进行校正。</div><div class=\"line\"> **/</div><div class=\"line\">+ (CGPoint) maximumLikelihoodPointFromArray:(NSArray*)array mToPxScale:(CGFloat)mToPxScale&#123;</div><div class=\"line\">    CGPoint retPoint = [MaximumLikelihood maximumLikelihoodPointFromArray:array];</div><div class=\"line\">    //根据像素与米的转换关系，判断若最近的小于1米，且计算坐标在最近区域外时，取交点坐标为最终结果坐标</div><div class=\"line\">    if (array.count &gt; 2) &#123;</div><div class=\"line\">        LikelihoodNode* nearest = [array firstObject];</div><div class=\"line\">        if (nearest.distance &lt;= 1.0) &#123;</div><div class=\"line\">            CGFloat xDist = (retPoint.x - nearest.point.x) * mToPxScale;</div><div class=\"line\">            CGFloat yDist = (retPoint.y - nearest.point.y) * mToPxScale;</div><div class=\"line\">            CGFloat distancePointToNearest = sqrt((xDist * xDist) + (yDist * yDist));</div><div class=\"line\">            if (distancePointToNearest &gt; nearest.distance) &#123;</div><div class=\"line\">                CGFloat λ = nearest.distance / (distancePointToNearest - nearest.distance);</div><div class=\"line\">                CGFloat x =  (nearest.point.x + λ * retPoint.x) / (1 + λ);</div><div class=\"line\">                CGFloat y =  (nearest.point.y + λ * retPoint.y) / (1 + λ);</div><div class=\"line\">                retPoint = CGPointMake(x, y);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return retPoint;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h4><p><a href=\"https://wenku.baidu.com/view/1db9c08a71fe910ef12df8df.html\" target=\"_blank\" rel=\"external\">https://wenku.baidu.com/view/1db9c08a71fe910ef12df8df.html</a><br><a href=\"https://wenku.baidu.com/view/3dba1baef524ccbff12184af.html?re=view\" target=\"_blank\" rel=\"external\">https://wenku.baidu.com/view/3dba1baef524ccbff12184af.html?re=view</a><br><a href=\"http://www.doc88.com/p-6037723035623.html\" target=\"_blank\" rel=\"external\">http://www.doc88.com/p-6037723035623.html</a></p>"},{"layout":"post","title":"二分查找","date":"2017-04-27T02:07:43.000Z","author":"liangtong","catalog":true,"_content":"\n\n​\t二分查找算法也称为折半搜索、二分搜索，是一种在有序数组中查找某一特定元素的搜索算法。算法是建立在有序数组基础上的。时间复杂度： T(n) = Θ(logn)。\n\n\n\n### 原理及实现    \n基本原理：使用递归、分治的思想\n * ① 当数组为空时，说明数组中不存在需查找的元素。\n * ② 用有序数组的中间位置元素与需查找元素进行大小比较，如果相等，则查找结束。\n * ③ 如果中间位置元素大于需查找元素，则从数组左侧位置进行递归查找。\n * ④ 如果中间位置元素小于需查找元素，则从数组右侧位置进行递归查找。\n\n<!-- more -->\n\n使用Swift编写简单的代码实现，如下：\n\n```Swift\n/**\n *  二分查找\n * 使用递归、分治的思想\n * ① 当数组为空时，说明数组中不存在需查找的元素。\n * ② 用有序数组的中间位置元素与需查找元素进行大小比较，如果相等，则查找结束。\n * ③ 如果中间位置元素大于需查找元素，则从数组左侧位置进行递归查找。\n * ④ 如果中间位置元素小于需查找元素，则从数组右侧位置进行递归查找。\n **/\n\nfunc binarySearch<T:Comparable>(array:Array<T>, start:Int, end:Int, value:T) -> Int{\n    let count = end - start + 1;\n    if count <= 0 {\n        return -1;//没有查找到\n    }\n    let midIndex = (start + end) / 2;\n    let midValue = array[midIndex];\n    if midValue > value {//在左侧查找\n        return binarySearch(array: array, start: start, end: midIndex - 1, value: value);\n    }else if midValue < value {//在右侧查找\n        return binarySearch(array: array, start: midIndex + 1, end: end, value: value);\n    }else{//位置查找到，即当前数组中间位置元素\n        return midIndex;\n    }\n}\n```\n\n### 测试用例及结果\n\n```Swift\n//方法调用\nfunc callBinarySearch<T:Comparable>(array: Array<T>, value:T){\n    \n    let index = binarySearch(array: array, start: 0, end: array.count - 1, value: value);\n    \n    print(\"Index Of Value \\(value)  In Array \\(array) is : \\(index)\")\n    \n}\n\nvar intArray =  [1, 4, 7, 8, 9, 11, 11, 15, 16, 24];\ncallBinarySearch(array: intArray , value: 3)\ncallBinarySearch(array: intArray , value: 16)\n\nvar stringArray =  [\"Assembly\", \"BASIC\", \"C#\", \"Java\", \"Objective-C\", \"PHP\", \"Swift\"];\ncallBinarySearch(array: stringArray,value:\"Assembly\")\ncallBinarySearch(array: stringArray,value:\"PHP\")\ncallBinarySearch(array: stringArray,value:\"AAA\")\n\n\n//程序输出\nIndex Of Value 3  In Array [1, 4, 7, 8, 9, 11, 11, 15, 16, 24] is : -1\nIndex Of Value 16  In Array [1, 4, 7, 8, 9, 11, 11, 15, 16, 24] is : 8\nIndex Of Value Assembly  In Array [\"Assembly\", \"BASIC\", \"C#\", \"Java\", \"Objective-C\", \"PHP\", \"Swift\"] is : 0\nIndex Of Value PHP  In Array [\"Assembly\", \"BASIC\", \"C#\", \"Java\", \"Objective-C\", \"PHP\", \"Swift\"] is : 5\nIndex Of Value AAA  In Array [\"Assembly\", \"BASIC\", \"C#\", \"Java\", \"Objective-C\", \"PHP\", \"Swift\"] is : -1\n```\n\n","source":"_posts/algorithm_search_binary.md","raw":"---\nlayout:     post\ntitle:      二分查找\ndate:       2017-04-27 10:07:43\nauthor:     liangtong\ncatalog: true\ncategories: Algorithm\ntags: Search\n\n---\n\n\n​\t二分查找算法也称为折半搜索、二分搜索，是一种在有序数组中查找某一特定元素的搜索算法。算法是建立在有序数组基础上的。时间复杂度： T(n) = Θ(logn)。\n\n\n\n### 原理及实现    \n基本原理：使用递归、分治的思想\n * ① 当数组为空时，说明数组中不存在需查找的元素。\n * ② 用有序数组的中间位置元素与需查找元素进行大小比较，如果相等，则查找结束。\n * ③ 如果中间位置元素大于需查找元素，则从数组左侧位置进行递归查找。\n * ④ 如果中间位置元素小于需查找元素，则从数组右侧位置进行递归查找。\n\n<!-- more -->\n\n使用Swift编写简单的代码实现，如下：\n\n```Swift\n/**\n *  二分查找\n * 使用递归、分治的思想\n * ① 当数组为空时，说明数组中不存在需查找的元素。\n * ② 用有序数组的中间位置元素与需查找元素进行大小比较，如果相等，则查找结束。\n * ③ 如果中间位置元素大于需查找元素，则从数组左侧位置进行递归查找。\n * ④ 如果中间位置元素小于需查找元素，则从数组右侧位置进行递归查找。\n **/\n\nfunc binarySearch<T:Comparable>(array:Array<T>, start:Int, end:Int, value:T) -> Int{\n    let count = end - start + 1;\n    if count <= 0 {\n        return -1;//没有查找到\n    }\n    let midIndex = (start + end) / 2;\n    let midValue = array[midIndex];\n    if midValue > value {//在左侧查找\n        return binarySearch(array: array, start: start, end: midIndex - 1, value: value);\n    }else if midValue < value {//在右侧查找\n        return binarySearch(array: array, start: midIndex + 1, end: end, value: value);\n    }else{//位置查找到，即当前数组中间位置元素\n        return midIndex;\n    }\n}\n```\n\n### 测试用例及结果\n\n```Swift\n//方法调用\nfunc callBinarySearch<T:Comparable>(array: Array<T>, value:T){\n    \n    let index = binarySearch(array: array, start: 0, end: array.count - 1, value: value);\n    \n    print(\"Index Of Value \\(value)  In Array \\(array) is : \\(index)\")\n    \n}\n\nvar intArray =  [1, 4, 7, 8, 9, 11, 11, 15, 16, 24];\ncallBinarySearch(array: intArray , value: 3)\ncallBinarySearch(array: intArray , value: 16)\n\nvar stringArray =  [\"Assembly\", \"BASIC\", \"C#\", \"Java\", \"Objective-C\", \"PHP\", \"Swift\"];\ncallBinarySearch(array: stringArray,value:\"Assembly\")\ncallBinarySearch(array: stringArray,value:\"PHP\")\ncallBinarySearch(array: stringArray,value:\"AAA\")\n\n\n//程序输出\nIndex Of Value 3  In Array [1, 4, 7, 8, 9, 11, 11, 15, 16, 24] is : -1\nIndex Of Value 16  In Array [1, 4, 7, 8, 9, 11, 11, 15, 16, 24] is : 8\nIndex Of Value Assembly  In Array [\"Assembly\", \"BASIC\", \"C#\", \"Java\", \"Objective-C\", \"PHP\", \"Swift\"] is : 0\nIndex Of Value PHP  In Array [\"Assembly\", \"BASIC\", \"C#\", \"Java\", \"Objective-C\", \"PHP\", \"Swift\"] is : 5\nIndex Of Value AAA  In Array [\"Assembly\", \"BASIC\", \"C#\", \"Java\", \"Objective-C\", \"PHP\", \"Swift\"] is : -1\n```\n\n","slug":"algorithm_search_binary","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4rk0001oko8avaoe5rr","content":"<p>​    二分查找算法也称为折半搜索、二分搜索，是一种在有序数组中查找某一特定元素的搜索算法。算法是建立在有序数组基础上的。时间复杂度： T(n) = Θ(logn)。</p>\n<h3 id=\"原理及实现\"><a href=\"#原理及实现\" class=\"headerlink\" title=\"原理及实现\"></a>原理及实现</h3><p>基本原理：使用递归、分治的思想</p>\n<ul>\n<li>① 当数组为空时，说明数组中不存在需查找的元素。</li>\n<li>② 用有序数组的中间位置元素与需查找元素进行大小比较，如果相等，则查找结束。</li>\n<li>③ 如果中间位置元素大于需查找元素，则从数组左侧位置进行递归查找。</li>\n<li>④ 如果中间位置元素小于需查找元素，则从数组右侧位置进行递归查找。</li>\n</ul>\n<a id=\"more\"></a>\n<p>使用Swift编写简单的代码实现，如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\"> *  二分查找</span></div><div class=\"line\"><span class=\"comment\"> * 使用递归、分治的思想</span></div><div class=\"line\"><span class=\"comment\"> * ① 当数组为空时，说明数组中不存在需查找的元素。</span></div><div class=\"line\"><span class=\"comment\"> * ② 用有序数组的中间位置元素与需查找元素进行大小比较，如果相等，则查找结束。</span></div><div class=\"line\"><span class=\"comment\"> * ③ 如果中间位置元素大于需查找元素，则从数组左侧位置进行递归查找。</span></div><div class=\"line\"><span class=\"comment\"> * ④ 如果中间位置元素小于需查找元素，则从数组右侧位置进行递归查找。</span></div><div class=\"line\"><span class=\"comment\"> **/</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">binarySearch</span>&lt;T:Comparable&gt;<span class=\"params\">(array:Array&lt;T&gt;, start:Int, end:Int, value:T)</span></span> -&gt; <span class=\"type\">Int</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> <span class=\"built_in\">count</span> = end - start + <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">count</span> &lt;= <span class=\"number\">0</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;<span class=\"comment\">//没有查找到</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">let</span> midIndex = (start + end) / <span class=\"number\">2</span>;</div><div class=\"line\">    <span class=\"keyword\">let</span> midValue = array[midIndex];</div><div class=\"line\">    <span class=\"keyword\">if</span> midValue &gt; value &#123;<span class=\"comment\">//在左侧查找</span></div><div class=\"line\">        <span class=\"keyword\">return</span> binarySearch(array: array, start: start, end: midIndex - <span class=\"number\">1</span>, value: value);</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> midValue &lt; value &#123;<span class=\"comment\">//在右侧查找</span></div><div class=\"line\">        <span class=\"keyword\">return</span> binarySearch(array: array, start: midIndex + <span class=\"number\">1</span>, end: end, value: value);</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;<span class=\"comment\">//位置查找到，即当前数组中间位置元素</span></div><div class=\"line\">        <span class=\"keyword\">return</span> midIndex;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"测试用例及结果\"><a href=\"#测试用例及结果\" class=\"headerlink\" title=\"测试用例及结果\"></a>测试用例及结果</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//方法调用</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">callBinarySearch</span>&lt;T:Comparable&gt;<span class=\"params\">(array: Array&lt;T&gt;, value:T)</span></span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">let</span> index = binarySearch(array: array, start: <span class=\"number\">0</span>, end: array.<span class=\"built_in\">count</span> - <span class=\"number\">1</span>, value: value);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Index Of Value <span class=\"subst\">\\(value)</span>  In Array <span class=\"subst\">\\(array)</span> is : <span class=\"subst\">\\(index)</span>\"</span>)</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> intArray =  [<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>, <span class=\"number\">16</span>, <span class=\"number\">24</span>];</div><div class=\"line\">callBinarySearch(array: intArray , value: <span class=\"number\">3</span>)</div><div class=\"line\">callBinarySearch(array: intArray , value: <span class=\"number\">16</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> stringArray =  [<span class=\"string\">\"Assembly\"</span>, <span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"C#\"</span>, <span class=\"string\">\"Java\"</span>, <span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"Swift\"</span>];</div><div class=\"line\">callBinarySearch(array: stringArray,value:<span class=\"string\">\"Assembly\"</span>)</div><div class=\"line\">callBinarySearch(array: stringArray,value:<span class=\"string\">\"PHP\"</span>)</div><div class=\"line\">callBinarySearch(array: stringArray,value:<span class=\"string\">\"AAA\"</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//程序输出</span></div><div class=\"line\"><span class=\"type\">Index</span> <span class=\"type\">Of</span> <span class=\"type\">Value</span> <span class=\"number\">3</span>  <span class=\"type\">In</span> <span class=\"type\">Array</span> [<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>, <span class=\"number\">16</span>, <span class=\"number\">24</span>] <span class=\"keyword\">is</span> : -<span class=\"number\">1</span></div><div class=\"line\"><span class=\"type\">Index</span> <span class=\"type\">Of</span> <span class=\"type\">Value</span> <span class=\"number\">16</span>  <span class=\"type\">In</span> <span class=\"type\">Array</span> [<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>, <span class=\"number\">16</span>, <span class=\"number\">24</span>] <span class=\"keyword\">is</span> : <span class=\"number\">8</span></div><div class=\"line\"><span class=\"type\">Index</span> <span class=\"type\">Of</span> <span class=\"type\">Value</span> <span class=\"type\">Assembly</span>  <span class=\"type\">In</span> <span class=\"type\">Array</span> [<span class=\"string\">\"Assembly\"</span>, <span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"C#\"</span>, <span class=\"string\">\"Java\"</span>, <span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"Swift\"</span>] <span class=\"keyword\">is</span> : <span class=\"number\">0</span></div><div class=\"line\"><span class=\"type\">Index</span> <span class=\"type\">Of</span> <span class=\"type\">Value</span> <span class=\"type\">PHP</span>  <span class=\"type\">In</span> <span class=\"type\">Array</span> [<span class=\"string\">\"Assembly\"</span>, <span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"C#\"</span>, <span class=\"string\">\"Java\"</span>, <span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"Swift\"</span>] <span class=\"keyword\">is</span> : <span class=\"number\">5</span></div><div class=\"line\"><span class=\"type\">Index</span> <span class=\"type\">Of</span> <span class=\"type\">Value</span> <span class=\"type\">AAA</span>  <span class=\"type\">In</span> <span class=\"type\">Array</span> [<span class=\"string\">\"Assembly\"</span>, <span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"C#\"</span>, <span class=\"string\">\"Java\"</span>, <span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"Swift\"</span>] <span class=\"keyword\">is</span> : -<span class=\"number\">1</span></div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>​    二分查找算法也称为折半搜索、二分搜索，是一种在有序数组中查找某一特定元素的搜索算法。算法是建立在有序数组基础上的。时间复杂度： T(n) = Θ(logn)。</p>\n<h3 id=\"原理及实现\"><a href=\"#原理及实现\" class=\"headerlink\" title=\"原理及实现\"></a>原理及实现</h3><p>基本原理：使用递归、分治的思想</p>\n<ul>\n<li>① 当数组为空时，说明数组中不存在需查找的元素。</li>\n<li>② 用有序数组的中间位置元素与需查找元素进行大小比较，如果相等，则查找结束。</li>\n<li>③ 如果中间位置元素大于需查找元素，则从数组左侧位置进行递归查找。</li>\n<li>④ 如果中间位置元素小于需查找元素，则从数组右侧位置进行递归查找。</li>\n</ul>","more":"<p>使用Swift编写简单的代码实现，如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\"> *  二分查找</span></div><div class=\"line\"><span class=\"comment\"> * 使用递归、分治的思想</span></div><div class=\"line\"><span class=\"comment\"> * ① 当数组为空时，说明数组中不存在需查找的元素。</span></div><div class=\"line\"><span class=\"comment\"> * ② 用有序数组的中间位置元素与需查找元素进行大小比较，如果相等，则查找结束。</span></div><div class=\"line\"><span class=\"comment\"> * ③ 如果中间位置元素大于需查找元素，则从数组左侧位置进行递归查找。</span></div><div class=\"line\"><span class=\"comment\"> * ④ 如果中间位置元素小于需查找元素，则从数组右侧位置进行递归查找。</span></div><div class=\"line\"><span class=\"comment\"> **/</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">binarySearch</span>&lt;T:Comparable&gt;<span class=\"params\">(array:Array&lt;T&gt;, start:Int, end:Int, value:T)</span></span> -&gt; <span class=\"type\">Int</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> <span class=\"built_in\">count</span> = end - start + <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">count</span> &lt;= <span class=\"number\">0</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;<span class=\"comment\">//没有查找到</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">let</span> midIndex = (start + end) / <span class=\"number\">2</span>;</div><div class=\"line\">    <span class=\"keyword\">let</span> midValue = array[midIndex];</div><div class=\"line\">    <span class=\"keyword\">if</span> midValue &gt; value &#123;<span class=\"comment\">//在左侧查找</span></div><div class=\"line\">        <span class=\"keyword\">return</span> binarySearch(array: array, start: start, end: midIndex - <span class=\"number\">1</span>, value: value);</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> midValue &lt; value &#123;<span class=\"comment\">//在右侧查找</span></div><div class=\"line\">        <span class=\"keyword\">return</span> binarySearch(array: array, start: midIndex + <span class=\"number\">1</span>, end: end, value: value);</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;<span class=\"comment\">//位置查找到，即当前数组中间位置元素</span></div><div class=\"line\">        <span class=\"keyword\">return</span> midIndex;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"测试用例及结果\"><a href=\"#测试用例及结果\" class=\"headerlink\" title=\"测试用例及结果\"></a>测试用例及结果</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//方法调用</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">callBinarySearch</span>&lt;T:Comparable&gt;<span class=\"params\">(array: Array&lt;T&gt;, value:T)</span></span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">let</span> index = binarySearch(array: array, start: <span class=\"number\">0</span>, end: array.<span class=\"built_in\">count</span> - <span class=\"number\">1</span>, value: value);</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Index Of Value <span class=\"subst\">\\(value)</span>  In Array <span class=\"subst\">\\(array)</span> is : <span class=\"subst\">\\(index)</span>\"</span>)</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> intArray =  [<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>, <span class=\"number\">16</span>, <span class=\"number\">24</span>];</div><div class=\"line\">callBinarySearch(array: intArray , value: <span class=\"number\">3</span>)</div><div class=\"line\">callBinarySearch(array: intArray , value: <span class=\"number\">16</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> stringArray =  [<span class=\"string\">\"Assembly\"</span>, <span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"C#\"</span>, <span class=\"string\">\"Java\"</span>, <span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"Swift\"</span>];</div><div class=\"line\">callBinarySearch(array: stringArray,value:<span class=\"string\">\"Assembly\"</span>)</div><div class=\"line\">callBinarySearch(array: stringArray,value:<span class=\"string\">\"PHP\"</span>)</div><div class=\"line\">callBinarySearch(array: stringArray,value:<span class=\"string\">\"AAA\"</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//程序输出</span></div><div class=\"line\"><span class=\"type\">Index</span> <span class=\"type\">Of</span> <span class=\"type\">Value</span> <span class=\"number\">3</span>  <span class=\"type\">In</span> <span class=\"type\">Array</span> [<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>, <span class=\"number\">16</span>, <span class=\"number\">24</span>] <span class=\"keyword\">is</span> : -<span class=\"number\">1</span></div><div class=\"line\"><span class=\"type\">Index</span> <span class=\"type\">Of</span> <span class=\"type\">Value</span> <span class=\"number\">16</span>  <span class=\"type\">In</span> <span class=\"type\">Array</span> [<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>, <span class=\"number\">16</span>, <span class=\"number\">24</span>] <span class=\"keyword\">is</span> : <span class=\"number\">8</span></div><div class=\"line\"><span class=\"type\">Index</span> <span class=\"type\">Of</span> <span class=\"type\">Value</span> <span class=\"type\">Assembly</span>  <span class=\"type\">In</span> <span class=\"type\">Array</span> [<span class=\"string\">\"Assembly\"</span>, <span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"C#\"</span>, <span class=\"string\">\"Java\"</span>, <span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"Swift\"</span>] <span class=\"keyword\">is</span> : <span class=\"number\">0</span></div><div class=\"line\"><span class=\"type\">Index</span> <span class=\"type\">Of</span> <span class=\"type\">Value</span> <span class=\"type\">PHP</span>  <span class=\"type\">In</span> <span class=\"type\">Array</span> [<span class=\"string\">\"Assembly\"</span>, <span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"C#\"</span>, <span class=\"string\">\"Java\"</span>, <span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"Swift\"</span>] <span class=\"keyword\">is</span> : <span class=\"number\">5</span></div><div class=\"line\"><span class=\"type\">Index</span> <span class=\"type\">Of</span> <span class=\"type\">Value</span> <span class=\"type\">AAA</span>  <span class=\"type\">In</span> <span class=\"type\">Array</span> [<span class=\"string\">\"Assembly\"</span>, <span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"C#\"</span>, <span class=\"string\">\"Java\"</span>, <span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"Swift\"</span>] <span class=\"keyword\">is</span> : -<span class=\"number\">1</span></div></pre></td></tr></table></figure>"},{"layout":"post","title":"计数排序","date":"2017-05-18T13:05:37.000Z","author":"liangtong","catalog":true,"_content":"\n​\t计数排序是一个非基于比较的整数排序算法，用空间换时间，优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围）。\n\n\n\n### 基本思想及实现   \n基本思想： 假设输入的线性表L的长度为n，L=L1,L2,..,Ln；线性表的元素属于有限偏序集S，|S|=k且k=O(n)，S={S1,S2,..Sk}；则计数排序可以描述如下：      \n* ① 扫描整个集合S，对每一个Si∈S，找到在线性表L中小于等于Si的元素的个数T(Si)；\n* ② 扫描整个线性表L，对L中的每一个元素Li，将Li放在输出线性表的第T(Li)个位置上，并将T(Li)减1。\n\n<!-- more -->\n\n使用Swift编写简单的代码实现，如下：    \n```Swift\n/**\n*  计数排序\n* 计数排序是一个非基于比较的排序算法，优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。当然这是一种牺牲空间换取时间的做法，而且当O(k)>O(n*log(n))的时候其效率反而不如基于比较的排序。\n* ① 扫描整个集合S，对每一个Si∈S，找到在线性表L中小于等于Si的元素的个数T(Si)；\n* ② 扫描整个线性表L，对L中的每一个元素Li，将Li放在输出线性表的第T(Li)个位置上，并将T(Li)减1。\n**/\nfunc countSort(sortArray:inout Array<Int>, maxValue:Int) -> Array<Int>{\nlet count = sortArray.count;\nvar retArray = Array<Int>();//用于存放返回值\nif count > 0 {\nvar countArray = Array<Int>();//用于存放计数器\nfor _ in 0 ... maxValue {//初始化计数器\ncountArray.append(0);\n}\nfor _ in 0 ..< count {\nretArray.append(0);\n}\n\n//第一个步骤：统计数量\nfor i in 0 ..< count {//统计小于位置i的元素个数\ncountArray[sortArray[i]] = countArray[sortArray[i]] + 1;\n}\nfor i in 1 ... maxValue {//统计出小于等于位置i的元素个数\ncountArray[i] = countArray[i] + countArray[i-1];\n}\n\n//第二个步骤：逆向扫描数组sortArray，将i位置元素放置到retArray中countArray对应值的位置上，同时修正countArray的值\nfor i in (0 ..< count).reversed() {\nlet value = sortArray[i];\nlet countValue = countArray[value];\nretArray[countValue - 1] = value;\ncountArray[value] = countArray[value] - 1;\n}\n}\nreturn retArray;\n}\n```\n\n### 测试用例及结果\n\n```Swift\nvar intArray =  [2, 5, 3, 0, 2, 3, 0, 3];\nprint(countSort(sortArray: &intArray,maxValue:5));\n\nintArray =  [100,93,97,92,96,99,92,89,93,97,90,94,92,95];\nprint(countSort(sortArray: &intArray,maxValue:100));\n\n\n//程序输出\n[0, 0, 2, 2, 3, 3, 3, 5]\n[89, 90, 92, 92, 92, 93, 93, 94, 95, 96, 97, 97, 99, 100]\n\n```\n","source":"_posts/algorithm_sort_count.md","raw":"---\nlayout:     post\ntitle:      计数排序\ndate:       2017-05-18 21:05:37\nauthor:     liangtong\ncatalog: true\ncategories: Algorithm\ntags: Sort\n\n---\n\n​\t计数排序是一个非基于比较的整数排序算法，用空间换时间，优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围）。\n\n\n\n### 基本思想及实现   \n基本思想： 假设输入的线性表L的长度为n，L=L1,L2,..,Ln；线性表的元素属于有限偏序集S，|S|=k且k=O(n)，S={S1,S2,..Sk}；则计数排序可以描述如下：      \n* ① 扫描整个集合S，对每一个Si∈S，找到在线性表L中小于等于Si的元素的个数T(Si)；\n* ② 扫描整个线性表L，对L中的每一个元素Li，将Li放在输出线性表的第T(Li)个位置上，并将T(Li)减1。\n\n<!-- more -->\n\n使用Swift编写简单的代码实现，如下：    \n```Swift\n/**\n*  计数排序\n* 计数排序是一个非基于比较的排序算法，优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。当然这是一种牺牲空间换取时间的做法，而且当O(k)>O(n*log(n))的时候其效率反而不如基于比较的排序。\n* ① 扫描整个集合S，对每一个Si∈S，找到在线性表L中小于等于Si的元素的个数T(Si)；\n* ② 扫描整个线性表L，对L中的每一个元素Li，将Li放在输出线性表的第T(Li)个位置上，并将T(Li)减1。\n**/\nfunc countSort(sortArray:inout Array<Int>, maxValue:Int) -> Array<Int>{\nlet count = sortArray.count;\nvar retArray = Array<Int>();//用于存放返回值\nif count > 0 {\nvar countArray = Array<Int>();//用于存放计数器\nfor _ in 0 ... maxValue {//初始化计数器\ncountArray.append(0);\n}\nfor _ in 0 ..< count {\nretArray.append(0);\n}\n\n//第一个步骤：统计数量\nfor i in 0 ..< count {//统计小于位置i的元素个数\ncountArray[sortArray[i]] = countArray[sortArray[i]] + 1;\n}\nfor i in 1 ... maxValue {//统计出小于等于位置i的元素个数\ncountArray[i] = countArray[i] + countArray[i-1];\n}\n\n//第二个步骤：逆向扫描数组sortArray，将i位置元素放置到retArray中countArray对应值的位置上，同时修正countArray的值\nfor i in (0 ..< count).reversed() {\nlet value = sortArray[i];\nlet countValue = countArray[value];\nretArray[countValue - 1] = value;\ncountArray[value] = countArray[value] - 1;\n}\n}\nreturn retArray;\n}\n```\n\n### 测试用例及结果\n\n```Swift\nvar intArray =  [2, 5, 3, 0, 2, 3, 0, 3];\nprint(countSort(sortArray: &intArray,maxValue:5));\n\nintArray =  [100,93,97,92,96,99,92,89,93,97,90,94,92,95];\nprint(countSort(sortArray: &intArray,maxValue:100));\n\n\n//程序输出\n[0, 0, 2, 2, 3, 3, 3, 5]\n[89, 90, 92, 92, 92, 93, 93, 94, 95, 96, 97, 97, 99, 100]\n\n```\n","slug":"algorithm_sort_count","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4ro0004oko89ftifc9k","content":"<p>​    计数排序是一个非基于比较的整数排序算法，用空间换时间，优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围）。</p>\n<h3 id=\"基本思想及实现\"><a href=\"#基本思想及实现\" class=\"headerlink\" title=\"基本思想及实现\"></a>基本思想及实现</h3><p>基本思想： 假设输入的线性表L的长度为n，L=L1,L2,..,Ln；线性表的元素属于有限偏序集S，|S|=k且k=O(n)，S={S1,S2,..Sk}；则计数排序可以描述如下：      </p>\n<ul>\n<li>① 扫描整个集合S，对每一个Si∈S，找到在线性表L中小于等于Si的元素的个数T(Si)；</li>\n<li>② 扫描整个线性表L，对L中的每一个元素Li，将Li放在输出线性表的第T(Li)个位置上，并将T(Li)减1。</li>\n</ul>\n<a id=\"more\"></a>\n<p>使用Swift编写简单的代码实现，如下：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">*  计数排序</span></div><div class=\"line\"><span class=\"comment\">* 计数排序是一个非基于比较的排序算法，优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。当然这是一种牺牲空间换取时间的做法，而且当O(k)&gt;O(n*log(n))的时候其效率反而不如基于比较的排序。</span></div><div class=\"line\"><span class=\"comment\">* ① 扫描整个集合S，对每一个Si∈S，找到在线性表L中小于等于Si的元素的个数T(Si)；</span></div><div class=\"line\"><span class=\"comment\">* ② 扫描整个线性表L，对L中的每一个元素Li，将Li放在输出线性表的第T(Li)个位置上，并将T(Li)减1。</span></div><div class=\"line\"><span class=\"comment\">**/</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">countSort</span><span class=\"params\">(sortArray:<span class=\"keyword\">inout</span> Array&lt;Int&gt;, maxValue:Int)</span></span> -&gt; <span class=\"type\">Array</span>&lt;<span class=\"type\">Int</span>&gt;&#123;</div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"built_in\">count</span> = sortArray.<span class=\"built_in\">count</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> retArray = <span class=\"type\">Array</span>&lt;<span class=\"type\">Int</span>&gt;();<span class=\"comment\">//用于存放返回值</span></div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"built_in\">count</span> &gt; <span class=\"number\">0</span> &#123;</div><div class=\"line\"><span class=\"keyword\">var</span> countArray = <span class=\"type\">Array</span>&lt;<span class=\"type\">Int</span>&gt;();<span class=\"comment\">//用于存放计数器</span></div><div class=\"line\"><span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span> ... maxValue &#123;<span class=\"comment\">//初始化计数器</span></div><div class=\"line\">countArray.append(<span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span> ..&lt; <span class=\"built_in\">count</span> &#123;</div><div class=\"line\">retArray.append(<span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//第一个步骤：统计数量</span></div><div class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span> ..&lt; <span class=\"built_in\">count</span> &#123;<span class=\"comment\">//统计小于位置i的元素个数</span></div><div class=\"line\">countArray[sortArray[i]] = countArray[sortArray[i]] + <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">1</span> ... maxValue &#123;<span class=\"comment\">//统计出小于等于位置i的元素个数</span></div><div class=\"line\">countArray[i] = countArray[i] + countArray[i-<span class=\"number\">1</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//第二个步骤：逆向扫描数组sortArray，将i位置元素放置到retArray中countArray对应值的位置上，同时修正countArray的值</span></div><div class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> (<span class=\"number\">0</span> ..&lt; <span class=\"built_in\">count</span>).reversed() &#123;</div><div class=\"line\"><span class=\"keyword\">let</span> value = sortArray[i];</div><div class=\"line\"><span class=\"keyword\">let</span> countValue = countArray[value];</div><div class=\"line\">retArray[countValue - <span class=\"number\">1</span>] = value;</div><div class=\"line\">countArray[value] = countArray[value] - <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">return</span> retArray;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"测试用例及结果\"><a href=\"#测试用例及结果\" class=\"headerlink\" title=\"测试用例及结果\"></a>测试用例及结果</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> intArray =  [<span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>];</div><div class=\"line\"><span class=\"built_in\">print</span>(countSort(sortArray: &amp;intArray,maxValue:<span class=\"number\">5</span>));</div><div class=\"line\"></div><div class=\"line\">intArray =  [<span class=\"number\">100</span>,<span class=\"number\">93</span>,<span class=\"number\">97</span>,<span class=\"number\">92</span>,<span class=\"number\">96</span>,<span class=\"number\">99</span>,<span class=\"number\">92</span>,<span class=\"number\">89</span>,<span class=\"number\">93</span>,<span class=\"number\">97</span>,<span class=\"number\">90</span>,<span class=\"number\">94</span>,<span class=\"number\">92</span>,<span class=\"number\">95</span>];</div><div class=\"line\"><span class=\"built_in\">print</span>(countSort(sortArray: &amp;intArray,maxValue:<span class=\"number\">100</span>));</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//程序输出</span></div><div class=\"line\">[<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>]</div><div class=\"line\">[<span class=\"number\">89</span>, <span class=\"number\">90</span>, <span class=\"number\">92</span>, <span class=\"number\">92</span>, <span class=\"number\">92</span>, <span class=\"number\">93</span>, <span class=\"number\">93</span>, <span class=\"number\">94</span>, <span class=\"number\">95</span>, <span class=\"number\">96</span>, <span class=\"number\">97</span>, <span class=\"number\">97</span>, <span class=\"number\">99</span>, <span class=\"number\">100</span>]</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>​    计数排序是一个非基于比较的整数排序算法，用空间换时间，优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围）。</p>\n<h3 id=\"基本思想及实现\"><a href=\"#基本思想及实现\" class=\"headerlink\" title=\"基本思想及实现\"></a>基本思想及实现</h3><p>基本思想： 假设输入的线性表L的长度为n，L=L1,L2,..,Ln；线性表的元素属于有限偏序集S，|S|=k且k=O(n)，S={S1,S2,..Sk}；则计数排序可以描述如下：      </p>\n<ul>\n<li>① 扫描整个集合S，对每一个Si∈S，找到在线性表L中小于等于Si的元素的个数T(Si)；</li>\n<li>② 扫描整个线性表L，对L中的每一个元素Li，将Li放在输出线性表的第T(Li)个位置上，并将T(Li)减1。</li>\n</ul>","more":"<p>使用Swift编写简单的代码实现，如下：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">*  计数排序</span></div><div class=\"line\"><span class=\"comment\">* 计数排序是一个非基于比较的排序算法，优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。当然这是一种牺牲空间换取时间的做法，而且当O(k)&gt;O(n*log(n))的时候其效率反而不如基于比较的排序。</span></div><div class=\"line\"><span class=\"comment\">* ① 扫描整个集合S，对每一个Si∈S，找到在线性表L中小于等于Si的元素的个数T(Si)；</span></div><div class=\"line\"><span class=\"comment\">* ② 扫描整个线性表L，对L中的每一个元素Li，将Li放在输出线性表的第T(Li)个位置上，并将T(Li)减1。</span></div><div class=\"line\"><span class=\"comment\">**/</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">countSort</span><span class=\"params\">(sortArray:<span class=\"keyword\">inout</span> Array&lt;Int&gt;, maxValue:Int)</span></span> -&gt; <span class=\"type\">Array</span>&lt;<span class=\"type\">Int</span>&gt;&#123;</div><div class=\"line\"><span class=\"keyword\">let</span> <span class=\"built_in\">count</span> = sortArray.<span class=\"built_in\">count</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> retArray = <span class=\"type\">Array</span>&lt;<span class=\"type\">Int</span>&gt;();<span class=\"comment\">//用于存放返回值</span></div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"built_in\">count</span> &gt; <span class=\"number\">0</span> &#123;</div><div class=\"line\"><span class=\"keyword\">var</span> countArray = <span class=\"type\">Array</span>&lt;<span class=\"type\">Int</span>&gt;();<span class=\"comment\">//用于存放计数器</span></div><div class=\"line\"><span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span> ... maxValue &#123;<span class=\"comment\">//初始化计数器</span></div><div class=\"line\">countArray.append(<span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span> ..&lt; <span class=\"built_in\">count</span> &#123;</div><div class=\"line\">retArray.append(<span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//第一个步骤：统计数量</span></div><div class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span> ..&lt; <span class=\"built_in\">count</span> &#123;<span class=\"comment\">//统计小于位置i的元素个数</span></div><div class=\"line\">countArray[sortArray[i]] = countArray[sortArray[i]] + <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">1</span> ... maxValue &#123;<span class=\"comment\">//统计出小于等于位置i的元素个数</span></div><div class=\"line\">countArray[i] = countArray[i] + countArray[i-<span class=\"number\">1</span>];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//第二个步骤：逆向扫描数组sortArray，将i位置元素放置到retArray中countArray对应值的位置上，同时修正countArray的值</span></div><div class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> (<span class=\"number\">0</span> ..&lt; <span class=\"built_in\">count</span>).reversed() &#123;</div><div class=\"line\"><span class=\"keyword\">let</span> value = sortArray[i];</div><div class=\"line\"><span class=\"keyword\">let</span> countValue = countArray[value];</div><div class=\"line\">retArray[countValue - <span class=\"number\">1</span>] = value;</div><div class=\"line\">countArray[value] = countArray[value] - <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">return</span> retArray;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"测试用例及结果\"><a href=\"#测试用例及结果\" class=\"headerlink\" title=\"测试用例及结果\"></a>测试用例及结果</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> intArray =  [<span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>];</div><div class=\"line\"><span class=\"built_in\">print</span>(countSort(sortArray: &amp;intArray,maxValue:<span class=\"number\">5</span>));</div><div class=\"line\"></div><div class=\"line\">intArray =  [<span class=\"number\">100</span>,<span class=\"number\">93</span>,<span class=\"number\">97</span>,<span class=\"number\">92</span>,<span class=\"number\">96</span>,<span class=\"number\">99</span>,<span class=\"number\">92</span>,<span class=\"number\">89</span>,<span class=\"number\">93</span>,<span class=\"number\">97</span>,<span class=\"number\">90</span>,<span class=\"number\">94</span>,<span class=\"number\">92</span>,<span class=\"number\">95</span>];</div><div class=\"line\"><span class=\"built_in\">print</span>(countSort(sortArray: &amp;intArray,maxValue:<span class=\"number\">100</span>));</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//程序输出</span></div><div class=\"line\">[<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>]</div><div class=\"line\">[<span class=\"number\">89</span>, <span class=\"number\">90</span>, <span class=\"number\">92</span>, <span class=\"number\">92</span>, <span class=\"number\">92</span>, <span class=\"number\">93</span>, <span class=\"number\">93</span>, <span class=\"number\">94</span>, <span class=\"number\">95</span>, <span class=\"number\">96</span>, <span class=\"number\">97</span>, <span class=\"number\">97</span>, <span class=\"number\">99</span>, <span class=\"number\">100</span>]</div></pre></td></tr></table></figure>"},{"layout":"post","title":"插入排序","date":"2017-04-25T13:22:00.000Z","author":"liangtong","catalog":true,"_content":"\n\n​\t每次将一个待排序的记录，按其大小插入到前面已经排好序的子序列中的适当位置，直到全部记录插入完成为止。时间复杂度 T(n) = Θ(n²)。\n\n\n\n### 原理及实现   \n基本原理：对待排序数组a[n]，假设第i(i∈[1,n])个元素左侧已排序，右侧未排序。    \n * ① 从i位置左侧已排序数组位置中，逆序遍历，查找元素a[i]的目标位置，即第一个比a[i]小的元素后边targetPos（或者第一个位置）。\n * ② 移动元素：将数组元素[targetPos + 1 .. i - 1] 整体向后移动一位。\n * ③ 将第i(i∈[1,n])个元素a[i]放置到[targetPos + 1]位置。\n * ④ 遍历执行①、②、③操作，直到最后一个元素a[n]。     \n\n<!-- more -->\n\n使用Swift进行功能实现，如下：\n\n```Swift\n/**\n * 插入排序 - 算法思想\n * 对待排序数组a[n]，假设第i(i∈[1,n])个元素左侧已排序，右侧未排序。\n * ① 从i位置左侧已排序数组位置中，逆序遍历，查找元素a[i]的目标位置，即第一个比a[i]小的元素后边targetPos（或者第一个位置）。\n * ② 移动元素：将数组元素[targetPos + 1 .. i - 1] 整体向后移动一位。\n * ③ 将第i(i∈[1,n])个元素a[i]放置到[targetPos + 1]位置。\n * ④ 遍历执行①、②、③操作，直到最后一个元素a[n]。\n *\n **/\nfunc insertSort<T: Comparable>(array: inout Array<T>){\n    let count = array.count;\n    if count > 1 {\n        //第i个元素的左侧为有序，右侧为无序。遍历执行操作④\n        for i in 1 ..< count {\n            let ai = array[i];\n            \n            var targetPos = i - 1;\n            var aj = array[targetPos];\n            //如果当前元素不小于前一个元素，表明数据已经是有序的，无需后续操作\n            if ai < aj {\n                //操作①，查找第一个比a[i]小的元素位置targetPos\n                while  ai < aj && targetPos >= 0 {\n                    targetPos = targetPos - 1;\n                    if targetPos >= 0 {\n                        aj = array[targetPos];\n                    }\n                }\n                //操作②，移动元素\n                for index in (targetPos + 1  ..< i).reversed() {\n                    array[index + 1] = array[index];\n                }\n                //操作③，赋值\n                array[targetPos + 1] = ai;\n            }\n            print(\"第\\(i)次处理结果： \\(array)\")\n        }\n    }\n}\n\n```\n\n### 测试用例及结果\n\n```Swift\n//测试用例\nvar intArray =  [16,4,7,9,8,11,11,15,24,1];\nprint(\"待排序整形数组：\\(intArray)\");\ninsertSort(array: &intArray);\n\n//程序输出\n待排序整形数组：[16, 4, 7, 9, 8, 11, 11, 15, 24, 1]\n第1次处理结果： [4, 16, 7, 9, 8, 11, 11, 15, 24, 1]\n第2次处理结果： [4, 7, 16, 9, 8, 11, 11, 15, 24, 1]\n第3次处理结果： [4, 7, 9, 16, 8, 11, 11, 15, 24, 1]\n第4次处理结果： [4, 7, 8, 9, 16, 11, 11, 15, 24, 1]\n第5次处理结果： [4, 7, 8, 9, 11, 16, 11, 15, 24, 1]\n第6次处理结果： [4, 7, 8, 9, 11, 11, 16, 15, 24, 1]\n第7次处理结果： [4, 7, 8, 9, 11, 11, 15, 16, 24, 1]\n第8次处理结果： [4, 7, 8, 9, 11, 11, 15, 16, 24, 1]\n第9次处理结果： [1, 4, 7, 8, 9, 11, 11, 15, 16, 24]\n```\n\n```Swift\n//测试用例\nvar stringArray =  [\"Java\",\"C#\",\"Python\",\"Objective-C\",\"Swift\",\"PHP\",\"BASIC\",\"Pasical\",\"Assembly\"];\nprint(\"待排序字符串数组：\\(stringArray)\");\ninsertSort(array: &stringArray);\n\n//程序输出\n待排序字符串数组：[\"Java\", \"C#\", \"Python\", \"Objective-C\", \"Swift\", \"PHP\", \"BASIC\", \"Pasical\", \"Assembly\"]\n第1次处理结果： [\"C#\", \"Java\", \"Python\", \"Objective-C\", \"Swift\", \"PHP\", \"BASIC\", \"Pasical\", \"Assembly\"]\n第2次处理结果： [\"C#\", \"Java\", \"Python\", \"Objective-C\", \"Swift\", \"PHP\", \"BASIC\", \"Pasical\", \"Assembly\"]\n第3次处理结果： [\"C#\", \"Java\", \"Objective-C\", \"Python\", \"Swift\", \"PHP\", \"BASIC\", \"Pasical\", \"Assembly\"]\n第4次处理结果： [\"C#\", \"Java\", \"Objective-C\", \"Python\", \"Swift\", \"PHP\", \"BASIC\", \"Pasical\", \"Assembly\"]\n第5次处理结果： [\"C#\", \"Java\", \"Objective-C\", \"PHP\", \"Python\", \"Swift\", \"BASIC\", \"Pasical\", \"Assembly\"]\n第6次处理结果： [\"BASIC\", \"C#\", \"Java\", \"Objective-C\", \"PHP\", \"Python\", \"Swift\", \"Pasical\", \"Assembly\"]\n第7次处理结果： [\"BASIC\", \"C#\", \"Java\", \"Objective-C\", \"PHP\", \"Pasical\", \"Python\", \"Swift\", \"Assembly\"]\n第8次处理结果： [\"Assembly\", \"BASIC\", \"C#\", \"Java\", \"Objective-C\", \"PHP\", \"Pasical\", \"Python\", \"Swift\"]\n```\n\n","source":"_posts/algorithm_sort_insert.md","raw":"---\nlayout:     post\ntitle:      插入排序\ndate:       2017-04-25 21:22:00\nauthor:     liangtong\ncatalog: true\ncategories: Algorithm\ntags: Sort\n\n---\n\n\n​\t每次将一个待排序的记录，按其大小插入到前面已经排好序的子序列中的适当位置，直到全部记录插入完成为止。时间复杂度 T(n) = Θ(n²)。\n\n\n\n### 原理及实现   \n基本原理：对待排序数组a[n]，假设第i(i∈[1,n])个元素左侧已排序，右侧未排序。    \n * ① 从i位置左侧已排序数组位置中，逆序遍历，查找元素a[i]的目标位置，即第一个比a[i]小的元素后边targetPos（或者第一个位置）。\n * ② 移动元素：将数组元素[targetPos + 1 .. i - 1] 整体向后移动一位。\n * ③ 将第i(i∈[1,n])个元素a[i]放置到[targetPos + 1]位置。\n * ④ 遍历执行①、②、③操作，直到最后一个元素a[n]。     \n\n<!-- more -->\n\n使用Swift进行功能实现，如下：\n\n```Swift\n/**\n * 插入排序 - 算法思想\n * 对待排序数组a[n]，假设第i(i∈[1,n])个元素左侧已排序，右侧未排序。\n * ① 从i位置左侧已排序数组位置中，逆序遍历，查找元素a[i]的目标位置，即第一个比a[i]小的元素后边targetPos（或者第一个位置）。\n * ② 移动元素：将数组元素[targetPos + 1 .. i - 1] 整体向后移动一位。\n * ③ 将第i(i∈[1,n])个元素a[i]放置到[targetPos + 1]位置。\n * ④ 遍历执行①、②、③操作，直到最后一个元素a[n]。\n *\n **/\nfunc insertSort<T: Comparable>(array: inout Array<T>){\n    let count = array.count;\n    if count > 1 {\n        //第i个元素的左侧为有序，右侧为无序。遍历执行操作④\n        for i in 1 ..< count {\n            let ai = array[i];\n            \n            var targetPos = i - 1;\n            var aj = array[targetPos];\n            //如果当前元素不小于前一个元素，表明数据已经是有序的，无需后续操作\n            if ai < aj {\n                //操作①，查找第一个比a[i]小的元素位置targetPos\n                while  ai < aj && targetPos >= 0 {\n                    targetPos = targetPos - 1;\n                    if targetPos >= 0 {\n                        aj = array[targetPos];\n                    }\n                }\n                //操作②，移动元素\n                for index in (targetPos + 1  ..< i).reversed() {\n                    array[index + 1] = array[index];\n                }\n                //操作③，赋值\n                array[targetPos + 1] = ai;\n            }\n            print(\"第\\(i)次处理结果： \\(array)\")\n        }\n    }\n}\n\n```\n\n### 测试用例及结果\n\n```Swift\n//测试用例\nvar intArray =  [16,4,7,9,8,11,11,15,24,1];\nprint(\"待排序整形数组：\\(intArray)\");\ninsertSort(array: &intArray);\n\n//程序输出\n待排序整形数组：[16, 4, 7, 9, 8, 11, 11, 15, 24, 1]\n第1次处理结果： [4, 16, 7, 9, 8, 11, 11, 15, 24, 1]\n第2次处理结果： [4, 7, 16, 9, 8, 11, 11, 15, 24, 1]\n第3次处理结果： [4, 7, 9, 16, 8, 11, 11, 15, 24, 1]\n第4次处理结果： [4, 7, 8, 9, 16, 11, 11, 15, 24, 1]\n第5次处理结果： [4, 7, 8, 9, 11, 16, 11, 15, 24, 1]\n第6次处理结果： [4, 7, 8, 9, 11, 11, 16, 15, 24, 1]\n第7次处理结果： [4, 7, 8, 9, 11, 11, 15, 16, 24, 1]\n第8次处理结果： [4, 7, 8, 9, 11, 11, 15, 16, 24, 1]\n第9次处理结果： [1, 4, 7, 8, 9, 11, 11, 15, 16, 24]\n```\n\n```Swift\n//测试用例\nvar stringArray =  [\"Java\",\"C#\",\"Python\",\"Objective-C\",\"Swift\",\"PHP\",\"BASIC\",\"Pasical\",\"Assembly\"];\nprint(\"待排序字符串数组：\\(stringArray)\");\ninsertSort(array: &stringArray);\n\n//程序输出\n待排序字符串数组：[\"Java\", \"C#\", \"Python\", \"Objective-C\", \"Swift\", \"PHP\", \"BASIC\", \"Pasical\", \"Assembly\"]\n第1次处理结果： [\"C#\", \"Java\", \"Python\", \"Objective-C\", \"Swift\", \"PHP\", \"BASIC\", \"Pasical\", \"Assembly\"]\n第2次处理结果： [\"C#\", \"Java\", \"Python\", \"Objective-C\", \"Swift\", \"PHP\", \"BASIC\", \"Pasical\", \"Assembly\"]\n第3次处理结果： [\"C#\", \"Java\", \"Objective-C\", \"Python\", \"Swift\", \"PHP\", \"BASIC\", \"Pasical\", \"Assembly\"]\n第4次处理结果： [\"C#\", \"Java\", \"Objective-C\", \"Python\", \"Swift\", \"PHP\", \"BASIC\", \"Pasical\", \"Assembly\"]\n第5次处理结果： [\"C#\", \"Java\", \"Objective-C\", \"PHP\", \"Python\", \"Swift\", \"BASIC\", \"Pasical\", \"Assembly\"]\n第6次处理结果： [\"BASIC\", \"C#\", \"Java\", \"Objective-C\", \"PHP\", \"Python\", \"Swift\", \"Pasical\", \"Assembly\"]\n第7次处理结果： [\"BASIC\", \"C#\", \"Java\", \"Objective-C\", \"PHP\", \"Pasical\", \"Python\", \"Swift\", \"Assembly\"]\n第8次处理结果： [\"Assembly\", \"BASIC\", \"C#\", \"Java\", \"Objective-C\", \"PHP\", \"Pasical\", \"Python\", \"Swift\"]\n```\n\n","slug":"algorithm_sort_insert","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4rp0005oko8clbgcxec","content":"<p>​    每次将一个待排序的记录，按其大小插入到前面已经排好序的子序列中的适当位置，直到全部记录插入完成为止。时间复杂度 T(n) = Θ(n²)。</p>\n<h3 id=\"原理及实现\"><a href=\"#原理及实现\" class=\"headerlink\" title=\"原理及实现\"></a>原理及实现</h3><p>基本原理：对待排序数组a[n]，假设第i(i∈[1,n])个元素左侧已排序，右侧未排序。    </p>\n<ul>\n<li>① 从i位置左侧已排序数组位置中，逆序遍历，查找元素a[i]的目标位置，即第一个比a[i]小的元素后边targetPos（或者第一个位置）。</li>\n<li>② 移动元素：将数组元素[targetPos + 1 .. i - 1] 整体向后移动一位。</li>\n<li>③ 将第i(i∈[1,n])个元素a[i]放置到[targetPos + 1]位置。</li>\n<li>④ 遍历执行①、②、③操作，直到最后一个元素a[n]。     </li>\n</ul>\n<a id=\"more\"></a>\n<p>使用Swift进行功能实现，如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\"> * 插入排序 - 算法思想</span></div><div class=\"line\"><span class=\"comment\"> * 对待排序数组a[n]，假设第i(i∈[1,n])个元素左侧已排序，右侧未排序。</span></div><div class=\"line\"><span class=\"comment\"> * ① 从i位置左侧已排序数组位置中，逆序遍历，查找元素a[i]的目标位置，即第一个比a[i]小的元素后边targetPos（或者第一个位置）。</span></div><div class=\"line\"><span class=\"comment\"> * ② 移动元素：将数组元素[targetPos + 1 .. i - 1] 整体向后移动一位。</span></div><div class=\"line\"><span class=\"comment\"> * ③ 将第i(i∈[1,n])个元素a[i]放置到[targetPos + 1]位置。</span></div><div class=\"line\"><span class=\"comment\"> * ④ 遍历执行①、②、③操作，直到最后一个元素a[n]。</span></div><div class=\"line\"><span class=\"comment\"> *</span></div><div class=\"line\"><span class=\"comment\"> **/</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">insertSort</span>&lt;T: Comparable&gt;<span class=\"params\">(array: <span class=\"keyword\">inout</span> Array&lt;T&gt;)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> <span class=\"built_in\">count</span> = array.<span class=\"built_in\">count</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">count</span> &gt; <span class=\"number\">1</span> &#123;</div><div class=\"line\">        <span class=\"comment\">//第i个元素的左侧为有序，右侧为无序。遍历执行操作④</span></div><div class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">1</span> ..&lt; <span class=\"built_in\">count</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">let</span> ai = array[i];</div><div class=\"line\">            </div><div class=\"line\">            <span class=\"keyword\">var</span> targetPos = i - <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"keyword\">var</span> aj = array[targetPos];</div><div class=\"line\">            <span class=\"comment\">//如果当前元素不小于前一个元素，表明数据已经是有序的，无需后续操作</span></div><div class=\"line\">            <span class=\"keyword\">if</span> ai &lt; aj &#123;</div><div class=\"line\">                <span class=\"comment\">//操作①，查找第一个比a[i]小的元素位置targetPos</span></div><div class=\"line\">                <span class=\"keyword\">while</span>  ai &lt; aj &amp;&amp; targetPos &gt;= <span class=\"number\">0</span> &#123;</div><div class=\"line\">                    targetPos = targetPos - <span class=\"number\">1</span>;</div><div class=\"line\">                    <span class=\"keyword\">if</span> targetPos &gt;= <span class=\"number\">0</span> &#123;</div><div class=\"line\">                        aj = array[targetPos];</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"comment\">//操作②，移动元素</span></div><div class=\"line\">                <span class=\"keyword\">for</span> index <span class=\"keyword\">in</span> (targetPos + <span class=\"number\">1</span>  ..&lt; i).reversed() &#123;</div><div class=\"line\">                    array[index + <span class=\"number\">1</span>] = array[index];</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"comment\">//操作③，赋值</span></div><div class=\"line\">                array[targetPos + <span class=\"number\">1</span>] = ai;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">\"第<span class=\"subst\">\\(i)</span>次处理结果： <span class=\"subst\">\\(array)</span>\"</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"测试用例及结果\"><a href=\"#测试用例及结果\" class=\"headerlink\" title=\"测试用例及结果\"></a>测试用例及结果</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//测试用例</span></div><div class=\"line\"><span class=\"keyword\">var</span> intArray =  [<span class=\"number\">16</span>,<span class=\"number\">4</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>,<span class=\"number\">8</span>,<span class=\"number\">11</span>,<span class=\"number\">11</span>,<span class=\"number\">15</span>,<span class=\"number\">24</span>,<span class=\"number\">1</span>];</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"待排序整形数组：<span class=\"subst\">\\(intArray)</span>\"</span>);</div><div class=\"line\">insertSort(array: &amp;intArray);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//程序输出</span></div><div class=\"line\">待排序整形数组：[<span class=\"number\">16</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">11</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>, <span class=\"number\">24</span>, <span class=\"number\">1</span>]</div><div class=\"line\">第<span class=\"number\">1</span>次处理结果： [<span class=\"number\">4</span>, <span class=\"number\">16</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">11</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>, <span class=\"number\">24</span>, <span class=\"number\">1</span>]</div><div class=\"line\">第<span class=\"number\">2</span>次处理结果： [<span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">16</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">11</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>, <span class=\"number\">24</span>, <span class=\"number\">1</span>]</div><div class=\"line\">第<span class=\"number\">3</span>次处理结果： [<span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">16</span>, <span class=\"number\">8</span>, <span class=\"number\">11</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>, <span class=\"number\">24</span>, <span class=\"number\">1</span>]</div><div class=\"line\">第<span class=\"number\">4</span>次处理结果： [<span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">16</span>, <span class=\"number\">11</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>, <span class=\"number\">24</span>, <span class=\"number\">1</span>]</div><div class=\"line\">第<span class=\"number\">5</span>次处理结果： [<span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">16</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>, <span class=\"number\">24</span>, <span class=\"number\">1</span>]</div><div class=\"line\">第<span class=\"number\">6</span>次处理结果： [<span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">11</span>, <span class=\"number\">16</span>, <span class=\"number\">15</span>, <span class=\"number\">24</span>, <span class=\"number\">1</span>]</div><div class=\"line\">第<span class=\"number\">7</span>次处理结果： [<span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>, <span class=\"number\">16</span>, <span class=\"number\">24</span>, <span class=\"number\">1</span>]</div><div class=\"line\">第<span class=\"number\">8</span>次处理结果： [<span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>, <span class=\"number\">16</span>, <span class=\"number\">24</span>, <span class=\"number\">1</span>]</div><div class=\"line\">第<span class=\"number\">9</span>次处理结果： [<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>, <span class=\"number\">16</span>, <span class=\"number\">24</span>]</div></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//测试用例</span></div><div class=\"line\"><span class=\"keyword\">var</span> stringArray =  [<span class=\"string\">\"Java\"</span>,<span class=\"string\">\"C#\"</span>,<span class=\"string\">\"Python\"</span>,<span class=\"string\">\"Objective-C\"</span>,<span class=\"string\">\"Swift\"</span>,<span class=\"string\">\"PHP\"</span>,<span class=\"string\">\"BASIC\"</span>,<span class=\"string\">\"Pasical\"</span>,<span class=\"string\">\"Assembly\"</span>];</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"待排序字符串数组：<span class=\"subst\">\\(stringArray)</span>\"</span>);</div><div class=\"line\">insertSort(array: &amp;stringArray);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//程序输出</span></div><div class=\"line\">待排序字符串数组：[<span class=\"string\">\"Java\"</span>, <span class=\"string\">\"C#\"</span>, <span class=\"string\">\"Python\"</span>, <span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"Swift\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"Pasical\"</span>, <span class=\"string\">\"Assembly\"</span>]</div><div class=\"line\">第<span class=\"number\">1</span>次处理结果： [<span class=\"string\">\"C#\"</span>, <span class=\"string\">\"Java\"</span>, <span class=\"string\">\"Python\"</span>, <span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"Swift\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"Pasical\"</span>, <span class=\"string\">\"Assembly\"</span>]</div><div class=\"line\">第<span class=\"number\">2</span>次处理结果： [<span class=\"string\">\"C#\"</span>, <span class=\"string\">\"Java\"</span>, <span class=\"string\">\"Python\"</span>, <span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"Swift\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"Pasical\"</span>, <span class=\"string\">\"Assembly\"</span>]</div><div class=\"line\">第<span class=\"number\">3</span>次处理结果： [<span class=\"string\">\"C#\"</span>, <span class=\"string\">\"Java\"</span>, <span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"Python\"</span>, <span class=\"string\">\"Swift\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"Pasical\"</span>, <span class=\"string\">\"Assembly\"</span>]</div><div class=\"line\">第<span class=\"number\">4</span>次处理结果： [<span class=\"string\">\"C#\"</span>, <span class=\"string\">\"Java\"</span>, <span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"Python\"</span>, <span class=\"string\">\"Swift\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"Pasical\"</span>, <span class=\"string\">\"Assembly\"</span>]</div><div class=\"line\">第<span class=\"number\">5</span>次处理结果： [<span class=\"string\">\"C#\"</span>, <span class=\"string\">\"Java\"</span>, <span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"Python\"</span>, <span class=\"string\">\"Swift\"</span>, <span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"Pasical\"</span>, <span class=\"string\">\"Assembly\"</span>]</div><div class=\"line\">第<span class=\"number\">6</span>次处理结果： [<span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"C#\"</span>, <span class=\"string\">\"Java\"</span>, <span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"Python\"</span>, <span class=\"string\">\"Swift\"</span>, <span class=\"string\">\"Pasical\"</span>, <span class=\"string\">\"Assembly\"</span>]</div><div class=\"line\">第<span class=\"number\">7</span>次处理结果： [<span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"C#\"</span>, <span class=\"string\">\"Java\"</span>, <span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"Pasical\"</span>, <span class=\"string\">\"Python\"</span>, <span class=\"string\">\"Swift\"</span>, <span class=\"string\">\"Assembly\"</span>]</div><div class=\"line\">第<span class=\"number\">8</span>次处理结果： [<span class=\"string\">\"Assembly\"</span>, <span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"C#\"</span>, <span class=\"string\">\"Java\"</span>, <span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"Pasical\"</span>, <span class=\"string\">\"Python\"</span>, <span class=\"string\">\"Swift\"</span>]</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>​    每次将一个待排序的记录，按其大小插入到前面已经排好序的子序列中的适当位置，直到全部记录插入完成为止。时间复杂度 T(n) = Θ(n²)。</p>\n<h3 id=\"原理及实现\"><a href=\"#原理及实现\" class=\"headerlink\" title=\"原理及实现\"></a>原理及实现</h3><p>基本原理：对待排序数组a[n]，假设第i(i∈[1,n])个元素左侧已排序，右侧未排序。    </p>\n<ul>\n<li>① 从i位置左侧已排序数组位置中，逆序遍历，查找元素a[i]的目标位置，即第一个比a[i]小的元素后边targetPos（或者第一个位置）。</li>\n<li>② 移动元素：将数组元素[targetPos + 1 .. i - 1] 整体向后移动一位。</li>\n<li>③ 将第i(i∈[1,n])个元素a[i]放置到[targetPos + 1]位置。</li>\n<li>④ 遍历执行①、②、③操作，直到最后一个元素a[n]。     </li>\n</ul>","more":"<p>使用Swift进行功能实现，如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\"> * 插入排序 - 算法思想</span></div><div class=\"line\"><span class=\"comment\"> * 对待排序数组a[n]，假设第i(i∈[1,n])个元素左侧已排序，右侧未排序。</span></div><div class=\"line\"><span class=\"comment\"> * ① 从i位置左侧已排序数组位置中，逆序遍历，查找元素a[i]的目标位置，即第一个比a[i]小的元素后边targetPos（或者第一个位置）。</span></div><div class=\"line\"><span class=\"comment\"> * ② 移动元素：将数组元素[targetPos + 1 .. i - 1] 整体向后移动一位。</span></div><div class=\"line\"><span class=\"comment\"> * ③ 将第i(i∈[1,n])个元素a[i]放置到[targetPos + 1]位置。</span></div><div class=\"line\"><span class=\"comment\"> * ④ 遍历执行①、②、③操作，直到最后一个元素a[n]。</span></div><div class=\"line\"><span class=\"comment\"> *</span></div><div class=\"line\"><span class=\"comment\"> **/</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">insertSort</span>&lt;T: Comparable&gt;<span class=\"params\">(array: <span class=\"keyword\">inout</span> Array&lt;T&gt;)</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> <span class=\"built_in\">count</span> = array.<span class=\"built_in\">count</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">count</span> &gt; <span class=\"number\">1</span> &#123;</div><div class=\"line\">        <span class=\"comment\">//第i个元素的左侧为有序，右侧为无序。遍历执行操作④</span></div><div class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">1</span> ..&lt; <span class=\"built_in\">count</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">let</span> ai = array[i];</div><div class=\"line\">            </div><div class=\"line\">            <span class=\"keyword\">var</span> targetPos = i - <span class=\"number\">1</span>;</div><div class=\"line\">            <span class=\"keyword\">var</span> aj = array[targetPos];</div><div class=\"line\">            <span class=\"comment\">//如果当前元素不小于前一个元素，表明数据已经是有序的，无需后续操作</span></div><div class=\"line\">            <span class=\"keyword\">if</span> ai &lt; aj &#123;</div><div class=\"line\">                <span class=\"comment\">//操作①，查找第一个比a[i]小的元素位置targetPos</span></div><div class=\"line\">                <span class=\"keyword\">while</span>  ai &lt; aj &amp;&amp; targetPos &gt;= <span class=\"number\">0</span> &#123;</div><div class=\"line\">                    targetPos = targetPos - <span class=\"number\">1</span>;</div><div class=\"line\">                    <span class=\"keyword\">if</span> targetPos &gt;= <span class=\"number\">0</span> &#123;</div><div class=\"line\">                        aj = array[targetPos];</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"comment\">//操作②，移动元素</span></div><div class=\"line\">                <span class=\"keyword\">for</span> index <span class=\"keyword\">in</span> (targetPos + <span class=\"number\">1</span>  ..&lt; i).reversed() &#123;</div><div class=\"line\">                    array[index + <span class=\"number\">1</span>] = array[index];</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"comment\">//操作③，赋值</span></div><div class=\"line\">                array[targetPos + <span class=\"number\">1</span>] = ai;</div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">\"第<span class=\"subst\">\\(i)</span>次处理结果： <span class=\"subst\">\\(array)</span>\"</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"测试用例及结果\"><a href=\"#测试用例及结果\" class=\"headerlink\" title=\"测试用例及结果\"></a>测试用例及结果</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//测试用例</span></div><div class=\"line\"><span class=\"keyword\">var</span> intArray =  [<span class=\"number\">16</span>,<span class=\"number\">4</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>,<span class=\"number\">8</span>,<span class=\"number\">11</span>,<span class=\"number\">11</span>,<span class=\"number\">15</span>,<span class=\"number\">24</span>,<span class=\"number\">1</span>];</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"待排序整形数组：<span class=\"subst\">\\(intArray)</span>\"</span>);</div><div class=\"line\">insertSort(array: &amp;intArray);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//程序输出</span></div><div class=\"line\">待排序整形数组：[<span class=\"number\">16</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">11</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>, <span class=\"number\">24</span>, <span class=\"number\">1</span>]</div><div class=\"line\">第<span class=\"number\">1</span>次处理结果： [<span class=\"number\">4</span>, <span class=\"number\">16</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">11</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>, <span class=\"number\">24</span>, <span class=\"number\">1</span>]</div><div class=\"line\">第<span class=\"number\">2</span>次处理结果： [<span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">16</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">11</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>, <span class=\"number\">24</span>, <span class=\"number\">1</span>]</div><div class=\"line\">第<span class=\"number\">3</span>次处理结果： [<span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">16</span>, <span class=\"number\">8</span>, <span class=\"number\">11</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>, <span class=\"number\">24</span>, <span class=\"number\">1</span>]</div><div class=\"line\">第<span class=\"number\">4</span>次处理结果： [<span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">16</span>, <span class=\"number\">11</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>, <span class=\"number\">24</span>, <span class=\"number\">1</span>]</div><div class=\"line\">第<span class=\"number\">5</span>次处理结果： [<span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">16</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>, <span class=\"number\">24</span>, <span class=\"number\">1</span>]</div><div class=\"line\">第<span class=\"number\">6</span>次处理结果： [<span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">11</span>, <span class=\"number\">16</span>, <span class=\"number\">15</span>, <span class=\"number\">24</span>, <span class=\"number\">1</span>]</div><div class=\"line\">第<span class=\"number\">7</span>次处理结果： [<span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>, <span class=\"number\">16</span>, <span class=\"number\">24</span>, <span class=\"number\">1</span>]</div><div class=\"line\">第<span class=\"number\">8</span>次处理结果： [<span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>, <span class=\"number\">16</span>, <span class=\"number\">24</span>, <span class=\"number\">1</span>]</div><div class=\"line\">第<span class=\"number\">9</span>次处理结果： [<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>, <span class=\"number\">16</span>, <span class=\"number\">24</span>]</div></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//测试用例</span></div><div class=\"line\"><span class=\"keyword\">var</span> stringArray =  [<span class=\"string\">\"Java\"</span>,<span class=\"string\">\"C#\"</span>,<span class=\"string\">\"Python\"</span>,<span class=\"string\">\"Objective-C\"</span>,<span class=\"string\">\"Swift\"</span>,<span class=\"string\">\"PHP\"</span>,<span class=\"string\">\"BASIC\"</span>,<span class=\"string\">\"Pasical\"</span>,<span class=\"string\">\"Assembly\"</span>];</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"待排序字符串数组：<span class=\"subst\">\\(stringArray)</span>\"</span>);</div><div class=\"line\">insertSort(array: &amp;stringArray);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//程序输出</span></div><div class=\"line\">待排序字符串数组：[<span class=\"string\">\"Java\"</span>, <span class=\"string\">\"C#\"</span>, <span class=\"string\">\"Python\"</span>, <span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"Swift\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"Pasical\"</span>, <span class=\"string\">\"Assembly\"</span>]</div><div class=\"line\">第<span class=\"number\">1</span>次处理结果： [<span class=\"string\">\"C#\"</span>, <span class=\"string\">\"Java\"</span>, <span class=\"string\">\"Python\"</span>, <span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"Swift\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"Pasical\"</span>, <span class=\"string\">\"Assembly\"</span>]</div><div class=\"line\">第<span class=\"number\">2</span>次处理结果： [<span class=\"string\">\"C#\"</span>, <span class=\"string\">\"Java\"</span>, <span class=\"string\">\"Python\"</span>, <span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"Swift\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"Pasical\"</span>, <span class=\"string\">\"Assembly\"</span>]</div><div class=\"line\">第<span class=\"number\">3</span>次处理结果： [<span class=\"string\">\"C#\"</span>, <span class=\"string\">\"Java\"</span>, <span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"Python\"</span>, <span class=\"string\">\"Swift\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"Pasical\"</span>, <span class=\"string\">\"Assembly\"</span>]</div><div class=\"line\">第<span class=\"number\">4</span>次处理结果： [<span class=\"string\">\"C#\"</span>, <span class=\"string\">\"Java\"</span>, <span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"Python\"</span>, <span class=\"string\">\"Swift\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"Pasical\"</span>, <span class=\"string\">\"Assembly\"</span>]</div><div class=\"line\">第<span class=\"number\">5</span>次处理结果： [<span class=\"string\">\"C#\"</span>, <span class=\"string\">\"Java\"</span>, <span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"Python\"</span>, <span class=\"string\">\"Swift\"</span>, <span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"Pasical\"</span>, <span class=\"string\">\"Assembly\"</span>]</div><div class=\"line\">第<span class=\"number\">6</span>次处理结果： [<span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"C#\"</span>, <span class=\"string\">\"Java\"</span>, <span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"Python\"</span>, <span class=\"string\">\"Swift\"</span>, <span class=\"string\">\"Pasical\"</span>, <span class=\"string\">\"Assembly\"</span>]</div><div class=\"line\">第<span class=\"number\">7</span>次处理结果： [<span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"C#\"</span>, <span class=\"string\">\"Java\"</span>, <span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"Pasical\"</span>, <span class=\"string\">\"Python\"</span>, <span class=\"string\">\"Swift\"</span>, <span class=\"string\">\"Assembly\"</span>]</div><div class=\"line\">第<span class=\"number\">8</span>次处理结果： [<span class=\"string\">\"Assembly\"</span>, <span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"C#\"</span>, <span class=\"string\">\"Java\"</span>, <span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"Pasical\"</span>, <span class=\"string\">\"Python\"</span>, <span class=\"string\">\"Swift\"</span>]</div></pre></td></tr></table></figure>"},{"layout":"post","title":"归并排序","date":"2017-04-26T06:25:00.000Z","author":"liangtong","catalog":true,"_content":"\n\n​\t归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。需要额外的存储空间，时间复杂度： T(n) = Θ(nlgn)。\n\n\n\n<!-- more -->\n\n\n### 基本原理及实现   \n基本原理：使用递归、分治思想，将待排序数组分割成字数组，将排序后的字数组合并。    \n * ① 当数组只包含一个元素时，直接返回该元素即可。\n * ② 取数组中间位置元素，递归调用左侧和右侧数组，进行归并排序。\n * ③ 将左侧和右侧排序后的有序数组进行合并。     \n\n使用Swift进行功能实现，如下：\n\n```Swift\n/**\n * 归并排序 - 算法思想\n * 使用递归、分治的思想。\n * ① 当数组只包含一个元素时，直接返回该元素即可。\n * ② 取数组中间位置元素，递归调用左侧和右侧数组，进行归并排序。\n * ③ 将左侧和右侧排序后的有序数组进行合并。\n *\n **/\nfunc mergeSort<T:Comparable>(array: Array<T>, start:Int , end:Int) -> Array<T>{\n    if start >= end {//① 只有一个元素，直接返回即可\n        return [array[start]];\n    }else{\n        let middle = (start + end) / 2;\n        //② 递归调用，给左侧数组排序\n        let leftSortArray = mergeSort(array:array,start:start,end:middle);\n        //② 递归调用，给右侧数组排序\n        let rightSortedArray = mergeSort(array: array, start: middle + 1, end: end);\n        \n        //③ 合并有序数组\n        var leftIndex = 0;\n        var rightIndex = 0;\n        let leftCount = leftSortArray.count;\n        let rightCount = rightSortedArray.count;\n        var retArray:Array<T> = [];\n\t// 两个有序数组均存在值时，依次插入最小值\n        while leftIndex < leftCount && rightIndex < rightCount {\n            let leftValue = leftSortArray[leftIndex];\n            let rightValue = rightSortedArray[rightIndex];\n            if leftValue < rightValue {\n                retArray.append(leftValue);\n                leftIndex += 1;\n            }else{\n                retArray.append(rightValue);\n                rightIndex += 1;\n            }\n        }\n        // 将左侧有序数组剩余部分依次插入到排序结果中\n        while leftIndex < leftCount {\n            let leftValue = leftSortArray[leftIndex];\n            retArray.append(leftValue);\n            leftIndex += 1;\n        }\n        // 将右侧有序数组剩余部分依次插入到排序结果中\n        while rightIndex < rightCount {\n            let rightValue = rightSortedArray[rightIndex];\n            retArray.append(rightValue);\n            rightIndex += 1;\n        }\n        \n        return retArray;\n    }\n}\n\n//调用方法\nfunc callMergeSort<T:Comparable>(array:Array<T>)->Array<T>{\n    let count = array.count;\n    if count > 0 {\n        return mergeSort(array: array, start: 0, end: count - 1);\n    }else{\n        return [];\n    }\n\n}\n```\n\n### 测试用例及结果\n\n```Swift\n//测试用例\nvar intArray =  [16,4,7,9,8,11,11,15,24,1];\nprint(\"待排序数组：\\(intArray)\");\nlet sortedArray = callMergeSort(array: intArray);\nprint(\"排序后数组：\\(sortedArray)\");\n\n//程序输出\n待排序数组：[16, 4, 7, 9, 8, 11, 11, 15, 24, 1]\n排序后数组：[1, 4, 7, 8, 9, 11, 11, 15, 16, 24]\n```\n\n```Swift\n//测试用例\nvar stringArray =  [\"Java\",\"C#\",\"Python\",\"Objective-C\",\"Swift\",\"PHP\",\"BASIC\",\"Pasical\",\"Assembly\"];\nprint(\"待排序数组：\\(stringArray)\");\nlet sortedStringArray = callMergeSort(array: stringArray);\nprint(\"排序后数组：\\(sortedStringArray)\");\n\n//程序输出\n待排序数组：[\"Java\", \"C#\", \"Python\", \"Objective-C\", \"Swift\", \"PHP\", \"BASIC\", \"Pasical\", \"Assembly\"]\n排序后数组：[\"Assembly\", \"BASIC\", \"C#\", \"Java\", \"Objective-C\", \"PHP\", \"Pasical\", \"Python\", \"Swift\"]\n```\n\n","source":"_posts/algorithm_sort_merge.md","raw":"---\nlayout:     post\ntitle:      归并排序\ndate:       2017-04-26 14:25:00\nauthor:     liangtong\ncatalog: true\ncategories: Algorithm\ntags: Sort\n\n---\n\n\n​\t归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。需要额外的存储空间，时间复杂度： T(n) = Θ(nlgn)。\n\n\n\n<!-- more -->\n\n\n### 基本原理及实现   \n基本原理：使用递归、分治思想，将待排序数组分割成字数组，将排序后的字数组合并。    \n * ① 当数组只包含一个元素时，直接返回该元素即可。\n * ② 取数组中间位置元素，递归调用左侧和右侧数组，进行归并排序。\n * ③ 将左侧和右侧排序后的有序数组进行合并。     \n\n使用Swift进行功能实现，如下：\n\n```Swift\n/**\n * 归并排序 - 算法思想\n * 使用递归、分治的思想。\n * ① 当数组只包含一个元素时，直接返回该元素即可。\n * ② 取数组中间位置元素，递归调用左侧和右侧数组，进行归并排序。\n * ③ 将左侧和右侧排序后的有序数组进行合并。\n *\n **/\nfunc mergeSort<T:Comparable>(array: Array<T>, start:Int , end:Int) -> Array<T>{\n    if start >= end {//① 只有一个元素，直接返回即可\n        return [array[start]];\n    }else{\n        let middle = (start + end) / 2;\n        //② 递归调用，给左侧数组排序\n        let leftSortArray = mergeSort(array:array,start:start,end:middle);\n        //② 递归调用，给右侧数组排序\n        let rightSortedArray = mergeSort(array: array, start: middle + 1, end: end);\n        \n        //③ 合并有序数组\n        var leftIndex = 0;\n        var rightIndex = 0;\n        let leftCount = leftSortArray.count;\n        let rightCount = rightSortedArray.count;\n        var retArray:Array<T> = [];\n\t// 两个有序数组均存在值时，依次插入最小值\n        while leftIndex < leftCount && rightIndex < rightCount {\n            let leftValue = leftSortArray[leftIndex];\n            let rightValue = rightSortedArray[rightIndex];\n            if leftValue < rightValue {\n                retArray.append(leftValue);\n                leftIndex += 1;\n            }else{\n                retArray.append(rightValue);\n                rightIndex += 1;\n            }\n        }\n        // 将左侧有序数组剩余部分依次插入到排序结果中\n        while leftIndex < leftCount {\n            let leftValue = leftSortArray[leftIndex];\n            retArray.append(leftValue);\n            leftIndex += 1;\n        }\n        // 将右侧有序数组剩余部分依次插入到排序结果中\n        while rightIndex < rightCount {\n            let rightValue = rightSortedArray[rightIndex];\n            retArray.append(rightValue);\n            rightIndex += 1;\n        }\n        \n        return retArray;\n    }\n}\n\n//调用方法\nfunc callMergeSort<T:Comparable>(array:Array<T>)->Array<T>{\n    let count = array.count;\n    if count > 0 {\n        return mergeSort(array: array, start: 0, end: count - 1);\n    }else{\n        return [];\n    }\n\n}\n```\n\n### 测试用例及结果\n\n```Swift\n//测试用例\nvar intArray =  [16,4,7,9,8,11,11,15,24,1];\nprint(\"待排序数组：\\(intArray)\");\nlet sortedArray = callMergeSort(array: intArray);\nprint(\"排序后数组：\\(sortedArray)\");\n\n//程序输出\n待排序数组：[16, 4, 7, 9, 8, 11, 11, 15, 24, 1]\n排序后数组：[1, 4, 7, 8, 9, 11, 11, 15, 16, 24]\n```\n\n```Swift\n//测试用例\nvar stringArray =  [\"Java\",\"C#\",\"Python\",\"Objective-C\",\"Swift\",\"PHP\",\"BASIC\",\"Pasical\",\"Assembly\"];\nprint(\"待排序数组：\\(stringArray)\");\nlet sortedStringArray = callMergeSort(array: stringArray);\nprint(\"排序后数组：\\(sortedStringArray)\");\n\n//程序输出\n待排序数组：[\"Java\", \"C#\", \"Python\", \"Objective-C\", \"Swift\", \"PHP\", \"BASIC\", \"Pasical\", \"Assembly\"]\n排序后数组：[\"Assembly\", \"BASIC\", \"C#\", \"Java\", \"Objective-C\", \"PHP\", \"Pasical\", \"Python\", \"Swift\"]\n```\n\n","slug":"algorithm_sort_merge","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4rr0006oko89f18uk5t","content":"<p>​    归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。需要额外的存储空间，时间复杂度： T(n) = Θ(nlgn)。</p>\n<a id=\"more\"></a>\n<h3 id=\"基本原理及实现\"><a href=\"#基本原理及实现\" class=\"headerlink\" title=\"基本原理及实现\"></a>基本原理及实现</h3><p>基本原理：使用递归、分治思想，将待排序数组分割成字数组，将排序后的字数组合并。    </p>\n<ul>\n<li>① 当数组只包含一个元素时，直接返回该元素即可。</li>\n<li>② 取数组中间位置元素，递归调用左侧和右侧数组，进行归并排序。</li>\n<li>③ 将左侧和右侧排序后的有序数组进行合并。     </li>\n</ul>\n<p>使用Swift进行功能实现，如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\"> * 归并排序 - 算法思想</span></div><div class=\"line\"><span class=\"comment\"> * 使用递归、分治的思想。</span></div><div class=\"line\"><span class=\"comment\"> * ① 当数组只包含一个元素时，直接返回该元素即可。</span></div><div class=\"line\"><span class=\"comment\"> * ② 取数组中间位置元素，递归调用左侧和右侧数组，进行归并排序。</span></div><div class=\"line\"><span class=\"comment\"> * ③ 将左侧和右侧排序后的有序数组进行合并。</span></div><div class=\"line\"><span class=\"comment\"> *</span></div><div class=\"line\"><span class=\"comment\"> **/</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">mergeSort</span>&lt;T:Comparable&gt;<span class=\"params\">(array: Array&lt;T&gt;, start:Int , end:Int)</span></span> -&gt; <span class=\"type\">Array</span>&lt;<span class=\"type\">T</span>&gt;&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> start &gt;= end &#123;<span class=\"comment\">//① 只有一个元素，直接返回即可</span></div><div class=\"line\">        <span class=\"keyword\">return</span> [array[start]];</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> middle = (start + end) / <span class=\"number\">2</span>;</div><div class=\"line\">        <span class=\"comment\">//② 递归调用，给左侧数组排序</span></div><div class=\"line\">        <span class=\"keyword\">let</span> leftSortArray = mergeSort(array:array,start:start,end:middle);</div><div class=\"line\">        <span class=\"comment\">//② 递归调用，给右侧数组排序</span></div><div class=\"line\">        <span class=\"keyword\">let</span> rightSortedArray = mergeSort(array: array, start: middle + <span class=\"number\">1</span>, end: end);</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//③ 合并有序数组</span></div><div class=\"line\">        <span class=\"keyword\">var</span> leftIndex = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">var</span> rightIndex = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">let</span> leftCount = leftSortArray.<span class=\"built_in\">count</span>;</div><div class=\"line\">        <span class=\"keyword\">let</span> rightCount = rightSortedArray.<span class=\"built_in\">count</span>;</div><div class=\"line\">        <span class=\"keyword\">var</span> retArray:<span class=\"type\">Array</span>&lt;<span class=\"type\">T</span>&gt; = [];</div><div class=\"line\">\t<span class=\"comment\">// 两个有序数组均存在值时，依次插入最小值</span></div><div class=\"line\">        <span class=\"keyword\">while</span> leftIndex &lt; leftCount &amp;&amp; rightIndex &lt; rightCount &#123;</div><div class=\"line\">            <span class=\"keyword\">let</span> leftValue = leftSortArray[leftIndex];</div><div class=\"line\">            <span class=\"keyword\">let</span> rightValue = rightSortedArray[rightIndex];</div><div class=\"line\">            <span class=\"keyword\">if</span> leftValue &lt; rightValue &#123;</div><div class=\"line\">                retArray.append(leftValue);</div><div class=\"line\">                leftIndex += <span class=\"number\">1</span>;</div><div class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">                retArray.append(rightValue);</div><div class=\"line\">                rightIndex += <span class=\"number\">1</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// 将左侧有序数组剩余部分依次插入到排序结果中</span></div><div class=\"line\">        <span class=\"keyword\">while</span> leftIndex &lt; leftCount &#123;</div><div class=\"line\">            <span class=\"keyword\">let</span> leftValue = leftSortArray[leftIndex];</div><div class=\"line\">            retArray.append(leftValue);</div><div class=\"line\">            leftIndex += <span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// 将右侧有序数组剩余部分依次插入到排序结果中</span></div><div class=\"line\">        <span class=\"keyword\">while</span> rightIndex &lt; rightCount &#123;</div><div class=\"line\">            <span class=\"keyword\">let</span> rightValue = rightSortedArray[rightIndex];</div><div class=\"line\">            retArray.append(rightValue);</div><div class=\"line\">            rightIndex += <span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">return</span> retArray;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//调用方法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">callMergeSort</span>&lt;T:Comparable&gt;<span class=\"params\">(array:Array&lt;T&gt;)</span></span>-&gt;<span class=\"type\">Array</span>&lt;<span class=\"type\">T</span>&gt;&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> <span class=\"built_in\">count</span> = array.<span class=\"built_in\">count</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">count</span> &gt; <span class=\"number\">0</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> mergeSort(array: array, start: <span class=\"number\">0</span>, end: <span class=\"built_in\">count</span> - <span class=\"number\">1</span>);</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> [];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"测试用例及结果\"><a href=\"#测试用例及结果\" class=\"headerlink\" title=\"测试用例及结果\"></a>测试用例及结果</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//测试用例</span></div><div class=\"line\"><span class=\"keyword\">var</span> intArray =  [<span class=\"number\">16</span>,<span class=\"number\">4</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>,<span class=\"number\">8</span>,<span class=\"number\">11</span>,<span class=\"number\">11</span>,<span class=\"number\">15</span>,<span class=\"number\">24</span>,<span class=\"number\">1</span>];</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"待排序数组：<span class=\"subst\">\\(intArray)</span>\"</span>);</div><div class=\"line\"><span class=\"keyword\">let</span> sortedArray = callMergeSort(array: intArray);</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"排序后数组：<span class=\"subst\">\\(sortedArray)</span>\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//程序输出</span></div><div class=\"line\">待排序数组：[<span class=\"number\">16</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">11</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>, <span class=\"number\">24</span>, <span class=\"number\">1</span>]</div><div class=\"line\">排序后数组：[<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>, <span class=\"number\">16</span>, <span class=\"number\">24</span>]</div></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//测试用例</span></div><div class=\"line\"><span class=\"keyword\">var</span> stringArray =  [<span class=\"string\">\"Java\"</span>,<span class=\"string\">\"C#\"</span>,<span class=\"string\">\"Python\"</span>,<span class=\"string\">\"Objective-C\"</span>,<span class=\"string\">\"Swift\"</span>,<span class=\"string\">\"PHP\"</span>,<span class=\"string\">\"BASIC\"</span>,<span class=\"string\">\"Pasical\"</span>,<span class=\"string\">\"Assembly\"</span>];</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"待排序数组：<span class=\"subst\">\\(stringArray)</span>\"</span>);</div><div class=\"line\"><span class=\"keyword\">let</span> sortedStringArray = callMergeSort(array: stringArray);</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"排序后数组：<span class=\"subst\">\\(sortedStringArray)</span>\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//程序输出</span></div><div class=\"line\">待排序数组：[<span class=\"string\">\"Java\"</span>, <span class=\"string\">\"C#\"</span>, <span class=\"string\">\"Python\"</span>, <span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"Swift\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"Pasical\"</span>, <span class=\"string\">\"Assembly\"</span>]</div><div class=\"line\">排序后数组：[<span class=\"string\">\"Assembly\"</span>, <span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"C#\"</span>, <span class=\"string\">\"Java\"</span>, <span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"Pasical\"</span>, <span class=\"string\">\"Python\"</span>, <span class=\"string\">\"Swift\"</span>]</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>​    归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。需要额外的存储空间，时间复杂度： T(n) = Θ(nlgn)。</p>","more":"<h3 id=\"基本原理及实现\"><a href=\"#基本原理及实现\" class=\"headerlink\" title=\"基本原理及实现\"></a>基本原理及实现</h3><p>基本原理：使用递归、分治思想，将待排序数组分割成字数组，将排序后的字数组合并。    </p>\n<ul>\n<li>① 当数组只包含一个元素时，直接返回该元素即可。</li>\n<li>② 取数组中间位置元素，递归调用左侧和右侧数组，进行归并排序。</li>\n<li>③ 将左侧和右侧排序后的有序数组进行合并。     </li>\n</ul>\n<p>使用Swift进行功能实现，如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\"> * 归并排序 - 算法思想</span></div><div class=\"line\"><span class=\"comment\"> * 使用递归、分治的思想。</span></div><div class=\"line\"><span class=\"comment\"> * ① 当数组只包含一个元素时，直接返回该元素即可。</span></div><div class=\"line\"><span class=\"comment\"> * ② 取数组中间位置元素，递归调用左侧和右侧数组，进行归并排序。</span></div><div class=\"line\"><span class=\"comment\"> * ③ 将左侧和右侧排序后的有序数组进行合并。</span></div><div class=\"line\"><span class=\"comment\"> *</span></div><div class=\"line\"><span class=\"comment\"> **/</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">mergeSort</span>&lt;T:Comparable&gt;<span class=\"params\">(array: Array&lt;T&gt;, start:Int , end:Int)</span></span> -&gt; <span class=\"type\">Array</span>&lt;<span class=\"type\">T</span>&gt;&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> start &gt;= end &#123;<span class=\"comment\">//① 只有一个元素，直接返回即可</span></div><div class=\"line\">        <span class=\"keyword\">return</span> [array[start]];</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> middle = (start + end) / <span class=\"number\">2</span>;</div><div class=\"line\">        <span class=\"comment\">//② 递归调用，给左侧数组排序</span></div><div class=\"line\">        <span class=\"keyword\">let</span> leftSortArray = mergeSort(array:array,start:start,end:middle);</div><div class=\"line\">        <span class=\"comment\">//② 递归调用，给右侧数组排序</span></div><div class=\"line\">        <span class=\"keyword\">let</span> rightSortedArray = mergeSort(array: array, start: middle + <span class=\"number\">1</span>, end: end);</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">//③ 合并有序数组</span></div><div class=\"line\">        <span class=\"keyword\">var</span> leftIndex = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">var</span> rightIndex = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">let</span> leftCount = leftSortArray.<span class=\"built_in\">count</span>;</div><div class=\"line\">        <span class=\"keyword\">let</span> rightCount = rightSortedArray.<span class=\"built_in\">count</span>;</div><div class=\"line\">        <span class=\"keyword\">var</span> retArray:<span class=\"type\">Array</span>&lt;<span class=\"type\">T</span>&gt; = [];</div><div class=\"line\">\t<span class=\"comment\">// 两个有序数组均存在值时，依次插入最小值</span></div><div class=\"line\">        <span class=\"keyword\">while</span> leftIndex &lt; leftCount &amp;&amp; rightIndex &lt; rightCount &#123;</div><div class=\"line\">            <span class=\"keyword\">let</span> leftValue = leftSortArray[leftIndex];</div><div class=\"line\">            <span class=\"keyword\">let</span> rightValue = rightSortedArray[rightIndex];</div><div class=\"line\">            <span class=\"keyword\">if</span> leftValue &lt; rightValue &#123;</div><div class=\"line\">                retArray.append(leftValue);</div><div class=\"line\">                leftIndex += <span class=\"number\">1</span>;</div><div class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">                retArray.append(rightValue);</div><div class=\"line\">                rightIndex += <span class=\"number\">1</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// 将左侧有序数组剩余部分依次插入到排序结果中</span></div><div class=\"line\">        <span class=\"keyword\">while</span> leftIndex &lt; leftCount &#123;</div><div class=\"line\">            <span class=\"keyword\">let</span> leftValue = leftSortArray[leftIndex];</div><div class=\"line\">            retArray.append(leftValue);</div><div class=\"line\">            leftIndex += <span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// 将右侧有序数组剩余部分依次插入到排序结果中</span></div><div class=\"line\">        <span class=\"keyword\">while</span> rightIndex &lt; rightCount &#123;</div><div class=\"line\">            <span class=\"keyword\">let</span> rightValue = rightSortedArray[rightIndex];</div><div class=\"line\">            retArray.append(rightValue);</div><div class=\"line\">            rightIndex += <span class=\"number\">1</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">return</span> retArray;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//调用方法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">callMergeSort</span>&lt;T:Comparable&gt;<span class=\"params\">(array:Array&lt;T&gt;)</span></span>-&gt;<span class=\"type\">Array</span>&lt;<span class=\"type\">T</span>&gt;&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> <span class=\"built_in\">count</span> = array.<span class=\"built_in\">count</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">count</span> &gt; <span class=\"number\">0</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> mergeSort(array: array, start: <span class=\"number\">0</span>, end: <span class=\"built_in\">count</span> - <span class=\"number\">1</span>);</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> [];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"测试用例及结果\"><a href=\"#测试用例及结果\" class=\"headerlink\" title=\"测试用例及结果\"></a>测试用例及结果</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//测试用例</span></div><div class=\"line\"><span class=\"keyword\">var</span> intArray =  [<span class=\"number\">16</span>,<span class=\"number\">4</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>,<span class=\"number\">8</span>,<span class=\"number\">11</span>,<span class=\"number\">11</span>,<span class=\"number\">15</span>,<span class=\"number\">24</span>,<span class=\"number\">1</span>];</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"待排序数组：<span class=\"subst\">\\(intArray)</span>\"</span>);</div><div class=\"line\"><span class=\"keyword\">let</span> sortedArray = callMergeSort(array: intArray);</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"排序后数组：<span class=\"subst\">\\(sortedArray)</span>\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//程序输出</span></div><div class=\"line\">待排序数组：[<span class=\"number\">16</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">11</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>, <span class=\"number\">24</span>, <span class=\"number\">1</span>]</div><div class=\"line\">排序后数组：[<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>, <span class=\"number\">16</span>, <span class=\"number\">24</span>]</div></pre></td></tr></table></figure>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//测试用例</span></div><div class=\"line\"><span class=\"keyword\">var</span> stringArray =  [<span class=\"string\">\"Java\"</span>,<span class=\"string\">\"C#\"</span>,<span class=\"string\">\"Python\"</span>,<span class=\"string\">\"Objective-C\"</span>,<span class=\"string\">\"Swift\"</span>,<span class=\"string\">\"PHP\"</span>,<span class=\"string\">\"BASIC\"</span>,<span class=\"string\">\"Pasical\"</span>,<span class=\"string\">\"Assembly\"</span>];</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"待排序数组：<span class=\"subst\">\\(stringArray)</span>\"</span>);</div><div class=\"line\"><span class=\"keyword\">let</span> sortedStringArray = callMergeSort(array: stringArray);</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"排序后数组：<span class=\"subst\">\\(sortedStringArray)</span>\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//程序输出</span></div><div class=\"line\">待排序数组：[<span class=\"string\">\"Java\"</span>, <span class=\"string\">\"C#\"</span>, <span class=\"string\">\"Python\"</span>, <span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"Swift\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"Pasical\"</span>, <span class=\"string\">\"Assembly\"</span>]</div><div class=\"line\">排序后数组：[<span class=\"string\">\"Assembly\"</span>, <span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"C#\"</span>, <span class=\"string\">\"Java\"</span>, <span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"Pasical\"</span>, <span class=\"string\">\"Python\"</span>, <span class=\"string\">\"Swift\"</span>]</div></pre></td></tr></table></figure>"},{"layout":"post","title":"快速排序","date":"2017-05-11T09:25:00.000Z","author":"liangtong","catalog":true,"_content":"\n​\t快速排序是采用分治法（Divide and Conquer）的应用。和归并排序不同的是，她不需要额外的存储空间，时间复杂度： T(n) = Θ(nlgn)，最坏情况下是：T(n) = Θ(n²)。\n\n\n\n### 基本原理及实现   \n基本原理： 使用递归、分治的思想，每次调用排序方法，随机选取一个key值，结果保证：key值所在数组中的位置，且能保证key左侧位置的数据总小于key值；右侧位置数据总大于key值      \n* ① 当数组为空时，数组不需要排序，算法结束。\n* ② 选取一个key值，可以是带排序数组中任意位置的元素，这里选第一个元素。\n* ③ 遍历数组(角标j)，将所有比key值小的元素移动到数组前边(角标i)。遍历结束时，i即是中间位置。\n* ④ 将key值与角标i位置元素位置互换。\n* ⑤ 递归对i位置左侧、右侧数组进行快速排序。\n\n<!-- more -->\n\n使用Swift编写简单的代码实现，如下：    \n```Swift\n/**\n*  快速排序\n* 使用递归、分治的思想，每次调用排序方法，选取一个key值，结果保证：key值所在数组中的位置，且能保证key左侧位置的数据总小于key值；右侧位置数据总大于key值\n* ① 当数组为空时，数组不需要排序，算法结束。\n* ② 选取一个key值，可以是带排序数组中任意位置的元素，这里选第一个元素。\n* ③ 遍历数组(角标j)，将所有比key值小的元素移动到数组前边(角标i)。遍历结束时，i即是中间位置。\n* ④ 将key值与角标i位置元素位置互换。\n* ⑤ 递归对i位置左侧、右侧数组进行快速排序。\n**/\nfunc quickSort<T:Comparable>(array:inout Array<T>, start:Int, end:Int){\nif end <= start {\nreturn;\n}\nlet key = array[start];//随机选取key值 - 这里我们固定选择第一个元素\nvar i = start;\nvar j = i + 1;\nwhile j <= end {//从key后开始遍历，查找所有比key小的元素，移动到数组前边\nlet aj = array[j];\nif key > aj {\n//交换元素\nlet tempValue = array[i+1];\narray[i+1] = aj;\narray[j] = tempValue;\n//重新设置角标\ni += 1;\n}\nj += 1;//数组遍历\n}\n//i位置即是最后一个比key值小的元素位置，然后交换key值和i位置元素\nlet ai = array[i];\narray[i] = key;\narray[start] = ai;\n\nprint(\"sorting：key：\\(key)  values: \\(array[start...end])\");\n\n//对i位置左侧、右侧的数组进行排序方法调用\nquickSort(array: &array, start: start, end: i - 1)\nquickSort(array: &array, start: i+1, end: end);\n}\n```\n\n### 测试用例及结果\n\n```Swift\nvar intArray =  [6,10,13,5,8,3,2,11];\nquickSort(array: &intArray,start:0,end:intArray.count-1);\nprint(\"排序结束：\\(intArray)\");\n\n\n//程序输出\nsorting：key：6  values: [2, 5, 3, 6, 8, 13, 10, 11]\nsorting：key：2  values: [2, 5, 3]\nsorting：key：5  values: [3, 5]\nsorting：key：8  values: [8, 13, 10, 11]\nsorting：key：13  values: [11, 10, 13]\nsorting：key：11  values: [10, 11]\n排序结束：[2, 3, 5, 6, 8, 10, 11, 13]\n\n\nvar stringArray =  [\"Java\",\"C#\",\"Python\",\"Objective-C\",\"Swift\",\"PHP\",\"BASIC\",\"Pasical\",\"Assembly\"];\nquickSort(array: &stringArray,start:0,end:stringArray.count-1);\nprint(\"排序结束：\\(stringArray)\");\n\n\n//程序输出\nsorting：key：Java  values: [\"Assembly\", \"C#\", \"BASIC\", \"Java\", \"Swift\", \"PHP\", \"Python\", \"Pasical\", \"Objective-C\"]\nsorting：key：Assembly  values: [\"Assembly\", \"C#\", \"BASIC\"]\nsorting：key：C#  values: [\"BASIC\", \"C#\"]\nsorting：key：Swift  values: [\"Objective-C\", \"PHP\", \"Python\", \"Pasical\", \"Swift\"]\nsorting：key：Objective-C  values: [\"Objective-C\", \"PHP\", \"Python\", \"Pasical\"]\nsorting：key：PHP  values: [\"PHP\", \"Python\", \"Pasical\"]\nsorting：key：Python  values: [\"Pasical\", \"Python\"]\n排序结束：[\"Assembly\", \"BASIC\", \"C#\", \"Java\", \"Objective-C\", \"PHP\", \"Pasical\", \"Python\", \"Swift\"]\n```\n","source":"_posts/algorithm_sort_quick.md","raw":"---\nlayout:     post\ntitle:      快速排序\ndate:       2017-05-11 17:25:00\nauthor:     liangtong\ncatalog: true\ncategories: Algorithm\ntags: Sort\n\n---\n\n​\t快速排序是采用分治法（Divide and Conquer）的应用。和归并排序不同的是，她不需要额外的存储空间，时间复杂度： T(n) = Θ(nlgn)，最坏情况下是：T(n) = Θ(n²)。\n\n\n\n### 基本原理及实现   \n基本原理： 使用递归、分治的思想，每次调用排序方法，随机选取一个key值，结果保证：key值所在数组中的位置，且能保证key左侧位置的数据总小于key值；右侧位置数据总大于key值      \n* ① 当数组为空时，数组不需要排序，算法结束。\n* ② 选取一个key值，可以是带排序数组中任意位置的元素，这里选第一个元素。\n* ③ 遍历数组(角标j)，将所有比key值小的元素移动到数组前边(角标i)。遍历结束时，i即是中间位置。\n* ④ 将key值与角标i位置元素位置互换。\n* ⑤ 递归对i位置左侧、右侧数组进行快速排序。\n\n<!-- more -->\n\n使用Swift编写简单的代码实现，如下：    \n```Swift\n/**\n*  快速排序\n* 使用递归、分治的思想，每次调用排序方法，选取一个key值，结果保证：key值所在数组中的位置，且能保证key左侧位置的数据总小于key值；右侧位置数据总大于key值\n* ① 当数组为空时，数组不需要排序，算法结束。\n* ② 选取一个key值，可以是带排序数组中任意位置的元素，这里选第一个元素。\n* ③ 遍历数组(角标j)，将所有比key值小的元素移动到数组前边(角标i)。遍历结束时，i即是中间位置。\n* ④ 将key值与角标i位置元素位置互换。\n* ⑤ 递归对i位置左侧、右侧数组进行快速排序。\n**/\nfunc quickSort<T:Comparable>(array:inout Array<T>, start:Int, end:Int){\nif end <= start {\nreturn;\n}\nlet key = array[start];//随机选取key值 - 这里我们固定选择第一个元素\nvar i = start;\nvar j = i + 1;\nwhile j <= end {//从key后开始遍历，查找所有比key小的元素，移动到数组前边\nlet aj = array[j];\nif key > aj {\n//交换元素\nlet tempValue = array[i+1];\narray[i+1] = aj;\narray[j] = tempValue;\n//重新设置角标\ni += 1;\n}\nj += 1;//数组遍历\n}\n//i位置即是最后一个比key值小的元素位置，然后交换key值和i位置元素\nlet ai = array[i];\narray[i] = key;\narray[start] = ai;\n\nprint(\"sorting：key：\\(key)  values: \\(array[start...end])\");\n\n//对i位置左侧、右侧的数组进行排序方法调用\nquickSort(array: &array, start: start, end: i - 1)\nquickSort(array: &array, start: i+1, end: end);\n}\n```\n\n### 测试用例及结果\n\n```Swift\nvar intArray =  [6,10,13,5,8,3,2,11];\nquickSort(array: &intArray,start:0,end:intArray.count-1);\nprint(\"排序结束：\\(intArray)\");\n\n\n//程序输出\nsorting：key：6  values: [2, 5, 3, 6, 8, 13, 10, 11]\nsorting：key：2  values: [2, 5, 3]\nsorting：key：5  values: [3, 5]\nsorting：key：8  values: [8, 13, 10, 11]\nsorting：key：13  values: [11, 10, 13]\nsorting：key：11  values: [10, 11]\n排序结束：[2, 3, 5, 6, 8, 10, 11, 13]\n\n\nvar stringArray =  [\"Java\",\"C#\",\"Python\",\"Objective-C\",\"Swift\",\"PHP\",\"BASIC\",\"Pasical\",\"Assembly\"];\nquickSort(array: &stringArray,start:0,end:stringArray.count-1);\nprint(\"排序结束：\\(stringArray)\");\n\n\n//程序输出\nsorting：key：Java  values: [\"Assembly\", \"C#\", \"BASIC\", \"Java\", \"Swift\", \"PHP\", \"Python\", \"Pasical\", \"Objective-C\"]\nsorting：key：Assembly  values: [\"Assembly\", \"C#\", \"BASIC\"]\nsorting：key：C#  values: [\"BASIC\", \"C#\"]\nsorting：key：Swift  values: [\"Objective-C\", \"PHP\", \"Python\", \"Pasical\", \"Swift\"]\nsorting：key：Objective-C  values: [\"Objective-C\", \"PHP\", \"Python\", \"Pasical\"]\nsorting：key：PHP  values: [\"PHP\", \"Python\", \"Pasical\"]\nsorting：key：Python  values: [\"Pasical\", \"Python\"]\n排序结束：[\"Assembly\", \"BASIC\", \"C#\", \"Java\", \"Objective-C\", \"PHP\", \"Pasical\", \"Python\", \"Swift\"]\n```\n","slug":"algorithm_sort_quick","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4rx000aoko8ck4z3g0r","content":"<p>​    快速排序是采用分治法（Divide and Conquer）的应用。和归并排序不同的是，她不需要额外的存储空间，时间复杂度： T(n) = Θ(nlgn)，最坏情况下是：T(n) = Θ(n²)。</p>\n<h3 id=\"基本原理及实现\"><a href=\"#基本原理及实现\" class=\"headerlink\" title=\"基本原理及实现\"></a>基本原理及实现</h3><p>基本原理： 使用递归、分治的思想，每次调用排序方法，随机选取一个key值，结果保证：key值所在数组中的位置，且能保证key左侧位置的数据总小于key值；右侧位置数据总大于key值      </p>\n<ul>\n<li>① 当数组为空时，数组不需要排序，算法结束。</li>\n<li>② 选取一个key值，可以是带排序数组中任意位置的元素，这里选第一个元素。</li>\n<li>③ 遍历数组(角标j)，将所有比key值小的元素移动到数组前边(角标i)。遍历结束时，i即是中间位置。</li>\n<li>④ 将key值与角标i位置元素位置互换。</li>\n<li>⑤ 递归对i位置左侧、右侧数组进行快速排序。</li>\n</ul>\n<a id=\"more\"></a>\n<p>使用Swift编写简单的代码实现，如下：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">*  快速排序</span></div><div class=\"line\"><span class=\"comment\">* 使用递归、分治的思想，每次调用排序方法，选取一个key值，结果保证：key值所在数组中的位置，且能保证key左侧位置的数据总小于key值；右侧位置数据总大于key值</span></div><div class=\"line\"><span class=\"comment\">* ① 当数组为空时，数组不需要排序，算法结束。</span></div><div class=\"line\"><span class=\"comment\">* ② 选取一个key值，可以是带排序数组中任意位置的元素，这里选第一个元素。</span></div><div class=\"line\"><span class=\"comment\">* ③ 遍历数组(角标j)，将所有比key值小的元素移动到数组前边(角标i)。遍历结束时，i即是中间位置。</span></div><div class=\"line\"><span class=\"comment\">* ④ 将key值与角标i位置元素位置互换。</span></div><div class=\"line\"><span class=\"comment\">* ⑤ 递归对i位置左侧、右侧数组进行快速排序。</span></div><div class=\"line\"><span class=\"comment\">**/</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">quickSort</span>&lt;T:Comparable&gt;<span class=\"params\">(array:<span class=\"keyword\">inout</span> Array&lt;T&gt;, start:Int, end:Int)</span></span>&#123;</div><div class=\"line\"><span class=\"keyword\">if</span> end &lt;= start &#123;</div><div class=\"line\"><span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> key = array[start];<span class=\"comment\">//随机选取key值 - 这里我们固定选择第一个元素</span></div><div class=\"line\"><span class=\"keyword\">var</span> i = start;</div><div class=\"line\"><span class=\"keyword\">var</span> j = i + <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"keyword\">while</span> j &lt;= end &#123;<span class=\"comment\">//从key后开始遍历，查找所有比key小的元素，移动到数组前边</span></div><div class=\"line\"><span class=\"keyword\">let</span> aj = array[j];</div><div class=\"line\"><span class=\"keyword\">if</span> key &gt; aj &#123;</div><div class=\"line\"><span class=\"comment\">//交换元素</span></div><div class=\"line\"><span class=\"keyword\">let</span> tempValue = array[i+<span class=\"number\">1</span>];</div><div class=\"line\">array[i+<span class=\"number\">1</span>] = aj;</div><div class=\"line\">array[j] = tempValue;</div><div class=\"line\"><span class=\"comment\">//重新设置角标</span></div><div class=\"line\">i += <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">j += <span class=\"number\">1</span>;<span class=\"comment\">//数组遍历</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//i位置即是最后一个比key值小的元素位置，然后交换key值和i位置元素</span></div><div class=\"line\"><span class=\"keyword\">let</span> ai = array[i];</div><div class=\"line\">array[i] = key;</div><div class=\"line\">array[start] = ai;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"sorting：key：<span class=\"subst\">\\(key)</span>  values: <span class=\"subst\">\\(array[start...end])</span>\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//对i位置左侧、右侧的数组进行排序方法调用</span></div><div class=\"line\"><span class=\"built_in\">quickSort</span>(array: &amp;array, start: start, end: i - <span class=\"number\">1</span>)</div><div class=\"line\"><span class=\"built_in\">quickSort</span>(array: &amp;array, start: i+<span class=\"number\">1</span>, end: end);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"测试用例及结果\"><a href=\"#测试用例及结果\" class=\"headerlink\" title=\"测试用例及结果\"></a>测试用例及结果</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> intArray =  [<span class=\"number\">6</span>,<span class=\"number\">10</span>,<span class=\"number\">13</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">11</span>];</div><div class=\"line\"><span class=\"built_in\">quickSort</span>(array: &amp;intArray,start:<span class=\"number\">0</span>,end:intArray.<span class=\"built_in\">count</span>-<span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"排序结束：<span class=\"subst\">\\(intArray)</span>\"</span>);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//程序输出</span></div><div class=\"line\">sorting：key：<span class=\"number\">6</span>  values: [<span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">13</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>]</div><div class=\"line\">sorting：key：<span class=\"number\">2</span>  values: [<span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>]</div><div class=\"line\">sorting：key：<span class=\"number\">5</span>  values: [<span class=\"number\">3</span>, <span class=\"number\">5</span>]</div><div class=\"line\">sorting：key：<span class=\"number\">8</span>  values: [<span class=\"number\">8</span>, <span class=\"number\">13</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>]</div><div class=\"line\">sorting：key：<span class=\"number\">13</span>  values: [<span class=\"number\">11</span>, <span class=\"number\">10</span>, <span class=\"number\">13</span>]</div><div class=\"line\">sorting：key：<span class=\"number\">11</span>  values: [<span class=\"number\">10</span>, <span class=\"number\">11</span>]</div><div class=\"line\">排序结束：[<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> stringArray =  [<span class=\"string\">\"Java\"</span>,<span class=\"string\">\"C#\"</span>,<span class=\"string\">\"Python\"</span>,<span class=\"string\">\"Objective-C\"</span>,<span class=\"string\">\"Swift\"</span>,<span class=\"string\">\"PHP\"</span>,<span class=\"string\">\"BASIC\"</span>,<span class=\"string\">\"Pasical\"</span>,<span class=\"string\">\"Assembly\"</span>];</div><div class=\"line\"><span class=\"built_in\">quickSort</span>(array: &amp;stringArray,start:<span class=\"number\">0</span>,end:stringArray.<span class=\"built_in\">count</span>-<span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"排序结束：<span class=\"subst\">\\(stringArray)</span>\"</span>);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//程序输出</span></div><div class=\"line\">sorting：key：<span class=\"type\">Java</span>  values: [<span class=\"string\">\"Assembly\"</span>, <span class=\"string\">\"C#\"</span>, <span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"Java\"</span>, <span class=\"string\">\"Swift\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"Python\"</span>, <span class=\"string\">\"Pasical\"</span>, <span class=\"string\">\"Objective-C\"</span>]</div><div class=\"line\">sorting：key：<span class=\"type\">Assembly</span>  values: [<span class=\"string\">\"Assembly\"</span>, <span class=\"string\">\"C#\"</span>, <span class=\"string\">\"BASIC\"</span>]</div><div class=\"line\">sorting：key：<span class=\"type\">C</span>#  values: [<span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"C#\"</span>]</div><div class=\"line\">sorting：key：<span class=\"type\">Swift</span>  values: [<span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"Python\"</span>, <span class=\"string\">\"Pasical\"</span>, <span class=\"string\">\"Swift\"</span>]</div><div class=\"line\">sorting：key：<span class=\"type\">Objective</span>-<span class=\"type\">C</span>  values: [<span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"Python\"</span>, <span class=\"string\">\"Pasical\"</span>]</div><div class=\"line\">sorting：key：<span class=\"type\">PHP</span>  values: [<span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"Python\"</span>, <span class=\"string\">\"Pasical\"</span>]</div><div class=\"line\">sorting：key：<span class=\"type\">Python</span>  values: [<span class=\"string\">\"Pasical\"</span>, <span class=\"string\">\"Python\"</span>]</div><div class=\"line\">排序结束：[<span class=\"string\">\"Assembly\"</span>, <span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"C#\"</span>, <span class=\"string\">\"Java\"</span>, <span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"Pasical\"</span>, <span class=\"string\">\"Python\"</span>, <span class=\"string\">\"Swift\"</span>]</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>​    快速排序是采用分治法（Divide and Conquer）的应用。和归并排序不同的是，她不需要额外的存储空间，时间复杂度： T(n) = Θ(nlgn)，最坏情况下是：T(n) = Θ(n²)。</p>\n<h3 id=\"基本原理及实现\"><a href=\"#基本原理及实现\" class=\"headerlink\" title=\"基本原理及实现\"></a>基本原理及实现</h3><p>基本原理： 使用递归、分治的思想，每次调用排序方法，随机选取一个key值，结果保证：key值所在数组中的位置，且能保证key左侧位置的数据总小于key值；右侧位置数据总大于key值      </p>\n<ul>\n<li>① 当数组为空时，数组不需要排序，算法结束。</li>\n<li>② 选取一个key值，可以是带排序数组中任意位置的元素，这里选第一个元素。</li>\n<li>③ 遍历数组(角标j)，将所有比key值小的元素移动到数组前边(角标i)。遍历结束时，i即是中间位置。</li>\n<li>④ 将key值与角标i位置元素位置互换。</li>\n<li>⑤ 递归对i位置左侧、右侧数组进行快速排序。</li>\n</ul>","more":"<p>使用Swift编写简单的代码实现，如下：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">*  快速排序</span></div><div class=\"line\"><span class=\"comment\">* 使用递归、分治的思想，每次调用排序方法，选取一个key值，结果保证：key值所在数组中的位置，且能保证key左侧位置的数据总小于key值；右侧位置数据总大于key值</span></div><div class=\"line\"><span class=\"comment\">* ① 当数组为空时，数组不需要排序，算法结束。</span></div><div class=\"line\"><span class=\"comment\">* ② 选取一个key值，可以是带排序数组中任意位置的元素，这里选第一个元素。</span></div><div class=\"line\"><span class=\"comment\">* ③ 遍历数组(角标j)，将所有比key值小的元素移动到数组前边(角标i)。遍历结束时，i即是中间位置。</span></div><div class=\"line\"><span class=\"comment\">* ④ 将key值与角标i位置元素位置互换。</span></div><div class=\"line\"><span class=\"comment\">* ⑤ 递归对i位置左侧、右侧数组进行快速排序。</span></div><div class=\"line\"><span class=\"comment\">**/</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">quickSort</span>&lt;T:Comparable&gt;<span class=\"params\">(array:<span class=\"keyword\">inout</span> Array&lt;T&gt;, start:Int, end:Int)</span></span>&#123;</div><div class=\"line\"><span class=\"keyword\">if</span> end &lt;= start &#123;</div><div class=\"line\"><span class=\"keyword\">return</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> key = array[start];<span class=\"comment\">//随机选取key值 - 这里我们固定选择第一个元素</span></div><div class=\"line\"><span class=\"keyword\">var</span> i = start;</div><div class=\"line\"><span class=\"keyword\">var</span> j = i + <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"keyword\">while</span> j &lt;= end &#123;<span class=\"comment\">//从key后开始遍历，查找所有比key小的元素，移动到数组前边</span></div><div class=\"line\"><span class=\"keyword\">let</span> aj = array[j];</div><div class=\"line\"><span class=\"keyword\">if</span> key &gt; aj &#123;</div><div class=\"line\"><span class=\"comment\">//交换元素</span></div><div class=\"line\"><span class=\"keyword\">let</span> tempValue = array[i+<span class=\"number\">1</span>];</div><div class=\"line\">array[i+<span class=\"number\">1</span>] = aj;</div><div class=\"line\">array[j] = tempValue;</div><div class=\"line\"><span class=\"comment\">//重新设置角标</span></div><div class=\"line\">i += <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">j += <span class=\"number\">1</span>;<span class=\"comment\">//数组遍历</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//i位置即是最后一个比key值小的元素位置，然后交换key值和i位置元素</span></div><div class=\"line\"><span class=\"keyword\">let</span> ai = array[i];</div><div class=\"line\">array[i] = key;</div><div class=\"line\">array[start] = ai;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"sorting：key：<span class=\"subst\">\\(key)</span>  values: <span class=\"subst\">\\(array[start...end])</span>\"</span>);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//对i位置左侧、右侧的数组进行排序方法调用</span></div><div class=\"line\"><span class=\"built_in\">quickSort</span>(array: &amp;array, start: start, end: i - <span class=\"number\">1</span>)</div><div class=\"line\"><span class=\"built_in\">quickSort</span>(array: &amp;array, start: i+<span class=\"number\">1</span>, end: end);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"测试用例及结果\"><a href=\"#测试用例及结果\" class=\"headerlink\" title=\"测试用例及结果\"></a>测试用例及结果</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> intArray =  [<span class=\"number\">6</span>,<span class=\"number\">10</span>,<span class=\"number\">13</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">11</span>];</div><div class=\"line\"><span class=\"built_in\">quickSort</span>(array: &amp;intArray,start:<span class=\"number\">0</span>,end:intArray.<span class=\"built_in\">count</span>-<span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"排序结束：<span class=\"subst\">\\(intArray)</span>\"</span>);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//程序输出</span></div><div class=\"line\">sorting：key：<span class=\"number\">6</span>  values: [<span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">13</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>]</div><div class=\"line\">sorting：key：<span class=\"number\">2</span>  values: [<span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>]</div><div class=\"line\">sorting：key：<span class=\"number\">5</span>  values: [<span class=\"number\">3</span>, <span class=\"number\">5</span>]</div><div class=\"line\">sorting：key：<span class=\"number\">8</span>  values: [<span class=\"number\">8</span>, <span class=\"number\">13</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>]</div><div class=\"line\">sorting：key：<span class=\"number\">13</span>  values: [<span class=\"number\">11</span>, <span class=\"number\">10</span>, <span class=\"number\">13</span>]</div><div class=\"line\">sorting：key：<span class=\"number\">11</span>  values: [<span class=\"number\">10</span>, <span class=\"number\">11</span>]</div><div class=\"line\">排序结束：[<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> stringArray =  [<span class=\"string\">\"Java\"</span>,<span class=\"string\">\"C#\"</span>,<span class=\"string\">\"Python\"</span>,<span class=\"string\">\"Objective-C\"</span>,<span class=\"string\">\"Swift\"</span>,<span class=\"string\">\"PHP\"</span>,<span class=\"string\">\"BASIC\"</span>,<span class=\"string\">\"Pasical\"</span>,<span class=\"string\">\"Assembly\"</span>];</div><div class=\"line\"><span class=\"built_in\">quickSort</span>(array: &amp;stringArray,start:<span class=\"number\">0</span>,end:stringArray.<span class=\"built_in\">count</span>-<span class=\"number\">1</span>);</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"排序结束：<span class=\"subst\">\\(stringArray)</span>\"</span>);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//程序输出</span></div><div class=\"line\">sorting：key：<span class=\"type\">Java</span>  values: [<span class=\"string\">\"Assembly\"</span>, <span class=\"string\">\"C#\"</span>, <span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"Java\"</span>, <span class=\"string\">\"Swift\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"Python\"</span>, <span class=\"string\">\"Pasical\"</span>, <span class=\"string\">\"Objective-C\"</span>]</div><div class=\"line\">sorting：key：<span class=\"type\">Assembly</span>  values: [<span class=\"string\">\"Assembly\"</span>, <span class=\"string\">\"C#\"</span>, <span class=\"string\">\"BASIC\"</span>]</div><div class=\"line\">sorting：key：<span class=\"type\">C</span>#  values: [<span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"C#\"</span>]</div><div class=\"line\">sorting：key：<span class=\"type\">Swift</span>  values: [<span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"Python\"</span>, <span class=\"string\">\"Pasical\"</span>, <span class=\"string\">\"Swift\"</span>]</div><div class=\"line\">sorting：key：<span class=\"type\">Objective</span>-<span class=\"type\">C</span>  values: [<span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"Python\"</span>, <span class=\"string\">\"Pasical\"</span>]</div><div class=\"line\">sorting：key：<span class=\"type\">PHP</span>  values: [<span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"Python\"</span>, <span class=\"string\">\"Pasical\"</span>]</div><div class=\"line\">sorting：key：<span class=\"type\">Python</span>  values: [<span class=\"string\">\"Pasical\"</span>, <span class=\"string\">\"Python\"</span>]</div><div class=\"line\">排序结束：[<span class=\"string\">\"Assembly\"</span>, <span class=\"string\">\"BASIC\"</span>, <span class=\"string\">\"C#\"</span>, <span class=\"string\">\"Java\"</span>, <span class=\"string\">\"Objective-C\"</span>, <span class=\"string\">\"PHP\"</span>, <span class=\"string\">\"Pasical\"</span>, <span class=\"string\">\"Python\"</span>, <span class=\"string\">\"Swift\"</span>]</div></pre></td></tr></table></figure>"},{"layout":"post","title":"iOS蓝牙开发 - Central模式","date":"2017-07-27T11:50:12.000Z","author":"liangtong","catalog":true,"_content":"\n\n\n\n\n\n### Central模式   \n中心模式(Central Model)，可以简单理解为设备App作为中心，连接其他蓝牙外设设备。区别于外设模式，官方介绍可自行[Google](https://www.google.com/hk)。这里主要介绍iOS上蓝牙设备作为中心模式的集成。\n\n### 功能集成   \n  作为蓝牙使用者，程序需要请求蓝牙设备授权，在info.plist配置文件中，添加代码:    \n``` Objective-C \n</array>\n<key>NSBluetoothPeripheralUsageDescription</key>\n<string>蓝牙设备请求描述，比如：程序需要使用蓝牙进行设备发现</string>\n```\n  项目Targets对应的 *BuildPhases* 中，引入 *CoreBluetooth.framework* ，使用的代码中引入头文件\n``` Objective-C \n#import <CoreBluetooth/CoreBluetooth.h>\n```\n\n<!-- more -->\n\n#### 请求蓝牙服务\n  使用CBCentralManager来进行蓝牙服务管理(授权请求)，监听蓝牙状态变化。    \n```ObjectiveC\n@property (nonatomic, strong) CBCentralManager *cMgr;\n\n//对象创建成功后，会请求使用蓝牙，CBCentralManagerDelegate协议会回调蓝牙的各个状态\n_cMgr = [[CBCentralManager alloc] initWithDelegate:self queue:nil];\n\n#pragma mark - CBCentralManagerDelegate\n- (void)centralManagerDidUpdateState:(CBCentralManager *)central{\n    switch (central.state) {\n        case 0:\n            NSLog(@\"CBCentralManagerStateUnknown\");\n            break;\n        case 1:\n            NSLog(@\"CBCentralManagerStateResetting\");\n            break;\n        case 2:\n            NSLog(@\"CBCentralManagerStateUnsupported\");//不支持蓝牙\n            break;\n        case 3:\n            NSLog(@\"CBCentralManagerStateUnauthorized\");\n            break;\n        case 4:\n            NSLog(@\"CBCentralManagerStatePoweredOff\");//蓝牙未开启\n            break;\n        case 5:\n            {\n                NSLog(@\"CBCentralManagerStatePoweredOn\");//蓝牙已开启\n                // 在中心管理者成功开启后再进行一些操作\n                // 搜索外设， 搜索成功之后,会调用我们找到外设的代理方法\n                [self.cMgr scanForPeripheralsWithServices:nil // 通过某些服务筛选外设\n                                                  options:nil]; // dict,条件\n            }\n            break;\n        default:\n            break;\n    }\n}\n```\n\n#### 设备(外设)搜索      \n  在设备蓝牙开启的情况下，通过 *CBCentralManager* 的 *scanForPeripheralsWithServices:options:* 方法来搜索蓝牙外设，搜索成功后通过CBCentralManagerDelegate协议回调将外设返回。    \n```Objective-C\n    //可以通过服务和选项进行蓝牙外设的过滤\n    [self.cMgr scanForPeripheralsWithServices:nil  options:nil]\n\n#pragma mark - CBCentralManagerDelegate\n//CBCentralManagerDelegate协议对应发现外设，协议回调函数附带外设携带的数据advertisementData和外设的信号强度RSSI\n- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary<NSString *, id> *)advertisementData RSSI:(NSNumber *)RSSI{\n    //此处我们可以将外设设备组织成列表展示出来，以便用户根据实际情况进行特定外设的连接。\n    if (![self.self.peripheralList containsObject:peripheral]) {\n        [self.peripheralList addObject:item];\n        [[NSNotificationCenter defaultCenter] jk_postNotificationOnMainThreadName:BluetoothPeripheralUpdateKey object:nil userInfo:nil];\n    }\n\n    //也可以根据信号强度、外设名称或者携带信息，直接过滤并通过CBCentralManager进行连接\n    //[self.cMgr connectPeripheral:self.peripheral options:nil];\n}\n```\n\n#### 设备连接   \n  通过CBCentralManager的 *connectPeripheral:options:* 方法进行外设的连接，连接成功后通过CBCentralManagerDelegate协议回调将外设返回。    \n```Objective-C\n    //外设的连接\n    [self.cMgr connectPeripheral:self.peripheral options:nil];\n\n    //中心管理者连接外设成功,协议回调返回\n- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral{\n    //设置外设代理\n    peripheral.delegate = self;\n}\n```   \n 此处需要注意的是，蓝牙连接受环境及设备的影响，经常会遇到连接断开的情况。此时可以通过在断开连接的协议回调中重新连接外设即可，此时连接时间非常快。   \n```Objective-C\n// 丢失连接\n- (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error{\n    NSLog(@\"%s, line = %d, %@=断开连接\", __FUNCTION__, __LINE__, peripheral.name);\n    if (self.connectedPeripheral) {\n        [self.cMgr connectPeripheral:self.peripheral options:nil];\n    }\n}\n```\n\n  通常情况下，我们在外设连接成功的回调中，设置外设回调相关协议代理CBPeripheralDelegate，以便后续的服务发现等操作。\n\n#### 服务发现   \n  在蓝牙外设连接成功的情况下，我们通过外设的 *discoverServices:* 方法进行外设服务的发现，发现成功后，通过外设协议CBPeripheralDelegate回调外设提供的服务信息。   \n```Objective-C\n    //外设服务发现\n    [self.peripheral discoverServices:nil];\n\n    //外设服务回调\n- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(nullable NSError *)error{\n    //    NSLog(@\"%s, line = %d\", __FUNCTION__, __LINE__);\n    for (CBService *s in peripheral.services) {\n        NSLog(@\" -- 发现服务 -- :%@\", s);\n    [self.connectedPeripheral discoverCharacteristics:nil forService:s];\n    }\n}\n```   \n  通常情况下，我们会对发现的服务进行过滤，查找有用的服务，并查阅其特征值。以上代码读取的所有服务的特征值。\n\n#### 特征值发现    \n   外设服务发现的前提下，通过外设的方法 *discoverCharacteristics:forService:* 来进行服务特征值的发现。通过外设协议CBPeripheralDelegate回调服务携带的特征值信息。     \n```Objective-C\n    //特征值发现\n    [self.peripheral discoverCharacteristics:nil forService:s];\n\n    //特征值发现回调\n- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(nullable NSError *)error{\n    NSLog(@\"%s, line = %d\", __FUNCTION__, __LINE__);\n    for (CBCharacteristic *characteristics in service.characteristics) {\n        //NSLog(@\"%s, line = %d, char = %@\", __FUNCTION__, __LINE__, cha);\n        NSLog(@\"characteristic name:%@ value is:%@\",characteristics.UUID,characteristics.value);\n        [self.peripheral readValueForCharacteristic:characteristics];//读取特征值\n        [self.peripheral discoverDescriptorsForCharacteristic:characteristics];//发现特征值所携带的描述信息\n    }\n}\n```    \n  发现外设特征值后，我们便可以读取特征值及发现特征值所携带的描述信息了\n\n#### 读取特征值\n 发现特征值后，通过外设的方法 *readValueForCharacteristic:* 读取特征值。通过外设协议CBPeripheralDelegate回调服务携带的特征值信息。     \n```Objective-C\n    //特征值读取\n    [self.peripheral readValueForCharacteristic:characteristics];\n\n    //特征值更新回调\n- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error{\n        NSLog(@\"%s, line = %d\", __FUNCTION__, __LINE__);\n    //特征值更新\n}\n```    \n  特征值携带的UUID、value信息可以直接读取，若特征值发生更新，则通过协议回调进行读取。\n#### 读取描述\n    发现特征值后，通过外设的方法 *discoverDescriptorsForCharacteristic:* 读取特征值的描述信息。通过外设协议CBPeripheralDelegate回调服务携带的特征值信息。 \n\n    当特征值发生变更的时候，若想要监听，则需要调用蓝牙外设的方法 *- (void)setNotifyValue:(BOOL)enabled forCharacteristic:(CBCharacteristic *)characteristic*\n```Objective-C\n    //特征值描述字段读取\n    [self.peripheral discoverDescriptorsForCharacteristic:characteristics];\n    //特征值变更通知\n    [self.peripheral setNotifyValue:YES forCharacteristic:characteristics];//接受通知\n\n//特征值描述更新回调\n- (void)peripheral:(CBPeripheral *)peripheral didDiscoverDescriptorsForCharacteristic:(CBCharacteristic *)characteristic error:(nullable NSError *)error{\n    NSLog(@\"===characteristic name:%@\",characteristic.service.UUID);\n    for (CBDescriptor *d in characteristic.descriptors) {\n        NSLog(@\"CBDescriptor name is :%@\",d.UUID);\n    [self.peripheral readValueForDescriptor:d];\n    }\n}\n- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForDescriptor:(CBDescriptor *)descriptor error:(nullable NSError *)error{\n    NSLog(@\"Descriptor name:%@ value is:%@\",descriptor.characteristic.UUID, descriptor.value);\n}\n\n```    \n  可读取描述的UUID和value等信息。   \n \n### 其他   \n​\t\n","source":"_posts/bluetooth_central.md","raw":"---\nlayout:     post\ntitle:      iOS蓝牙开发 - Central模式\ndate:       2017-07-27 19:50:12\nauthor:     liangtong\ncatalog: true\ncategories: 蓝牙\ntags: Bluetooth\n\n---\n\n\n\n\n\n\n### Central模式   \n中心模式(Central Model)，可以简单理解为设备App作为中心，连接其他蓝牙外设设备。区别于外设模式，官方介绍可自行[Google](https://www.google.com/hk)。这里主要介绍iOS上蓝牙设备作为中心模式的集成。\n\n### 功能集成   \n  作为蓝牙使用者，程序需要请求蓝牙设备授权，在info.plist配置文件中，添加代码:    \n``` Objective-C \n</array>\n<key>NSBluetoothPeripheralUsageDescription</key>\n<string>蓝牙设备请求描述，比如：程序需要使用蓝牙进行设备发现</string>\n```\n  项目Targets对应的 *BuildPhases* 中，引入 *CoreBluetooth.framework* ，使用的代码中引入头文件\n``` Objective-C \n#import <CoreBluetooth/CoreBluetooth.h>\n```\n\n<!-- more -->\n\n#### 请求蓝牙服务\n  使用CBCentralManager来进行蓝牙服务管理(授权请求)，监听蓝牙状态变化。    \n```ObjectiveC\n@property (nonatomic, strong) CBCentralManager *cMgr;\n\n//对象创建成功后，会请求使用蓝牙，CBCentralManagerDelegate协议会回调蓝牙的各个状态\n_cMgr = [[CBCentralManager alloc] initWithDelegate:self queue:nil];\n\n#pragma mark - CBCentralManagerDelegate\n- (void)centralManagerDidUpdateState:(CBCentralManager *)central{\n    switch (central.state) {\n        case 0:\n            NSLog(@\"CBCentralManagerStateUnknown\");\n            break;\n        case 1:\n            NSLog(@\"CBCentralManagerStateResetting\");\n            break;\n        case 2:\n            NSLog(@\"CBCentralManagerStateUnsupported\");//不支持蓝牙\n            break;\n        case 3:\n            NSLog(@\"CBCentralManagerStateUnauthorized\");\n            break;\n        case 4:\n            NSLog(@\"CBCentralManagerStatePoweredOff\");//蓝牙未开启\n            break;\n        case 5:\n            {\n                NSLog(@\"CBCentralManagerStatePoweredOn\");//蓝牙已开启\n                // 在中心管理者成功开启后再进行一些操作\n                // 搜索外设， 搜索成功之后,会调用我们找到外设的代理方法\n                [self.cMgr scanForPeripheralsWithServices:nil // 通过某些服务筛选外设\n                                                  options:nil]; // dict,条件\n            }\n            break;\n        default:\n            break;\n    }\n}\n```\n\n#### 设备(外设)搜索      \n  在设备蓝牙开启的情况下，通过 *CBCentralManager* 的 *scanForPeripheralsWithServices:options:* 方法来搜索蓝牙外设，搜索成功后通过CBCentralManagerDelegate协议回调将外设返回。    \n```Objective-C\n    //可以通过服务和选项进行蓝牙外设的过滤\n    [self.cMgr scanForPeripheralsWithServices:nil  options:nil]\n\n#pragma mark - CBCentralManagerDelegate\n//CBCentralManagerDelegate协议对应发现外设，协议回调函数附带外设携带的数据advertisementData和外设的信号强度RSSI\n- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary<NSString *, id> *)advertisementData RSSI:(NSNumber *)RSSI{\n    //此处我们可以将外设设备组织成列表展示出来，以便用户根据实际情况进行特定外设的连接。\n    if (![self.self.peripheralList containsObject:peripheral]) {\n        [self.peripheralList addObject:item];\n        [[NSNotificationCenter defaultCenter] jk_postNotificationOnMainThreadName:BluetoothPeripheralUpdateKey object:nil userInfo:nil];\n    }\n\n    //也可以根据信号强度、外设名称或者携带信息，直接过滤并通过CBCentralManager进行连接\n    //[self.cMgr connectPeripheral:self.peripheral options:nil];\n}\n```\n\n#### 设备连接   \n  通过CBCentralManager的 *connectPeripheral:options:* 方法进行外设的连接，连接成功后通过CBCentralManagerDelegate协议回调将外设返回。    \n```Objective-C\n    //外设的连接\n    [self.cMgr connectPeripheral:self.peripheral options:nil];\n\n    //中心管理者连接外设成功,协议回调返回\n- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral{\n    //设置外设代理\n    peripheral.delegate = self;\n}\n```   \n 此处需要注意的是，蓝牙连接受环境及设备的影响，经常会遇到连接断开的情况。此时可以通过在断开连接的协议回调中重新连接外设即可，此时连接时间非常快。   \n```Objective-C\n// 丢失连接\n- (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error{\n    NSLog(@\"%s, line = %d, %@=断开连接\", __FUNCTION__, __LINE__, peripheral.name);\n    if (self.connectedPeripheral) {\n        [self.cMgr connectPeripheral:self.peripheral options:nil];\n    }\n}\n```\n\n  通常情况下，我们在外设连接成功的回调中，设置外设回调相关协议代理CBPeripheralDelegate，以便后续的服务发现等操作。\n\n#### 服务发现   \n  在蓝牙外设连接成功的情况下，我们通过外设的 *discoverServices:* 方法进行外设服务的发现，发现成功后，通过外设协议CBPeripheralDelegate回调外设提供的服务信息。   \n```Objective-C\n    //外设服务发现\n    [self.peripheral discoverServices:nil];\n\n    //外设服务回调\n- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(nullable NSError *)error{\n    //    NSLog(@\"%s, line = %d\", __FUNCTION__, __LINE__);\n    for (CBService *s in peripheral.services) {\n        NSLog(@\" -- 发现服务 -- :%@\", s);\n    [self.connectedPeripheral discoverCharacteristics:nil forService:s];\n    }\n}\n```   \n  通常情况下，我们会对发现的服务进行过滤，查找有用的服务，并查阅其特征值。以上代码读取的所有服务的特征值。\n\n#### 特征值发现    \n   外设服务发现的前提下，通过外设的方法 *discoverCharacteristics:forService:* 来进行服务特征值的发现。通过外设协议CBPeripheralDelegate回调服务携带的特征值信息。     \n```Objective-C\n    //特征值发现\n    [self.peripheral discoverCharacteristics:nil forService:s];\n\n    //特征值发现回调\n- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(nullable NSError *)error{\n    NSLog(@\"%s, line = %d\", __FUNCTION__, __LINE__);\n    for (CBCharacteristic *characteristics in service.characteristics) {\n        //NSLog(@\"%s, line = %d, char = %@\", __FUNCTION__, __LINE__, cha);\n        NSLog(@\"characteristic name:%@ value is:%@\",characteristics.UUID,characteristics.value);\n        [self.peripheral readValueForCharacteristic:characteristics];//读取特征值\n        [self.peripheral discoverDescriptorsForCharacteristic:characteristics];//发现特征值所携带的描述信息\n    }\n}\n```    \n  发现外设特征值后，我们便可以读取特征值及发现特征值所携带的描述信息了\n\n#### 读取特征值\n 发现特征值后，通过外设的方法 *readValueForCharacteristic:* 读取特征值。通过外设协议CBPeripheralDelegate回调服务携带的特征值信息。     \n```Objective-C\n    //特征值读取\n    [self.peripheral readValueForCharacteristic:characteristics];\n\n    //特征值更新回调\n- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error{\n        NSLog(@\"%s, line = %d\", __FUNCTION__, __LINE__);\n    //特征值更新\n}\n```    \n  特征值携带的UUID、value信息可以直接读取，若特征值发生更新，则通过协议回调进行读取。\n#### 读取描述\n    发现特征值后，通过外设的方法 *discoverDescriptorsForCharacteristic:* 读取特征值的描述信息。通过外设协议CBPeripheralDelegate回调服务携带的特征值信息。 \n\n    当特征值发生变更的时候，若想要监听，则需要调用蓝牙外设的方法 *- (void)setNotifyValue:(BOOL)enabled forCharacteristic:(CBCharacteristic *)characteristic*\n```Objective-C\n    //特征值描述字段读取\n    [self.peripheral discoverDescriptorsForCharacteristic:characteristics];\n    //特征值变更通知\n    [self.peripheral setNotifyValue:YES forCharacteristic:characteristics];//接受通知\n\n//特征值描述更新回调\n- (void)peripheral:(CBPeripheral *)peripheral didDiscoverDescriptorsForCharacteristic:(CBCharacteristic *)characteristic error:(nullable NSError *)error{\n    NSLog(@\"===characteristic name:%@\",characteristic.service.UUID);\n    for (CBDescriptor *d in characteristic.descriptors) {\n        NSLog(@\"CBDescriptor name is :%@\",d.UUID);\n    [self.peripheral readValueForDescriptor:d];\n    }\n}\n- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForDescriptor:(CBDescriptor *)descriptor error:(nullable NSError *)error{\n    NSLog(@\"Descriptor name:%@ value is:%@\",descriptor.characteristic.UUID, descriptor.value);\n}\n\n```    \n  可读取描述的UUID和value等信息。   \n \n### 其他   \n​\t\n","slug":"bluetooth_central","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4rz000boko8xdj5lmoe","content":"<h3 id=\"Central模式\"><a href=\"#Central模式\" class=\"headerlink\" title=\"Central模式\"></a>Central模式</h3><p>中心模式(Central Model)，可以简单理解为设备App作为中心，连接其他蓝牙外设设备。区别于外设模式，官方介绍可自行<a href=\"https://www.google.com/hk\" target=\"_blank\" rel=\"external\">Google</a>。这里主要介绍iOS上蓝牙设备作为中心模式的集成。</p>\n<h3 id=\"功能集成\"><a href=\"#功能集成\" class=\"headerlink\" title=\"功能集成\"></a>功能集成</h3><p>  作为蓝牙使用者，程序需要请求蓝牙设备授权，在info.plist配置文件中，添加代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;/array&gt;</div><div class=\"line\">&lt;key&gt;NSBluetoothPeripheralUsageDescription&lt;/key&gt;</div><div class=\"line\">&lt;string&gt;蓝牙设备请求描述，比如：程序需要使用蓝牙进行设备发现&lt;/string&gt;</div></pre></td></tr></table></figure></p>\n<p>  项目Targets对应的 <em>BuildPhases</em> 中，引入 <em>CoreBluetooth.framework</em> ，使用的代码中引入头文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &lt;CoreBluetooth/CoreBluetooth.h&gt;</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h4 id=\"请求蓝牙服务\"><a href=\"#请求蓝牙服务\" class=\"headerlink\" title=\"请求蓝牙服务\"></a>请求蓝牙服务</h4><p>  使用CBCentralManager来进行蓝牙服务管理(授权请求)，监听蓝牙状态变化。<br><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) CBCentralManager *cMgr;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//对象创建成功后，会请求使用蓝牙，CBCentralManagerDelegate协议会回调蓝牙的各个状态</span></div><div class=\"line\">_cMgr = [[CBCentralManager alloc] initWithDelegate:<span class=\"keyword\">self</span> queue:<span class=\"literal\">nil</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#pragma mark - CBCentralManagerDelegate</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)centralManagerDidUpdateState:(CBCentralManager *)central&#123;</div><div class=\"line\">    <span class=\"keyword\">switch</span> (central.state) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"CBCentralManagerStateUnknown\"</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"CBCentralManagerStateResetting\"</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"CBCentralManagerStateUnsupported\"</span>);<span class=\"comment\">//不支持蓝牙</span></div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">3</span>:</div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"CBCentralManagerStateUnauthorized\"</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">4</span>:</div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"CBCentralManagerStatePoweredOff\"</span>);<span class=\"comment\">//蓝牙未开启</span></div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">5</span>:</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"CBCentralManagerStatePoweredOn\"</span>);<span class=\"comment\">//蓝牙已开启</span></div><div class=\"line\">                <span class=\"comment\">// 在中心管理者成功开启后再进行一些操作</span></div><div class=\"line\">                <span class=\"comment\">// 搜索外设， 搜索成功之后,会调用我们找到外设的代理方法</span></div><div class=\"line\">                [<span class=\"keyword\">self</span>.cMgr scanForPeripheralsWithServices:<span class=\"literal\">nil</span> <span class=\"comment\">// 通过某些服务筛选外设</span></div><div class=\"line\">                                                  options:<span class=\"literal\">nil</span>]; <span class=\"comment\">// dict,条件</span></div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">default</span>:</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"设备-外设-搜索\"><a href=\"#设备-外设-搜索\" class=\"headerlink\" title=\"设备(外设)搜索\"></a>设备(外设)搜索</h4><p>  在设备蓝牙开启的情况下，通过 <em>CBCentralManager</em> 的 <em>scanForPeripheralsWithServices:options:</em> 方法来搜索蓝牙外设，搜索成功后通过CBCentralManagerDelegate协议回调将外设返回。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">    //可以通过服务和选项进行蓝牙外设的过滤</div><div class=\"line\">    [self.cMgr scanForPeripheralsWithServices:nil  options:nil]</div><div class=\"line\"></div><div class=\"line\">#pragma mark - CBCentralManagerDelegate</div><div class=\"line\">//CBCentralManagerDelegate协议对应发现外设，协议回调函数附带外设携带的数据advertisementData和外设的信号强度RSSI</div><div class=\"line\">- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary&lt;NSString *, id&gt; *)advertisementData RSSI:(NSNumber *)RSSI&#123;</div><div class=\"line\">    //此处我们可以将外设设备组织成列表展示出来，以便用户根据实际情况进行特定外设的连接。</div><div class=\"line\">    if (![self.self.peripheralList containsObject:peripheral]) &#123;</div><div class=\"line\">        [self.peripheralList addObject:item];</div><div class=\"line\">        [[NSNotificationCenter defaultCenter] jk_postNotificationOnMainThreadName:BluetoothPeripheralUpdateKey object:nil userInfo:nil];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //也可以根据信号强度、外设名称或者携带信息，直接过滤并通过CBCentralManager进行连接</div><div class=\"line\">    //[self.cMgr connectPeripheral:self.peripheral options:nil];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"设备连接\"><a href=\"#设备连接\" class=\"headerlink\" title=\"设备连接\"></a>设备连接</h4><p>  通过CBCentralManager的 <em>connectPeripheral:options:</em> 方法进行外设的连接，连接成功后通过CBCentralManagerDelegate协议回调将外设返回。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">    //外设的连接</div><div class=\"line\">    [self.cMgr connectPeripheral:self.peripheral options:nil];</div><div class=\"line\"></div><div class=\"line\">    //中心管理者连接外设成功,协议回调返回</div><div class=\"line\">- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral&#123;</div><div class=\"line\">    //设置外设代理</div><div class=\"line\">    peripheral.delegate = self;</div><div class=\"line\">&#125;</div><div class=\"line\">```   </div><div class=\"line\"> 此处需要注意的是，蓝牙连接受环境及设备的影响，经常会遇到连接断开的情况。此时可以通过在断开连接的协议回调中重新连接外设即可，此时连接时间非常快。   </div><div class=\"line\">```Objective-C</div><div class=\"line\">// 丢失连接</div><div class=\"line\">- (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error&#123;</div><div class=\"line\">    NSLog(@&quot;%s, line = %d, %@=断开连接&quot;, __FUNCTION__, __LINE__, peripheral.name);</div><div class=\"line\">    if (self.connectedPeripheral) &#123;</div><div class=\"line\">        [self.cMgr connectPeripheral:self.peripheral options:nil];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>  通常情况下，我们在外设连接成功的回调中，设置外设回调相关协议代理CBPeripheralDelegate，以便后续的服务发现等操作。</p>\n<h4 id=\"服务发现\"><a href=\"#服务发现\" class=\"headerlink\" title=\"服务发现\"></a>服务发现</h4><p>  在蓝牙外设连接成功的情况下，我们通过外设的 <em>discoverServices:</em> 方法进行外设服务的发现，发现成功后，通过外设协议CBPeripheralDelegate回调外设提供的服务信息。   </p>\n<pre><code class=\"Objective-C\">    //外设服务发现\n    [self.peripheral discoverServices:nil];\n\n    //外设服务回调\n- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(nullable NSError *)error{\n    //    NSLog(@&quot;%s, line = %d&quot;, __FUNCTION__, __LINE__);\n    for (CBService *s in peripheral.services) {\n        NSLog(@&quot; -- 发现服务 -- :%@&quot;, s);\n    [self.connectedPeripheral discoverCharacteristics:nil forService:s];\n    }\n}\n</code></pre>\n<p>  通常情况下，我们会对发现的服务进行过滤，查找有用的服务，并查阅其特征值。以上代码读取的所有服务的特征值。</p>\n<h4 id=\"特征值发现\"><a href=\"#特征值发现\" class=\"headerlink\" title=\"特征值发现\"></a>特征值发现</h4><p>   外设服务发现的前提下，通过外设的方法 <em>discoverCharacteristics:forService:</em> 来进行服务特征值的发现。通过外设协议CBPeripheralDelegate回调服务携带的特征值信息。     </p>\n<pre><code class=\"Objective-C\">    //特征值发现\n    [self.peripheral discoverCharacteristics:nil forService:s];\n\n    //特征值发现回调\n- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(nullable NSError *)error{\n    NSLog(@&quot;%s, line = %d&quot;, __FUNCTION__, __LINE__);\n    for (CBCharacteristic *characteristics in service.characteristics) {\n        //NSLog(@&quot;%s, line = %d, char = %@&quot;, __FUNCTION__, __LINE__, cha);\n        NSLog(@&quot;characteristic name:%@ value is:%@&quot;,characteristics.UUID,characteristics.value);\n        [self.peripheral readValueForCharacteristic:characteristics];//读取特征值\n        [self.peripheral discoverDescriptorsForCharacteristic:characteristics];//发现特征值所携带的描述信息\n    }\n}\n</code></pre>\n<p>  发现外设特征值后，我们便可以读取特征值及发现特征值所携带的描述信息了</p>\n<h4 id=\"读取特征值\"><a href=\"#读取特征值\" class=\"headerlink\" title=\"读取特征值\"></a>读取特征值</h4><p> 发现特征值后，通过外设的方法 <em>readValueForCharacteristic:</em> 读取特征值。通过外设协议CBPeripheralDelegate回调服务携带的特征值信息。     </p>\n<pre><code class=\"Objective-C\">    //特征值读取\n    [self.peripheral readValueForCharacteristic:characteristics];\n\n    //特征值更新回调\n- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error{\n        NSLog(@&quot;%s, line = %d&quot;, __FUNCTION__, __LINE__);\n    //特征值更新\n}\n</code></pre>\n<p>  特征值携带的UUID、value信息可以直接读取，若特征值发生更新，则通过协议回调进行读取。</p>\n<h4 id=\"读取描述\"><a href=\"#读取描述\" class=\"headerlink\" title=\"读取描述\"></a>读取描述</h4><pre><code>发现特征值后，通过外设的方法 *discoverDescriptorsForCharacteristic:* 读取特征值的描述信息。通过外设协议CBPeripheralDelegate回调服务携带的特征值信息。 \n\n当特征值发生变更的时候，若想要监听，则需要调用蓝牙外设的方法 *- (void)setNotifyValue:(BOOL)enabled forCharacteristic:(CBCharacteristic *)characteristic*\n</code></pre><pre><code class=\"Objective-C\">    //特征值描述字段读取\n    [self.peripheral discoverDescriptorsForCharacteristic:characteristics];\n    //特征值变更通知\n    [self.peripheral setNotifyValue:YES forCharacteristic:characteristics];//接受通知\n\n//特征值描述更新回调\n- (void)peripheral:(CBPeripheral *)peripheral didDiscoverDescriptorsForCharacteristic:(CBCharacteristic *)characteristic error:(nullable NSError *)error{\n    NSLog(@&quot;===characteristic name:%@&quot;,characteristic.service.UUID);\n    for (CBDescriptor *d in characteristic.descriptors) {\n        NSLog(@&quot;CBDescriptor name is :%@&quot;,d.UUID);\n    [self.peripheral readValueForDescriptor:d];\n    }\n}\n- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForDescriptor:(CBDescriptor *)descriptor error:(nullable NSError *)error{\n    NSLog(@&quot;Descriptor name:%@ value is:%@&quot;,descriptor.characteristic.UUID, descriptor.value);\n}\n</code></pre>\n<p>  可读取描述的UUID和value等信息。   </p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>​    </p>\n","site":{"data":{}},"excerpt":"<h3 id=\"Central模式\"><a href=\"#Central模式\" class=\"headerlink\" title=\"Central模式\"></a>Central模式</h3><p>中心模式(Central Model)，可以简单理解为设备App作为中心，连接其他蓝牙外设设备。区别于外设模式，官方介绍可自行<a href=\"https://www.google.com/hk\" target=\"_blank\" rel=\"external\">Google</a>。这里主要介绍iOS上蓝牙设备作为中心模式的集成。</p>\n<h3 id=\"功能集成\"><a href=\"#功能集成\" class=\"headerlink\" title=\"功能集成\"></a>功能集成</h3><p>  作为蓝牙使用者，程序需要请求蓝牙设备授权，在info.plist配置文件中，添加代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;/array&gt;</div><div class=\"line\">&lt;key&gt;NSBluetoothPeripheralUsageDescription&lt;/key&gt;</div><div class=\"line\">&lt;string&gt;蓝牙设备请求描述，比如：程序需要使用蓝牙进行设备发现&lt;/string&gt;</div></pre></td></tr></table></figure></p>\n<p>  项目Targets对应的 <em>BuildPhases</em> 中，引入 <em>CoreBluetooth.framework</em> ，使用的代码中引入头文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &lt;CoreBluetooth/CoreBluetooth.h&gt;</div></pre></td></tr></table></figure></p>","more":"<h4 id=\"请求蓝牙服务\"><a href=\"#请求蓝牙服务\" class=\"headerlink\" title=\"请求蓝牙服务\"></a>请求蓝牙服务</h4><p>  使用CBCentralManager来进行蓝牙服务管理(授权请求)，监听蓝牙状态变化。<br><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) CBCentralManager *cMgr;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//对象创建成功后，会请求使用蓝牙，CBCentralManagerDelegate协议会回调蓝牙的各个状态</span></div><div class=\"line\">_cMgr = [[CBCentralManager alloc] initWithDelegate:<span class=\"keyword\">self</span> queue:<span class=\"literal\">nil</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#pragma mark - CBCentralManagerDelegate</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)centralManagerDidUpdateState:(CBCentralManager *)central&#123;</div><div class=\"line\">    <span class=\"keyword\">switch</span> (central.state) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"CBCentralManagerStateUnknown\"</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"CBCentralManagerStateResetting\"</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"CBCentralManagerStateUnsupported\"</span>);<span class=\"comment\">//不支持蓝牙</span></div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">3</span>:</div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"CBCentralManagerStateUnauthorized\"</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">4</span>:</div><div class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"CBCentralManagerStatePoweredOff\"</span>);<span class=\"comment\">//蓝牙未开启</span></div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">5</span>:</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"CBCentralManagerStatePoweredOn\"</span>);<span class=\"comment\">//蓝牙已开启</span></div><div class=\"line\">                <span class=\"comment\">// 在中心管理者成功开启后再进行一些操作</span></div><div class=\"line\">                <span class=\"comment\">// 搜索外设， 搜索成功之后,会调用我们找到外设的代理方法</span></div><div class=\"line\">                [<span class=\"keyword\">self</span>.cMgr scanForPeripheralsWithServices:<span class=\"literal\">nil</span> <span class=\"comment\">// 通过某些服务筛选外设</span></div><div class=\"line\">                                                  options:<span class=\"literal\">nil</span>]; <span class=\"comment\">// dict,条件</span></div><div class=\"line\">            &#125;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">default</span>:</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"设备-外设-搜索\"><a href=\"#设备-外设-搜索\" class=\"headerlink\" title=\"设备(外设)搜索\"></a>设备(外设)搜索</h4><p>  在设备蓝牙开启的情况下，通过 <em>CBCentralManager</em> 的 <em>scanForPeripheralsWithServices:options:</em> 方法来搜索蓝牙外设，搜索成功后通过CBCentralManagerDelegate协议回调将外设返回。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">    //可以通过服务和选项进行蓝牙外设的过滤</div><div class=\"line\">    [self.cMgr scanForPeripheralsWithServices:nil  options:nil]</div><div class=\"line\"></div><div class=\"line\">#pragma mark - CBCentralManagerDelegate</div><div class=\"line\">//CBCentralManagerDelegate协议对应发现外设，协议回调函数附带外设携带的数据advertisementData和外设的信号强度RSSI</div><div class=\"line\">- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary&lt;NSString *, id&gt; *)advertisementData RSSI:(NSNumber *)RSSI&#123;</div><div class=\"line\">    //此处我们可以将外设设备组织成列表展示出来，以便用户根据实际情况进行特定外设的连接。</div><div class=\"line\">    if (![self.self.peripheralList containsObject:peripheral]) &#123;</div><div class=\"line\">        [self.peripheralList addObject:item];</div><div class=\"line\">        [[NSNotificationCenter defaultCenter] jk_postNotificationOnMainThreadName:BluetoothPeripheralUpdateKey object:nil userInfo:nil];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //也可以根据信号强度、外设名称或者携带信息，直接过滤并通过CBCentralManager进行连接</div><div class=\"line\">    //[self.cMgr connectPeripheral:self.peripheral options:nil];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"设备连接\"><a href=\"#设备连接\" class=\"headerlink\" title=\"设备连接\"></a>设备连接</h4><p>  通过CBCentralManager的 <em>connectPeripheral:options:</em> 方法进行外设的连接，连接成功后通过CBCentralManagerDelegate协议回调将外设返回。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">    //外设的连接</div><div class=\"line\">    [self.cMgr connectPeripheral:self.peripheral options:nil];</div><div class=\"line\"></div><div class=\"line\">    //中心管理者连接外设成功,协议回调返回</div><div class=\"line\">- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral&#123;</div><div class=\"line\">    //设置外设代理</div><div class=\"line\">    peripheral.delegate = self;</div><div class=\"line\">&#125;</div><div class=\"line\">```   </div><div class=\"line\"> 此处需要注意的是，蓝牙连接受环境及设备的影响，经常会遇到连接断开的情况。此时可以通过在断开连接的协议回调中重新连接外设即可，此时连接时间非常快。   </div><div class=\"line\">```Objective-C</div><div class=\"line\">// 丢失连接</div><div class=\"line\">- (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error&#123;</div><div class=\"line\">    NSLog(@&quot;%s, line = %d, %@=断开连接&quot;, __FUNCTION__, __LINE__, peripheral.name);</div><div class=\"line\">    if (self.connectedPeripheral) &#123;</div><div class=\"line\">        [self.cMgr connectPeripheral:self.peripheral options:nil];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>  通常情况下，我们在外设连接成功的回调中，设置外设回调相关协议代理CBPeripheralDelegate，以便后续的服务发现等操作。</p>\n<h4 id=\"服务发现\"><a href=\"#服务发现\" class=\"headerlink\" title=\"服务发现\"></a>服务发现</h4><p>  在蓝牙外设连接成功的情况下，我们通过外设的 <em>discoverServices:</em> 方法进行外设服务的发现，发现成功后，通过外设协议CBPeripheralDelegate回调外设提供的服务信息。   </p>\n<pre><code class=\"Objective-C\">    //外设服务发现\n    [self.peripheral discoverServices:nil];\n\n    //外设服务回调\n- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(nullable NSError *)error{\n    //    NSLog(@&quot;%s, line = %d&quot;, __FUNCTION__, __LINE__);\n    for (CBService *s in peripheral.services) {\n        NSLog(@&quot; -- 发现服务 -- :%@&quot;, s);\n    [self.connectedPeripheral discoverCharacteristics:nil forService:s];\n    }\n}\n</code></pre>\n<p>  通常情况下，我们会对发现的服务进行过滤，查找有用的服务，并查阅其特征值。以上代码读取的所有服务的特征值。</p>\n<h4 id=\"特征值发现\"><a href=\"#特征值发现\" class=\"headerlink\" title=\"特征值发现\"></a>特征值发现</h4><p>   外设服务发现的前提下，通过外设的方法 <em>discoverCharacteristics:forService:</em> 来进行服务特征值的发现。通过外设协议CBPeripheralDelegate回调服务携带的特征值信息。     </p>\n<pre><code class=\"Objective-C\">    //特征值发现\n    [self.peripheral discoverCharacteristics:nil forService:s];\n\n    //特征值发现回调\n- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(nullable NSError *)error{\n    NSLog(@&quot;%s, line = %d&quot;, __FUNCTION__, __LINE__);\n    for (CBCharacteristic *characteristics in service.characteristics) {\n        //NSLog(@&quot;%s, line = %d, char = %@&quot;, __FUNCTION__, __LINE__, cha);\n        NSLog(@&quot;characteristic name:%@ value is:%@&quot;,characteristics.UUID,characteristics.value);\n        [self.peripheral readValueForCharacteristic:characteristics];//读取特征值\n        [self.peripheral discoverDescriptorsForCharacteristic:characteristics];//发现特征值所携带的描述信息\n    }\n}\n</code></pre>\n<p>  发现外设特征值后，我们便可以读取特征值及发现特征值所携带的描述信息了</p>\n<h4 id=\"读取特征值\"><a href=\"#读取特征值\" class=\"headerlink\" title=\"读取特征值\"></a>读取特征值</h4><p> 发现特征值后，通过外设的方法 <em>readValueForCharacteristic:</em> 读取特征值。通过外设协议CBPeripheralDelegate回调服务携带的特征值信息。     </p>\n<pre><code class=\"Objective-C\">    //特征值读取\n    [self.peripheral readValueForCharacteristic:characteristics];\n\n    //特征值更新回调\n- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error{\n        NSLog(@&quot;%s, line = %d&quot;, __FUNCTION__, __LINE__);\n    //特征值更新\n}\n</code></pre>\n<p>  特征值携带的UUID、value信息可以直接读取，若特征值发生更新，则通过协议回调进行读取。</p>\n<h4 id=\"读取描述\"><a href=\"#读取描述\" class=\"headerlink\" title=\"读取描述\"></a>读取描述</h4><pre><code>发现特征值后，通过外设的方法 *discoverDescriptorsForCharacteristic:* 读取特征值的描述信息。通过外设协议CBPeripheralDelegate回调服务携带的特征值信息。 \n\n当特征值发生变更的时候，若想要监听，则需要调用蓝牙外设的方法 *- (void)setNotifyValue:(BOOL)enabled forCharacteristic:(CBCharacteristic *)characteristic*\n</code></pre><pre><code class=\"Objective-C\">    //特征值描述字段读取\n    [self.peripheral discoverDescriptorsForCharacteristic:characteristics];\n    //特征值变更通知\n    [self.peripheral setNotifyValue:YES forCharacteristic:characteristics];//接受通知\n\n//特征值描述更新回调\n- (void)peripheral:(CBPeripheral *)peripheral didDiscoverDescriptorsForCharacteristic:(CBCharacteristic *)characteristic error:(nullable NSError *)error{\n    NSLog(@&quot;===characteristic name:%@&quot;,characteristic.service.UUID);\n    for (CBDescriptor *d in characteristic.descriptors) {\n        NSLog(@&quot;CBDescriptor name is :%@&quot;,d.UUID);\n    [self.peripheral readValueForDescriptor:d];\n    }\n}\n- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForDescriptor:(CBDescriptor *)descriptor error:(nullable NSError *)error{\n    NSLog(@&quot;Descriptor name:%@ value is:%@&quot;,descriptor.characteristic.UUID, descriptor.value);\n}\n</code></pre>\n<p>  可读取描述的UUID和value等信息。   </p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>​    </p>"},{"layout":"post","title":"蓝牙Central模式 - 水准仪蓝牙交互","date":"2017-08-24T10:50:12.000Z","author":"liangtong","catalog":true,"_content":"\n\n​\t工程测量中，[Trimble](http://www.trimble.com/)电子水准仪(DiNi Level)在测量完成后，通过蓝牙模块与外设进行数据交互，本文介绍外设如何作为中心模式与水准仪进行数据交互。\n\n#### 前期准备\n\n前期准备工作包括以下几个方面：   \n + 蓝牙外设扫描\n + 蓝牙外设连接\n + 外设服务发现\n + 特征值发现\n   + 订阅\n\n\n<!-- more -->\n\n可以参照[iOS蓝牙开发 - Central模式](https://l900416.github.io/2017/07/27/bluetooth_central/)，此处不再赘述，参照以下摘要信息：\n\n```bash\n2017-08-24 16:15:39.860 RoadBridgeOnline[1067:189910] CBCentralManagerStatePoweredOn\n2017-08-24 16:15:50.121 RoadBridgeOnline[1067:189910] -[BluetoothViewModel centralManager:didConnectPeripheral:], line = 198, CRTB_BT_MODULE=连接成功\n2017-08-24 16:15:50.188 RoadBridgeOnline[1067:189910]  -- 发现服务 -- :<CBService: 0x15e6301c0, isPrimary = YES, UUID = 1101>\n2017-08-24 16:15:50.189 RoadBridgeOnline[1067:189910]  -- 发现服务 -- :<CBService: 0x15e6a6590, isPrimary = YES, UUID = 00001016-D102-11E1-9B23-00025B00A5A5>\n2017-08-24 16:15:50.191 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didDiscoverCharacteristicsForService:error:], line = 236\n2017-08-24 16:15:50.191 RoadBridgeOnline[1067:189910] characteristic name:1102 value is: \n\n2017-08-24 16:15:50.193 RoadBridgeOnline[1067:189910] characteristic name:1103 value is:\n2017-08-24 16:15:50.194 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didDiscoverCharacteristicsForService:error:], line = 236\n2017-08-24 16:15:50.195 RoadBridgeOnline[1067:189910] characteristic name:00001013-D102-11E1-9B23-00025B00A5A5 value is:\n2017-08-24 16:15:50.197 RoadBridgeOnline[1067:189910] characteristic name:00001018-D102-11E1-9B23-00025B00A5A5 value is:\n2017-08-24 16:15:50.198 RoadBridgeOnline[1067:189910] characteristic name:00001014-D102-11E1-9B23-00025B00A5A5 value is:\n2017-08-24 16:15:50.199 RoadBridgeOnline[1067:189910] characteristic name:00001011-D102-11E1-9B23-00025B00A5A5 value is:\n2017-08-24 16:15:50.248 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 248\n2017-08-24 16:15:50.248 RoadBridgeOnline[1067:189910] characteristic name:1102 value is: \n\n```\n\n\n#### 特征值订阅／监听\n\n水准仪与蓝牙外设的通讯，主要是通过特征值来实现，故此处进行单独介绍。在特征值发现之后，我们可以根据特征值进行过滤，监听特定的特征值，这样，当特征值发生变更的时候，会通过CBPeripheralDelegate协议回调特征值数据。使用蓝牙外设对象 *CBPeripheral* 的方法 *setNotifyValue:forCharacteristic:* 来进行监听\n\n```Objective-C\n\t//订阅 - 接受通知\n    [self.connectedPeripheral setNotifyValue:YES forCharacteristic:characteristics];\n```\n\n通过协议回调处理特征值。\n\n```Objective-C\n/**\n * CBPeripheralDelegate协议，当特征值发生变更的时候，回调\n **/\n- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error{\n        NSLog(@\"%s, line = %d\", __FUNCTION__, __LINE__);\n    NSString* valueString = [[NSString alloc] initWithData:characteristic.value  encoding:NSUTF8StringEncoding];\n    [self.readValueArray addObject:valueString];\n    [self postRecievedCharacteristicValue];\n    \n    NSLog(@\"characteristic name:%@ value is:%@\",characteristic.UUID,valueString);\n//    NSLog(@\"接收到的数组：\\n%@\",self.readValueArray);\n}\n\n/**\n  * 将水准仪返回的数据进行处理，获取关键字段，数据处理成功后，直接发全局Event通知。\n  * 单点测量\n  * 水准线路测量 - 后视\n  * 水准线路测量 - 前视\n  **/\n-(void)postRecievedCharacteristicValue{\n    if ([self.readValueArray count] > 0) {\n        NSString * fullString = [self.readValueArray componentsJoinedByString:@\"\"];\n        NSLog(@\"待处理的特质值为：\\n %@ \\n\",fullString);\n        \n        NSArray* sepArray = [fullString componentsSeparatedByString:@\"|\"];\n        NSMutableDictionary* postDic = [[NSMutableDictionary alloc] init];\n        \n\t    //处理字符串数据，将不同数据进行封装，代码略\n        \n        if ([[postDic allKeys] count] > 0) {//直接全局通知\n            [[NSNotificationCenter defaultCenter] jk_postNotificationOnMainThreadName:RBBluetoothMeasureUpdateKey object:postDic];\n        }\n    }\n}\n```\n需要注意的是水准仪蓝牙数据的回传时将字符串进行了分隔。我们需要首先进行数据拼接，之后才能进行数据提取操作，以下是拼接后的字符串及原始字符串：\n\n```Objective-C\n//以下是拼接后的字符串（水准线路测量 - 前视）\nFor M5|Adr    32|KD1      5-a    g 15:49:151  L1|Rf        1.49585 m   |HD          9.988 m   |                      | \nFor M5|Adr    33|KD1      5-a    g 15:49:15   L1|                      |                      |Z        -0.43374 m   | \n\n//以下是回调log信息：\nFor M5|Adr      |K\n2017-08-24 16:18:42.299 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 248\n2017-08-24 16:18:42.300 RoadBridgeOnline[1067:189910] characteristic name:1102 value is:D1       16    2 16:\n2017-08-24 16:18:42.327 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 248\n2017-08-24 16:18:42.328 RoadBridgeOnline[1067:189910] characteristic name:1102 value is:17:37  L41|         \n2017-08-24 16:18:42.329 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 248\n2017-08-24 16:18:42.330 RoadBridgeOnline[1067:189910] characteristic name:1102 value is:             |      \n2017-08-24 16:18:42.357 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 248\n2017-08-24 16:18:42.358 RoadBridgeOnline[1067:189910] characteristic name:1102 value is:                |Z  \n2017-08-24 16:18:42.387 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 248\n2017-08-24 16:18:42.398 RoadBridgeOnline[1067:189910] characteristic name:1102 value is:      44.98000 m   |\n2017-08-24 16:18:42.477 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 248\n```\n\n#### 测量数据处理\n\n在前台界面相关的 *界面控制器* 中，使用 *NSNotificationCenter* 进行监听，对监听到的数据进行相应的业务逻辑处理\n\n```Objective-C\n-(void)viewWillAppear:(BOOL)animated{\n    [super viewWillAppear:animated];\n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(recieveLocalNotification:) name:BluetoothPeripheralUpdateKey object:nil];\n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(recieveLocalNotification:) name:RBBluetoothMeasureUpdateKey object:nil];\n}\n\n-(void)recieveLocalNotification:(NSNotification*)notification{\n    NSString* notificationKeyName = [notification name];\n    //蓝牙连接状态发生变更\n    //蓝牙单点测量数据变更通知\n    if ([notificationKeyName isEqualToString:BluetoothPeripheralUpdateKey]) {\n        [self updateBluetoothConnectionImage];\n    }else if ([notificationKeyName isEqualToString:RBBluetoothMeasureUpdateKey]) {\n        NSDictionary* measuredDic = notification.object;\n        [self uploadBluetoothMeasureData:measuredDic];\n    }\n}\n-(void)viewWillDisappear:(BOOL)animated{\n    [super viewWillDisappear:animated];\n    [[NSNotificationCenter defaultCenter] removeObserver:self];\n}\n```\n​\t\n","source":"_posts/bluetooth_central_level.md","raw":"---\nlayout:     post\ntitle:      蓝牙Central模式 - 水准仪蓝牙交互\ndate:       2017-08-24 18:50:12\nauthor:     liangtong\ncatalog: true\ncategories: 蓝牙\ntags: Bluetooth\n\n---\n\n\n​\t工程测量中，[Trimble](http://www.trimble.com/)电子水准仪(DiNi Level)在测量完成后，通过蓝牙模块与外设进行数据交互，本文介绍外设如何作为中心模式与水准仪进行数据交互。\n\n#### 前期准备\n\n前期准备工作包括以下几个方面：   \n + 蓝牙外设扫描\n + 蓝牙外设连接\n + 外设服务发现\n + 特征值发现\n   + 订阅\n\n\n<!-- more -->\n\n可以参照[iOS蓝牙开发 - Central模式](https://l900416.github.io/2017/07/27/bluetooth_central/)，此处不再赘述，参照以下摘要信息：\n\n```bash\n2017-08-24 16:15:39.860 RoadBridgeOnline[1067:189910] CBCentralManagerStatePoweredOn\n2017-08-24 16:15:50.121 RoadBridgeOnline[1067:189910] -[BluetoothViewModel centralManager:didConnectPeripheral:], line = 198, CRTB_BT_MODULE=连接成功\n2017-08-24 16:15:50.188 RoadBridgeOnline[1067:189910]  -- 发现服务 -- :<CBService: 0x15e6301c0, isPrimary = YES, UUID = 1101>\n2017-08-24 16:15:50.189 RoadBridgeOnline[1067:189910]  -- 发现服务 -- :<CBService: 0x15e6a6590, isPrimary = YES, UUID = 00001016-D102-11E1-9B23-00025B00A5A5>\n2017-08-24 16:15:50.191 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didDiscoverCharacteristicsForService:error:], line = 236\n2017-08-24 16:15:50.191 RoadBridgeOnline[1067:189910] characteristic name:1102 value is: \n\n2017-08-24 16:15:50.193 RoadBridgeOnline[1067:189910] characteristic name:1103 value is:\n2017-08-24 16:15:50.194 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didDiscoverCharacteristicsForService:error:], line = 236\n2017-08-24 16:15:50.195 RoadBridgeOnline[1067:189910] characteristic name:00001013-D102-11E1-9B23-00025B00A5A5 value is:\n2017-08-24 16:15:50.197 RoadBridgeOnline[1067:189910] characteristic name:00001018-D102-11E1-9B23-00025B00A5A5 value is:\n2017-08-24 16:15:50.198 RoadBridgeOnline[1067:189910] characteristic name:00001014-D102-11E1-9B23-00025B00A5A5 value is:\n2017-08-24 16:15:50.199 RoadBridgeOnline[1067:189910] characteristic name:00001011-D102-11E1-9B23-00025B00A5A5 value is:\n2017-08-24 16:15:50.248 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 248\n2017-08-24 16:15:50.248 RoadBridgeOnline[1067:189910] characteristic name:1102 value is: \n\n```\n\n\n#### 特征值订阅／监听\n\n水准仪与蓝牙外设的通讯，主要是通过特征值来实现，故此处进行单独介绍。在特征值发现之后，我们可以根据特征值进行过滤，监听特定的特征值，这样，当特征值发生变更的时候，会通过CBPeripheralDelegate协议回调特征值数据。使用蓝牙外设对象 *CBPeripheral* 的方法 *setNotifyValue:forCharacteristic:* 来进行监听\n\n```Objective-C\n\t//订阅 - 接受通知\n    [self.connectedPeripheral setNotifyValue:YES forCharacteristic:characteristics];\n```\n\n通过协议回调处理特征值。\n\n```Objective-C\n/**\n * CBPeripheralDelegate协议，当特征值发生变更的时候，回调\n **/\n- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error{\n        NSLog(@\"%s, line = %d\", __FUNCTION__, __LINE__);\n    NSString* valueString = [[NSString alloc] initWithData:characteristic.value  encoding:NSUTF8StringEncoding];\n    [self.readValueArray addObject:valueString];\n    [self postRecievedCharacteristicValue];\n    \n    NSLog(@\"characteristic name:%@ value is:%@\",characteristic.UUID,valueString);\n//    NSLog(@\"接收到的数组：\\n%@\",self.readValueArray);\n}\n\n/**\n  * 将水准仪返回的数据进行处理，获取关键字段，数据处理成功后，直接发全局Event通知。\n  * 单点测量\n  * 水准线路测量 - 后视\n  * 水准线路测量 - 前视\n  **/\n-(void)postRecievedCharacteristicValue{\n    if ([self.readValueArray count] > 0) {\n        NSString * fullString = [self.readValueArray componentsJoinedByString:@\"\"];\n        NSLog(@\"待处理的特质值为：\\n %@ \\n\",fullString);\n        \n        NSArray* sepArray = [fullString componentsSeparatedByString:@\"|\"];\n        NSMutableDictionary* postDic = [[NSMutableDictionary alloc] init];\n        \n\t    //处理字符串数据，将不同数据进行封装，代码略\n        \n        if ([[postDic allKeys] count] > 0) {//直接全局通知\n            [[NSNotificationCenter defaultCenter] jk_postNotificationOnMainThreadName:RBBluetoothMeasureUpdateKey object:postDic];\n        }\n    }\n}\n```\n需要注意的是水准仪蓝牙数据的回传时将字符串进行了分隔。我们需要首先进行数据拼接，之后才能进行数据提取操作，以下是拼接后的字符串及原始字符串：\n\n```Objective-C\n//以下是拼接后的字符串（水准线路测量 - 前视）\nFor M5|Adr    32|KD1      5-a    g 15:49:151  L1|Rf        1.49585 m   |HD          9.988 m   |                      | \nFor M5|Adr    33|KD1      5-a    g 15:49:15   L1|                      |                      |Z        -0.43374 m   | \n\n//以下是回调log信息：\nFor M5|Adr      |K\n2017-08-24 16:18:42.299 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 248\n2017-08-24 16:18:42.300 RoadBridgeOnline[1067:189910] characteristic name:1102 value is:D1       16    2 16:\n2017-08-24 16:18:42.327 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 248\n2017-08-24 16:18:42.328 RoadBridgeOnline[1067:189910] characteristic name:1102 value is:17:37  L41|         \n2017-08-24 16:18:42.329 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 248\n2017-08-24 16:18:42.330 RoadBridgeOnline[1067:189910] characteristic name:1102 value is:             |      \n2017-08-24 16:18:42.357 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 248\n2017-08-24 16:18:42.358 RoadBridgeOnline[1067:189910] characteristic name:1102 value is:                |Z  \n2017-08-24 16:18:42.387 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 248\n2017-08-24 16:18:42.398 RoadBridgeOnline[1067:189910] characteristic name:1102 value is:      44.98000 m   |\n2017-08-24 16:18:42.477 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 248\n```\n\n#### 测量数据处理\n\n在前台界面相关的 *界面控制器* 中，使用 *NSNotificationCenter* 进行监听，对监听到的数据进行相应的业务逻辑处理\n\n```Objective-C\n-(void)viewWillAppear:(BOOL)animated{\n    [super viewWillAppear:animated];\n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(recieveLocalNotification:) name:BluetoothPeripheralUpdateKey object:nil];\n    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(recieveLocalNotification:) name:RBBluetoothMeasureUpdateKey object:nil];\n}\n\n-(void)recieveLocalNotification:(NSNotification*)notification{\n    NSString* notificationKeyName = [notification name];\n    //蓝牙连接状态发生变更\n    //蓝牙单点测量数据变更通知\n    if ([notificationKeyName isEqualToString:BluetoothPeripheralUpdateKey]) {\n        [self updateBluetoothConnectionImage];\n    }else if ([notificationKeyName isEqualToString:RBBluetoothMeasureUpdateKey]) {\n        NSDictionary* measuredDic = notification.object;\n        [self uploadBluetoothMeasureData:measuredDic];\n    }\n}\n-(void)viewWillDisappear:(BOOL)animated{\n    [super viewWillDisappear:animated];\n    [[NSNotificationCenter defaultCenter] removeObserver:self];\n}\n```\n​\t\n","slug":"bluetooth_central_level","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4s2000foko8xh1octfc","content":"<p>​    工程测量中，<a href=\"http://www.trimble.com/\" target=\"_blank\" rel=\"external\">Trimble</a>电子水准仪(DiNi Level)在测量完成后，通过蓝牙模块与外设进行数据交互，本文介绍外设如何作为中心模式与水准仪进行数据交互。</p>\n<h4 id=\"前期准备\"><a href=\"#前期准备\" class=\"headerlink\" title=\"前期准备\"></a>前期准备</h4><p>前期准备工作包括以下几个方面：   </p>\n<ul>\n<li>蓝牙外设扫描</li>\n<li>蓝牙外设连接</li>\n<li>外设服务发现</li>\n<li>特征值发现<ul>\n<li>订阅</li>\n</ul>\n</li>\n</ul>\n<a id=\"more\"></a>\n<p>可以参照<a href=\"https://l900416.github.io/2017/07/27/bluetooth_central/\">iOS蓝牙开发 - Central模式</a>，此处不再赘述，参照以下摘要信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">2017-08-24 16:15:39.860 RoadBridgeOnline[1067:189910] CBCentralManagerStatePoweredOn</div><div class=\"line\">2017-08-24 16:15:50.121 RoadBridgeOnline[1067:189910] -[BluetoothViewModel centralManager:didConnectPeripheral:], line = 198, CRTB_BT_MODULE=连接成功</div><div class=\"line\">2017-08-24 16:15:50.188 RoadBridgeOnline[1067:189910]  -- 发现服务 -- :&lt;CBService: 0x15e6301c0, isPrimary = YES, UUID = 1101&gt;</div><div class=\"line\">2017-08-24 16:15:50.189 RoadBridgeOnline[1067:189910]  -- 发现服务 -- :&lt;CBService: 0x15e6a6590, isPrimary = YES, UUID = 00001016-D102-11E1-9B23-00025B00A5A5&gt;</div><div class=\"line\">2017-08-24 16:15:50.191 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didDiscoverCharacteristicsForService:error:], line = 236</div><div class=\"line\">2017-08-24 16:15:50.191 RoadBridgeOnline[1067:189910] characteristic name:1102 value is: </div><div class=\"line\"></div><div class=\"line\">2017-08-24 16:15:50.193 RoadBridgeOnline[1067:189910] characteristic name:1103 value is:</div><div class=\"line\">2017-08-24 16:15:50.194 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didDiscoverCharacteristicsForService:error:], line = 236</div><div class=\"line\">2017-08-24 16:15:50.195 RoadBridgeOnline[1067:189910] characteristic name:00001013-D102-11E1-9B23-00025B00A5A5 value is:</div><div class=\"line\">2017-08-24 16:15:50.197 RoadBridgeOnline[1067:189910] characteristic name:00001018-D102-11E1-9B23-00025B00A5A5 value is:</div><div class=\"line\">2017-08-24 16:15:50.198 RoadBridgeOnline[1067:189910] characteristic name:00001014-D102-11E1-9B23-00025B00A5A5 value is:</div><div class=\"line\">2017-08-24 16:15:50.199 RoadBridgeOnline[1067:189910] characteristic name:00001011-D102-11E1-9B23-00025B00A5A5 value is:</div><div class=\"line\">2017-08-24 16:15:50.248 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 248</div><div class=\"line\">2017-08-24 16:15:50.248 RoadBridgeOnline[1067:189910] characteristic name:1102 value is:</div></pre></td></tr></table></figure>\n<h4 id=\"特征值订阅／监听\"><a href=\"#特征值订阅／监听\" class=\"headerlink\" title=\"特征值订阅／监听\"></a>特征值订阅／监听</h4><p>水准仪与蓝牙外设的通讯，主要是通过特征值来实现，故此处进行单独介绍。在特征值发现之后，我们可以根据特征值进行过滤，监听特定的特征值，这样，当特征值发生变更的时候，会通过CBPeripheralDelegate协议回调特征值数据。使用蓝牙外设对象 <em>CBPeripheral</em> 的方法 <em>setNotifyValue:forCharacteristic:</em> 来进行监听</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">//订阅 - 接受通知</div><div class=\"line\">   [self.connectedPeripheral setNotifyValue:YES forCharacteristic:characteristics];</div></pre></td></tr></table></figure>\n<p>通过协议回调处理特征值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * CBPeripheralDelegate协议，当特征值发生变更的时候，回调</div><div class=\"line\"> **/</div><div class=\"line\">- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error&#123;</div><div class=\"line\">        NSLog(@&quot;%s, line = %d&quot;, __FUNCTION__, __LINE__);</div><div class=\"line\">    NSString* valueString = [[NSString alloc] initWithData:characteristic.value  encoding:NSUTF8StringEncoding];</div><div class=\"line\">    [self.readValueArray addObject:valueString];</div><div class=\"line\">    [self postRecievedCharacteristicValue];</div><div class=\"line\">    </div><div class=\"line\">    NSLog(@&quot;characteristic name:%@ value is:%@&quot;,characteristic.UUID,valueString);</div><div class=\"line\">//    NSLog(@&quot;接收到的数组：\\n%@&quot;,self.readValueArray);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">  * 将水准仪返回的数据进行处理，获取关键字段，数据处理成功后，直接发全局Event通知。</div><div class=\"line\">  * 单点测量</div><div class=\"line\">  * 水准线路测量 - 后视</div><div class=\"line\">  * 水准线路测量 - 前视</div><div class=\"line\">  **/</div><div class=\"line\">-(void)postRecievedCharacteristicValue&#123;</div><div class=\"line\">    if ([self.readValueArray count] &gt; 0) &#123;</div><div class=\"line\">        NSString * fullString = [self.readValueArray componentsJoinedByString:@&quot;&quot;];</div><div class=\"line\">        NSLog(@&quot;待处理的特质值为：\\n %@ \\n&quot;,fullString);</div><div class=\"line\">        </div><div class=\"line\">        NSArray* sepArray = [fullString componentsSeparatedByString:@&quot;|&quot;];</div><div class=\"line\">        NSMutableDictionary* postDic = [[NSMutableDictionary alloc] init];</div><div class=\"line\">        </div><div class=\"line\">\t    //处理字符串数据，将不同数据进行封装，代码略</div><div class=\"line\">        </div><div class=\"line\">        if ([[postDic allKeys] count] &gt; 0) &#123;//直接全局通知</div><div class=\"line\">            [[NSNotificationCenter defaultCenter] jk_postNotificationOnMainThreadName:RBBluetoothMeasureUpdateKey object:postDic];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>需要注意的是水准仪蓝牙数据的回传时将字符串进行了分隔。我们需要首先进行数据拼接，之后才能进行数据提取操作，以下是拼接后的字符串及原始字符串：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">//以下是拼接后的字符串（水准线路测量 - 前视）</div><div class=\"line\">For M5|Adr    32|KD1      5-a    g 15:49:151  L1|Rf        1.49585 m   |HD          9.988 m   |                      | </div><div class=\"line\">For M5|Adr    33|KD1      5-a    g 15:49:15   L1|                      |                      |Z        -0.43374 m   | </div><div class=\"line\"></div><div class=\"line\">//以下是回调log信息：</div><div class=\"line\">For M5|Adr      |K</div><div class=\"line\">2017-08-24 16:18:42.299 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 248</div><div class=\"line\">2017-08-24 16:18:42.300 RoadBridgeOnline[1067:189910] characteristic name:1102 value is:D1       16    2 16:</div><div class=\"line\">2017-08-24 16:18:42.327 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 248</div><div class=\"line\">2017-08-24 16:18:42.328 RoadBridgeOnline[1067:189910] characteristic name:1102 value is:17:37  L41|         </div><div class=\"line\">2017-08-24 16:18:42.329 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 248</div><div class=\"line\">2017-08-24 16:18:42.330 RoadBridgeOnline[1067:189910] characteristic name:1102 value is:             |      </div><div class=\"line\">2017-08-24 16:18:42.357 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 248</div><div class=\"line\">2017-08-24 16:18:42.358 RoadBridgeOnline[1067:189910] characteristic name:1102 value is:                |Z  </div><div class=\"line\">2017-08-24 16:18:42.387 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 248</div><div class=\"line\">2017-08-24 16:18:42.398 RoadBridgeOnline[1067:189910] characteristic name:1102 value is:      44.98000 m   |</div><div class=\"line\">2017-08-24 16:18:42.477 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 248</div></pre></td></tr></table></figure>\n<h4 id=\"测量数据处理\"><a href=\"#测量数据处理\" class=\"headerlink\" title=\"测量数据处理\"></a>测量数据处理</h4><p>在前台界面相关的 <em>界面控制器</em> 中，使用 <em>NSNotificationCenter</em> 进行监听，对监听到的数据进行相应的业务逻辑处理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)viewWillAppear:(BOOL)animated&#123;</div><div class=\"line\">    [super viewWillAppear:animated];</div><div class=\"line\">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(recieveLocalNotification:) name:BluetoothPeripheralUpdateKey object:nil];</div><div class=\"line\">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(recieveLocalNotification:) name:RBBluetoothMeasureUpdateKey object:nil];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)recieveLocalNotification:(NSNotification*)notification&#123;</div><div class=\"line\">    NSString* notificationKeyName = [notification name];</div><div class=\"line\">    //蓝牙连接状态发生变更</div><div class=\"line\">    //蓝牙单点测量数据变更通知</div><div class=\"line\">    if ([notificationKeyName isEqualToString:BluetoothPeripheralUpdateKey]) &#123;</div><div class=\"line\">        [self updateBluetoothConnectionImage];</div><div class=\"line\">    &#125;else if ([notificationKeyName isEqualToString:RBBluetoothMeasureUpdateKey]) &#123;</div><div class=\"line\">        NSDictionary* measuredDic = notification.object;</div><div class=\"line\">        [self uploadBluetoothMeasureData:measuredDic];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)viewWillDisappear:(BOOL)animated&#123;</div><div class=\"line\">    [super viewWillDisappear:animated];</div><div class=\"line\">    [[NSNotificationCenter defaultCenter] removeObserver:self];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>​    </p>\n","site":{"data":{}},"excerpt":"<p>​    工程测量中，<a href=\"http://www.trimble.com/\" target=\"_blank\" rel=\"external\">Trimble</a>电子水准仪(DiNi Level)在测量完成后，通过蓝牙模块与外设进行数据交互，本文介绍外设如何作为中心模式与水准仪进行数据交互。</p>\n<h4 id=\"前期准备\"><a href=\"#前期准备\" class=\"headerlink\" title=\"前期准备\"></a>前期准备</h4><p>前期准备工作包括以下几个方面：   </p>\n<ul>\n<li>蓝牙外设扫描</li>\n<li>蓝牙外设连接</li>\n<li>外设服务发现</li>\n<li>特征值发现<ul>\n<li>订阅</li>\n</ul>\n</li>\n</ul>","more":"<p>可以参照<a href=\"https://l900416.github.io/2017/07/27/bluetooth_central/\">iOS蓝牙开发 - Central模式</a>，此处不再赘述，参照以下摘要信息：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">2017-08-24 16:15:39.860 RoadBridgeOnline[1067:189910] CBCentralManagerStatePoweredOn</div><div class=\"line\">2017-08-24 16:15:50.121 RoadBridgeOnline[1067:189910] -[BluetoothViewModel centralManager:didConnectPeripheral:], line = 198, CRTB_BT_MODULE=连接成功</div><div class=\"line\">2017-08-24 16:15:50.188 RoadBridgeOnline[1067:189910]  -- 发现服务 -- :&lt;CBService: 0x15e6301c0, isPrimary = YES, UUID = 1101&gt;</div><div class=\"line\">2017-08-24 16:15:50.189 RoadBridgeOnline[1067:189910]  -- 发现服务 -- :&lt;CBService: 0x15e6a6590, isPrimary = YES, UUID = 00001016-D102-11E1-9B23-00025B00A5A5&gt;</div><div class=\"line\">2017-08-24 16:15:50.191 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didDiscoverCharacteristicsForService:error:], line = 236</div><div class=\"line\">2017-08-24 16:15:50.191 RoadBridgeOnline[1067:189910] characteristic name:1102 value is: </div><div class=\"line\"></div><div class=\"line\">2017-08-24 16:15:50.193 RoadBridgeOnline[1067:189910] characteristic name:1103 value is:</div><div class=\"line\">2017-08-24 16:15:50.194 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didDiscoverCharacteristicsForService:error:], line = 236</div><div class=\"line\">2017-08-24 16:15:50.195 RoadBridgeOnline[1067:189910] characteristic name:00001013-D102-11E1-9B23-00025B00A5A5 value is:</div><div class=\"line\">2017-08-24 16:15:50.197 RoadBridgeOnline[1067:189910] characteristic name:00001018-D102-11E1-9B23-00025B00A5A5 value is:</div><div class=\"line\">2017-08-24 16:15:50.198 RoadBridgeOnline[1067:189910] characteristic name:00001014-D102-11E1-9B23-00025B00A5A5 value is:</div><div class=\"line\">2017-08-24 16:15:50.199 RoadBridgeOnline[1067:189910] characteristic name:00001011-D102-11E1-9B23-00025B00A5A5 value is:</div><div class=\"line\">2017-08-24 16:15:50.248 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 248</div><div class=\"line\">2017-08-24 16:15:50.248 RoadBridgeOnline[1067:189910] characteristic name:1102 value is:</div></pre></td></tr></table></figure>\n<h4 id=\"特征值订阅／监听\"><a href=\"#特征值订阅／监听\" class=\"headerlink\" title=\"特征值订阅／监听\"></a>特征值订阅／监听</h4><p>水准仪与蓝牙外设的通讯，主要是通过特征值来实现，故此处进行单独介绍。在特征值发现之后，我们可以根据特征值进行过滤，监听特定的特征值，这样，当特征值发生变更的时候，会通过CBPeripheralDelegate协议回调特征值数据。使用蓝牙外设对象 <em>CBPeripheral</em> 的方法 <em>setNotifyValue:forCharacteristic:</em> 来进行监听</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">//订阅 - 接受通知</div><div class=\"line\">   [self.connectedPeripheral setNotifyValue:YES forCharacteristic:characteristics];</div></pre></td></tr></table></figure>\n<p>通过协议回调处理特征值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * CBPeripheralDelegate协议，当特征值发生变更的时候，回调</div><div class=\"line\"> **/</div><div class=\"line\">- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error&#123;</div><div class=\"line\">        NSLog(@&quot;%s, line = %d&quot;, __FUNCTION__, __LINE__);</div><div class=\"line\">    NSString* valueString = [[NSString alloc] initWithData:characteristic.value  encoding:NSUTF8StringEncoding];</div><div class=\"line\">    [self.readValueArray addObject:valueString];</div><div class=\"line\">    [self postRecievedCharacteristicValue];</div><div class=\"line\">    </div><div class=\"line\">    NSLog(@&quot;characteristic name:%@ value is:%@&quot;,characteristic.UUID,valueString);</div><div class=\"line\">//    NSLog(@&quot;接收到的数组：\\n%@&quot;,self.readValueArray);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">  * 将水准仪返回的数据进行处理，获取关键字段，数据处理成功后，直接发全局Event通知。</div><div class=\"line\">  * 单点测量</div><div class=\"line\">  * 水准线路测量 - 后视</div><div class=\"line\">  * 水准线路测量 - 前视</div><div class=\"line\">  **/</div><div class=\"line\">-(void)postRecievedCharacteristicValue&#123;</div><div class=\"line\">    if ([self.readValueArray count] &gt; 0) &#123;</div><div class=\"line\">        NSString * fullString = [self.readValueArray componentsJoinedByString:@&quot;&quot;];</div><div class=\"line\">        NSLog(@&quot;待处理的特质值为：\\n %@ \\n&quot;,fullString);</div><div class=\"line\">        </div><div class=\"line\">        NSArray* sepArray = [fullString componentsSeparatedByString:@&quot;|&quot;];</div><div class=\"line\">        NSMutableDictionary* postDic = [[NSMutableDictionary alloc] init];</div><div class=\"line\">        </div><div class=\"line\">\t    //处理字符串数据，将不同数据进行封装，代码略</div><div class=\"line\">        </div><div class=\"line\">        if ([[postDic allKeys] count] &gt; 0) &#123;//直接全局通知</div><div class=\"line\">            [[NSNotificationCenter defaultCenter] jk_postNotificationOnMainThreadName:RBBluetoothMeasureUpdateKey object:postDic];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>需要注意的是水准仪蓝牙数据的回传时将字符串进行了分隔。我们需要首先进行数据拼接，之后才能进行数据提取操作，以下是拼接后的字符串及原始字符串：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">//以下是拼接后的字符串（水准线路测量 - 前视）</div><div class=\"line\">For M5|Adr    32|KD1      5-a    g 15:49:151  L1|Rf        1.49585 m   |HD          9.988 m   |                      | </div><div class=\"line\">For M5|Adr    33|KD1      5-a    g 15:49:15   L1|                      |                      |Z        -0.43374 m   | </div><div class=\"line\"></div><div class=\"line\">//以下是回调log信息：</div><div class=\"line\">For M5|Adr      |K</div><div class=\"line\">2017-08-24 16:18:42.299 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 248</div><div class=\"line\">2017-08-24 16:18:42.300 RoadBridgeOnline[1067:189910] characteristic name:1102 value is:D1       16    2 16:</div><div class=\"line\">2017-08-24 16:18:42.327 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 248</div><div class=\"line\">2017-08-24 16:18:42.328 RoadBridgeOnline[1067:189910] characteristic name:1102 value is:17:37  L41|         </div><div class=\"line\">2017-08-24 16:18:42.329 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 248</div><div class=\"line\">2017-08-24 16:18:42.330 RoadBridgeOnline[1067:189910] characteristic name:1102 value is:             |      </div><div class=\"line\">2017-08-24 16:18:42.357 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 248</div><div class=\"line\">2017-08-24 16:18:42.358 RoadBridgeOnline[1067:189910] characteristic name:1102 value is:                |Z  </div><div class=\"line\">2017-08-24 16:18:42.387 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 248</div><div class=\"line\">2017-08-24 16:18:42.398 RoadBridgeOnline[1067:189910] characteristic name:1102 value is:      44.98000 m   |</div><div class=\"line\">2017-08-24 16:18:42.477 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 248</div></pre></td></tr></table></figure>\n<h4 id=\"测量数据处理\"><a href=\"#测量数据处理\" class=\"headerlink\" title=\"测量数据处理\"></a>测量数据处理</h4><p>在前台界面相关的 <em>界面控制器</em> 中，使用 <em>NSNotificationCenter</em> 进行监听，对监听到的数据进行相应的业务逻辑处理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(void)viewWillAppear:(BOOL)animated&#123;</div><div class=\"line\">    [super viewWillAppear:animated];</div><div class=\"line\">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(recieveLocalNotification:) name:BluetoothPeripheralUpdateKey object:nil];</div><div class=\"line\">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(recieveLocalNotification:) name:RBBluetoothMeasureUpdateKey object:nil];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)recieveLocalNotification:(NSNotification*)notification&#123;</div><div class=\"line\">    NSString* notificationKeyName = [notification name];</div><div class=\"line\">    //蓝牙连接状态发生变更</div><div class=\"line\">    //蓝牙单点测量数据变更通知</div><div class=\"line\">    if ([notificationKeyName isEqualToString:BluetoothPeripheralUpdateKey]) &#123;</div><div class=\"line\">        [self updateBluetoothConnectionImage];</div><div class=\"line\">    &#125;else if ([notificationKeyName isEqualToString:RBBluetoothMeasureUpdateKey]) &#123;</div><div class=\"line\">        NSDictionary* measuredDic = notification.object;</div><div class=\"line\">        [self uploadBluetoothMeasureData:measuredDic];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">-(void)viewWillDisappear:(BOOL)animated&#123;</div><div class=\"line\">    [super viewWillDisappear:animated];</div><div class=\"line\">    [[NSNotificationCenter defaultCenter] removeObserver:self];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>​    </p>"},{"layout":"post","title":"iBeacon应用","date":"2017-03-13T13:25:19.000Z","author":"liangtong","catalog":true,"_content":"\n\n​\t讲述iBeacon技术的方案设想、设计及实际应用。充分利用iBeacon的优势，位置、距离、感知相关的场合构造合适的场景。\n\n\n\n<!-- more -->\n\n### 方案设想   \n在上一篇文章中有提到iBeacon应用场景举例。这里从3各方面进行描述：   \n* 测距\n\n    主要是在程序前台激活状态下，可能会用到的场景：\n\n\t* 周边摇、现场摇、签到等\n\t* 产品介绍，商场导购，博物馆导游等 \n\t* 位置修正，iBeacon的精度可以辅助一些其他功能\n\t* 精确区域预警、地理围栏\n\t* 室内导航等\n\n* 监听\n\n    托管给iOS系统，程序本身不需要打开即可触发功能，可能会用到以下场景：   \n\t* 欢迎语：比如当用户手持设备进入任意场景区域内时，进行交互提醒。\n\t* 业务联动：比如当用户进入某个控制区后，告知概况，同周边设备联动。\n\t* 区域预警：比如设置特定的围栏区域。\n\t* 其他：比如与门禁系统联动等\n\n* 角色交换\n\n    通常情况下，iBeacon设备作为基站，移动设备比如iPhone和iPad来接收信号，从而进行机遇位置的场景交互。我们也可以讲iPhone和iPad作为基站，给其设定特定的区域值进行广播。而接收设备位置固定等。可以设想以下场景：\n\n\t* 演示大屏上展示周边设备。\n\t* 教师要求输入动态口令进行签到。\n\n### 基础方案\n\n​\t理想情况下，以下数据需要预缓存，保证在无网络或者网络环境差的情况下，交互动作可以顺利进行。因此，各类信息的版本控制需要在前期考虑。\n\n#### iBeacon策略\n​\tiBeacon策略，或者说应用场景。如上一篇文章中所说，这里主要在iBeacon对应的区域Region（ProximityUUID & Major & Minor）上的三个值上做文章。 比如：  \n* ProximityUUID ： 公司编码\n* Major ： 建筑编码\n* Minor ： 某类区域（物品）编码\n\n策略相关信息确定后，就可以给不同的策略配置个性化信息了，比如进入／离开策略对应的区域时，定制以下信息：   \n* 通知声音：个性化提示音\n* 通知内容：跟具体业务相关\n* 通知优先级：当多个策略同时触发时，可根据优先级来动态显示\n* 通知频次：用来确保特定时间段内，不重复通知\n\n#### iBeacon业务\n​\t单纯的触发iBeacon对应区域的策略，仅仅是对用户的消息提醒，我们比较关注的是策略的后续动作。比如当用户到达某个iBeacon区域（或者在某个区域驻足时间较长）后，收到了个性化的策略通知。很自然的点击查看感兴趣的消息，那么后续的动作就是这里所说的iBeacon业务。通常情况下，后续动作包括以下几种：   \n* 打开某个本地模块\n* 打开某个Web网页\n* 打开某个本地网页\n* 无后续动作\n\n需要注意的是，后续动作可能不止一种。\n\n#### 策略业务关联\n\n​\t为了保证数据的灵活，策略与业务的对应关系为1:N（N >= 0），当策略对应多个业务的时候，需要考虑各业务的优先级等。\n\n#### 用户策略\n\n​\t除了一些共通的策略外，用户也可以拥有独特权限的策略，比如同一个区域，不同角色进入时，看到的数据根据其权限表现出差异。\n\n### 应用\n\n#### 设备选择\niBeacon设备选取可能会考虑的几个因素包括：   \n* 电池及续航\n* 设备运维\n* 设备部署\n* 设备美感\n* 设备软件能力\n* 设备使用\n\n通常情况下，电池、部署、软件能力需要着重考虑。\n\n#### 设备部署\n\n部署时可能需要考虑以下几个因素：   \n* 环境干扰\n* 工厂校正电压\n* 放置位置（高度／间距）\n\n### 总结\n​\tiBeacon技术在旅游景点、博物馆、商场、酒店、会议室等场景中可以给人很好的用户体验，但在成本、运维部署方面一直存在着问题。目前情况下小范围内玩iBeacon，还是很有搞头的。\n","source":"_posts/bluetooth_iBeacon2.md","raw":"---\nlayout:     post\ntitle:      iBeacon应用\ndate:       2017-03-13 21:25:19\nauthor:     liangtong\ncatalog: true\ncategories: 蓝牙\ntags: iBeacon\n\n---\n\n\n​\t讲述iBeacon技术的方案设想、设计及实际应用。充分利用iBeacon的优势，位置、距离、感知相关的场合构造合适的场景。\n\n\n\n<!-- more -->\n\n### 方案设想   \n在上一篇文章中有提到iBeacon应用场景举例。这里从3各方面进行描述：   \n* 测距\n\n    主要是在程序前台激活状态下，可能会用到的场景：\n\n\t* 周边摇、现场摇、签到等\n\t* 产品介绍，商场导购，博物馆导游等 \n\t* 位置修正，iBeacon的精度可以辅助一些其他功能\n\t* 精确区域预警、地理围栏\n\t* 室内导航等\n\n* 监听\n\n    托管给iOS系统，程序本身不需要打开即可触发功能，可能会用到以下场景：   \n\t* 欢迎语：比如当用户手持设备进入任意场景区域内时，进行交互提醒。\n\t* 业务联动：比如当用户进入某个控制区后，告知概况，同周边设备联动。\n\t* 区域预警：比如设置特定的围栏区域。\n\t* 其他：比如与门禁系统联动等\n\n* 角色交换\n\n    通常情况下，iBeacon设备作为基站，移动设备比如iPhone和iPad来接收信号，从而进行机遇位置的场景交互。我们也可以讲iPhone和iPad作为基站，给其设定特定的区域值进行广播。而接收设备位置固定等。可以设想以下场景：\n\n\t* 演示大屏上展示周边设备。\n\t* 教师要求输入动态口令进行签到。\n\n### 基础方案\n\n​\t理想情况下，以下数据需要预缓存，保证在无网络或者网络环境差的情况下，交互动作可以顺利进行。因此，各类信息的版本控制需要在前期考虑。\n\n#### iBeacon策略\n​\tiBeacon策略，或者说应用场景。如上一篇文章中所说，这里主要在iBeacon对应的区域Region（ProximityUUID & Major & Minor）上的三个值上做文章。 比如：  \n* ProximityUUID ： 公司编码\n* Major ： 建筑编码\n* Minor ： 某类区域（物品）编码\n\n策略相关信息确定后，就可以给不同的策略配置个性化信息了，比如进入／离开策略对应的区域时，定制以下信息：   \n* 通知声音：个性化提示音\n* 通知内容：跟具体业务相关\n* 通知优先级：当多个策略同时触发时，可根据优先级来动态显示\n* 通知频次：用来确保特定时间段内，不重复通知\n\n#### iBeacon业务\n​\t单纯的触发iBeacon对应区域的策略，仅仅是对用户的消息提醒，我们比较关注的是策略的后续动作。比如当用户到达某个iBeacon区域（或者在某个区域驻足时间较长）后，收到了个性化的策略通知。很自然的点击查看感兴趣的消息，那么后续的动作就是这里所说的iBeacon业务。通常情况下，后续动作包括以下几种：   \n* 打开某个本地模块\n* 打开某个Web网页\n* 打开某个本地网页\n* 无后续动作\n\n需要注意的是，后续动作可能不止一种。\n\n#### 策略业务关联\n\n​\t为了保证数据的灵活，策略与业务的对应关系为1:N（N >= 0），当策略对应多个业务的时候，需要考虑各业务的优先级等。\n\n#### 用户策略\n\n​\t除了一些共通的策略外，用户也可以拥有独特权限的策略，比如同一个区域，不同角色进入时，看到的数据根据其权限表现出差异。\n\n### 应用\n\n#### 设备选择\niBeacon设备选取可能会考虑的几个因素包括：   \n* 电池及续航\n* 设备运维\n* 设备部署\n* 设备美感\n* 设备软件能力\n* 设备使用\n\n通常情况下，电池、部署、软件能力需要着重考虑。\n\n#### 设备部署\n\n部署时可能需要考虑以下几个因素：   \n* 环境干扰\n* 工厂校正电压\n* 放置位置（高度／间距）\n\n### 总结\n​\tiBeacon技术在旅游景点、博物馆、商场、酒店、会议室等场景中可以给人很好的用户体验，但在成本、运维部署方面一直存在着问题。目前情况下小范围内玩iBeacon，还是很有搞头的。\n","slug":"bluetooth_iBeacon2","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4s3000ioko8xit9krng","content":"<p>​    讲述iBeacon技术的方案设想、设计及实际应用。充分利用iBeacon的优势，位置、距离、感知相关的场合构造合适的场景。</p>\n<a id=\"more\"></a>\n<h3 id=\"方案设想\"><a href=\"#方案设想\" class=\"headerlink\" title=\"方案设想\"></a>方案设想</h3><p>在上一篇文章中有提到iBeacon应用场景举例。这里从3各方面进行描述：   </p>\n<ul>\n<li><p>测距</p>\n<p>  主要是在程序前台激活状态下，可能会用到的场景：</p>\n<ul>\n<li>周边摇、现场摇、签到等</li>\n<li>产品介绍，商场导购，博物馆导游等 </li>\n<li>位置修正，iBeacon的精度可以辅助一些其他功能</li>\n<li>精确区域预警、地理围栏</li>\n<li>室内导航等</li>\n</ul>\n</li>\n<li><p>监听</p>\n<p>  托管给iOS系统，程序本身不需要打开即可触发功能，可能会用到以下场景：   </p>\n<ul>\n<li>欢迎语：比如当用户手持设备进入任意场景区域内时，进行交互提醒。</li>\n<li>业务联动：比如当用户进入某个控制区后，告知概况，同周边设备联动。</li>\n<li>区域预警：比如设置特定的围栏区域。</li>\n<li>其他：比如与门禁系统联动等</li>\n</ul>\n</li>\n<li><p>角色交换</p>\n<p>  通常情况下，iBeacon设备作为基站，移动设备比如iPhone和iPad来接收信号，从而进行机遇位置的场景交互。我们也可以讲iPhone和iPad作为基站，给其设定特定的区域值进行广播。而接收设备位置固定等。可以设想以下场景：</p>\n<ul>\n<li>演示大屏上展示周边设备。</li>\n<li>教师要求输入动态口令进行签到。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"基础方案\"><a href=\"#基础方案\" class=\"headerlink\" title=\"基础方案\"></a>基础方案</h3><p>​    理想情况下，以下数据需要预缓存，保证在无网络或者网络环境差的情况下，交互动作可以顺利进行。因此，各类信息的版本控制需要在前期考虑。</p>\n<h4 id=\"iBeacon策略\"><a href=\"#iBeacon策略\" class=\"headerlink\" title=\"iBeacon策略\"></a>iBeacon策略</h4><p>​    iBeacon策略，或者说应用场景。如上一篇文章中所说，这里主要在iBeacon对应的区域Region（ProximityUUID &amp; Major &amp; Minor）上的三个值上做文章。 比如：  </p>\n<ul>\n<li>ProximityUUID ： 公司编码</li>\n<li>Major ： 建筑编码</li>\n<li>Minor ： 某类区域（物品）编码</li>\n</ul>\n<p>策略相关信息确定后，就可以给不同的策略配置个性化信息了，比如进入／离开策略对应的区域时，定制以下信息：   </p>\n<ul>\n<li>通知声音：个性化提示音</li>\n<li>通知内容：跟具体业务相关</li>\n<li>通知优先级：当多个策略同时触发时，可根据优先级来动态显示</li>\n<li>通知频次：用来确保特定时间段内，不重复通知</li>\n</ul>\n<h4 id=\"iBeacon业务\"><a href=\"#iBeacon业务\" class=\"headerlink\" title=\"iBeacon业务\"></a>iBeacon业务</h4><p>​    单纯的触发iBeacon对应区域的策略，仅仅是对用户的消息提醒，我们比较关注的是策略的后续动作。比如当用户到达某个iBeacon区域（或者在某个区域驻足时间较长）后，收到了个性化的策略通知。很自然的点击查看感兴趣的消息，那么后续的动作就是这里所说的iBeacon业务。通常情况下，后续动作包括以下几种：   </p>\n<ul>\n<li>打开某个本地模块</li>\n<li>打开某个Web网页</li>\n<li>打开某个本地网页</li>\n<li>无后续动作</li>\n</ul>\n<p>需要注意的是，后续动作可能不止一种。</p>\n<h4 id=\"策略业务关联\"><a href=\"#策略业务关联\" class=\"headerlink\" title=\"策略业务关联\"></a>策略业务关联</h4><p>​    为了保证数据的灵活，策略与业务的对应关系为1:N（N &gt;= 0），当策略对应多个业务的时候，需要考虑各业务的优先级等。</p>\n<h4 id=\"用户策略\"><a href=\"#用户策略\" class=\"headerlink\" title=\"用户策略\"></a>用户策略</h4><p>​    除了一些共通的策略外，用户也可以拥有独特权限的策略，比如同一个区域，不同角色进入时，看到的数据根据其权限表现出差异。</p>\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><h4 id=\"设备选择\"><a href=\"#设备选择\" class=\"headerlink\" title=\"设备选择\"></a>设备选择</h4><p>iBeacon设备选取可能会考虑的几个因素包括：   </p>\n<ul>\n<li>电池及续航</li>\n<li>设备运维</li>\n<li>设备部署</li>\n<li>设备美感</li>\n<li>设备软件能力</li>\n<li>设备使用</li>\n</ul>\n<p>通常情况下，电池、部署、软件能力需要着重考虑。</p>\n<h4 id=\"设备部署\"><a href=\"#设备部署\" class=\"headerlink\" title=\"设备部署\"></a>设备部署</h4><p>部署时可能需要考虑以下几个因素：   </p>\n<ul>\n<li>环境干扰</li>\n<li>工厂校正电压</li>\n<li>放置位置（高度／间距）</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>​    iBeacon技术在旅游景点、博物馆、商场、酒店、会议室等场景中可以给人很好的用户体验，但在成本、运维部署方面一直存在着问题。目前情况下小范围内玩iBeacon，还是很有搞头的。</p>\n","site":{"data":{}},"excerpt":"<p>​    讲述iBeacon技术的方案设想、设计及实际应用。充分利用iBeacon的优势，位置、距离、感知相关的场合构造合适的场景。</p>","more":"<h3 id=\"方案设想\"><a href=\"#方案设想\" class=\"headerlink\" title=\"方案设想\"></a>方案设想</h3><p>在上一篇文章中有提到iBeacon应用场景举例。这里从3各方面进行描述：   </p>\n<ul>\n<li><p>测距</p>\n<p>  主要是在程序前台激活状态下，可能会用到的场景：</p>\n<ul>\n<li>周边摇、现场摇、签到等</li>\n<li>产品介绍，商场导购，博物馆导游等 </li>\n<li>位置修正，iBeacon的精度可以辅助一些其他功能</li>\n<li>精确区域预警、地理围栏</li>\n<li>室内导航等</li>\n</ul>\n</li>\n<li><p>监听</p>\n<p>  托管给iOS系统，程序本身不需要打开即可触发功能，可能会用到以下场景：   </p>\n<ul>\n<li>欢迎语：比如当用户手持设备进入任意场景区域内时，进行交互提醒。</li>\n<li>业务联动：比如当用户进入某个控制区后，告知概况，同周边设备联动。</li>\n<li>区域预警：比如设置特定的围栏区域。</li>\n<li>其他：比如与门禁系统联动等</li>\n</ul>\n</li>\n<li><p>角色交换</p>\n<p>  通常情况下，iBeacon设备作为基站，移动设备比如iPhone和iPad来接收信号，从而进行机遇位置的场景交互。我们也可以讲iPhone和iPad作为基站，给其设定特定的区域值进行广播。而接收设备位置固定等。可以设想以下场景：</p>\n<ul>\n<li>演示大屏上展示周边设备。</li>\n<li>教师要求输入动态口令进行签到。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"基础方案\"><a href=\"#基础方案\" class=\"headerlink\" title=\"基础方案\"></a>基础方案</h3><p>​    理想情况下，以下数据需要预缓存，保证在无网络或者网络环境差的情况下，交互动作可以顺利进行。因此，各类信息的版本控制需要在前期考虑。</p>\n<h4 id=\"iBeacon策略\"><a href=\"#iBeacon策略\" class=\"headerlink\" title=\"iBeacon策略\"></a>iBeacon策略</h4><p>​    iBeacon策略，或者说应用场景。如上一篇文章中所说，这里主要在iBeacon对应的区域Region（ProximityUUID &amp; Major &amp; Minor）上的三个值上做文章。 比如：  </p>\n<ul>\n<li>ProximityUUID ： 公司编码</li>\n<li>Major ： 建筑编码</li>\n<li>Minor ： 某类区域（物品）编码</li>\n</ul>\n<p>策略相关信息确定后，就可以给不同的策略配置个性化信息了，比如进入／离开策略对应的区域时，定制以下信息：   </p>\n<ul>\n<li>通知声音：个性化提示音</li>\n<li>通知内容：跟具体业务相关</li>\n<li>通知优先级：当多个策略同时触发时，可根据优先级来动态显示</li>\n<li>通知频次：用来确保特定时间段内，不重复通知</li>\n</ul>\n<h4 id=\"iBeacon业务\"><a href=\"#iBeacon业务\" class=\"headerlink\" title=\"iBeacon业务\"></a>iBeacon业务</h4><p>​    单纯的触发iBeacon对应区域的策略，仅仅是对用户的消息提醒，我们比较关注的是策略的后续动作。比如当用户到达某个iBeacon区域（或者在某个区域驻足时间较长）后，收到了个性化的策略通知。很自然的点击查看感兴趣的消息，那么后续的动作就是这里所说的iBeacon业务。通常情况下，后续动作包括以下几种：   </p>\n<ul>\n<li>打开某个本地模块</li>\n<li>打开某个Web网页</li>\n<li>打开某个本地网页</li>\n<li>无后续动作</li>\n</ul>\n<p>需要注意的是，后续动作可能不止一种。</p>\n<h4 id=\"策略业务关联\"><a href=\"#策略业务关联\" class=\"headerlink\" title=\"策略业务关联\"></a>策略业务关联</h4><p>​    为了保证数据的灵活，策略与业务的对应关系为1:N（N &gt;= 0），当策略对应多个业务的时候，需要考虑各业务的优先级等。</p>\n<h4 id=\"用户策略\"><a href=\"#用户策略\" class=\"headerlink\" title=\"用户策略\"></a>用户策略</h4><p>​    除了一些共通的策略外，用户也可以拥有独特权限的策略，比如同一个区域，不同角色进入时，看到的数据根据其权限表现出差异。</p>\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><h4 id=\"设备选择\"><a href=\"#设备选择\" class=\"headerlink\" title=\"设备选择\"></a>设备选择</h4><p>iBeacon设备选取可能会考虑的几个因素包括：   </p>\n<ul>\n<li>电池及续航</li>\n<li>设备运维</li>\n<li>设备部署</li>\n<li>设备美感</li>\n<li>设备软件能力</li>\n<li>设备使用</li>\n</ul>\n<p>通常情况下，电池、部署、软件能力需要着重考虑。</p>\n<h4 id=\"设备部署\"><a href=\"#设备部署\" class=\"headerlink\" title=\"设备部署\"></a>设备部署</h4><p>部署时可能需要考虑以下几个因素：   </p>\n<ul>\n<li>环境干扰</li>\n<li>工厂校正电压</li>\n<li>放置位置（高度／间距）</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>​    iBeacon技术在旅游景点、博物馆、商场、酒店、会议室等场景中可以给人很好的用户体验，但在成本、运维部署方面一直存在着问题。目前情况下小范围内玩iBeacon，还是很有搞头的。</p>"},{"layout":"post","title":"iBeacon基础","date":"2017-02-11T14:50:12.000Z","author":"liangtong","catalog":true,"_content":"\n\n\n​\t<a href=\"https://developer.apple.com/ibeacon/\"> iBeacon </a> 标准是Apple在2013年WWDC上提出的，运行在iOS7+系统的设备上，且要求设备配备低功耗蓝牙BLE通信功能。本文简单介绍下iBeacon在位置、感知、距离方面的基本能力。\n\n\n\n\n### 位置服务\n​\t位置服务(Location Service)通常是在某个区域(Region)，通过GPS来实现的某些功能。比如当你手持安装星巴克应用的苹果手机在星巴克附近时，锁屏状态下会在屏幕左下角显示该应用的图标。<a href=\"http://lbs.amap.com/\"> 高德地图 </a>中的地理围栏就是一个实际应用场景。位置服务有以下缺点：   \n\n* GPS本身定位精度能力有限，位置服务不可能提供精确的位置服务；\n* 室内环境下GPS信号普遍不好，或者信号不可达；\n\n<!-- more -->\n\n### iBeacon\n​\tiBeacon技术是基于基站的形式。一个iBeacon可以被认为是一个区域（物体所在位置+覆盖半径），由于使用低功耗蓝牙技术，实验环境下其精度可以达到10cm范围内（虽然有些吹嘘，但亲测是相当精确的）。关于iBeacon的软件部分，需要了解以下几个概念：\n\n* Region : ProximityUUID & Major & Minor\n* Advertise Interval\n* Measured Power\n* RSSI    \n\n关于iBeacon区域的定义，由3个值来唯一确定一个区域，举例如下图：\n![](/post/iOS/iBeacon/uuid_major_minor.png) \n图描述的很清楚了，我们可以通过ProximityUUID、Major和Minor三个值来定义不同的有关联的区域（事物），并通过不同的值组合来做很多有意思的事情。\n\n### iBeacon基础场景\n\n#### 监听\n​\t区域监听(Region Monitoring)即当设备进入／离开某个／某类区域的时候，可以触发后续联动，其监听的区域可能是ProximityUUID代表的某个大的类别区域比如一个公司在全国的所有子公司、或者由ProximityUUID和Major组合的相对小的区域比如某个城市中的子公司。至于什么区域就比较灵活了。\n​\t一般情况下，iOS程序退出或者后台挂起后，程序是不能执行的(其他Background-Mode除外)。但是这里所说的区域监听是托管给iOS系统，也就是说程序设置完监听区域后，iOS系统会托管，当设备进入／离开监听区域时，系统会触发相应的操作，并唤醒程序。\n\n#### 测距\n测距（Ranging）即设备与Beacon区域中心点的接近距离（接近状态），包括：   \n* Immediate 非常近\n* Near 1～3米\n* Far 3米以外\n* Unknown 距离不可测量\n\n测距是在iOS程序处于前台激活状态下使用的，程序推到后台时，该功能便不可用。\n\n#### 应用场景举例\n\n监听：由iOS系统接管，所以该功能需慎用，搞不好会让用户厌烦。   \n\n* 欢迎语：比如商店入口／出口放置，用来给顾客相关提示。\n* 物品介绍：比如在博物馆某些区域，导游和网络信号不好的情况下，可以通过给文物贴上标签(iBeacon)，让每个设备都当导游。\n* 业务确认：比如在某些病房中放置，在特定时刻向病人确定吃药情况。\n* 预警：比如钥匙坠，当不在身边时及时提醒。\n* 其他：比如门禁、宠物饰品等\n\n测距：需要程序处于前台激活状态下使用，这里主要用在区域相关和用户互动的场景。\n\n* 商场活动：比如现场抽奖、现场摇一摇\n* 自动售货机：付款\n* 活动签到：上课／开会等\n* 商场导购：在某个商品前停留，自动推该商品信息、折扣信息等\n* 微信摇一摇周边\n* 其他：室内导航等\n\n\n### 现状\n​\t经过这么多年的发展，iBeacon技术并没有达到前几年预想的效果。可能是受成本及运维的影响，也可能是关于位置感知的场景化需求太少，一直没有流行起来。目前国内主要的厂商包括：智石科技、四月兄弟、DropBeacon等，提供了Beacon的基础能力，但在设备美观及精确度方面个人不敢恭维。\n国外Beacon技术相对先进不少，应该是受苹果的影响。比较突出的一个是<a href=\"http://estimote.com/\"> Estiomte </a>，他家的产品及配套SDK是真心不错，就是略贵。\n","source":"_posts/bluetooth_iBeacon1.md","raw":"---\nlayout:     post\ntitle:      iBeacon基础\ndate:       2017-02-11 22:50:12\nauthor:     liangtong\ncatalog: true\ncategories: 蓝牙\ntags: iBeacon\n\n---\n\n\n\n​\t<a href=\"https://developer.apple.com/ibeacon/\"> iBeacon </a> 标准是Apple在2013年WWDC上提出的，运行在iOS7+系统的设备上，且要求设备配备低功耗蓝牙BLE通信功能。本文简单介绍下iBeacon在位置、感知、距离方面的基本能力。\n\n\n\n\n### 位置服务\n​\t位置服务(Location Service)通常是在某个区域(Region)，通过GPS来实现的某些功能。比如当你手持安装星巴克应用的苹果手机在星巴克附近时，锁屏状态下会在屏幕左下角显示该应用的图标。<a href=\"http://lbs.amap.com/\"> 高德地图 </a>中的地理围栏就是一个实际应用场景。位置服务有以下缺点：   \n\n* GPS本身定位精度能力有限，位置服务不可能提供精确的位置服务；\n* 室内环境下GPS信号普遍不好，或者信号不可达；\n\n<!-- more -->\n\n### iBeacon\n​\tiBeacon技术是基于基站的形式。一个iBeacon可以被认为是一个区域（物体所在位置+覆盖半径），由于使用低功耗蓝牙技术，实验环境下其精度可以达到10cm范围内（虽然有些吹嘘，但亲测是相当精确的）。关于iBeacon的软件部分，需要了解以下几个概念：\n\n* Region : ProximityUUID & Major & Minor\n* Advertise Interval\n* Measured Power\n* RSSI    \n\n关于iBeacon区域的定义，由3个值来唯一确定一个区域，举例如下图：\n![](/post/iOS/iBeacon/uuid_major_minor.png) \n图描述的很清楚了，我们可以通过ProximityUUID、Major和Minor三个值来定义不同的有关联的区域（事物），并通过不同的值组合来做很多有意思的事情。\n\n### iBeacon基础场景\n\n#### 监听\n​\t区域监听(Region Monitoring)即当设备进入／离开某个／某类区域的时候，可以触发后续联动，其监听的区域可能是ProximityUUID代表的某个大的类别区域比如一个公司在全国的所有子公司、或者由ProximityUUID和Major组合的相对小的区域比如某个城市中的子公司。至于什么区域就比较灵活了。\n​\t一般情况下，iOS程序退出或者后台挂起后，程序是不能执行的(其他Background-Mode除外)。但是这里所说的区域监听是托管给iOS系统，也就是说程序设置完监听区域后，iOS系统会托管，当设备进入／离开监听区域时，系统会触发相应的操作，并唤醒程序。\n\n#### 测距\n测距（Ranging）即设备与Beacon区域中心点的接近距离（接近状态），包括：   \n* Immediate 非常近\n* Near 1～3米\n* Far 3米以外\n* Unknown 距离不可测量\n\n测距是在iOS程序处于前台激活状态下使用的，程序推到后台时，该功能便不可用。\n\n#### 应用场景举例\n\n监听：由iOS系统接管，所以该功能需慎用，搞不好会让用户厌烦。   \n\n* 欢迎语：比如商店入口／出口放置，用来给顾客相关提示。\n* 物品介绍：比如在博物馆某些区域，导游和网络信号不好的情况下，可以通过给文物贴上标签(iBeacon)，让每个设备都当导游。\n* 业务确认：比如在某些病房中放置，在特定时刻向病人确定吃药情况。\n* 预警：比如钥匙坠，当不在身边时及时提醒。\n* 其他：比如门禁、宠物饰品等\n\n测距：需要程序处于前台激活状态下使用，这里主要用在区域相关和用户互动的场景。\n\n* 商场活动：比如现场抽奖、现场摇一摇\n* 自动售货机：付款\n* 活动签到：上课／开会等\n* 商场导购：在某个商品前停留，自动推该商品信息、折扣信息等\n* 微信摇一摇周边\n* 其他：室内导航等\n\n\n### 现状\n​\t经过这么多年的发展，iBeacon技术并没有达到前几年预想的效果。可能是受成本及运维的影响，也可能是关于位置感知的场景化需求太少，一直没有流行起来。目前国内主要的厂商包括：智石科技、四月兄弟、DropBeacon等，提供了Beacon的基础能力，但在设备美观及精确度方面个人不敢恭维。\n国外Beacon技术相对先进不少，应该是受苹果的影响。比较突出的一个是<a href=\"http://estimote.com/\"> Estiomte </a>，他家的产品及配套SDK是真心不错，就是略贵。\n","slug":"bluetooth_iBeacon1","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4s4000moko873rrrf65","content":"<p>​    <a href=\"https://developer.apple.com/ibeacon/\" target=\"_blank\" rel=\"external\"> iBeacon </a> 标准是Apple在2013年WWDC上提出的，运行在iOS7+系统的设备上，且要求设备配备低功耗蓝牙BLE通信功能。本文简单介绍下iBeacon在位置、感知、距离方面的基本能力。</p>\n<h3 id=\"位置服务\"><a href=\"#位置服务\" class=\"headerlink\" title=\"位置服务\"></a>位置服务</h3><p>​    位置服务(Location Service)通常是在某个区域(Region)，通过GPS来实现的某些功能。比如当你手持安装星巴克应用的苹果手机在星巴克附近时，锁屏状态下会在屏幕左下角显示该应用的图标。<a href=\"http://lbs.amap.com/\" target=\"_blank\" rel=\"external\"> 高德地图 </a>中的地理围栏就是一个实际应用场景。位置服务有以下缺点：   </p>\n<ul>\n<li>GPS本身定位精度能力有限，位置服务不可能提供精确的位置服务；</li>\n<li>室内环境下GPS信号普遍不好，或者信号不可达；</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"iBeacon\"><a href=\"#iBeacon\" class=\"headerlink\" title=\"iBeacon\"></a>iBeacon</h3><p>​    iBeacon技术是基于基站的形式。一个iBeacon可以被认为是一个区域（物体所在位置+覆盖半径），由于使用低功耗蓝牙技术，实验环境下其精度可以达到10cm范围内（虽然有些吹嘘，但亲测是相当精确的）。关于iBeacon的软件部分，需要了解以下几个概念：</p>\n<ul>\n<li>Region : ProximityUUID &amp; Major &amp; Minor</li>\n<li>Advertise Interval</li>\n<li>Measured Power</li>\n<li>RSSI    </li>\n</ul>\n<p>关于iBeacon区域的定义，由3个值来唯一确定一个区域，举例如下图：<br><img src=\"/post/iOS/iBeacon/uuid_major_minor.png\" alt=\"\"><br>图描述的很清楚了，我们可以通过ProximityUUID、Major和Minor三个值来定义不同的有关联的区域（事物），并通过不同的值组合来做很多有意思的事情。</p>\n<h3 id=\"iBeacon基础场景\"><a href=\"#iBeacon基础场景\" class=\"headerlink\" title=\"iBeacon基础场景\"></a>iBeacon基础场景</h3><h4 id=\"监听\"><a href=\"#监听\" class=\"headerlink\" title=\"监听\"></a>监听</h4><p>​    区域监听(Region Monitoring)即当设备进入／离开某个／某类区域的时候，可以触发后续联动，其监听的区域可能是ProximityUUID代表的某个大的类别区域比如一个公司在全国的所有子公司、或者由ProximityUUID和Major组合的相对小的区域比如某个城市中的子公司。至于什么区域就比较灵活了。<br>​    一般情况下，iOS程序退出或者后台挂起后，程序是不能执行的(其他Background-Mode除外)。但是这里所说的区域监听是托管给iOS系统，也就是说程序设置完监听区域后，iOS系统会托管，当设备进入／离开监听区域时，系统会触发相应的操作，并唤醒程序。</p>\n<h4 id=\"测距\"><a href=\"#测距\" class=\"headerlink\" title=\"测距\"></a>测距</h4><p>测距（Ranging）即设备与Beacon区域中心点的接近距离（接近状态），包括：   </p>\n<ul>\n<li>Immediate 非常近</li>\n<li>Near 1～3米</li>\n<li>Far 3米以外</li>\n<li>Unknown 距离不可测量</li>\n</ul>\n<p>测距是在iOS程序处于前台激活状态下使用的，程序推到后台时，该功能便不可用。</p>\n<h4 id=\"应用场景举例\"><a href=\"#应用场景举例\" class=\"headerlink\" title=\"应用场景举例\"></a>应用场景举例</h4><p>监听：由iOS系统接管，所以该功能需慎用，搞不好会让用户厌烦。   </p>\n<ul>\n<li>欢迎语：比如商店入口／出口放置，用来给顾客相关提示。</li>\n<li>物品介绍：比如在博物馆某些区域，导游和网络信号不好的情况下，可以通过给文物贴上标签(iBeacon)，让每个设备都当导游。</li>\n<li>业务确认：比如在某些病房中放置，在特定时刻向病人确定吃药情况。</li>\n<li>预警：比如钥匙坠，当不在身边时及时提醒。</li>\n<li>其他：比如门禁、宠物饰品等</li>\n</ul>\n<p>测距：需要程序处于前台激活状态下使用，这里主要用在区域相关和用户互动的场景。</p>\n<ul>\n<li>商场活动：比如现场抽奖、现场摇一摇</li>\n<li>自动售货机：付款</li>\n<li>活动签到：上课／开会等</li>\n<li>商场导购：在某个商品前停留，自动推该商品信息、折扣信息等</li>\n<li>微信摇一摇周边</li>\n<li>其他：室内导航等</li>\n</ul>\n<h3 id=\"现状\"><a href=\"#现状\" class=\"headerlink\" title=\"现状\"></a>现状</h3><p>​    经过这么多年的发展，iBeacon技术并没有达到前几年预想的效果。可能是受成本及运维的影响，也可能是关于位置感知的场景化需求太少，一直没有流行起来。目前国内主要的厂商包括：智石科技、四月兄弟、DropBeacon等，提供了Beacon的基础能力，但在设备美观及精确度方面个人不敢恭维。<br>国外Beacon技术相对先进不少，应该是受苹果的影响。比较突出的一个是<a href=\"http://estimote.com/\" target=\"_blank\" rel=\"external\"> Estiomte </a>，他家的产品及配套SDK是真心不错，就是略贵。</p>\n","site":{"data":{}},"excerpt":"<p>​    <a href=\"https://developer.apple.com/ibeacon/\" target=\"_blank\" rel=\"external\"> iBeacon </a> 标准是Apple在2013年WWDC上提出的，运行在iOS7+系统的设备上，且要求设备配备低功耗蓝牙BLE通信功能。本文简单介绍下iBeacon在位置、感知、距离方面的基本能力。</p>\n<h3 id=\"位置服务\"><a href=\"#位置服务\" class=\"headerlink\" title=\"位置服务\"></a>位置服务</h3><p>​    位置服务(Location Service)通常是在某个区域(Region)，通过GPS来实现的某些功能。比如当你手持安装星巴克应用的苹果手机在星巴克附近时，锁屏状态下会在屏幕左下角显示该应用的图标。<a href=\"http://lbs.amap.com/\" target=\"_blank\" rel=\"external\"> 高德地图 </a>中的地理围栏就是一个实际应用场景。位置服务有以下缺点：   </p>\n<ul>\n<li>GPS本身定位精度能力有限，位置服务不可能提供精确的位置服务；</li>\n<li>室内环境下GPS信号普遍不好，或者信号不可达；</li>\n</ul>","more":"<h3 id=\"iBeacon\"><a href=\"#iBeacon\" class=\"headerlink\" title=\"iBeacon\"></a>iBeacon</h3><p>​    iBeacon技术是基于基站的形式。一个iBeacon可以被认为是一个区域（物体所在位置+覆盖半径），由于使用低功耗蓝牙技术，实验环境下其精度可以达到10cm范围内（虽然有些吹嘘，但亲测是相当精确的）。关于iBeacon的软件部分，需要了解以下几个概念：</p>\n<ul>\n<li>Region : ProximityUUID &amp; Major &amp; Minor</li>\n<li>Advertise Interval</li>\n<li>Measured Power</li>\n<li>RSSI    </li>\n</ul>\n<p>关于iBeacon区域的定义，由3个值来唯一确定一个区域，举例如下图：<br><img src=\"/post/iOS/iBeacon/uuid_major_minor.png\" alt=\"\"><br>图描述的很清楚了，我们可以通过ProximityUUID、Major和Minor三个值来定义不同的有关联的区域（事物），并通过不同的值组合来做很多有意思的事情。</p>\n<h3 id=\"iBeacon基础场景\"><a href=\"#iBeacon基础场景\" class=\"headerlink\" title=\"iBeacon基础场景\"></a>iBeacon基础场景</h3><h4 id=\"监听\"><a href=\"#监听\" class=\"headerlink\" title=\"监听\"></a>监听</h4><p>​    区域监听(Region Monitoring)即当设备进入／离开某个／某类区域的时候，可以触发后续联动，其监听的区域可能是ProximityUUID代表的某个大的类别区域比如一个公司在全国的所有子公司、或者由ProximityUUID和Major组合的相对小的区域比如某个城市中的子公司。至于什么区域就比较灵活了。<br>​    一般情况下，iOS程序退出或者后台挂起后，程序是不能执行的(其他Background-Mode除外)。但是这里所说的区域监听是托管给iOS系统，也就是说程序设置完监听区域后，iOS系统会托管，当设备进入／离开监听区域时，系统会触发相应的操作，并唤醒程序。</p>\n<h4 id=\"测距\"><a href=\"#测距\" class=\"headerlink\" title=\"测距\"></a>测距</h4><p>测距（Ranging）即设备与Beacon区域中心点的接近距离（接近状态），包括：   </p>\n<ul>\n<li>Immediate 非常近</li>\n<li>Near 1～3米</li>\n<li>Far 3米以外</li>\n<li>Unknown 距离不可测量</li>\n</ul>\n<p>测距是在iOS程序处于前台激活状态下使用的，程序推到后台时，该功能便不可用。</p>\n<h4 id=\"应用场景举例\"><a href=\"#应用场景举例\" class=\"headerlink\" title=\"应用场景举例\"></a>应用场景举例</h4><p>监听：由iOS系统接管，所以该功能需慎用，搞不好会让用户厌烦。   </p>\n<ul>\n<li>欢迎语：比如商店入口／出口放置，用来给顾客相关提示。</li>\n<li>物品介绍：比如在博物馆某些区域，导游和网络信号不好的情况下，可以通过给文物贴上标签(iBeacon)，让每个设备都当导游。</li>\n<li>业务确认：比如在某些病房中放置，在特定时刻向病人确定吃药情况。</li>\n<li>预警：比如钥匙坠，当不在身边时及时提醒。</li>\n<li>其他：比如门禁、宠物饰品等</li>\n</ul>\n<p>测距：需要程序处于前台激活状态下使用，这里主要用在区域相关和用户互动的场景。</p>\n<ul>\n<li>商场活动：比如现场抽奖、现场摇一摇</li>\n<li>自动售货机：付款</li>\n<li>活动签到：上课／开会等</li>\n<li>商场导购：在某个商品前停留，自动推该商品信息、折扣信息等</li>\n<li>微信摇一摇周边</li>\n<li>其他：室内导航等</li>\n</ul>\n<h3 id=\"现状\"><a href=\"#现状\" class=\"headerlink\" title=\"现状\"></a>现状</h3><p>​    经过这么多年的发展，iBeacon技术并没有达到前几年预想的效果。可能是受成本及运维的影响，也可能是关于位置感知的场景化需求太少，一直没有流行起来。目前国内主要的厂商包括：智石科技、四月兄弟、DropBeacon等，提供了Beacon的基础能力，但在设备美观及精确度方面个人不敢恭维。<br>国外Beacon技术相对先进不少，应该是受苹果的影响。比较突出的一个是<a href=\"http://estimote.com/\" target=\"_blank\" rel=\"external\"> Estiomte </a>，他家的产品及配套SDK是真心不错，就是略贵。</p>"},{"layout":"post","title":"基数排序","date":"2017-06-13T03:25:37.000Z","author":"liangtong","catalog":true,"_content":"\n\n\n​\t基数排序（radix sort）属于“分配式排序”（distribution sort），基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。参照斯坦福大学算法公开课视频\n\n\n\n<!-- more -->\n\n### 基本思想及实现   \n基本思想： 对于一个整型数组：      \n* ① 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。\n* ② 排序算法使用计数排序思想\n\n使用Swift编写简单的代码实现，如下：    \n```Swift\n/**\n*  基数排序\n* 分布式排序算法\n* 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。\n* 基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。\n* 排序使用 - 计数排序\n**/\n\n\n/**\n*\n*  @brief 基数排序 - LSD\n*  @param  sortArray 待排序整形数组\n*  @param  loop    排序轮次\n*  @param  step    步长\n*\n**/\nfunc radixSort(sortArray:inout Array<Int>, loop:Int,step:Int){\n\n    let length = sortArray.count;//待排序数组长度\n\n    /**\n    * 根据最高位和最低位，确定每次进行计数排序的中间位数\n    **/\n    var msb = 1;//最高位\n    var minimum = 1;//最低位\n    for _ in 0 ..< loop * step {\n        msb = msb * 10;\n    }\n    for _ in 0 ..< step {\n        minimum = minimum * 10;\n    }\n\n    /**\n    * 计数排序 - 非基于比较的排序算法 。 可参照上一篇文章\n    */\n    var countArray = Array<Int>();\n    var buckets = Array<Int>()\n    for _ in 0 ... minimum {\n        countArray.append(0);\n    }\n    for _ in 0 ..< length{\n        buckets.append(0);\n    }\n    //第一个步骤：统计数量\n    for i in 0 ..< length {//统计小于位置i的元素个数\n        let sortValue = sortArray[i] / msb % minimum;\n        countArray[sortValue] = countArray[sortValue] + 1;\n    }\n    for i in 1 ... minimum {//统计出小于等于位置i的元素个数\n        countArray[i] = countArray[i] + countArray[i - 1];\n    }\n    //第二个步骤：逆向扫描数组sortArray，将i位置元素放置到retArray中countArray对应值的位置上，同时修正countArray的值\n    for i in (0 ..< length).reversed() {\n        let value = sortArray[i] / msb % minimum;\n        let countValue = countArray[value];\n        buckets[countValue - 1] = sortArray[i];\n        countArray[value] = countArray[value] - 1;\n    }\n\n    //对本次基数排序结果进行排序\n    for i in 0 ..< length {\n        sortArray[i] = buckets[i];\n    }\n}\n```\n\n### 测试用例及结果\n\n```Swift\n    var intArray =  [14, 22, 28, 39, 43, 81, 93, 100, 92, 96, 99, 95, 10563, 55, 7, 65, 73, 999, 1024, 20490, 1];\n\n    var maxValue = 0;\n    var maxLength = 1;\n    var step = 2;\n    var loopTimes = 0;\n\n    for i in 0 ..< intArray.count{\n        if intArray[i] > maxValue{\n            maxValue = intArray[i];\n        }\n    }\n\n    while(maxValue / 10 != 0){\n        maxLength = maxLength + 1;\n        maxValue = maxValue / 10;\n    }\n\n    if maxLength % step > 0{\n        loopTimes = 1;\n    }\n    loopTimes = loopTimes + maxLength / step;\n\n    print(\"待排序数组\\(intArray)\");\n    print(\"步长：\\(step)\");\n    for i in 0 ..< loopTimes{\n        radixSort(sortArray: &intArray, loop: i, step: step);\n        print(\"第\\(i)次基数排序后结果：\\(intArray)\");\n    }\n\n//程序输出\n待排序数组[14, 22, 28, 39, 43, 81, 93, 100, 92, 96, 99, 95, 10563, 55, 7, 65, 73, 999, 1024, 20490, 1]\n步长：2\n第0次基数排序后结果：[100, 1, 7, 14, 22, 1024, 28, 39, 43, 55, 10563, 65, 73, 81, 20490, 92, 93, 95, 96, 99, 999]\n第1次基数排序后结果：[1, 7, 14, 22, 28, 39, 43, 55, 65, 73, 81, 92, 93, 95, 96, 99, 100, 20490, 10563, 999, 1024]\n第2次基数排序后结果：[1, 7, 14, 22, 28, 39, 43, 55, 65, 73, 81, 92, 93, 95, 96, 99, 100, 999, 1024, 10563, 20490]\n\n```\n\n","source":"_posts/algorithm_sort_radix.md","raw":"---\nlayout:     post\ntitle:      基数排序\ndate:       2017-06-13 11:25:37\nauthor:     liangtong\ncatalog: true\ncategories: Algorithm\ntags: Sort\n\n---\n\n\n\n​\t基数排序（radix sort）属于“分配式排序”（distribution sort），基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。参照斯坦福大学算法公开课视频\n\n\n\n<!-- more -->\n\n### 基本思想及实现   \n基本思想： 对于一个整型数组：      \n* ① 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。\n* ② 排序算法使用计数排序思想\n\n使用Swift编写简单的代码实现，如下：    \n```Swift\n/**\n*  基数排序\n* 分布式排序算法\n* 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。\n* 基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。\n* 排序使用 - 计数排序\n**/\n\n\n/**\n*\n*  @brief 基数排序 - LSD\n*  @param  sortArray 待排序整形数组\n*  @param  loop    排序轮次\n*  @param  step    步长\n*\n**/\nfunc radixSort(sortArray:inout Array<Int>, loop:Int,step:Int){\n\n    let length = sortArray.count;//待排序数组长度\n\n    /**\n    * 根据最高位和最低位，确定每次进行计数排序的中间位数\n    **/\n    var msb = 1;//最高位\n    var minimum = 1;//最低位\n    for _ in 0 ..< loop * step {\n        msb = msb * 10;\n    }\n    for _ in 0 ..< step {\n        minimum = minimum * 10;\n    }\n\n    /**\n    * 计数排序 - 非基于比较的排序算法 。 可参照上一篇文章\n    */\n    var countArray = Array<Int>();\n    var buckets = Array<Int>()\n    for _ in 0 ... minimum {\n        countArray.append(0);\n    }\n    for _ in 0 ..< length{\n        buckets.append(0);\n    }\n    //第一个步骤：统计数量\n    for i in 0 ..< length {//统计小于位置i的元素个数\n        let sortValue = sortArray[i] / msb % minimum;\n        countArray[sortValue] = countArray[sortValue] + 1;\n    }\n    for i in 1 ... minimum {//统计出小于等于位置i的元素个数\n        countArray[i] = countArray[i] + countArray[i - 1];\n    }\n    //第二个步骤：逆向扫描数组sortArray，将i位置元素放置到retArray中countArray对应值的位置上，同时修正countArray的值\n    for i in (0 ..< length).reversed() {\n        let value = sortArray[i] / msb % minimum;\n        let countValue = countArray[value];\n        buckets[countValue - 1] = sortArray[i];\n        countArray[value] = countArray[value] - 1;\n    }\n\n    //对本次基数排序结果进行排序\n    for i in 0 ..< length {\n        sortArray[i] = buckets[i];\n    }\n}\n```\n\n### 测试用例及结果\n\n```Swift\n    var intArray =  [14, 22, 28, 39, 43, 81, 93, 100, 92, 96, 99, 95, 10563, 55, 7, 65, 73, 999, 1024, 20490, 1];\n\n    var maxValue = 0;\n    var maxLength = 1;\n    var step = 2;\n    var loopTimes = 0;\n\n    for i in 0 ..< intArray.count{\n        if intArray[i] > maxValue{\n            maxValue = intArray[i];\n        }\n    }\n\n    while(maxValue / 10 != 0){\n        maxLength = maxLength + 1;\n        maxValue = maxValue / 10;\n    }\n\n    if maxLength % step > 0{\n        loopTimes = 1;\n    }\n    loopTimes = loopTimes + maxLength / step;\n\n    print(\"待排序数组\\(intArray)\");\n    print(\"步长：\\(step)\");\n    for i in 0 ..< loopTimes{\n        radixSort(sortArray: &intArray, loop: i, step: step);\n        print(\"第\\(i)次基数排序后结果：\\(intArray)\");\n    }\n\n//程序输出\n待排序数组[14, 22, 28, 39, 43, 81, 93, 100, 92, 96, 99, 95, 10563, 55, 7, 65, 73, 999, 1024, 20490, 1]\n步长：2\n第0次基数排序后结果：[100, 1, 7, 14, 22, 1024, 28, 39, 43, 55, 10563, 65, 73, 81, 20490, 92, 93, 95, 96, 99, 999]\n第1次基数排序后结果：[1, 7, 14, 22, 28, 39, 43, 55, 65, 73, 81, 92, 93, 95, 96, 99, 100, 20490, 10563, 999, 1024]\n第2次基数排序后结果：[1, 7, 14, 22, 28, 39, 43, 55, 65, 73, 81, 92, 93, 95, 96, 99, 100, 999, 1024, 10563, 20490]\n\n```\n\n","slug":"algorithm_sort_radix","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4s5000poko86fxx63x2","content":"<p>​    基数排序（radix sort）属于“分配式排序”（distribution sort），基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。参照斯坦福大学算法公开课视频</p>\n<a id=\"more\"></a>\n<h3 id=\"基本思想及实现\"><a href=\"#基本思想及实现\" class=\"headerlink\" title=\"基本思想及实现\"></a>基本思想及实现</h3><p>基本思想： 对于一个整型数组：      </p>\n<ul>\n<li>① 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</li>\n<li>② 排序算法使用计数排序思想</li>\n</ul>\n<p>使用Swift编写简单的代码实现，如下：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">*  基数排序</span></div><div class=\"line\"><span class=\"comment\">* 分布式排序算法</span></div><div class=\"line\"><span class=\"comment\">* 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</span></div><div class=\"line\"><span class=\"comment\">* 基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</span></div><div class=\"line\"><span class=\"comment\">* 排序使用 - 计数排序</span></div><div class=\"line\"><span class=\"comment\">**/</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">*</span></div><div class=\"line\"><span class=\"comment\">*  @brief 基数排序 - LSD</span></div><div class=\"line\"><span class=\"comment\">*  @param  sortArray 待排序整形数组</span></div><div class=\"line\"><span class=\"comment\">*  @param  loop    排序轮次</span></div><div class=\"line\"><span class=\"comment\">*  @param  step    步长</span></div><div class=\"line\"><span class=\"comment\">*</span></div><div class=\"line\"><span class=\"comment\">**/</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">radixSort</span><span class=\"params\">(sortArray:<span class=\"keyword\">inout</span> Array&lt;Int&gt;, loop:Int,step:Int)</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">let</span> length = sortArray.<span class=\"built_in\">count</span>;<span class=\"comment\">//待排序数组长度</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">    * 根据最高位和最低位，确定每次进行计数排序的中间位数</span></div><div class=\"line\"><span class=\"comment\">    **/</span></div><div class=\"line\">    <span class=\"keyword\">var</span> msb = <span class=\"number\">1</span>;<span class=\"comment\">//最高位</span></div><div class=\"line\">    <span class=\"keyword\">var</span> minimum = <span class=\"number\">1</span>;<span class=\"comment\">//最低位</span></div><div class=\"line\">    <span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span> ..&lt; loop * step &#123;</div><div class=\"line\">        msb = msb * <span class=\"number\">10</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span> ..&lt; step &#123;</div><div class=\"line\">        minimum = minimum * <span class=\"number\">10</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">    * 计数排序 - 非基于比较的排序算法 。 可参照上一篇文章</span></div><div class=\"line\"><span class=\"comment\">    */</span></div><div class=\"line\">    <span class=\"keyword\">var</span> countArray = <span class=\"type\">Array</span>&lt;<span class=\"type\">Int</span>&gt;();</div><div class=\"line\">    <span class=\"keyword\">var</span> buckets = <span class=\"type\">Array</span>&lt;<span class=\"type\">Int</span>&gt;()</div><div class=\"line\">    <span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span> ... minimum &#123;</div><div class=\"line\">        countArray.append(<span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span> ..&lt; length&#123;</div><div class=\"line\">        buckets.append(<span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//第一个步骤：统计数量</span></div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span> ..&lt; length &#123;<span class=\"comment\">//统计小于位置i的元素个数</span></div><div class=\"line\">        <span class=\"keyword\">let</span> sortValue = sortArray[i] / msb % minimum;</div><div class=\"line\">        countArray[sortValue] = countArray[sortValue] + <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">1</span> ... minimum &#123;<span class=\"comment\">//统计出小于等于位置i的元素个数</span></div><div class=\"line\">        countArray[i] = countArray[i] + countArray[i - <span class=\"number\">1</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//第二个步骤：逆向扫描数组sortArray，将i位置元素放置到retArray中countArray对应值的位置上，同时修正countArray的值</span></div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> (<span class=\"number\">0</span> ..&lt; length).reversed() &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> value = sortArray[i] / msb % minimum;</div><div class=\"line\">        <span class=\"keyword\">let</span> countValue = countArray[value];</div><div class=\"line\">        buckets[countValue - <span class=\"number\">1</span>] = sortArray[i];</div><div class=\"line\">        countArray[value] = countArray[value] - <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//对本次基数排序结果进行排序</span></div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span> ..&lt; length &#123;</div><div class=\"line\">        sortArray[i] = buckets[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"测试用例及结果\"><a href=\"#测试用例及结果\" class=\"headerlink\" title=\"测试用例及结果\"></a>测试用例及结果</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">    <span class=\"keyword\">var</span> intArray =  [<span class=\"number\">14</span>, <span class=\"number\">22</span>, <span class=\"number\">28</span>, <span class=\"number\">39</span>, <span class=\"number\">43</span>, <span class=\"number\">81</span>, <span class=\"number\">93</span>, <span class=\"number\">100</span>, <span class=\"number\">92</span>, <span class=\"number\">96</span>, <span class=\"number\">99</span>, <span class=\"number\">95</span>, <span class=\"number\">10563</span>, <span class=\"number\">55</span>, <span class=\"number\">7</span>, <span class=\"number\">65</span>, <span class=\"number\">73</span>, <span class=\"number\">999</span>, <span class=\"number\">1024</span>, <span class=\"number\">20490</span>, <span class=\"number\">1</span>];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> maxValue = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> maxLength = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> step = <span class=\"number\">2</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> loopTimes = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span> ..&lt; intArray.<span class=\"built_in\">count</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> intArray[i] &gt; maxValue&#123;</div><div class=\"line\">            maxValue = intArray[i];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(maxValue / <span class=\"number\">10</span> != <span class=\"number\">0</span>)&#123;</div><div class=\"line\">        maxLength = maxLength + <span class=\"number\">1</span>;</div><div class=\"line\">        maxValue = maxValue / <span class=\"number\">10</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> maxLength % step &gt; <span class=\"number\">0</span>&#123;</div><div class=\"line\">        loopTimes = <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    loopTimes = loopTimes + maxLength / step;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"待排序数组<span class=\"subst\">\\(intArray)</span>\"</span>);</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"步长：<span class=\"subst\">\\(step)</span>\"</span>);</div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span> ..&lt; loopTimes&#123;</div><div class=\"line\">        radixSort(sortArray: &amp;intArray, loop: i, step: step);</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"第<span class=\"subst\">\\(i)</span>次基数排序后结果：<span class=\"subst\">\\(intArray)</span>\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//程序输出</span></div><div class=\"line\">待排序数组[<span class=\"number\">14</span>, <span class=\"number\">22</span>, <span class=\"number\">28</span>, <span class=\"number\">39</span>, <span class=\"number\">43</span>, <span class=\"number\">81</span>, <span class=\"number\">93</span>, <span class=\"number\">100</span>, <span class=\"number\">92</span>, <span class=\"number\">96</span>, <span class=\"number\">99</span>, <span class=\"number\">95</span>, <span class=\"number\">10563</span>, <span class=\"number\">55</span>, <span class=\"number\">7</span>, <span class=\"number\">65</span>, <span class=\"number\">73</span>, <span class=\"number\">999</span>, <span class=\"number\">1024</span>, <span class=\"number\">20490</span>, <span class=\"number\">1</span>]</div><div class=\"line\">步长：<span class=\"number\">2</span></div><div class=\"line\">第<span class=\"number\">0</span>次基数排序后结果：[<span class=\"number\">100</span>, <span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">14</span>, <span class=\"number\">22</span>, <span class=\"number\">1024</span>, <span class=\"number\">28</span>, <span class=\"number\">39</span>, <span class=\"number\">43</span>, <span class=\"number\">55</span>, <span class=\"number\">10563</span>, <span class=\"number\">65</span>, <span class=\"number\">73</span>, <span class=\"number\">81</span>, <span class=\"number\">20490</span>, <span class=\"number\">92</span>, <span class=\"number\">93</span>, <span class=\"number\">95</span>, <span class=\"number\">96</span>, <span class=\"number\">99</span>, <span class=\"number\">999</span>]</div><div class=\"line\">第<span class=\"number\">1</span>次基数排序后结果：[<span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">14</span>, <span class=\"number\">22</span>, <span class=\"number\">28</span>, <span class=\"number\">39</span>, <span class=\"number\">43</span>, <span class=\"number\">55</span>, <span class=\"number\">65</span>, <span class=\"number\">73</span>, <span class=\"number\">81</span>, <span class=\"number\">92</span>, <span class=\"number\">93</span>, <span class=\"number\">95</span>, <span class=\"number\">96</span>, <span class=\"number\">99</span>, <span class=\"number\">100</span>, <span class=\"number\">20490</span>, <span class=\"number\">10563</span>, <span class=\"number\">999</span>, <span class=\"number\">1024</span>]</div><div class=\"line\">第<span class=\"number\">2</span>次基数排序后结果：[<span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">14</span>, <span class=\"number\">22</span>, <span class=\"number\">28</span>, <span class=\"number\">39</span>, <span class=\"number\">43</span>, <span class=\"number\">55</span>, <span class=\"number\">65</span>, <span class=\"number\">73</span>, <span class=\"number\">81</span>, <span class=\"number\">92</span>, <span class=\"number\">93</span>, <span class=\"number\">95</span>, <span class=\"number\">96</span>, <span class=\"number\">99</span>, <span class=\"number\">100</span>, <span class=\"number\">999</span>, <span class=\"number\">1024</span>, <span class=\"number\">10563</span>, <span class=\"number\">20490</span>]</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>​    基数排序（radix sort）属于“分配式排序”（distribution sort），基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。参照斯坦福大学算法公开课视频</p>","more":"<h3 id=\"基本思想及实现\"><a href=\"#基本思想及实现\" class=\"headerlink\" title=\"基本思想及实现\"></a>基本思想及实现</h3><p>基本思想： 对于一个整型数组：      </p>\n<ul>\n<li>① 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</li>\n<li>② 排序算法使用计数排序思想</li>\n</ul>\n<p>使用Swift编写简单的代码实现，如下：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">*  基数排序</span></div><div class=\"line\"><span class=\"comment\">* 分布式排序算法</span></div><div class=\"line\"><span class=\"comment\">* 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</span></div><div class=\"line\"><span class=\"comment\">* 基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</span></div><div class=\"line\"><span class=\"comment\">* 排序使用 - 计数排序</span></div><div class=\"line\"><span class=\"comment\">**/</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">*</span></div><div class=\"line\"><span class=\"comment\">*  @brief 基数排序 - LSD</span></div><div class=\"line\"><span class=\"comment\">*  @param  sortArray 待排序整形数组</span></div><div class=\"line\"><span class=\"comment\">*  @param  loop    排序轮次</span></div><div class=\"line\"><span class=\"comment\">*  @param  step    步长</span></div><div class=\"line\"><span class=\"comment\">*</span></div><div class=\"line\"><span class=\"comment\">**/</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">radixSort</span><span class=\"params\">(sortArray:<span class=\"keyword\">inout</span> Array&lt;Int&gt;, loop:Int,step:Int)</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">let</span> length = sortArray.<span class=\"built_in\">count</span>;<span class=\"comment\">//待排序数组长度</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">    * 根据最高位和最低位，确定每次进行计数排序的中间位数</span></div><div class=\"line\"><span class=\"comment\">    **/</span></div><div class=\"line\">    <span class=\"keyword\">var</span> msb = <span class=\"number\">1</span>;<span class=\"comment\">//最高位</span></div><div class=\"line\">    <span class=\"keyword\">var</span> minimum = <span class=\"number\">1</span>;<span class=\"comment\">//最低位</span></div><div class=\"line\">    <span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span> ..&lt; loop * step &#123;</div><div class=\"line\">        msb = msb * <span class=\"number\">10</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span> ..&lt; step &#123;</div><div class=\"line\">        minimum = minimum * <span class=\"number\">10</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\"><span class=\"comment\">    * 计数排序 - 非基于比较的排序算法 。 可参照上一篇文章</span></div><div class=\"line\"><span class=\"comment\">    */</span></div><div class=\"line\">    <span class=\"keyword\">var</span> countArray = <span class=\"type\">Array</span>&lt;<span class=\"type\">Int</span>&gt;();</div><div class=\"line\">    <span class=\"keyword\">var</span> buckets = <span class=\"type\">Array</span>&lt;<span class=\"type\">Int</span>&gt;()</div><div class=\"line\">    <span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span> ... minimum &#123;</div><div class=\"line\">        countArray.append(<span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span> ..&lt; length&#123;</div><div class=\"line\">        buckets.append(<span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//第一个步骤：统计数量</span></div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span> ..&lt; length &#123;<span class=\"comment\">//统计小于位置i的元素个数</span></div><div class=\"line\">        <span class=\"keyword\">let</span> sortValue = sortArray[i] / msb % minimum;</div><div class=\"line\">        countArray[sortValue] = countArray[sortValue] + <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">1</span> ... minimum &#123;<span class=\"comment\">//统计出小于等于位置i的元素个数</span></div><div class=\"line\">        countArray[i] = countArray[i] + countArray[i - <span class=\"number\">1</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//第二个步骤：逆向扫描数组sortArray，将i位置元素放置到retArray中countArray对应值的位置上，同时修正countArray的值</span></div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> (<span class=\"number\">0</span> ..&lt; length).reversed() &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> value = sortArray[i] / msb % minimum;</div><div class=\"line\">        <span class=\"keyword\">let</span> countValue = countArray[value];</div><div class=\"line\">        buckets[countValue - <span class=\"number\">1</span>] = sortArray[i];</div><div class=\"line\">        countArray[value] = countArray[value] - <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//对本次基数排序结果进行排序</span></div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span> ..&lt; length &#123;</div><div class=\"line\">        sortArray[i] = buckets[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"测试用例及结果\"><a href=\"#测试用例及结果\" class=\"headerlink\" title=\"测试用例及结果\"></a>测试用例及结果</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">    <span class=\"keyword\">var</span> intArray =  [<span class=\"number\">14</span>, <span class=\"number\">22</span>, <span class=\"number\">28</span>, <span class=\"number\">39</span>, <span class=\"number\">43</span>, <span class=\"number\">81</span>, <span class=\"number\">93</span>, <span class=\"number\">100</span>, <span class=\"number\">92</span>, <span class=\"number\">96</span>, <span class=\"number\">99</span>, <span class=\"number\">95</span>, <span class=\"number\">10563</span>, <span class=\"number\">55</span>, <span class=\"number\">7</span>, <span class=\"number\">65</span>, <span class=\"number\">73</span>, <span class=\"number\">999</span>, <span class=\"number\">1024</span>, <span class=\"number\">20490</span>, <span class=\"number\">1</span>];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> maxValue = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> maxLength = <span class=\"number\">1</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> step = <span class=\"number\">2</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> loopTimes = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span> ..&lt; intArray.<span class=\"built_in\">count</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> intArray[i] &gt; maxValue&#123;</div><div class=\"line\">            maxValue = intArray[i];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">while</span>(maxValue / <span class=\"number\">10</span> != <span class=\"number\">0</span>)&#123;</div><div class=\"line\">        maxLength = maxLength + <span class=\"number\">1</span>;</div><div class=\"line\">        maxValue = maxValue / <span class=\"number\">10</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> maxLength % step &gt; <span class=\"number\">0</span>&#123;</div><div class=\"line\">        loopTimes = <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    loopTimes = loopTimes + maxLength / step;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"待排序数组<span class=\"subst\">\\(intArray)</span>\"</span>);</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"步长：<span class=\"subst\">\\(step)</span>\"</span>);</div><div class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span> ..&lt; loopTimes&#123;</div><div class=\"line\">        radixSort(sortArray: &amp;intArray, loop: i, step: step);</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"第<span class=\"subst\">\\(i)</span>次基数排序后结果：<span class=\"subst\">\\(intArray)</span>\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//程序输出</span></div><div class=\"line\">待排序数组[<span class=\"number\">14</span>, <span class=\"number\">22</span>, <span class=\"number\">28</span>, <span class=\"number\">39</span>, <span class=\"number\">43</span>, <span class=\"number\">81</span>, <span class=\"number\">93</span>, <span class=\"number\">100</span>, <span class=\"number\">92</span>, <span class=\"number\">96</span>, <span class=\"number\">99</span>, <span class=\"number\">95</span>, <span class=\"number\">10563</span>, <span class=\"number\">55</span>, <span class=\"number\">7</span>, <span class=\"number\">65</span>, <span class=\"number\">73</span>, <span class=\"number\">999</span>, <span class=\"number\">1024</span>, <span class=\"number\">20490</span>, <span class=\"number\">1</span>]</div><div class=\"line\">步长：<span class=\"number\">2</span></div><div class=\"line\">第<span class=\"number\">0</span>次基数排序后结果：[<span class=\"number\">100</span>, <span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">14</span>, <span class=\"number\">22</span>, <span class=\"number\">1024</span>, <span class=\"number\">28</span>, <span class=\"number\">39</span>, <span class=\"number\">43</span>, <span class=\"number\">55</span>, <span class=\"number\">10563</span>, <span class=\"number\">65</span>, <span class=\"number\">73</span>, <span class=\"number\">81</span>, <span class=\"number\">20490</span>, <span class=\"number\">92</span>, <span class=\"number\">93</span>, <span class=\"number\">95</span>, <span class=\"number\">96</span>, <span class=\"number\">99</span>, <span class=\"number\">999</span>]</div><div class=\"line\">第<span class=\"number\">1</span>次基数排序后结果：[<span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">14</span>, <span class=\"number\">22</span>, <span class=\"number\">28</span>, <span class=\"number\">39</span>, <span class=\"number\">43</span>, <span class=\"number\">55</span>, <span class=\"number\">65</span>, <span class=\"number\">73</span>, <span class=\"number\">81</span>, <span class=\"number\">92</span>, <span class=\"number\">93</span>, <span class=\"number\">95</span>, <span class=\"number\">96</span>, <span class=\"number\">99</span>, <span class=\"number\">100</span>, <span class=\"number\">20490</span>, <span class=\"number\">10563</span>, <span class=\"number\">999</span>, <span class=\"number\">1024</span>]</div><div class=\"line\">第<span class=\"number\">2</span>次基数排序后结果：[<span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">14</span>, <span class=\"number\">22</span>, <span class=\"number\">28</span>, <span class=\"number\">39</span>, <span class=\"number\">43</span>, <span class=\"number\">55</span>, <span class=\"number\">65</span>, <span class=\"number\">73</span>, <span class=\"number\">81</span>, <span class=\"number\">92</span>, <span class=\"number\">93</span>, <span class=\"number\">95</span>, <span class=\"number\">96</span>, <span class=\"number\">99</span>, <span class=\"number\">100</span>, <span class=\"number\">999</span>, <span class=\"number\">1024</span>, <span class=\"number\">10563</span>, <span class=\"number\">20490</span>]</div></pre></td></tr></table></figure>"},{"layout":"post","title":"基于蓝牙的室内定位","date":"2017-08-23T10:50:12.000Z","author":"liangtong","catalog":true,"_content":"\n\n\n\n基于Wi-Fi的室内定位，首先采集指纹库，即取多个角度的RSSI值，然后对原始RSSI值进行指纹数据入口。AP扫描硬件设备的RSSI和指纹库数据进行碰撞。来计算出设备的位置。\n指纹库数据对采集设备的依赖比较大。尤其是目前各手机硬件厂商的蓝牙模块不同的情况下，定位精度影响比较大。\n\n利用蓝牙进行室内定位，由目标设备本身采集周围定位用蓝牙信号，从而在目标设备上进行定位运算，来实现室内定位。\n\n\n<!-- more -->\n\n#### 蓝牙定位\n\n使用蓝牙定位需要解决的一个问题是定位设备与目标设备的距离问题。我们可以轻松的通过蓝牙扫描来获取定位设备的RSSI值，那么问题的关键就是如何将RSSI值转换成距离了。\n目前有两种方式来实现：   \n + 基于高度定制的蓝牙设备，由其提供距离参数，比如iBeacon技术的EstimoteBeacon\n   - 距离可以直接获取\n   - 被硬件绑定\n + 基于统一的蓝牙设备的RSSI，自行计算距离\n   - 定位用蓝牙设备可以自行选取\n   - 距离可以自行通过校正函数进行获取：d = 10<sup>((abs(RSSI) - A) / (10 * n))</sup>\n      - d - 计算所得距离\n      - RSSI - 接收信号强度（负值）\n      - A - 发射端和接收端相隔1米时的信号强度\n      - n - 环境衰减因子\n\n> 通过RSSI进行距离计算的时候，需要考虑蓝牙设备的校正因子measuredPower\t\t       \n\n当获取到距离后，可以通过极大似然估算法进行目标设备室内定位计算。可以参照[基于二维空间的极大似然估计算法](https://l900416.github.io/2017/08/23/algorithm_location_maximum_likelihood/) 。 \n\n\n#### 定位数据处理\n\n受外界干扰，当扫描到的定位用蓝牙设备RSSI太小(或者距离过大)的时候，我们就可以考虑忽略掉。取有效的参数进行计算。结合设备本身对传感器信息，对定位数据进行展示。\n\n![](/post/bluetooth/location_maximum_likelihood.jpg) \n\n\n定位数据摘要信息如下：\n\n![](/post/bluetooth/location_maximum_likelihood_log.jpg) \n\n\n\n\n#### 参照文档\n\n​\thttps://wenku.baidu.com/view/3dba1baef524ccbff12184af.html?re=view\n​\thttp://hxqhit.blog.163.com/blog/static/15357922200948112142918/\n","source":"_posts/bluetooth_location_maximum_likelihood.md","raw":"---\nlayout:     post\ntitle:      基于蓝牙的室内定位\ndate:       2017-08-23 18:50:12\nauthor:     liangtong\ncatalog: true\ncategories: 蓝牙\ntags: 位置\n\n---\n\n\n\n\n基于Wi-Fi的室内定位，首先采集指纹库，即取多个角度的RSSI值，然后对原始RSSI值进行指纹数据入口。AP扫描硬件设备的RSSI和指纹库数据进行碰撞。来计算出设备的位置。\n指纹库数据对采集设备的依赖比较大。尤其是目前各手机硬件厂商的蓝牙模块不同的情况下，定位精度影响比较大。\n\n利用蓝牙进行室内定位，由目标设备本身采集周围定位用蓝牙信号，从而在目标设备上进行定位运算，来实现室内定位。\n\n\n<!-- more -->\n\n#### 蓝牙定位\n\n使用蓝牙定位需要解决的一个问题是定位设备与目标设备的距离问题。我们可以轻松的通过蓝牙扫描来获取定位设备的RSSI值，那么问题的关键就是如何将RSSI值转换成距离了。\n目前有两种方式来实现：   \n + 基于高度定制的蓝牙设备，由其提供距离参数，比如iBeacon技术的EstimoteBeacon\n   - 距离可以直接获取\n   - 被硬件绑定\n + 基于统一的蓝牙设备的RSSI，自行计算距离\n   - 定位用蓝牙设备可以自行选取\n   - 距离可以自行通过校正函数进行获取：d = 10<sup>((abs(RSSI) - A) / (10 * n))</sup>\n      - d - 计算所得距离\n      - RSSI - 接收信号强度（负值）\n      - A - 发射端和接收端相隔1米时的信号强度\n      - n - 环境衰减因子\n\n> 通过RSSI进行距离计算的时候，需要考虑蓝牙设备的校正因子measuredPower\t\t       \n\n当获取到距离后，可以通过极大似然估算法进行目标设备室内定位计算。可以参照[基于二维空间的极大似然估计算法](https://l900416.github.io/2017/08/23/algorithm_location_maximum_likelihood/) 。 \n\n\n#### 定位数据处理\n\n受外界干扰，当扫描到的定位用蓝牙设备RSSI太小(或者距离过大)的时候，我们就可以考虑忽略掉。取有效的参数进行计算。结合设备本身对传感器信息，对定位数据进行展示。\n\n![](/post/bluetooth/location_maximum_likelihood.jpg) \n\n\n定位数据摘要信息如下：\n\n![](/post/bluetooth/location_maximum_likelihood_log.jpg) \n\n\n\n\n#### 参照文档\n\n​\thttps://wenku.baidu.com/view/3dba1baef524ccbff12184af.html?re=view\n​\thttp://hxqhit.blog.163.com/blog/static/15357922200948112142918/\n","slug":"bluetooth_location_maximum_likelihood","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4s7000toko801kkjimq","content":"<p>基于Wi-Fi的室内定位，首先采集指纹库，即取多个角度的RSSI值，然后对原始RSSI值进行指纹数据入口。AP扫描硬件设备的RSSI和指纹库数据进行碰撞。来计算出设备的位置。<br>指纹库数据对采集设备的依赖比较大。尤其是目前各手机硬件厂商的蓝牙模块不同的情况下，定位精度影响比较大。</p>\n<p>利用蓝牙进行室内定位，由目标设备本身采集周围定位用蓝牙信号，从而在目标设备上进行定位运算，来实现室内定位。</p>\n<a id=\"more\"></a>\n<h4 id=\"蓝牙定位\"><a href=\"#蓝牙定位\" class=\"headerlink\" title=\"蓝牙定位\"></a>蓝牙定位</h4><p>使用蓝牙定位需要解决的一个问题是定位设备与目标设备的距离问题。我们可以轻松的通过蓝牙扫描来获取定位设备的RSSI值，那么问题的关键就是如何将RSSI值转换成距离了。<br>目前有两种方式来实现：   </p>\n<ul>\n<li>基于高度定制的蓝牙设备，由其提供距离参数，比如iBeacon技术的EstimoteBeacon<ul>\n<li>距离可以直接获取</li>\n<li>被硬件绑定</li>\n</ul>\n</li>\n<li>基于统一的蓝牙设备的RSSI，自行计算距离<ul>\n<li>定位用蓝牙设备可以自行选取</li>\n<li>距离可以自行通过校正函数进行获取：d = 10<sup>((abs(RSSI) - A) / (10 * n))</sup><ul>\n<li>d - 计算所得距离</li>\n<li>RSSI - 接收信号强度（负值）</li>\n<li>A - 发射端和接收端相隔1米时的信号强度</li>\n<li>n - 环境衰减因子</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>通过RSSI进行距离计算的时候，需要考虑蓝牙设备的校正因子measuredPower               </p>\n</blockquote>\n<p>当获取到距离后，可以通过极大似然估算法进行目标设备室内定位计算。可以参照<a href=\"https://l900416.github.io/2017/08/23/algorithm_location_maximum_likelihood/\">基于二维空间的极大似然估计算法</a> 。 </p>\n<h4 id=\"定位数据处理\"><a href=\"#定位数据处理\" class=\"headerlink\" title=\"定位数据处理\"></a>定位数据处理</h4><p>受外界干扰，当扫描到的定位用蓝牙设备RSSI太小(或者距离过大)的时候，我们就可以考虑忽略掉。取有效的参数进行计算。结合设备本身对传感器信息，对定位数据进行展示。</p>\n<p><img src=\"/post/bluetooth/location_maximum_likelihood.jpg\" alt=\"\"> </p>\n<p>定位数据摘要信息如下：</p>\n<p><img src=\"/post/bluetooth/location_maximum_likelihood_log.jpg\" alt=\"\"> </p>\n<h4 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h4><p>​    <a href=\"https://wenku.baidu.com/view/3dba1baef524ccbff12184af.html?re=view\" target=\"_blank\" rel=\"external\">https://wenku.baidu.com/view/3dba1baef524ccbff12184af.html?re=view</a><br>​    <a href=\"http://hxqhit.blog.163.com/blog/static/15357922200948112142918/\" target=\"_blank\" rel=\"external\">http://hxqhit.blog.163.com/blog/static/15357922200948112142918/</a></p>\n","site":{"data":{}},"excerpt":"<p>基于Wi-Fi的室内定位，首先采集指纹库，即取多个角度的RSSI值，然后对原始RSSI值进行指纹数据入口。AP扫描硬件设备的RSSI和指纹库数据进行碰撞。来计算出设备的位置。<br>指纹库数据对采集设备的依赖比较大。尤其是目前各手机硬件厂商的蓝牙模块不同的情况下，定位精度影响比较大。</p>\n<p>利用蓝牙进行室内定位，由目标设备本身采集周围定位用蓝牙信号，从而在目标设备上进行定位运算，来实现室内定位。</p>","more":"<h4 id=\"蓝牙定位\"><a href=\"#蓝牙定位\" class=\"headerlink\" title=\"蓝牙定位\"></a>蓝牙定位</h4><p>使用蓝牙定位需要解决的一个问题是定位设备与目标设备的距离问题。我们可以轻松的通过蓝牙扫描来获取定位设备的RSSI值，那么问题的关键就是如何将RSSI值转换成距离了。<br>目前有两种方式来实现：   </p>\n<ul>\n<li>基于高度定制的蓝牙设备，由其提供距离参数，比如iBeacon技术的EstimoteBeacon<ul>\n<li>距离可以直接获取</li>\n<li>被硬件绑定</li>\n</ul>\n</li>\n<li>基于统一的蓝牙设备的RSSI，自行计算距离<ul>\n<li>定位用蓝牙设备可以自行选取</li>\n<li>距离可以自行通过校正函数进行获取：d = 10<sup>((abs(RSSI) - A) / (10 * n))</sup><ul>\n<li>d - 计算所得距离</li>\n<li>RSSI - 接收信号强度（负值）</li>\n<li>A - 发射端和接收端相隔1米时的信号强度</li>\n<li>n - 环境衰减因子</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>通过RSSI进行距离计算的时候，需要考虑蓝牙设备的校正因子measuredPower               </p>\n</blockquote>\n<p>当获取到距离后，可以通过极大似然估算法进行目标设备室内定位计算。可以参照<a href=\"https://l900416.github.io/2017/08/23/algorithm_location_maximum_likelihood/\">基于二维空间的极大似然估计算法</a> 。 </p>\n<h4 id=\"定位数据处理\"><a href=\"#定位数据处理\" class=\"headerlink\" title=\"定位数据处理\"></a>定位数据处理</h4><p>受外界干扰，当扫描到的定位用蓝牙设备RSSI太小(或者距离过大)的时候，我们就可以考虑忽略掉。取有效的参数进行计算。结合设备本身对传感器信息，对定位数据进行展示。</p>\n<p><img src=\"/post/bluetooth/location_maximum_likelihood.jpg\" alt=\"\"> </p>\n<p>定位数据摘要信息如下：</p>\n<p><img src=\"/post/bluetooth/location_maximum_likelihood_log.jpg\" alt=\"\"> </p>\n<h4 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h4><p>​    <a href=\"https://wenku.baidu.com/view/3dba1baef524ccbff12184af.html?re=view\" target=\"_blank\" rel=\"external\">https://wenku.baidu.com/view/3dba1baef524ccbff12184af.html?re=view</a><br>​    <a href=\"http://hxqhit.blog.163.com/blog/static/15357922200948112142918/\" target=\"_blank\" rel=\"external\">http://hxqhit.blog.163.com/blog/static/15357922200948112142918/</a></p>"},{"layout":"post","title":"iOS蓝牙开发 - Peripheral模式","date":"2017-08-08T10:50:12.000Z","author":"liangtong","catalog":true,"_content":"\n\n\n\n\n\n### Peripheral模式   \n周边模式(Peripheral Model)，可以简单理解为设备App作为周边，供其他蓝牙设备连接。区别于中心模式。\n蓝牙设备不能同时作为周边和中心设备，在某次连接中，只能担当一个角色。\n\n\n<!-- more -->\n\n### 功能集成   \n  作为蓝牙使用者，程序需要请求蓝牙设备授权，在info.plist配置文件中，添加代码:    \n``` Objective-C \n</array>\n<key>NSBluetoothPeripheralUsageDescription</key>\n<string>蓝牙设备请求描述，比如：程序需要使用蓝牙进行设备发现</string>\n```\n  项目Targets对应的 *Build Phases* 中，引入 *CoreBluetooth.framework* ，使用的代码中引入头文件\n``` Objective-C \n#import <CoreBluetooth/CoreBluetooth.h>\n```\n\n#### 请求蓝牙服务\n  使用CBPeripheralManagerDelegate来进行蓝牙服务管理(授权请求)，监听蓝牙状态变化。    \n```ObjectiveC\n@property (nonatomic, strong) CBPeripheralManagerDelegate *perManager;\n\n//对象创建成功后，会请求使用蓝牙，CBPeripheralManagerDelegate协议会回调蓝牙的各个状态\n_perManager = [[CBPeripheralManager alloc] initWithDelegate:self queue:nil];\n\n#pragma mark - CBPeripheralManagerDelegate\n- (void)peripheralManagerDidUpdateState:(CBPeripheralManager *)peripheral{\n    if (peripheral.state == CBManagerStatePoweredOn) {\n        \n    }\n}\n```\n在蓝牙开启的情况下，可以创建服务、创建特质值等。\n\n\n\n#### 带特质值的服务创建     \n  在设备蓝牙开启的情况下，可以建立服务 *CBMutableService* 和特征值 *CBCharacteristic* 并通过 * CBPeripheralManagerDelegate* 的 *addService:* 方法将带有特征值的服务注册给蓝牙设备。注册成功后，通过 * CBPeripheralManagerDelegate* 协议将服务返回。    \n```Objective-C\n    //创建服务，其中服务关键字UUID换成自己的\n    CBMutableService * service = [[CBMutableService alloc] initWithType:\n                                  [CBUUID UUIDWithString:@\"service UUID\"] primary:YES];\n    //创建特征值，其中特征值的UUID换成自己的，特征值可以携带value信息（nsdata）\n    CBCharacteristic * characteristic = [[CBMutableCharacteristic alloc] initWithType:[CBUUID UUIDWithString:@\"characteristic UUID\"]\n                                                                           properties:(CBCharacteristicPropertyRead |\n                                                                                        CBCharacteristicPropertyWrite |\n                                                                                        CBCharacteristicPropertyNotify) \n                                                                                value:[@\"characteristic value\"\n                                                                    dataUsingEncoding:NSUTF8StringEncoding]  \n                                                                          permissions:CBAttributePermissionsReadable];\n\n    //将特征值加入到服务中\n    service.characteristics = @[characteristic];\n\n    //给设备添加服务，注册服务\n    [_perManager addService:service];\n\n#pragma mark - CBPeripheralManagerDelegate\n//服务注册成功后，会通过以下回调将信息返回\n- (void)peripheralManager:(CBPeripheralManager *)peripheral \n  \t\t\tdidAddService:(CBService *)service\n              \t\terror:(NSError *)error{\n    //对于注册成功的服务，蓝牙设备可以直接进行广播\n    //开启广播，此处我们广播刚才注册的服务，UUID是：service uuid\n    [_perManager startAdvertising:\n     @{CBAdvertisementDataServiceUUIDsKey:[CBUUID UUIDWithString:@\"service UUID\"]}];\t\n}\n```\n\n注：一个服务可以携带多个特征值，一个蓝牙周边设备可以注册多个服务。\n\n#### 开启广播   \n  通过CBPeripheralManager的 *startAdvertising:* 方法开启广播，成功后通过CBPeripheralManagerDelegate协议回调。    \n```Objective-C\n    //开启广播\n    [_perManager startAdvertising:@{CBAdvertisementDataServiceUUIDsKey:[CBUUID UUIDWithString:@\"service UUID\"]}];\n\n    //开启广播的回调\n- (void)peripheralManagerDidStartAdvertising:(CBPeripheralManager *)peripheral \n  \t\t\t\t\t\t\t\t\t\terror:(NSError *)error {\n}\n```\n\n#### 数据读写   \n \n当外设蓝牙设备收到ATT特征值请求时，协议 * CBPeripheralManagerDelegate* 的方法会被触发。参照协议描述，在处理数据读／写操作的协议回调方法中，必须执行方法 *respondToRequest:withResult:*\n\n```Objective-C\n// 读数据请求\n- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveReadRequest:(CBATTRequest *)request {\n    //请求的响应\n    NSData *data = request.characteristic.value; //蓝牙中心设备想读取的数据\n    [request setValue:data];// 读取的值\n    [_perManager respondToRequest:request withResult:CBATTErrorSuccess];\n}\n\n//写数据请求\n- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveWriteRequests:(NSArray<CBATTRequest *> *)requests {\n    //请求的响应\n    //需要转换成CBMutableCharacteristic对象才能进行写值\n    for (CBATTRequest* request in requests) {\n        CBMutableCharacteristic *c =(CBMutableCharacteristic *)request.characteristic;\n        c.value = request.value;\n        [_perManager respondToRequest:[requests firstObject] withResult:CBATTErrorSuccess];\n    }\n}\n```\n​\n#### 特征值订阅\n当蓝牙中心设备在进行蓝牙设备服务的特征发现时，若将特征值配置包含被通知 *CBCharacteristicPropertyNotify* ， 则协议中的以下回调会被调用。\n\n```Objective-C\n//订阅characteristics\n-(void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didSubscribeToCharacteristic:(CBCharacteristic *)characteristic{\n    NSLog(@\"订阅了 %@的数据\",characteristic.UUID);\n    \n    //每秒执行一次给主设备发送一个当前时间的秒数\n    _timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(sendData:) userInfo:characteristic  repeats:YES];\n}\n//如果不设置订阅的设备，则代表全部。\n-(void)sendData:(NSTimer *)t {\n    CBMutableCharacteristic *characteristic = t.userInfo;\n    [_perManager updateValue:[@\"Subscribe To Characteristic Value Send \" dataUsingEncoding:NSUTF8StringEncoding] forCharacteristic:characteristic onSubscribedCentrals:nil];\n}\n\n//取消订阅characteristics\n-(void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didUnsubscribeFromCharacteristic:(CBCharacteristic *)characteristic{\n    NSLog(@\"取消订阅 %@的数据\",characteristic.UUID);\n    \n    //取消回应\n    [_timer invalidate];\n}\n```\n\t\n","source":"_posts/bluetooth_peripheral.md","raw":"---\nlayout:     post\ntitle:      iOS蓝牙开发 - Peripheral模式\ndate:       2017-08-08 18:50:12\nauthor:     liangtong\ncatalog: true\ncategories: 蓝牙\ntags: Bluetooth\n\n---\n\n\n\n\n\n\n### Peripheral模式   \n周边模式(Peripheral Model)，可以简单理解为设备App作为周边，供其他蓝牙设备连接。区别于中心模式。\n蓝牙设备不能同时作为周边和中心设备，在某次连接中，只能担当一个角色。\n\n\n<!-- more -->\n\n### 功能集成   \n  作为蓝牙使用者，程序需要请求蓝牙设备授权，在info.plist配置文件中，添加代码:    \n``` Objective-C \n</array>\n<key>NSBluetoothPeripheralUsageDescription</key>\n<string>蓝牙设备请求描述，比如：程序需要使用蓝牙进行设备发现</string>\n```\n  项目Targets对应的 *Build Phases* 中，引入 *CoreBluetooth.framework* ，使用的代码中引入头文件\n``` Objective-C \n#import <CoreBluetooth/CoreBluetooth.h>\n```\n\n#### 请求蓝牙服务\n  使用CBPeripheralManagerDelegate来进行蓝牙服务管理(授权请求)，监听蓝牙状态变化。    \n```ObjectiveC\n@property (nonatomic, strong) CBPeripheralManagerDelegate *perManager;\n\n//对象创建成功后，会请求使用蓝牙，CBPeripheralManagerDelegate协议会回调蓝牙的各个状态\n_perManager = [[CBPeripheralManager alloc] initWithDelegate:self queue:nil];\n\n#pragma mark - CBPeripheralManagerDelegate\n- (void)peripheralManagerDidUpdateState:(CBPeripheralManager *)peripheral{\n    if (peripheral.state == CBManagerStatePoweredOn) {\n        \n    }\n}\n```\n在蓝牙开启的情况下，可以创建服务、创建特质值等。\n\n\n\n#### 带特质值的服务创建     \n  在设备蓝牙开启的情况下，可以建立服务 *CBMutableService* 和特征值 *CBCharacteristic* 并通过 * CBPeripheralManagerDelegate* 的 *addService:* 方法将带有特征值的服务注册给蓝牙设备。注册成功后，通过 * CBPeripheralManagerDelegate* 协议将服务返回。    \n```Objective-C\n    //创建服务，其中服务关键字UUID换成自己的\n    CBMutableService * service = [[CBMutableService alloc] initWithType:\n                                  [CBUUID UUIDWithString:@\"service UUID\"] primary:YES];\n    //创建特征值，其中特征值的UUID换成自己的，特征值可以携带value信息（nsdata）\n    CBCharacteristic * characteristic = [[CBMutableCharacteristic alloc] initWithType:[CBUUID UUIDWithString:@\"characteristic UUID\"]\n                                                                           properties:(CBCharacteristicPropertyRead |\n                                                                                        CBCharacteristicPropertyWrite |\n                                                                                        CBCharacteristicPropertyNotify) \n                                                                                value:[@\"characteristic value\"\n                                                                    dataUsingEncoding:NSUTF8StringEncoding]  \n                                                                          permissions:CBAttributePermissionsReadable];\n\n    //将特征值加入到服务中\n    service.characteristics = @[characteristic];\n\n    //给设备添加服务，注册服务\n    [_perManager addService:service];\n\n#pragma mark - CBPeripheralManagerDelegate\n//服务注册成功后，会通过以下回调将信息返回\n- (void)peripheralManager:(CBPeripheralManager *)peripheral \n  \t\t\tdidAddService:(CBService *)service\n              \t\terror:(NSError *)error{\n    //对于注册成功的服务，蓝牙设备可以直接进行广播\n    //开启广播，此处我们广播刚才注册的服务，UUID是：service uuid\n    [_perManager startAdvertising:\n     @{CBAdvertisementDataServiceUUIDsKey:[CBUUID UUIDWithString:@\"service UUID\"]}];\t\n}\n```\n\n注：一个服务可以携带多个特征值，一个蓝牙周边设备可以注册多个服务。\n\n#### 开启广播   \n  通过CBPeripheralManager的 *startAdvertising:* 方法开启广播，成功后通过CBPeripheralManagerDelegate协议回调。    \n```Objective-C\n    //开启广播\n    [_perManager startAdvertising:@{CBAdvertisementDataServiceUUIDsKey:[CBUUID UUIDWithString:@\"service UUID\"]}];\n\n    //开启广播的回调\n- (void)peripheralManagerDidStartAdvertising:(CBPeripheralManager *)peripheral \n  \t\t\t\t\t\t\t\t\t\terror:(NSError *)error {\n}\n```\n\n#### 数据读写   \n \n当外设蓝牙设备收到ATT特征值请求时，协议 * CBPeripheralManagerDelegate* 的方法会被触发。参照协议描述，在处理数据读／写操作的协议回调方法中，必须执行方法 *respondToRequest:withResult:*\n\n```Objective-C\n// 读数据请求\n- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveReadRequest:(CBATTRequest *)request {\n    //请求的响应\n    NSData *data = request.characteristic.value; //蓝牙中心设备想读取的数据\n    [request setValue:data];// 读取的值\n    [_perManager respondToRequest:request withResult:CBATTErrorSuccess];\n}\n\n//写数据请求\n- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveWriteRequests:(NSArray<CBATTRequest *> *)requests {\n    //请求的响应\n    //需要转换成CBMutableCharacteristic对象才能进行写值\n    for (CBATTRequest* request in requests) {\n        CBMutableCharacteristic *c =(CBMutableCharacteristic *)request.characteristic;\n        c.value = request.value;\n        [_perManager respondToRequest:[requests firstObject] withResult:CBATTErrorSuccess];\n    }\n}\n```\n​\n#### 特征值订阅\n当蓝牙中心设备在进行蓝牙设备服务的特征发现时，若将特征值配置包含被通知 *CBCharacteristicPropertyNotify* ， 则协议中的以下回调会被调用。\n\n```Objective-C\n//订阅characteristics\n-(void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didSubscribeToCharacteristic:(CBCharacteristic *)characteristic{\n    NSLog(@\"订阅了 %@的数据\",characteristic.UUID);\n    \n    //每秒执行一次给主设备发送一个当前时间的秒数\n    _timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(sendData:) userInfo:characteristic  repeats:YES];\n}\n//如果不设置订阅的设备，则代表全部。\n-(void)sendData:(NSTimer *)t {\n    CBMutableCharacteristic *characteristic = t.userInfo;\n    [_perManager updateValue:[@\"Subscribe To Characteristic Value Send \" dataUsingEncoding:NSUTF8StringEncoding] forCharacteristic:characteristic onSubscribedCentrals:nil];\n}\n\n//取消订阅characteristics\n-(void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didUnsubscribeFromCharacteristic:(CBCharacteristic *)characteristic{\n    NSLog(@\"取消订阅 %@的数据\",characteristic.UUID);\n    \n    //取消回应\n    [_timer invalidate];\n}\n```\n\t\n","slug":"bluetooth_peripheral","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4s8000woko8y3d3ly9x","content":"<h3 id=\"Peripheral模式\"><a href=\"#Peripheral模式\" class=\"headerlink\" title=\"Peripheral模式\"></a>Peripheral模式</h3><p>周边模式(Peripheral Model)，可以简单理解为设备App作为周边，供其他蓝牙设备连接。区别于中心模式。<br>蓝牙设备不能同时作为周边和中心设备，在某次连接中，只能担当一个角色。</p>\n<a id=\"more\"></a>\n<h3 id=\"功能集成\"><a href=\"#功能集成\" class=\"headerlink\" title=\"功能集成\"></a>功能集成</h3><p>  作为蓝牙使用者，程序需要请求蓝牙设备授权，在info.plist配置文件中，添加代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;/array&gt;</div><div class=\"line\">&lt;key&gt;NSBluetoothPeripheralUsageDescription&lt;/key&gt;</div><div class=\"line\">&lt;string&gt;蓝牙设备请求描述，比如：程序需要使用蓝牙进行设备发现&lt;/string&gt;</div></pre></td></tr></table></figure></p>\n<p>  项目Targets对应的 <em>Build Phases</em> 中，引入 <em>CoreBluetooth.framework</em> ，使用的代码中引入头文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &lt;CoreBluetooth/CoreBluetooth.h&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"请求蓝牙服务\"><a href=\"#请求蓝牙服务\" class=\"headerlink\" title=\"请求蓝牙服务\"></a>请求蓝牙服务</h4><p>  使用CBPeripheralManagerDelegate来进行蓝牙服务管理(授权请求)，监听蓝牙状态变化。<br><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) CBPeripheralManagerDelegate *perManager;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//对象创建成功后，会请求使用蓝牙，CBPeripheralManagerDelegate协议会回调蓝牙的各个状态</span></div><div class=\"line\">_perManager = [[CBPeripheralManager alloc] initWithDelegate:<span class=\"keyword\">self</span> queue:<span class=\"literal\">nil</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#pragma mark - CBPeripheralManagerDelegate</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)peripheralManagerDidUpdateState:(CBPeripheralManager *)peripheral&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (peripheral.state == CBManagerStatePoweredOn) &#123;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在蓝牙开启的情况下，可以创建服务、创建特质值等。</p>\n<h4 id=\"带特质值的服务创建\"><a href=\"#带特质值的服务创建\" class=\"headerlink\" title=\"带特质值的服务创建\"></a>带特质值的服务创建</h4><p>  在设备蓝牙开启的情况下，可以建立服务 <em>CBMutableService</em> 和特征值 <em>CBCharacteristic</em> 并通过 <em> CBPeripheralManagerDelegate</em> 的 <em>addService:</em> 方法将带有特征值的服务注册给蓝牙设备。注册成功后，通过 <em> CBPeripheralManagerDelegate</em> 协议将服务返回。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">    //创建服务，其中服务关键字UUID换成自己的</div><div class=\"line\">    CBMutableService * service = [[CBMutableService alloc] initWithType:</div><div class=\"line\">                                  [CBUUID UUIDWithString:@&quot;service UUID&quot;] primary:YES];</div><div class=\"line\">    //创建特征值，其中特征值的UUID换成自己的，特征值可以携带value信息（nsdata）</div><div class=\"line\">    CBCharacteristic * characteristic = [[CBMutableCharacteristic alloc] initWithType:[CBUUID UUIDWithString:@&quot;characteristic UUID&quot;]</div><div class=\"line\">                                                                           properties:(CBCharacteristicPropertyRead |</div><div class=\"line\">                                                                                        CBCharacteristicPropertyWrite |</div><div class=\"line\">                                                                                        CBCharacteristicPropertyNotify) </div><div class=\"line\">                                                                                value:[@&quot;characteristic value&quot;</div><div class=\"line\">                                                                    dataUsingEncoding:NSUTF8StringEncoding]  </div><div class=\"line\">                                                                          permissions:CBAttributePermissionsReadable];</div><div class=\"line\"></div><div class=\"line\">    //将特征值加入到服务中</div><div class=\"line\">    service.characteristics = @[characteristic];</div><div class=\"line\"></div><div class=\"line\">    //给设备添加服务，注册服务</div><div class=\"line\">    [_perManager addService:service];</div><div class=\"line\"></div><div class=\"line\">#pragma mark - CBPeripheralManagerDelegate</div><div class=\"line\">//服务注册成功后，会通过以下回调将信息返回</div><div class=\"line\">- (void)peripheralManager:(CBPeripheralManager *)peripheral </div><div class=\"line\">  \t\t\tdidAddService:(CBService *)service</div><div class=\"line\">              \t\terror:(NSError *)error&#123;</div><div class=\"line\">    //对于注册成功的服务，蓝牙设备可以直接进行广播</div><div class=\"line\">    //开启广播，此处我们广播刚才注册的服务，UUID是：service uuid</div><div class=\"line\">    [_perManager startAdvertising:</div><div class=\"line\">     @&#123;CBAdvertisementDataServiceUUIDsKey:[CBUUID UUIDWithString:@&quot;service UUID&quot;]&#125;];\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注：一个服务可以携带多个特征值，一个蓝牙周边设备可以注册多个服务。</p>\n<h4 id=\"开启广播\"><a href=\"#开启广播\" class=\"headerlink\" title=\"开启广播\"></a>开启广播</h4><p>  通过CBPeripheralManager的 <em>startAdvertising:</em> 方法开启广播，成功后通过CBPeripheralManagerDelegate协议回调。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">    //开启广播</div><div class=\"line\">    [_perManager startAdvertising:@&#123;CBAdvertisementDataServiceUUIDsKey:[CBUUID UUIDWithString:@&quot;service UUID&quot;]&#125;];</div><div class=\"line\"></div><div class=\"line\">    //开启广播的回调</div><div class=\"line\">- (void)peripheralManagerDidStartAdvertising:(CBPeripheralManager *)peripheral </div><div class=\"line\">  \t\t\t\t\t\t\t\t\t\terror:(NSError *)error &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"数据读写\"><a href=\"#数据读写\" class=\"headerlink\" title=\"数据读写\"></a>数据读写</h4><p>当外设蓝牙设备收到ATT特征值请求时，协议 <em> CBPeripheralManagerDelegate</em> 的方法会被触发。参照协议描述，在处理数据读／写操作的协议回调方法中，必须执行方法 <em>respondToRequest:withResult:</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 读数据请求</div><div class=\"line\">- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveReadRequest:(CBATTRequest *)request &#123;</div><div class=\"line\">    //请求的响应</div><div class=\"line\">    NSData *data = request.characteristic.value; //蓝牙中心设备想读取的数据</div><div class=\"line\">    [request setValue:data];// 读取的值</div><div class=\"line\">    [_perManager respondToRequest:request withResult:CBATTErrorSuccess];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//写数据请求</div><div class=\"line\">- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveWriteRequests:(NSArray&lt;CBATTRequest *&gt; *)requests &#123;</div><div class=\"line\">    //请求的响应</div><div class=\"line\">    //需要转换成CBMutableCharacteristic对象才能进行写值</div><div class=\"line\">    for (CBATTRequest* request in requests) &#123;</div><div class=\"line\">        CBMutableCharacteristic *c =(CBMutableCharacteristic *)request.characteristic;</div><div class=\"line\">        c.value = request.value;</div><div class=\"line\">        [_perManager respondToRequest:[requests firstObject] withResult:CBATTErrorSuccess];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>​</p>\n<h4 id=\"特征值订阅\"><a href=\"#特征值订阅\" class=\"headerlink\" title=\"特征值订阅\"></a>特征值订阅</h4><p>当蓝牙中心设备在进行蓝牙设备服务的特征发现时，若将特征值配置包含被通知 <em>CBCharacteristicPropertyNotify</em> ， 则协议中的以下回调会被调用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">//订阅characteristics</div><div class=\"line\">-(void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didSubscribeToCharacteristic:(CBCharacteristic *)characteristic&#123;</div><div class=\"line\">    NSLog(@&quot;订阅了 %@的数据&quot;,characteristic.UUID);</div><div class=\"line\">    </div><div class=\"line\">    //每秒执行一次给主设备发送一个当前时间的秒数</div><div class=\"line\">    _timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(sendData:) userInfo:characteristic  repeats:YES];</div><div class=\"line\">&#125;</div><div class=\"line\">//如果不设置订阅的设备，则代表全部。</div><div class=\"line\">-(void)sendData:(NSTimer *)t &#123;</div><div class=\"line\">    CBMutableCharacteristic *characteristic = t.userInfo;</div><div class=\"line\">    [_perManager updateValue:[@&quot;Subscribe To Characteristic Value Send &quot; dataUsingEncoding:NSUTF8StringEncoding] forCharacteristic:characteristic onSubscribedCentrals:nil];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//取消订阅characteristics</div><div class=\"line\">-(void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didUnsubscribeFromCharacteristic:(CBCharacteristic *)characteristic&#123;</div><div class=\"line\">    NSLog(@&quot;取消订阅 %@的数据&quot;,characteristic.UUID);</div><div class=\"line\">    </div><div class=\"line\">    //取消回应</div><div class=\"line\">    [_timer invalidate];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"Peripheral模式\"><a href=\"#Peripheral模式\" class=\"headerlink\" title=\"Peripheral模式\"></a>Peripheral模式</h3><p>周边模式(Peripheral Model)，可以简单理解为设备App作为周边，供其他蓝牙设备连接。区别于中心模式。<br>蓝牙设备不能同时作为周边和中心设备，在某次连接中，只能担当一个角色。</p>","more":"<h3 id=\"功能集成\"><a href=\"#功能集成\" class=\"headerlink\" title=\"功能集成\"></a>功能集成</h3><p>  作为蓝牙使用者，程序需要请求蓝牙设备授权，在info.plist配置文件中，添加代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;/array&gt;</div><div class=\"line\">&lt;key&gt;NSBluetoothPeripheralUsageDescription&lt;/key&gt;</div><div class=\"line\">&lt;string&gt;蓝牙设备请求描述，比如：程序需要使用蓝牙进行设备发现&lt;/string&gt;</div></pre></td></tr></table></figure></p>\n<p>  项目Targets对应的 <em>Build Phases</em> 中，引入 <em>CoreBluetooth.framework</em> ，使用的代码中引入头文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">#import &lt;CoreBluetooth/CoreBluetooth.h&gt;</div></pre></td></tr></table></figure></p>\n<h4 id=\"请求蓝牙服务\"><a href=\"#请求蓝牙服务\" class=\"headerlink\" title=\"请求蓝牙服务\"></a>请求蓝牙服务</h4><p>  使用CBPeripheralManagerDelegate来进行蓝牙服务管理(授权请求)，监听蓝牙状态变化。<br><figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) CBPeripheralManagerDelegate *perManager;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//对象创建成功后，会请求使用蓝牙，CBPeripheralManagerDelegate协议会回调蓝牙的各个状态</span></div><div class=\"line\">_perManager = [[CBPeripheralManager alloc] initWithDelegate:<span class=\"keyword\">self</span> queue:<span class=\"literal\">nil</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#pragma mark - CBPeripheralManagerDelegate</span></div><div class=\"line\">- (<span class=\"keyword\">void</span>)peripheralManagerDidUpdateState:(CBPeripheralManager *)peripheral&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (peripheral.state == CBManagerStatePoweredOn) &#123;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在蓝牙开启的情况下，可以创建服务、创建特质值等。</p>\n<h4 id=\"带特质值的服务创建\"><a href=\"#带特质值的服务创建\" class=\"headerlink\" title=\"带特质值的服务创建\"></a>带特质值的服务创建</h4><p>  在设备蓝牙开启的情况下，可以建立服务 <em>CBMutableService</em> 和特征值 <em>CBCharacteristic</em> 并通过 <em> CBPeripheralManagerDelegate</em> 的 <em>addService:</em> 方法将带有特征值的服务注册给蓝牙设备。注册成功后，通过 <em> CBPeripheralManagerDelegate</em> 协议将服务返回。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">    //创建服务，其中服务关键字UUID换成自己的</div><div class=\"line\">    CBMutableService * service = [[CBMutableService alloc] initWithType:</div><div class=\"line\">                                  [CBUUID UUIDWithString:@&quot;service UUID&quot;] primary:YES];</div><div class=\"line\">    //创建特征值，其中特征值的UUID换成自己的，特征值可以携带value信息（nsdata）</div><div class=\"line\">    CBCharacteristic * characteristic = [[CBMutableCharacteristic alloc] initWithType:[CBUUID UUIDWithString:@&quot;characteristic UUID&quot;]</div><div class=\"line\">                                                                           properties:(CBCharacteristicPropertyRead |</div><div class=\"line\">                                                                                        CBCharacteristicPropertyWrite |</div><div class=\"line\">                                                                                        CBCharacteristicPropertyNotify) </div><div class=\"line\">                                                                                value:[@&quot;characteristic value&quot;</div><div class=\"line\">                                                                    dataUsingEncoding:NSUTF8StringEncoding]  </div><div class=\"line\">                                                                          permissions:CBAttributePermissionsReadable];</div><div class=\"line\"></div><div class=\"line\">    //将特征值加入到服务中</div><div class=\"line\">    service.characteristics = @[characteristic];</div><div class=\"line\"></div><div class=\"line\">    //给设备添加服务，注册服务</div><div class=\"line\">    [_perManager addService:service];</div><div class=\"line\"></div><div class=\"line\">#pragma mark - CBPeripheralManagerDelegate</div><div class=\"line\">//服务注册成功后，会通过以下回调将信息返回</div><div class=\"line\">- (void)peripheralManager:(CBPeripheralManager *)peripheral </div><div class=\"line\">  \t\t\tdidAddService:(CBService *)service</div><div class=\"line\">              \t\terror:(NSError *)error&#123;</div><div class=\"line\">    //对于注册成功的服务，蓝牙设备可以直接进行广播</div><div class=\"line\">    //开启广播，此处我们广播刚才注册的服务，UUID是：service uuid</div><div class=\"line\">    [_perManager startAdvertising:</div><div class=\"line\">     @&#123;CBAdvertisementDataServiceUUIDsKey:[CBUUID UUIDWithString:@&quot;service UUID&quot;]&#125;];\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注：一个服务可以携带多个特征值，一个蓝牙周边设备可以注册多个服务。</p>\n<h4 id=\"开启广播\"><a href=\"#开启广播\" class=\"headerlink\" title=\"开启广播\"></a>开启广播</h4><p>  通过CBPeripheralManager的 <em>startAdvertising:</em> 方法开启广播，成功后通过CBPeripheralManagerDelegate协议回调。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">    //开启广播</div><div class=\"line\">    [_perManager startAdvertising:@&#123;CBAdvertisementDataServiceUUIDsKey:[CBUUID UUIDWithString:@&quot;service UUID&quot;]&#125;];</div><div class=\"line\"></div><div class=\"line\">    //开启广播的回调</div><div class=\"line\">- (void)peripheralManagerDidStartAdvertising:(CBPeripheralManager *)peripheral </div><div class=\"line\">  \t\t\t\t\t\t\t\t\t\terror:(NSError *)error &#123;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"数据读写\"><a href=\"#数据读写\" class=\"headerlink\" title=\"数据读写\"></a>数据读写</h4><p>当外设蓝牙设备收到ATT特征值请求时，协议 <em> CBPeripheralManagerDelegate</em> 的方法会被触发。参照协议描述，在处理数据读／写操作的协议回调方法中，必须执行方法 <em>respondToRequest:withResult:</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 读数据请求</div><div class=\"line\">- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveReadRequest:(CBATTRequest *)request &#123;</div><div class=\"line\">    //请求的响应</div><div class=\"line\">    NSData *data = request.characteristic.value; //蓝牙中心设备想读取的数据</div><div class=\"line\">    [request setValue:data];// 读取的值</div><div class=\"line\">    [_perManager respondToRequest:request withResult:CBATTErrorSuccess];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//写数据请求</div><div class=\"line\">- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveWriteRequests:(NSArray&lt;CBATTRequest *&gt; *)requests &#123;</div><div class=\"line\">    //请求的响应</div><div class=\"line\">    //需要转换成CBMutableCharacteristic对象才能进行写值</div><div class=\"line\">    for (CBATTRequest* request in requests) &#123;</div><div class=\"line\">        CBMutableCharacteristic *c =(CBMutableCharacteristic *)request.characteristic;</div><div class=\"line\">        c.value = request.value;</div><div class=\"line\">        [_perManager respondToRequest:[requests firstObject] withResult:CBATTErrorSuccess];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>​</p>\n<h4 id=\"特征值订阅\"><a href=\"#特征值订阅\" class=\"headerlink\" title=\"特征值订阅\"></a>特征值订阅</h4><p>当蓝牙中心设备在进行蓝牙设备服务的特征发现时，若将特征值配置包含被通知 <em>CBCharacteristicPropertyNotify</em> ， 则协议中的以下回调会被调用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">//订阅characteristics</div><div class=\"line\">-(void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didSubscribeToCharacteristic:(CBCharacteristic *)characteristic&#123;</div><div class=\"line\">    NSLog(@&quot;订阅了 %@的数据&quot;,characteristic.UUID);</div><div class=\"line\">    </div><div class=\"line\">    //每秒执行一次给主设备发送一个当前时间的秒数</div><div class=\"line\">    _timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(sendData:) userInfo:characteristic  repeats:YES];</div><div class=\"line\">&#125;</div><div class=\"line\">//如果不设置订阅的设备，则代表全部。</div><div class=\"line\">-(void)sendData:(NSTimer *)t &#123;</div><div class=\"line\">    CBMutableCharacteristic *characteristic = t.userInfo;</div><div class=\"line\">    [_perManager updateValue:[@&quot;Subscribe To Characteristic Value Send &quot; dataUsingEncoding:NSUTF8StringEncoding] forCharacteristic:characteristic onSubscribedCentrals:nil];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//取消订阅characteristics</div><div class=\"line\">-(void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didUnsubscribeFromCharacteristic:(CBCharacteristic *)characteristic&#123;</div><div class=\"line\">    NSLog(@&quot;取消订阅 %@的数据&quot;,characteristic.UUID);</div><div class=\"line\">    </div><div class=\"line\">    //取消回应</div><div class=\"line\">    [_timer invalidate];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"layout":"post","title":"FMDB","date":"2017-04-27T04:07:43.000Z","author":"liangtong","catalog":true,"_content":"\n\n​\tSQLite是一款轻型的数据库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。它使用B+树存储表，整个SQLite数据库就是这些B+树组成的森林。。它的设计目标是嵌入式的，目前被广泛应用。<a href=\"https://github.com/ccgus/fmdb/\"> FMDB </a> 是基于SQLite的实现 。\n\n\n\n\n### 数据库（连接）   \n数据库在使用前均需要建立连接，FMDB提供了两种方式对应数据库文件’通常xx.db’路径建立连接。FMDatabase是一个单一的用来执行SQL语句的数据库连接，使用同步的方式进行，如果需要在多线程执行查询或者更新，则需要使用FMDatabaseQueue\n\n<!-- more -->\n\n#### FMDatabase      \nFMDatabase可以用来执行增、删、改、查相关的SQL语句，通常情况下，不会有什么问题。这里需要说明的一点是移动端在涉及到多线程操作时，不要使用单例模式建立一个FMDatabase对象，否则会发生死锁问题。其官方文档中也有给出警告: Do not instantiate a single `FMDatabase` object and use it across multiple threads.\n\n#### FMDatabaseQueue    \nFMDatabaseQueue的方法调用时异步的，通常在多线程中使用。即使在不同的闭包中使用，也是在发送在同一个线程中。\n\n### 表结构操作      \nSQLite对于每个表的元数据(表名、根节点地址、表scheme等)信息均记录在一个叫’sql_master’的表中。常见的表结构变更包括创建、修改、删除，这些信息的变更均会影响’sql_master’表。\n\n#### 创建      \n表的创建跟通常sql语句区别不大，通常在表创建时设置主键、默认值等。使用语法如下：   \n```SQL\nCREATE TABLE  IF NOT EXISTS RecordSign(recordId text NOT NULL PRIMARY KEY, \n\t\t\t\t\tprojectName TEXT, \n\t\t\t\t\tvisibleState INTEGER DEFAULT 0 , \n\t\t\t\t\tlastTriggerTime text DEFAULT '2017-03-13 23:59:59')\n```\n\n#### 查询     \n判断某个表是否存在，语法如下：   \n```SQL\nselect * from sqlite_master where type = 'table' and name = '表名'\n```\n\n判断某个表中是否存在某列，语法如下（通过判断sql语句中是否包含列名）：   \n```SQL\nselect * from sqlite_master where type = 'table' and name = '表名' and sql like %列表%\n```\n\n#### 删除    \n表的删除，使用drop语句：  \n```SQL\nDROP TABLE '表名'\n```\n\n### 表内容操作\n多表联合操作使用关键字：`join`，或者`in`(如果不需要跨表取字段的话)，比如：       \n```SQL\nNSString* filterBusinessIDSql = [NSString stringWithFormat:@\"select businessID from BeaconRelatedPolicyAndBusiness where isValid = 1 and policyID in ('%@')\", [minPriorityPolicyIDArray componentsJoinedByString:@\"','\"]];  \n\nNSString* retSql = [NSString stringWithFormat:@\"select * from BeaconBusinessMsg where businessID in (%@) and isValid = 1 order by priority asc\",filterBusinessIDSql];\n```\n\n#### 插入   \n支持使用`insert` 或 `insert or replace` 或 `insert or ignore` 等语法   \n```SQL\n[dbms executeUpdate:@\"insert OR IGNORE into RecordSign (recordId, projectName,visibleState) values (?, ?,  1)\",\n                         recordId,\n                         projectName\n                         ];\n```\n#### 更新     \n使用`update`语句进行表结构的更新，如下：    \n```SQL\n[dbms executeUpdate:@\"update RecordSign set projectName = ? ,  visibleState = 1 where  recordId = ? \",\n               projectName,\n               recordId\n\t\t\t\t];\n```\n#### 查询    \n使用 `select` 关键字进行表数据查询，返回 `ResultSet` ，然后可以根据具体情况进行处理。     \n```SQL\n[dbms executeQuery:@\"select * from RecordSign where  recordId = ? \",recordId];\n```\n#### 删除    \n使用 `delete` 关键字来删除表中的记录。    \n```SQL\n [dbms executeUpdate:@\"delete from RecordSign where visibleState = 0\"];\n```\n#### 批处理      \n当涉及到数据量比较大或者原子性操作时，可能会用到批处理相关操作，例如：    \n```SQL\n//假设数据量不是太大，不需要通过分批次提交\n[[GKDatabaseManager sharedInstance].dbQueue inTransaction:^(FMDatabase *dbms, BOOL *rollback) {\n    [dbms executeUpdate:@\"update  RecordSign set visibleState = 0 \"];\n    for (NSDictionary* projectModel in projectList) {\n        NSString* recordId = [projectModel objectForKey:@\"recordId\"];\n        NSString* projectName = [projectModel objectForKey:@\"projectName\"];\n\n        FMResultSet* retSet = [dbms executeQuery:@\"select * from RecordSign where  recordId = ? \",recordId];\n        if ([retSet next]) {\n            [dbms executeUpdate:@\"update RecordSign set projectName = ? ,  visibleState = 1 where  recordId = ? \",\n                        projectName,\n                         recordId\n                         ];\n        }else{\n            [dbms executeUpdate:@\"insert OR IGNORE into RecordSign (recordId, projectName,visibleState) values (?, ?,  1)\",\n                         recordId,\n                         projectName\n                         ];\n        }//end if retSet\n        [retSet close];\n    }//end for\n    [dbms executeUpdate:@\"delete from RecordSign where visibleState = 0\"];\n}];\n[[GKDatabaseManager sharedInstance].dbQueue close];\n```\n\n### 使用心结     \n\n我的态度是：数据库能实现的东西，自己就没必要再折腾了。数据库本身是一个很强大的软件，她已经可以帮助我们解决很多的问题。\n所以在拿到需求后，别急着写代码逻辑，最好先考虑下是否可以利用这些现成的工具。有时候数据库处理数据的能力比自己写程序效率要高很多，且代价也比较小；数据库已经实现的功能，当然没有必要再自行编写程序解决，除非你觉得自己比数据库处理的好。      \n\n\n\n- 使用SQLite数据库处理缓存的话，需要考虑数据库表结构的更新。\n    - 建议在建立表结构的时候，添加版本信息，比如 `tablename_v1`。就像CoreData处理版本升级时的version版本号一样。\n    - 数据迁移。\n    - 表结构受损后的数据恢复。   \n- 数据库连接的选择\n    - FMDatabase是同步操作，FMDatabaseQueue是异步操作。\n    - 不要单例FMDatabase对象，在多线程处理时各种死锁绝对够你受的。\n    - 不要将FMDatabase和FMDatabaseQueue同时使用，否则等着数据异常或者死锁崩溃吧。\n\n\n\n","source":"_posts/database_sqlite3_fmdb.md","raw":"---\nlayout:     post\ntitle:      FMDB\ndate:       2017-04-27 12:07:43\nauthor:     liangtong\ncatalog: true\ncategories: Database\ntags: SQLite3\n\n---\n\n\n​\tSQLite是一款轻型的数据库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。它使用B+树存储表，整个SQLite数据库就是这些B+树组成的森林。。它的设计目标是嵌入式的，目前被广泛应用。<a href=\"https://github.com/ccgus/fmdb/\"> FMDB </a> 是基于SQLite的实现 。\n\n\n\n\n### 数据库（连接）   \n数据库在使用前均需要建立连接，FMDB提供了两种方式对应数据库文件’通常xx.db’路径建立连接。FMDatabase是一个单一的用来执行SQL语句的数据库连接，使用同步的方式进行，如果需要在多线程执行查询或者更新，则需要使用FMDatabaseQueue\n\n<!-- more -->\n\n#### FMDatabase      \nFMDatabase可以用来执行增、删、改、查相关的SQL语句，通常情况下，不会有什么问题。这里需要说明的一点是移动端在涉及到多线程操作时，不要使用单例模式建立一个FMDatabase对象，否则会发生死锁问题。其官方文档中也有给出警告: Do not instantiate a single `FMDatabase` object and use it across multiple threads.\n\n#### FMDatabaseQueue    \nFMDatabaseQueue的方法调用时异步的，通常在多线程中使用。即使在不同的闭包中使用，也是在发送在同一个线程中。\n\n### 表结构操作      \nSQLite对于每个表的元数据(表名、根节点地址、表scheme等)信息均记录在一个叫’sql_master’的表中。常见的表结构变更包括创建、修改、删除，这些信息的变更均会影响’sql_master’表。\n\n#### 创建      \n表的创建跟通常sql语句区别不大，通常在表创建时设置主键、默认值等。使用语法如下：   \n```SQL\nCREATE TABLE  IF NOT EXISTS RecordSign(recordId text NOT NULL PRIMARY KEY, \n\t\t\t\t\tprojectName TEXT, \n\t\t\t\t\tvisibleState INTEGER DEFAULT 0 , \n\t\t\t\t\tlastTriggerTime text DEFAULT '2017-03-13 23:59:59')\n```\n\n#### 查询     \n判断某个表是否存在，语法如下：   \n```SQL\nselect * from sqlite_master where type = 'table' and name = '表名'\n```\n\n判断某个表中是否存在某列，语法如下（通过判断sql语句中是否包含列名）：   \n```SQL\nselect * from sqlite_master where type = 'table' and name = '表名' and sql like %列表%\n```\n\n#### 删除    \n表的删除，使用drop语句：  \n```SQL\nDROP TABLE '表名'\n```\n\n### 表内容操作\n多表联合操作使用关键字：`join`，或者`in`(如果不需要跨表取字段的话)，比如：       \n```SQL\nNSString* filterBusinessIDSql = [NSString stringWithFormat:@\"select businessID from BeaconRelatedPolicyAndBusiness where isValid = 1 and policyID in ('%@')\", [minPriorityPolicyIDArray componentsJoinedByString:@\"','\"]];  \n\nNSString* retSql = [NSString stringWithFormat:@\"select * from BeaconBusinessMsg where businessID in (%@) and isValid = 1 order by priority asc\",filterBusinessIDSql];\n```\n\n#### 插入   \n支持使用`insert` 或 `insert or replace` 或 `insert or ignore` 等语法   \n```SQL\n[dbms executeUpdate:@\"insert OR IGNORE into RecordSign (recordId, projectName,visibleState) values (?, ?,  1)\",\n                         recordId,\n                         projectName\n                         ];\n```\n#### 更新     \n使用`update`语句进行表结构的更新，如下：    \n```SQL\n[dbms executeUpdate:@\"update RecordSign set projectName = ? ,  visibleState = 1 where  recordId = ? \",\n               projectName,\n               recordId\n\t\t\t\t];\n```\n#### 查询    \n使用 `select` 关键字进行表数据查询，返回 `ResultSet` ，然后可以根据具体情况进行处理。     \n```SQL\n[dbms executeQuery:@\"select * from RecordSign where  recordId = ? \",recordId];\n```\n#### 删除    \n使用 `delete` 关键字来删除表中的记录。    \n```SQL\n [dbms executeUpdate:@\"delete from RecordSign where visibleState = 0\"];\n```\n#### 批处理      \n当涉及到数据量比较大或者原子性操作时，可能会用到批处理相关操作，例如：    \n```SQL\n//假设数据量不是太大，不需要通过分批次提交\n[[GKDatabaseManager sharedInstance].dbQueue inTransaction:^(FMDatabase *dbms, BOOL *rollback) {\n    [dbms executeUpdate:@\"update  RecordSign set visibleState = 0 \"];\n    for (NSDictionary* projectModel in projectList) {\n        NSString* recordId = [projectModel objectForKey:@\"recordId\"];\n        NSString* projectName = [projectModel objectForKey:@\"projectName\"];\n\n        FMResultSet* retSet = [dbms executeQuery:@\"select * from RecordSign where  recordId = ? \",recordId];\n        if ([retSet next]) {\n            [dbms executeUpdate:@\"update RecordSign set projectName = ? ,  visibleState = 1 where  recordId = ? \",\n                        projectName,\n                         recordId\n                         ];\n        }else{\n            [dbms executeUpdate:@\"insert OR IGNORE into RecordSign (recordId, projectName,visibleState) values (?, ?,  1)\",\n                         recordId,\n                         projectName\n                         ];\n        }//end if retSet\n        [retSet close];\n    }//end for\n    [dbms executeUpdate:@\"delete from RecordSign where visibleState = 0\"];\n}];\n[[GKDatabaseManager sharedInstance].dbQueue close];\n```\n\n### 使用心结     \n\n我的态度是：数据库能实现的东西，自己就没必要再折腾了。数据库本身是一个很强大的软件，她已经可以帮助我们解决很多的问题。\n所以在拿到需求后，别急着写代码逻辑，最好先考虑下是否可以利用这些现成的工具。有时候数据库处理数据的能力比自己写程序效率要高很多，且代价也比较小；数据库已经实现的功能，当然没有必要再自行编写程序解决，除非你觉得自己比数据库处理的好。      \n\n\n\n- 使用SQLite数据库处理缓存的话，需要考虑数据库表结构的更新。\n    - 建议在建立表结构的时候，添加版本信息，比如 `tablename_v1`。就像CoreData处理版本升级时的version版本号一样。\n    - 数据迁移。\n    - 表结构受损后的数据恢复。   \n- 数据库连接的选择\n    - FMDatabase是同步操作，FMDatabaseQueue是异步操作。\n    - 不要单例FMDatabase对象，在多线程处理时各种死锁绝对够你受的。\n    - 不要将FMDatabase和FMDatabaseQueue同时使用，否则等着数据异常或者死锁崩溃吧。\n\n\n\n","slug":"database_sqlite3_fmdb","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4sc0011oko80cupl7u3","content":"<p>​    SQLite是一款轻型的数据库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。它使用B+树存储表，整个SQLite数据库就是这些B+树组成的森林。。它的设计目标是嵌入式的，目前被广泛应用。<a href=\"https://github.com/ccgus/fmdb/\" target=\"_blank\" rel=\"external\"> FMDB </a> 是基于SQLite的实现 。</p>\n<h3 id=\"数据库（连接）\"><a href=\"#数据库（连接）\" class=\"headerlink\" title=\"数据库（连接）\"></a>数据库（连接）</h3><p>数据库在使用前均需要建立连接，FMDB提供了两种方式对应数据库文件’通常xx.db’路径建立连接。FMDatabase是一个单一的用来执行SQL语句的数据库连接，使用同步的方式进行，如果需要在多线程执行查询或者更新，则需要使用FMDatabaseQueue</p>\n<a id=\"more\"></a>\n<h4 id=\"FMDatabase\"><a href=\"#FMDatabase\" class=\"headerlink\" title=\"FMDatabase\"></a>FMDatabase</h4><p>FMDatabase可以用来执行增、删、改、查相关的SQL语句，通常情况下，不会有什么问题。这里需要说明的一点是移动端在涉及到多线程操作时，不要使用单例模式建立一个FMDatabase对象，否则会发生死锁问题。其官方文档中也有给出警告: Do not instantiate a single <code>FMDatabase</code> object and use it across multiple threads.</p>\n<h4 id=\"FMDatabaseQueue\"><a href=\"#FMDatabaseQueue\" class=\"headerlink\" title=\"FMDatabaseQueue\"></a>FMDatabaseQueue</h4><p>FMDatabaseQueue的方法调用时异步的，通常在多线程中使用。即使在不同的闭包中使用，也是在发送在同一个线程中。</p>\n<h3 id=\"表结构操作\"><a href=\"#表结构操作\" class=\"headerlink\" title=\"表结构操作\"></a>表结构操作</h3><p>SQLite对于每个表的元数据(表名、根节点地址、表scheme等)信息均记录在一个叫’sql_master’的表中。常见的表结构变更包括创建、修改、删除，这些信息的变更均会影响’sql_master’表。</p>\n<h4 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h4><p>表的创建跟通常sql语句区别不大，通常在表创建时设置主键、默认值等。使用语法如下：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span>  <span class=\"keyword\">IF</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">EXISTS</span> RecordSign(recordId <span class=\"built_in\">text</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> PRIMARY <span class=\"keyword\">KEY</span>, </div><div class=\"line\">\t\t\t\t\tprojectName <span class=\"built_in\">TEXT</span>, </div><div class=\"line\">\t\t\t\t\tvisibleState <span class=\"built_in\">INTEGER</span> <span class=\"keyword\">DEFAULT</span> <span class=\"number\">0</span> , </div><div class=\"line\">\t\t\t\t\tlastTriggerTime <span class=\"built_in\">text</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">'2017-03-13 23:59:59'</span>)</div></pre></td></tr></table></figure></p>\n<h4 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h4><p>判断某个表是否存在，语法如下：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> sqlite_master <span class=\"keyword\">where</span> <span class=\"keyword\">type</span> = <span class=\"string\">'table'</span> <span class=\"keyword\">and</span> <span class=\"keyword\">name</span> = <span class=\"string\">'表名'</span></div></pre></td></tr></table></figure></p>\n<p>判断某个表中是否存在某列，语法如下（通过判断sql语句中是否包含列名）：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> sqlite_master <span class=\"keyword\">where</span> <span class=\"keyword\">type</span> = <span class=\"string\">'table'</span> <span class=\"keyword\">and</span> <span class=\"keyword\">name</span> = <span class=\"string\">'表名'</span> <span class=\"keyword\">and</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">like</span> %列表%</div></pre></td></tr></table></figure></p>\n<h4 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h4><p>表的删除，使用drop语句：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">'表名'</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"表内容操作\"><a href=\"#表内容操作\" class=\"headerlink\" title=\"表内容操作\"></a>表内容操作</h3><p>多表联合操作使用关键字：<code>join</code>，或者<code>in</code>(如果不需要跨表取字段的话)，比如：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSString* filterBusinessIDSql = [NSString stringWithFormat:@\"select businessID from BeaconRelatedPolicyAndBusiness where isValid = 1 and policyID in ('%@')\", [minPriorityPolicyIDArray componentsJoinedByString:@\"','\"]];  </div><div class=\"line\"></div><div class=\"line\">NSString* retSql = [NSString stringWithFormat:@\"select * from BeaconBusinessMsg where businessID in (%@) and isValid = 1 order by priority asc\",filterBusinessIDSql];</div></pre></td></tr></table></figure></p>\n<h4 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h4><p>支持使用<code>insert</code> 或 <code>insert or replace</code> 或 <code>insert or ignore</code> 等语法<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[dbms executeUpdate:@\"<span class=\"keyword\">insert</span> <span class=\"keyword\">OR</span> <span class=\"keyword\">IGNORE</span> <span class=\"keyword\">into</span> RecordSign (recordId, projectName,visibleState) <span class=\"keyword\">values</span> (?, ?,  <span class=\"number\">1</span>)<span class=\"string\">\",</span></div><div class=\"line\"><span class=\"string\">                         recordId,</span></div><div class=\"line\"><span class=\"string\">                         projectName</span></div><div class=\"line\"><span class=\"string\">                         ];</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h4><p>使用<code>update</code>语句进行表结构的更新，如下：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[dbms executeUpdate:@\"<span class=\"keyword\">update</span> RecordSign <span class=\"keyword\">set</span> projectName = ? ,  visibleState = <span class=\"number\">1</span> <span class=\"keyword\">where</span>  recordId = ? <span class=\"string\">\",</span></div><div class=\"line\"><span class=\"string\">               projectName,</span></div><div class=\"line\"><span class=\"string\">               recordId</span></div><div class=\"line\"><span class=\"string\">\t\t\t\t];</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"查询-1\"><a href=\"#查询-1\" class=\"headerlink\" title=\"查询\"></a>查询</h4><p>使用 <code>select</code> 关键字进行表数据查询，返回 <code>ResultSet</code> ，然后可以根据具体情况进行处理。<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[dbms executeQuery:@\"<span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> RecordSign <span class=\"keyword\">where</span>  recordId = ? <span class=\"string\">\",recordId];</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"删除-1\"><a href=\"#删除-1\" class=\"headerlink\" title=\"删除\"></a>删除</h4><p>使用 <code>delete</code> 关键字来删除表中的记录。<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[dbms executeUpdate:@\"<span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> RecordSign <span class=\"keyword\">where</span> visibleState = <span class=\"number\">0</span><span class=\"string\">\"];</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"批处理\"><a href=\"#批处理\" class=\"headerlink\" title=\"批处理\"></a>批处理</h4><p>当涉及到数据量比较大或者原子性操作时，可能会用到批处理相关操作，例如：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">//假设数据量不是太大，不需要通过分批次提交</div><div class=\"line\">[[GKDatabaseManager sharedInstance].dbQueue inTransaction:^(FMDatabase *dbms, BOOL *rollback) &#123;</div><div class=\"line\">    [dbms executeUpdate:@\"<span class=\"keyword\">update</span>  RecordSign <span class=\"keyword\">set</span> visibleState = <span class=\"number\">0</span> <span class=\"string\">\"];</span></div><div class=\"line\"><span class=\"string\">    for (NSDictionary* projectModel in projectList) &#123;</span></div><div class=\"line\"><span class=\"string\">        NSString* recordId = [projectModel objectForKey:@\"</span>recordId<span class=\"string\">\"];</span></div><div class=\"line\"><span class=\"string\">        NSString* projectName = [projectModel objectForKey:@\"</span>projectName<span class=\"string\">\"];</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">        FMResultSet* retSet = [dbms executeQuery:@\"</span><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> RecordSign <span class=\"keyword\">where</span>  recordId = ? <span class=\"string\">\",recordId];</span></div><div class=\"line\"><span class=\"string\">        if ([retSet next]) &#123;</span></div><div class=\"line\"><span class=\"string\">            [dbms executeUpdate:@\"</span><span class=\"keyword\">update</span> RecordSign <span class=\"keyword\">set</span> projectName = ? ,  visibleState = <span class=\"number\">1</span> <span class=\"keyword\">where</span>  recordId = ? <span class=\"string\">\",</span></div><div class=\"line\"><span class=\"string\">                        projectName,</span></div><div class=\"line\"><span class=\"string\">                         recordId</span></div><div class=\"line\"><span class=\"string\">                         ];</span></div><div class=\"line\"><span class=\"string\">        &#125;else&#123;</span></div><div class=\"line\"><span class=\"string\">            [dbms executeUpdate:@\"</span><span class=\"keyword\">insert</span> <span class=\"keyword\">OR</span> <span class=\"keyword\">IGNORE</span> <span class=\"keyword\">into</span> RecordSign (recordId, projectName,visibleState) <span class=\"keyword\">values</span> (?, ?,  <span class=\"number\">1</span>)<span class=\"string\">\",</span></div><div class=\"line\"><span class=\"string\">                         recordId,</span></div><div class=\"line\"><span class=\"string\">                         projectName</span></div><div class=\"line\"><span class=\"string\">                         ];</span></div><div class=\"line\"><span class=\"string\">        &#125;//end if retSet</span></div><div class=\"line\"><span class=\"string\">        [retSet close];</span></div><div class=\"line\"><span class=\"string\">    &#125;//end for</span></div><div class=\"line\"><span class=\"string\">    [dbms executeUpdate:@\"</span><span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> RecordSign <span class=\"keyword\">where</span> visibleState = <span class=\"number\">0</span><span class=\"string\">\"];</span></div><div class=\"line\"><span class=\"string\">&#125;];</span></div><div class=\"line\"><span class=\"string\">[[GKDatabaseManager sharedInstance].dbQueue close];</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"使用心结\"><a href=\"#使用心结\" class=\"headerlink\" title=\"使用心结\"></a>使用心结</h3><p>我的态度是：数据库能实现的东西，自己就没必要再折腾了。数据库本身是一个很强大的软件，她已经可以帮助我们解决很多的问题。<br>所以在拿到需求后，别急着写代码逻辑，最好先考虑下是否可以利用这些现成的工具。有时候数据库处理数据的能力比自己写程序效率要高很多，且代价也比较小；数据库已经实现的功能，当然没有必要再自行编写程序解决，除非你觉得自己比数据库处理的好。      </p>\n<ul>\n<li>使用SQLite数据库处理缓存的话，需要考虑数据库表结构的更新。<ul>\n<li>建议在建立表结构的时候，添加版本信息，比如 <code>tablename_v1</code>。就像CoreData处理版本升级时的version版本号一样。</li>\n<li>数据迁移。</li>\n<li>表结构受损后的数据恢复。   </li>\n</ul>\n</li>\n<li>数据库连接的选择<ul>\n<li>FMDatabase是同步操作，FMDatabaseQueue是异步操作。</li>\n<li>不要单例FMDatabase对象，在多线程处理时各种死锁绝对够你受的。</li>\n<li>不要将FMDatabase和FMDatabaseQueue同时使用，否则等着数据异常或者死锁崩溃吧。</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>​    SQLite是一款轻型的数据库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。它使用B+树存储表，整个SQLite数据库就是这些B+树组成的森林。。它的设计目标是嵌入式的，目前被广泛应用。<a href=\"https://github.com/ccgus/fmdb/\" target=\"_blank\" rel=\"external\"> FMDB </a> 是基于SQLite的实现 。</p>\n<h3 id=\"数据库（连接）\"><a href=\"#数据库（连接）\" class=\"headerlink\" title=\"数据库（连接）\"></a>数据库（连接）</h3><p>数据库在使用前均需要建立连接，FMDB提供了两种方式对应数据库文件’通常xx.db’路径建立连接。FMDatabase是一个单一的用来执行SQL语句的数据库连接，使用同步的方式进行，如果需要在多线程执行查询或者更新，则需要使用FMDatabaseQueue</p>","more":"<h4 id=\"FMDatabase\"><a href=\"#FMDatabase\" class=\"headerlink\" title=\"FMDatabase\"></a>FMDatabase</h4><p>FMDatabase可以用来执行增、删、改、查相关的SQL语句，通常情况下，不会有什么问题。这里需要说明的一点是移动端在涉及到多线程操作时，不要使用单例模式建立一个FMDatabase对象，否则会发生死锁问题。其官方文档中也有给出警告: Do not instantiate a single <code>FMDatabase</code> object and use it across multiple threads.</p>\n<h4 id=\"FMDatabaseQueue\"><a href=\"#FMDatabaseQueue\" class=\"headerlink\" title=\"FMDatabaseQueue\"></a>FMDatabaseQueue</h4><p>FMDatabaseQueue的方法调用时异步的，通常在多线程中使用。即使在不同的闭包中使用，也是在发送在同一个线程中。</p>\n<h3 id=\"表结构操作\"><a href=\"#表结构操作\" class=\"headerlink\" title=\"表结构操作\"></a>表结构操作</h3><p>SQLite对于每个表的元数据(表名、根节点地址、表scheme等)信息均记录在一个叫’sql_master’的表中。常见的表结构变更包括创建、修改、删除，这些信息的变更均会影响’sql_master’表。</p>\n<h4 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h4><p>表的创建跟通常sql语句区别不大，通常在表创建时设置主键、默认值等。使用语法如下：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span>  <span class=\"keyword\">IF</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">EXISTS</span> RecordSign(recordId <span class=\"built_in\">text</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> PRIMARY <span class=\"keyword\">KEY</span>, </div><div class=\"line\">\t\t\t\t\tprojectName <span class=\"built_in\">TEXT</span>, </div><div class=\"line\">\t\t\t\t\tvisibleState <span class=\"built_in\">INTEGER</span> <span class=\"keyword\">DEFAULT</span> <span class=\"number\">0</span> , </div><div class=\"line\">\t\t\t\t\tlastTriggerTime <span class=\"built_in\">text</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">'2017-03-13 23:59:59'</span>)</div></pre></td></tr></table></figure></p>\n<h4 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h4><p>判断某个表是否存在，语法如下：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> sqlite_master <span class=\"keyword\">where</span> <span class=\"keyword\">type</span> = <span class=\"string\">'table'</span> <span class=\"keyword\">and</span> <span class=\"keyword\">name</span> = <span class=\"string\">'表名'</span></div></pre></td></tr></table></figure></p>\n<p>判断某个表中是否存在某列，语法如下（通过判断sql语句中是否包含列名）：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> sqlite_master <span class=\"keyword\">where</span> <span class=\"keyword\">type</span> = <span class=\"string\">'table'</span> <span class=\"keyword\">and</span> <span class=\"keyword\">name</span> = <span class=\"string\">'表名'</span> <span class=\"keyword\">and</span> <span class=\"keyword\">sql</span> <span class=\"keyword\">like</span> %列表%</div></pre></td></tr></table></figure></p>\n<h4 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h4><p>表的删除，使用drop语句：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">'表名'</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"表内容操作\"><a href=\"#表内容操作\" class=\"headerlink\" title=\"表内容操作\"></a>表内容操作</h3><p>多表联合操作使用关键字：<code>join</code>，或者<code>in</code>(如果不需要跨表取字段的话)，比如：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">NSString* filterBusinessIDSql = [NSString stringWithFormat:@\"select businessID from BeaconRelatedPolicyAndBusiness where isValid = 1 and policyID in ('%@')\", [minPriorityPolicyIDArray componentsJoinedByString:@\"','\"]];  </div><div class=\"line\"></div><div class=\"line\">NSString* retSql = [NSString stringWithFormat:@\"select * from BeaconBusinessMsg where businessID in (%@) and isValid = 1 order by priority asc\",filterBusinessIDSql];</div></pre></td></tr></table></figure></p>\n<h4 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h4><p>支持使用<code>insert</code> 或 <code>insert or replace</code> 或 <code>insert or ignore</code> 等语法<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[dbms executeUpdate:@\"<span class=\"keyword\">insert</span> <span class=\"keyword\">OR</span> <span class=\"keyword\">IGNORE</span> <span class=\"keyword\">into</span> RecordSign (recordId, projectName,visibleState) <span class=\"keyword\">values</span> (?, ?,  <span class=\"number\">1</span>)<span class=\"string\">\",</span></div><div class=\"line\"><span class=\"string\">                         recordId,</span></div><div class=\"line\"><span class=\"string\">                         projectName</span></div><div class=\"line\"><span class=\"string\">                         ];</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h4><p>使用<code>update</code>语句进行表结构的更新，如下：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">[dbms executeUpdate:@\"<span class=\"keyword\">update</span> RecordSign <span class=\"keyword\">set</span> projectName = ? ,  visibleState = <span class=\"number\">1</span> <span class=\"keyword\">where</span>  recordId = ? <span class=\"string\">\",</span></div><div class=\"line\"><span class=\"string\">               projectName,</span></div><div class=\"line\"><span class=\"string\">               recordId</span></div><div class=\"line\"><span class=\"string\">\t\t\t\t];</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"查询-1\"><a href=\"#查询-1\" class=\"headerlink\" title=\"查询\"></a>查询</h4><p>使用 <code>select</code> 关键字进行表数据查询，返回 <code>ResultSet</code> ，然后可以根据具体情况进行处理。<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[dbms executeQuery:@\"<span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> RecordSign <span class=\"keyword\">where</span>  recordId = ? <span class=\"string\">\",recordId];</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"删除-1\"><a href=\"#删除-1\" class=\"headerlink\" title=\"删除\"></a>删除</h4><p>使用 <code>delete</code> 关键字来删除表中的记录。<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[dbms executeUpdate:@\"<span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> RecordSign <span class=\"keyword\">where</span> visibleState = <span class=\"number\">0</span><span class=\"string\">\"];</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"批处理\"><a href=\"#批处理\" class=\"headerlink\" title=\"批处理\"></a>批处理</h4><p>当涉及到数据量比较大或者原子性操作时，可能会用到批处理相关操作，例如：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">//假设数据量不是太大，不需要通过分批次提交</div><div class=\"line\">[[GKDatabaseManager sharedInstance].dbQueue inTransaction:^(FMDatabase *dbms, BOOL *rollback) &#123;</div><div class=\"line\">    [dbms executeUpdate:@\"<span class=\"keyword\">update</span>  RecordSign <span class=\"keyword\">set</span> visibleState = <span class=\"number\">0</span> <span class=\"string\">\"];</span></div><div class=\"line\"><span class=\"string\">    for (NSDictionary* projectModel in projectList) &#123;</span></div><div class=\"line\"><span class=\"string\">        NSString* recordId = [projectModel objectForKey:@\"</span>recordId<span class=\"string\">\"];</span></div><div class=\"line\"><span class=\"string\">        NSString* projectName = [projectModel objectForKey:@\"</span>projectName<span class=\"string\">\"];</span></div><div class=\"line\"><span class=\"string\"></span></div><div class=\"line\"><span class=\"string\">        FMResultSet* retSet = [dbms executeQuery:@\"</span><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> RecordSign <span class=\"keyword\">where</span>  recordId = ? <span class=\"string\">\",recordId];</span></div><div class=\"line\"><span class=\"string\">        if ([retSet next]) &#123;</span></div><div class=\"line\"><span class=\"string\">            [dbms executeUpdate:@\"</span><span class=\"keyword\">update</span> RecordSign <span class=\"keyword\">set</span> projectName = ? ,  visibleState = <span class=\"number\">1</span> <span class=\"keyword\">where</span>  recordId = ? <span class=\"string\">\",</span></div><div class=\"line\"><span class=\"string\">                        projectName,</span></div><div class=\"line\"><span class=\"string\">                         recordId</span></div><div class=\"line\"><span class=\"string\">                         ];</span></div><div class=\"line\"><span class=\"string\">        &#125;else&#123;</span></div><div class=\"line\"><span class=\"string\">            [dbms executeUpdate:@\"</span><span class=\"keyword\">insert</span> <span class=\"keyword\">OR</span> <span class=\"keyword\">IGNORE</span> <span class=\"keyword\">into</span> RecordSign (recordId, projectName,visibleState) <span class=\"keyword\">values</span> (?, ?,  <span class=\"number\">1</span>)<span class=\"string\">\",</span></div><div class=\"line\"><span class=\"string\">                         recordId,</span></div><div class=\"line\"><span class=\"string\">                         projectName</span></div><div class=\"line\"><span class=\"string\">                         ];</span></div><div class=\"line\"><span class=\"string\">        &#125;//end if retSet</span></div><div class=\"line\"><span class=\"string\">        [retSet close];</span></div><div class=\"line\"><span class=\"string\">    &#125;//end for</span></div><div class=\"line\"><span class=\"string\">    [dbms executeUpdate:@\"</span><span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> RecordSign <span class=\"keyword\">where</span> visibleState = <span class=\"number\">0</span><span class=\"string\">\"];</span></div><div class=\"line\"><span class=\"string\">&#125;];</span></div><div class=\"line\"><span class=\"string\">[[GKDatabaseManager sharedInstance].dbQueue close];</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"使用心结\"><a href=\"#使用心结\" class=\"headerlink\" title=\"使用心结\"></a>使用心结</h3><p>我的态度是：数据库能实现的东西，自己就没必要再折腾了。数据库本身是一个很强大的软件，她已经可以帮助我们解决很多的问题。<br>所以在拿到需求后，别急着写代码逻辑，最好先考虑下是否可以利用这些现成的工具。有时候数据库处理数据的能力比自己写程序效率要高很多，且代价也比较小；数据库已经实现的功能，当然没有必要再自行编写程序解决，除非你觉得自己比数据库处理的好。      </p>\n<ul>\n<li>使用SQLite数据库处理缓存的话，需要考虑数据库表结构的更新。<ul>\n<li>建议在建立表结构的时候，添加版本信息，比如 <code>tablename_v1</code>。就像CoreData处理版本升级时的version版本号一样。</li>\n<li>数据迁移。</li>\n<li>表结构受损后的数据恢复。   </li>\n</ul>\n</li>\n<li>数据库连接的选择<ul>\n<li>FMDatabase是同步操作，FMDatabaseQueue是异步操作。</li>\n<li>不要单例FMDatabase对象，在多线程处理时各种死锁绝对够你受的。</li>\n<li>不要将FMDatabase和FMDatabaseQueue同时使用，否则等着数据异常或者死锁崩溃吧。</li>\n</ul>\n</li>\n</ul>"},{"layout":"post","title":"LTxMenu","date":"2017-05-19T10:10:12.000Z","author":"liangtong","catalog":true,"_content":"\n\n**[ Update v2.0.0 ]** Similar to Facebook News Feed , Alipay Life , QZone and other social applications . click a drop-down button to display more functions\n\n\n\n### Introduction\n\n​         In Facebook News Feed , Alipay Life , QZone and other social applications , they all contain a function drop-down button which would show a list of more functions when taped . I didn’t find any on GitHub , so I wrote a similar UI controls myself using Objective-C. ：\n\n![](https://raw.githubusercontent.com/l900416/LTxMenu/master/screenshots/1.png)\n\n>>GitHub link : <a href=\"https://github.com/l900416/LTxMenu\">LTxMenu</a>\n\n<!-- more -->\n\n### Get Start\n> * Manually add the files into your Xcode project.\n> * LTxMenu is available as LTxMenu in Cocoapods.\n\n\n### How To Use\n​\tCreate a LTxMenuView Object:\n\n```Objective-C\n/**\n* class instance method with dataSource and delegate. you can also create with [[LTxMenuView alloc] init] then set the dataSource and the delegate.\n**/\n+ (instancetype)instanceWithDataSource:(id <LTxMenuViewDataSource>)dataSource delegate:(id <LTxMenuViewDelegate>)delegate;\n/**\n* show menuView in viewController from a special position.\n* @param viewController the menuview 's container\n* @param position the menuview 's arrow direction\n**/\n- (void)showMenu:(UIViewController*)viewController from:(CGRect)position;\n/**\n* hide the menuview. usually you did not need to call this method\n**/\n- (void)dismissMenu;\n```\n​\tDataSource && Delegate\n\n```Objective-C\n\n#pragma mark LTxMenuViewDelegate\n@protocol LTxMenuViewDelegate<NSObject>\n\n@optional\n/**\n* called when a specified index was selected.\n**/\n-(void)didSelectRowAtIndex:(NSInteger)index;\n\n/**\n* called when a specified accessoryView was selected.\n**/\n-(void)didSelectAccessoryView:(UIView*)accessoryView\natIndex:(NSInteger)index;\n@end\n\n#pragma mark LTxMenuViewDataSource\n@protocol LTxMenuViewDataSource<NSObject>\n\n@required\n/**\n* Returns the number of rows\n**/\n- (NSInteger)numberOfRows;\n\n@optional\n/**\n* Returns the height of specified index. default value is 50.\n**/\n- (CGFloat)heightForRowAtIndex:(NSInteger)index;\n\n/**\n* Returns the attributedTitle of specified index.\n**/\n- (NSAttributedString*)attributedTitleForRowAtIndex:(NSInteger)index;\n\n/**\n* Returns the image of specified index.\n**/\n- (UIImage*)imageForRowAtIndex:(NSInteger)index;\n\n/**\n* Returns the accessoryViews placed at the end of specified index.\n**/\n- (NSArray<UIView*>*)accessoryViewsAtIndex:(NSInteger)index;\n@end;\n```\n\n### How it works\n​\tLTxMenu use **LTxMenuItem** class to config view showed in row. and **LTxMenuView** class with callback methods to calculate the UI performance .  draw arrow and the border use  **UIBezierPath** class . and the show/hide animation use **UIKit**.\n\n### Reference\n\n​\thttps://github.com/kolyvan/kxmenu\n\n\n\n\n\n\n\n\n\n","source":"_posts/iOS_ObjC_LTxMenu_v2.0.0.md","raw":"---\nlayout:     post\ntitle:      LTxMenu\ndate:       2017-05-19 18:10:12\nauthor:     liangtong\ncatalog: true\ncategories: iOS\ntags: Menu \n\n---\n\n\n**[ Update v2.0.0 ]** Similar to Facebook News Feed , Alipay Life , QZone and other social applications . click a drop-down button to display more functions\n\n\n\n### Introduction\n\n​         In Facebook News Feed , Alipay Life , QZone and other social applications , they all contain a function drop-down button which would show a list of more functions when taped . I didn’t find any on GitHub , so I wrote a similar UI controls myself using Objective-C. ：\n\n![](https://raw.githubusercontent.com/l900416/LTxMenu/master/screenshots/1.png)\n\n>>GitHub link : <a href=\"https://github.com/l900416/LTxMenu\">LTxMenu</a>\n\n<!-- more -->\n\n### Get Start\n> * Manually add the files into your Xcode project.\n> * LTxMenu is available as LTxMenu in Cocoapods.\n\n\n### How To Use\n​\tCreate a LTxMenuView Object:\n\n```Objective-C\n/**\n* class instance method with dataSource and delegate. you can also create with [[LTxMenuView alloc] init] then set the dataSource and the delegate.\n**/\n+ (instancetype)instanceWithDataSource:(id <LTxMenuViewDataSource>)dataSource delegate:(id <LTxMenuViewDelegate>)delegate;\n/**\n* show menuView in viewController from a special position.\n* @param viewController the menuview 's container\n* @param position the menuview 's arrow direction\n**/\n- (void)showMenu:(UIViewController*)viewController from:(CGRect)position;\n/**\n* hide the menuview. usually you did not need to call this method\n**/\n- (void)dismissMenu;\n```\n​\tDataSource && Delegate\n\n```Objective-C\n\n#pragma mark LTxMenuViewDelegate\n@protocol LTxMenuViewDelegate<NSObject>\n\n@optional\n/**\n* called when a specified index was selected.\n**/\n-(void)didSelectRowAtIndex:(NSInteger)index;\n\n/**\n* called when a specified accessoryView was selected.\n**/\n-(void)didSelectAccessoryView:(UIView*)accessoryView\natIndex:(NSInteger)index;\n@end\n\n#pragma mark LTxMenuViewDataSource\n@protocol LTxMenuViewDataSource<NSObject>\n\n@required\n/**\n* Returns the number of rows\n**/\n- (NSInteger)numberOfRows;\n\n@optional\n/**\n* Returns the height of specified index. default value is 50.\n**/\n- (CGFloat)heightForRowAtIndex:(NSInteger)index;\n\n/**\n* Returns the attributedTitle of specified index.\n**/\n- (NSAttributedString*)attributedTitleForRowAtIndex:(NSInteger)index;\n\n/**\n* Returns the image of specified index.\n**/\n- (UIImage*)imageForRowAtIndex:(NSInteger)index;\n\n/**\n* Returns the accessoryViews placed at the end of specified index.\n**/\n- (NSArray<UIView*>*)accessoryViewsAtIndex:(NSInteger)index;\n@end;\n```\n\n### How it works\n​\tLTxMenu use **LTxMenuItem** class to config view showed in row. and **LTxMenuView** class with callback methods to calculate the UI performance .  draw arrow and the border use  **UIBezierPath** class . and the show/hide animation use **UIKit**.\n\n### Reference\n\n​\thttps://github.com/kolyvan/kxmenu\n\n\n\n\n\n\n\n\n\n","slug":"iOS_ObjC_LTxMenu_v2.0.0","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4se0014oko8o2bywwpj","content":"<p><strong>[ Update v2.0.0 ]</strong> Similar to Facebook News Feed , Alipay Life , QZone and other social applications . click a drop-down button to display more functions</p>\n<h3 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h3><p>​         In Facebook News Feed , Alipay Life , QZone and other social applications , they all contain a function drop-down button which would show a list of more functions when taped . I didn’t find any on GitHub , so I wrote a similar UI controls myself using Objective-C. ：</p>\n<p><img src=\"https://raw.githubusercontent.com/l900416/LTxMenu/master/screenshots/1.png\" alt=\"\"></p>\n<blockquote>\n<blockquote>\n<p>GitHub link : <a href=\"https://github.com/l900416/LTxMenu\" target=\"_blank\" rel=\"external\">LTxMenu</a></p>\n</blockquote>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"Get-Start\"><a href=\"#Get-Start\" class=\"headerlink\" title=\"Get Start\"></a>Get Start</h3><blockquote>\n<ul>\n<li>Manually add the files into your Xcode project.</li>\n<li>LTxMenu is available as LTxMenu in Cocoapods.</li>\n</ul>\n</blockquote>\n<h3 id=\"How-To-Use\"><a href=\"#How-To-Use\" class=\"headerlink\" title=\"How To Use\"></a>How To Use</h3><p>​    Create a LTxMenuView Object:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">* class instance method with dataSource and delegate. you can also create with [[LTxMenuView alloc] init] then set the dataSource and the delegate.</div><div class=\"line\">**/</div><div class=\"line\">+ (instancetype)instanceWithDataSource:(id &lt;LTxMenuViewDataSource&gt;)dataSource delegate:(id &lt;LTxMenuViewDelegate&gt;)delegate;</div><div class=\"line\">/**</div><div class=\"line\">* show menuView in viewController from a special position.</div><div class=\"line\">* @param viewController the menuview &apos;s container</div><div class=\"line\">* @param position the menuview &apos;s arrow direction</div><div class=\"line\">**/</div><div class=\"line\">- (void)showMenu:(UIViewController*)viewController from:(CGRect)position;</div><div class=\"line\">/**</div><div class=\"line\">* hide the menuview. usually you did not need to call this method</div><div class=\"line\">**/</div><div class=\"line\">- (void)dismissMenu;</div></pre></td></tr></table></figure>\n<p>​    DataSource &amp;&amp; Delegate</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">#pragma mark LTxMenuViewDelegate</div><div class=\"line\">@protocol LTxMenuViewDelegate&lt;NSObject&gt;</div><div class=\"line\"></div><div class=\"line\">@optional</div><div class=\"line\">/**</div><div class=\"line\">* called when a specified index was selected.</div><div class=\"line\">**/</div><div class=\"line\">-(void)didSelectRowAtIndex:(NSInteger)index;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">* called when a specified accessoryView was selected.</div><div class=\"line\">**/</div><div class=\"line\">-(void)didSelectAccessoryView:(UIView*)accessoryView</div><div class=\"line\">atIndex:(NSInteger)index;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">#pragma mark LTxMenuViewDataSource</div><div class=\"line\">@protocol LTxMenuViewDataSource&lt;NSObject&gt;</div><div class=\"line\"></div><div class=\"line\">@required</div><div class=\"line\">/**</div><div class=\"line\">* Returns the number of rows</div><div class=\"line\">**/</div><div class=\"line\">- (NSInteger)numberOfRows;</div><div class=\"line\"></div><div class=\"line\">@optional</div><div class=\"line\">/**</div><div class=\"line\">* Returns the height of specified index. default value is 50.</div><div class=\"line\">**/</div><div class=\"line\">- (CGFloat)heightForRowAtIndex:(NSInteger)index;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">* Returns the attributedTitle of specified index.</div><div class=\"line\">**/</div><div class=\"line\">- (NSAttributedString*)attributedTitleForRowAtIndex:(NSInteger)index;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">* Returns the image of specified index.</div><div class=\"line\">**/</div><div class=\"line\">- (UIImage*)imageForRowAtIndex:(NSInteger)index;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">* Returns the accessoryViews placed at the end of specified index.</div><div class=\"line\">**/</div><div class=\"line\">- (NSArray&lt;UIView*&gt;*)accessoryViewsAtIndex:(NSInteger)index;</div><div class=\"line\">@end;</div></pre></td></tr></table></figure>\n<h3 id=\"How-it-works\"><a href=\"#How-it-works\" class=\"headerlink\" title=\"How it works\"></a>How it works</h3><p>​    LTxMenu use <strong>LTxMenuItem</strong> class to config view showed in row. and <strong>LTxMenuView</strong> class with callback methods to calculate the UI performance .  draw arrow and the border use  <strong>UIBezierPath</strong> class . and the show/hide animation use <strong>UIKit</strong>.</p>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><p>​    <a href=\"https://github.com/kolyvan/kxmenu\" target=\"_blank\" rel=\"external\">https://github.com/kolyvan/kxmenu</a></p>\n","site":{"data":{}},"excerpt":"<p><strong>[ Update v2.0.0 ]</strong> Similar to Facebook News Feed , Alipay Life , QZone and other social applications . click a drop-down button to display more functions</p>\n<h3 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h3><p>​         In Facebook News Feed , Alipay Life , QZone and other social applications , they all contain a function drop-down button which would show a list of more functions when taped . I didn’t find any on GitHub , so I wrote a similar UI controls myself using Objective-C. ：</p>\n<p><img src=\"https://raw.githubusercontent.com/l900416/LTxMenu/master/screenshots/1.png\" alt=\"\"></p>\n<blockquote>\n<blockquote>\n<p>GitHub link : <a href=\"https://github.com/l900416/LTxMenu\" target=\"_blank\" rel=\"external\">LTxMenu</a></p>\n</blockquote>\n</blockquote>","more":"<h3 id=\"Get-Start\"><a href=\"#Get-Start\" class=\"headerlink\" title=\"Get Start\"></a>Get Start</h3><blockquote>\n<ul>\n<li>Manually add the files into your Xcode project.</li>\n<li>LTxMenu is available as LTxMenu in Cocoapods.</li>\n</ul>\n</blockquote>\n<h3 id=\"How-To-Use\"><a href=\"#How-To-Use\" class=\"headerlink\" title=\"How To Use\"></a>How To Use</h3><p>​    Create a LTxMenuView Object:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">* class instance method with dataSource and delegate. you can also create with [[LTxMenuView alloc] init] then set the dataSource and the delegate.</div><div class=\"line\">**/</div><div class=\"line\">+ (instancetype)instanceWithDataSource:(id &lt;LTxMenuViewDataSource&gt;)dataSource delegate:(id &lt;LTxMenuViewDelegate&gt;)delegate;</div><div class=\"line\">/**</div><div class=\"line\">* show menuView in viewController from a special position.</div><div class=\"line\">* @param viewController the menuview &apos;s container</div><div class=\"line\">* @param position the menuview &apos;s arrow direction</div><div class=\"line\">**/</div><div class=\"line\">- (void)showMenu:(UIViewController*)viewController from:(CGRect)position;</div><div class=\"line\">/**</div><div class=\"line\">* hide the menuview. usually you did not need to call this method</div><div class=\"line\">**/</div><div class=\"line\">- (void)dismissMenu;</div></pre></td></tr></table></figure>\n<p>​    DataSource &amp;&amp; Delegate</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">#pragma mark LTxMenuViewDelegate</div><div class=\"line\">@protocol LTxMenuViewDelegate&lt;NSObject&gt;</div><div class=\"line\"></div><div class=\"line\">@optional</div><div class=\"line\">/**</div><div class=\"line\">* called when a specified index was selected.</div><div class=\"line\">**/</div><div class=\"line\">-(void)didSelectRowAtIndex:(NSInteger)index;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">* called when a specified accessoryView was selected.</div><div class=\"line\">**/</div><div class=\"line\">-(void)didSelectAccessoryView:(UIView*)accessoryView</div><div class=\"line\">atIndex:(NSInteger)index;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">#pragma mark LTxMenuViewDataSource</div><div class=\"line\">@protocol LTxMenuViewDataSource&lt;NSObject&gt;</div><div class=\"line\"></div><div class=\"line\">@required</div><div class=\"line\">/**</div><div class=\"line\">* Returns the number of rows</div><div class=\"line\">**/</div><div class=\"line\">- (NSInteger)numberOfRows;</div><div class=\"line\"></div><div class=\"line\">@optional</div><div class=\"line\">/**</div><div class=\"line\">* Returns the height of specified index. default value is 50.</div><div class=\"line\">**/</div><div class=\"line\">- (CGFloat)heightForRowAtIndex:(NSInteger)index;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">* Returns the attributedTitle of specified index.</div><div class=\"line\">**/</div><div class=\"line\">- (NSAttributedString*)attributedTitleForRowAtIndex:(NSInteger)index;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">* Returns the image of specified index.</div><div class=\"line\">**/</div><div class=\"line\">- (UIImage*)imageForRowAtIndex:(NSInteger)index;</div><div class=\"line\"></div><div class=\"line\">/**</div><div class=\"line\">* Returns the accessoryViews placed at the end of specified index.</div><div class=\"line\">**/</div><div class=\"line\">- (NSArray&lt;UIView*&gt;*)accessoryViewsAtIndex:(NSInteger)index;</div><div class=\"line\">@end;</div></pre></td></tr></table></figure>\n<h3 id=\"How-it-works\"><a href=\"#How-it-works\" class=\"headerlink\" title=\"How it works\"></a>How it works</h3><p>​    LTxMenu use <strong>LTxMenuItem</strong> class to config view showed in row. and <strong>LTxMenuView</strong> class with callback methods to calculate the UI performance .  draw arrow and the border use  <strong>UIBezierPath</strong> class . and the show/hide animation use <strong>UIKit</strong>.</p>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><p>​    <a href=\"https://github.com/kolyvan/kxmenu\" target=\"_blank\" rel=\"external\">https://github.com/kolyvan/kxmenu</a></p>"},{"layout":"post","title":"LTxMenu","date":"2016-10-20T07:10:12.000Z","author":"liangtong","catalog":true,"_content":"\n* content\n{:toc}\n\n**[ Update v1.0.0 ]** Similar to Facebook News Feed , Alipay Life , QZone and other social applications . click a drop-down button to display more functions\n\n\n\n### Introduction\n\n​         In Facebook News Feed , Alipay Life , QZone and other social applications , they all contain a function drop-down button which would show a list of more functions when taped . I didn’t find any on GitHub , so I wrote a similar UI controls myself using Objective-C. ：\n\n![](https://raw.githubusercontent.com/l900416/LTxMenu/64a7706ae5c6fbde8e7b5f2eb6706b6f56795b05/screenshots/1.gif)\n\n>>GitHub link : <a href=\"https://github.com/l900416/LTxMenu\">LTxMenu</a>\n\n<!-- more -->\n\n### Get Start\n> * Manually add the files into your Xcode project.\n> * LTxMenu is available as LTxMenu in Cocoapods.\n\n\n### How To Use\n​\tCreate a LTxMenuView Object:\n\n```Objective-C\n    @property (nonatomic, strong)LTxMenuView* menuView;\n```\n​\tI was too lazy to write a protocol 😄，use callback methods：\n\n```Objective-C\n    _menuView = [[LTxMenuView alloc] init];//init\n    __weak __typeof(self) weakSelf = self;\n    _menuView.numberOfRows = ^(){//row numbers\n        return (int)weakSelf.menuItems.count;\n    };\n    _menuView.heightForRow = ^(NSInteger row){//height of a row\n        return 50.f;\n    };\n    _menuView.rowAtIndex = ^(NSInteger row){//the content of a row\n        NSDictionary* menuItem = [weakSelf.menuItems objectAtIndex:row];\n        return [LTxMenuItem menuItemWithImage:[menuItem objectForKey:@\"image\"]\n                                        title:[menuItem objectForKey:@\"title\"]\n                                rightBtnItems:[menuItem objectForKey:@\"more\"]//An array contains subClass of UIView\n                                     tapBlock:^(NSString *identifier) {\n                                         NSLog(@\"tap at %@\",identifier);\n                                         __strong __typeof(weakSelf)strongSelf = weakSelf;\n                                         [strongSelf.menuView dismissMenu];\n                                     }];\n    };\n    [_menuView showMenuInView:self.view\n                     fromRect:sender.frame];\n```\n\n### How it works\n​\tLTxMenu use **LTxMenuItem** class to config view showed in row. and **LTxMenuView** class with callback methods to calculate the UI performance .  draw arrow and the border use  **UIBezierPath** class . and the show/hide animation use **UIKit**.\n\n### Reference\n\n​\thttps://github.com/kolyvan/kxmenu\n\n\n\n\n\n\n\n\n\n","source":"_posts/iOS_ObjC_LTxMenu_v1.0.0.md","raw":"---\nlayout:     post\ntitle:      LTxMenu\ndate:       2016-10-20 15:10:12\nauthor:     liangtong\ncatalog: true\ncategories: iOS\ntags: Menu \n\n---\n\n* content\n{:toc}\n\n**[ Update v1.0.0 ]** Similar to Facebook News Feed , Alipay Life , QZone and other social applications . click a drop-down button to display more functions\n\n\n\n### Introduction\n\n​         In Facebook News Feed , Alipay Life , QZone and other social applications , they all contain a function drop-down button which would show a list of more functions when taped . I didn’t find any on GitHub , so I wrote a similar UI controls myself using Objective-C. ：\n\n![](https://raw.githubusercontent.com/l900416/LTxMenu/64a7706ae5c6fbde8e7b5f2eb6706b6f56795b05/screenshots/1.gif)\n\n>>GitHub link : <a href=\"https://github.com/l900416/LTxMenu\">LTxMenu</a>\n\n<!-- more -->\n\n### Get Start\n> * Manually add the files into your Xcode project.\n> * LTxMenu is available as LTxMenu in Cocoapods.\n\n\n### How To Use\n​\tCreate a LTxMenuView Object:\n\n```Objective-C\n    @property (nonatomic, strong)LTxMenuView* menuView;\n```\n​\tI was too lazy to write a protocol 😄，use callback methods：\n\n```Objective-C\n    _menuView = [[LTxMenuView alloc] init];//init\n    __weak __typeof(self) weakSelf = self;\n    _menuView.numberOfRows = ^(){//row numbers\n        return (int)weakSelf.menuItems.count;\n    };\n    _menuView.heightForRow = ^(NSInteger row){//height of a row\n        return 50.f;\n    };\n    _menuView.rowAtIndex = ^(NSInteger row){//the content of a row\n        NSDictionary* menuItem = [weakSelf.menuItems objectAtIndex:row];\n        return [LTxMenuItem menuItemWithImage:[menuItem objectForKey:@\"image\"]\n                                        title:[menuItem objectForKey:@\"title\"]\n                                rightBtnItems:[menuItem objectForKey:@\"more\"]//An array contains subClass of UIView\n                                     tapBlock:^(NSString *identifier) {\n                                         NSLog(@\"tap at %@\",identifier);\n                                         __strong __typeof(weakSelf)strongSelf = weakSelf;\n                                         [strongSelf.menuView dismissMenu];\n                                     }];\n    };\n    [_menuView showMenuInView:self.view\n                     fromRect:sender.frame];\n```\n\n### How it works\n​\tLTxMenu use **LTxMenuItem** class to config view showed in row. and **LTxMenuView** class with callback methods to calculate the UI performance .  draw arrow and the border use  **UIBezierPath** class . and the show/hide animation use **UIKit**.\n\n### Reference\n\n​\thttps://github.com/kolyvan/kxmenu\n\n\n\n\n\n\n\n\n\n","slug":"iOS_ObjC_LTxMenu_v1.0.0","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4tp001uoko855agfdwh","content":"<ul>\n<li>content<br>{:toc}</li>\n</ul>\n<p><strong>[ Update v1.0.0 ]</strong> Similar to Facebook News Feed , Alipay Life , QZone and other social applications . click a drop-down button to display more functions</p>\n<h3 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h3><p>​         In Facebook News Feed , Alipay Life , QZone and other social applications , they all contain a function drop-down button which would show a list of more functions when taped . I didn’t find any on GitHub , so I wrote a similar UI controls myself using Objective-C. ：</p>\n<p><img src=\"https://raw.githubusercontent.com/l900416/LTxMenu/64a7706ae5c6fbde8e7b5f2eb6706b6f56795b05/screenshots/1.gif\" alt=\"\"></p>\n<blockquote>\n<blockquote>\n<p>GitHub link : <a href=\"https://github.com/l900416/LTxMenu\" target=\"_blank\" rel=\"external\">LTxMenu</a></p>\n</blockquote>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"Get-Start\"><a href=\"#Get-Start\" class=\"headerlink\" title=\"Get Start\"></a>Get Start</h3><blockquote>\n<ul>\n<li>Manually add the files into your Xcode project.</li>\n<li>LTxMenu is available as LTxMenu in Cocoapods.</li>\n</ul>\n</blockquote>\n<h3 id=\"How-To-Use\"><a href=\"#How-To-Use\" class=\"headerlink\" title=\"How To Use\"></a>How To Use</h3><p>​    Create a LTxMenuView Object:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property (nonatomic, strong)LTxMenuView* menuView;</div></pre></td></tr></table></figure>\n<p>​    I was too lazy to write a protocol 😄，use callback methods：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">_menuView = [[LTxMenuView alloc] init];//init</div><div class=\"line\">__weak __typeof(self) weakSelf = self;</div><div class=\"line\">_menuView.numberOfRows = ^()&#123;//row numbers</div><div class=\"line\">    return (int)weakSelf.menuItems.count;</div><div class=\"line\">&#125;;</div><div class=\"line\">_menuView.heightForRow = ^(NSInteger row)&#123;//height of a row</div><div class=\"line\">    return 50.f;</div><div class=\"line\">&#125;;</div><div class=\"line\">_menuView.rowAtIndex = ^(NSInteger row)&#123;//the content of a row</div><div class=\"line\">    NSDictionary* menuItem = [weakSelf.menuItems objectAtIndex:row];</div><div class=\"line\">    return [LTxMenuItem menuItemWithImage:[menuItem objectForKey:@&quot;image&quot;]</div><div class=\"line\">                                    title:[menuItem objectForKey:@&quot;title&quot;]</div><div class=\"line\">                            rightBtnItems:[menuItem objectForKey:@&quot;more&quot;]//An array contains subClass of UIView</div><div class=\"line\">                                 tapBlock:^(NSString *identifier) &#123;</div><div class=\"line\">                                     NSLog(@&quot;tap at %@&quot;,identifier);</div><div class=\"line\">                                     __strong __typeof(weakSelf)strongSelf = weakSelf;</div><div class=\"line\">                                     [strongSelf.menuView dismissMenu];</div><div class=\"line\">                                 &#125;];</div><div class=\"line\">&#125;;</div><div class=\"line\">[_menuView showMenuInView:self.view</div><div class=\"line\">                 fromRect:sender.frame];</div></pre></td></tr></table></figure>\n<h3 id=\"How-it-works\"><a href=\"#How-it-works\" class=\"headerlink\" title=\"How it works\"></a>How it works</h3><p>​    LTxMenu use <strong>LTxMenuItem</strong> class to config view showed in row. and <strong>LTxMenuView</strong> class with callback methods to calculate the UI performance .  draw arrow and the border use  <strong>UIBezierPath</strong> class . and the show/hide animation use <strong>UIKit</strong>.</p>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><p>​    <a href=\"https://github.com/kolyvan/kxmenu\" target=\"_blank\" rel=\"external\">https://github.com/kolyvan/kxmenu</a></p>\n","site":{"data":{}},"excerpt":"<ul>\n<li>content<br>{:toc}</li>\n</ul>\n<p><strong>[ Update v1.0.0 ]</strong> Similar to Facebook News Feed , Alipay Life , QZone and other social applications . click a drop-down button to display more functions</p>\n<h3 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h3><p>​         In Facebook News Feed , Alipay Life , QZone and other social applications , they all contain a function drop-down button which would show a list of more functions when taped . I didn’t find any on GitHub , so I wrote a similar UI controls myself using Objective-C. ：</p>\n<p><img src=\"https://raw.githubusercontent.com/l900416/LTxMenu/64a7706ae5c6fbde8e7b5f2eb6706b6f56795b05/screenshots/1.gif\" alt=\"\"></p>\n<blockquote>\n<blockquote>\n<p>GitHub link : <a href=\"https://github.com/l900416/LTxMenu\" target=\"_blank\" rel=\"external\">LTxMenu</a></p>\n</blockquote>\n</blockquote>","more":"<h3 id=\"Get-Start\"><a href=\"#Get-Start\" class=\"headerlink\" title=\"Get Start\"></a>Get Start</h3><blockquote>\n<ul>\n<li>Manually add the files into your Xcode project.</li>\n<li>LTxMenu is available as LTxMenu in Cocoapods.</li>\n</ul>\n</blockquote>\n<h3 id=\"How-To-Use\"><a href=\"#How-To-Use\" class=\"headerlink\" title=\"How To Use\"></a>How To Use</h3><p>​    Create a LTxMenuView Object:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property (nonatomic, strong)LTxMenuView* menuView;</div></pre></td></tr></table></figure>\n<p>​    I was too lazy to write a protocol 😄，use callback methods：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">_menuView = [[LTxMenuView alloc] init];//init</div><div class=\"line\">__weak __typeof(self) weakSelf = self;</div><div class=\"line\">_menuView.numberOfRows = ^()&#123;//row numbers</div><div class=\"line\">    return (int)weakSelf.menuItems.count;</div><div class=\"line\">&#125;;</div><div class=\"line\">_menuView.heightForRow = ^(NSInteger row)&#123;//height of a row</div><div class=\"line\">    return 50.f;</div><div class=\"line\">&#125;;</div><div class=\"line\">_menuView.rowAtIndex = ^(NSInteger row)&#123;//the content of a row</div><div class=\"line\">    NSDictionary* menuItem = [weakSelf.menuItems objectAtIndex:row];</div><div class=\"line\">    return [LTxMenuItem menuItemWithImage:[menuItem objectForKey:@&quot;image&quot;]</div><div class=\"line\">                                    title:[menuItem objectForKey:@&quot;title&quot;]</div><div class=\"line\">                            rightBtnItems:[menuItem objectForKey:@&quot;more&quot;]//An array contains subClass of UIView</div><div class=\"line\">                                 tapBlock:^(NSString *identifier) &#123;</div><div class=\"line\">                                     NSLog(@&quot;tap at %@&quot;,identifier);</div><div class=\"line\">                                     __strong __typeof(weakSelf)strongSelf = weakSelf;</div><div class=\"line\">                                     [strongSelf.menuView dismissMenu];</div><div class=\"line\">                                 &#125;];</div><div class=\"line\">&#125;;</div><div class=\"line\">[_menuView showMenuInView:self.view</div><div class=\"line\">                 fromRect:sender.frame];</div></pre></td></tr></table></figure>\n<h3 id=\"How-it-works\"><a href=\"#How-it-works\" class=\"headerlink\" title=\"How it works\"></a>How it works</h3><p>​    LTxMenu use <strong>LTxMenuItem</strong> class to config view showed in row. and <strong>LTxMenuView</strong> class with callback methods to calculate the UI performance .  draw arrow and the border use  <strong>UIBezierPath</strong> class . and the show/hide animation use <strong>UIKit</strong>.</p>\n<h3 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h3><p>​    <a href=\"https://github.com/kolyvan/kxmenu\" target=\"_blank\" rel=\"external\">https://github.com/kolyvan/kxmenu</a></p>"},{"layout":"post","title":"UISearchBar自定义","date":"2016-10-19T09:50:00.000Z","author":"liangtong","catalog":true,"_content":"\n\n参照一些常用应用对UISearchBar进行UI展示自定义\n\n\n\n\n#### 前言\n\n​        系统默认的搜索栏（UISearchBar）默认样子真心不好看，而平时iOS移动项目中又缺不了搜索功能，参照一些常用应用对UISearchBar进行UI展示自定义，效果图如下：\n\n![](/post/iOS/Objective-C/rendering.gif)\n\n#### UISearchBar介绍\n\n​        如图所示，包括placeholder、textfiled、clearButton、bookmarkButton、leftView等：\n\n![](/post/iOS/Objective-C/default_1.png)\n\n>> * ① SearchBar的TextField的leftView；\n>> * ② SearchBar的TextField的placeholder；\n>> * ③ SearchBar的BookmarkIcon，默认不显示；\n\n\n\n<!-- more -->\n\n\n![](/post/iOS/Objective-C/default_2.png)\n\n>> * ④ SearchBar的搜索Text；\n>> * ⑤ SearchBar的ClearButton；\n\n#### 实现步骤\n\n* **1、修改SearchBar背景图**\n\n```objective-c\n//修改SearchBar背景（透明）图片，去除默认的黑线\n[self setBackgroundImage:[UIImage new]];\n```\n\n* **2、修改所搜索框背景图片，并切圆角**\n\n```objective-c\n//输入框背景图片\n[self setSearchFieldBackgroundImage:[self searchFieldBackgroundImage] forState:UIControlStateNormal];\n//将输入框切圆角\n[self setSearchTextBackgroundCorner];\n```\n\n![](/post/iOS/Objective-C/process_2.png)\n\n* **3、显示BookmarkButton，并设置其显示图标**\n\n```objective-c\n//显示BookmarkButton，并设置其图标（照相机）\nself.showsBookmarkButton = YES;\n[self setImage:[UIImage imageNamed:@\"ic_searchbar_camera\"] forSearchBarIcon:UISearchBarIconBookmark  state:UIControlStateNormal];\n```\n\n![](/post/iOS/Objective-C/process_3.png)\n\n* **4、设置「清空」图标图标**\n\n```objective-c\n//文本发生变更的时候，修改「清空」图标\n[self setImage:[UIImage imageNamed:@\"ic_searchbar_clear\"] forSearchBarIcon:UISearchBarIconClear  state:UIControlStateNormal];\n[self setImage:[UIImage imageNamed:@\"ic_searchbar_clear\"] forSearchBarIcon:UISearchBarIconClear  state:UIControlStateHighlighted];\n```\n\n![](/post/iOS/Objective-C/process_4.png)\n\n* **5、修改搜索框左侧的图标**\n\n```objective-c\n//搜索框左侧的搜索图标修改（默认是灰色）\nUITextField* searchField = [self valueForKey:@\"_searchField\"];\nUIImageView* searchIV = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@\"ic_searchbar_search\"]];\nsearchField.leftView = searchIV;\nsearchField.leftViewMode = UITextFieldViewModeAlways;\n```\n\n* **6、修改输入框文本颜色**\n\n```objective-c\n//改变searcher的textcolor\nsearchField.textColor = [UIColor whiteColor];\n//改变placeholder的颜色\n[searchField setValue:[UIColor whiteColor] forKeyPath:@\"_placeholderLabel.textColor\"];\n```\n\n![](/post/iOS/Objective-C/process_6.png)\n\n* **7、附上调用方法**\n\n```objective-c\n//搜索框的背景图片\n- (UIImage*) searchFieldBackgroundImage\n{\n    CGFloat height = 32.f;\n    UIColor* bgColor = [UIColor colorWithRed:47/255.0 green:123/255.0 blue:200/255.0 alpha:0.5];\n    CGRect r= CGRectMake(0.0f, 0.0f, 1.0f, height);\n    UIGraphicsBeginImageContext(r.size);\n    CGContextRef context = UIGraphicsGetCurrentContext();\n    CGContextSetFillColorWithColor(context, [bgColor CGColor]);\n    CGContextFillRect(context, r);\n    UIImage *img = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n    return img;\n}\n\n//切圆角\n-(void)setSearchTextBackgroundCorner{\n    for (UIView *subview in self.subviews) {\n        for(UIView* grandSonView in subview.subviews){\n            if ([grandSonView isKindOfClass:NSClassFromString(@\"UISearchBarBackground\")]) {\n                grandSonView.alpha = 0.0f;\n            }else if([grandSonView isKindOfClass:NSClassFromString(@\"UISearchBarTextField\")] ){\n                grandSonView.layer.cornerRadius = 5.0f;\n                grandSonView.layer.masksToBounds = YES;\n            }else{\n                grandSonView.alpha = 0.0f;\n            }\n        }\n    }\n}\n```\n\n\n\n#### 源码下载\n\nhttps://pan.baidu.com/s/1i5JiW3z\n\n\n\n#### 参考资料\n\nhttps://developer.apple.com/reference/uikit/uisearchbar\n\nhttp://stackoverflow.com/questions/2139115/uisearchbar-clear-background-color-or-set-background-image-iphone-sdk/5557255#5557255\n\n\n\n\n\n\n\n\n\n","source":"_posts/iOS_ObjC_SearchBar.md","raw":"---\nlayout:     post\ntitle:      UISearchBar自定义\ndate:       2016-10-19 17:50:00\nauthor:     liangtong\ncatalog: true\ncategories: iOS\ntags:  Note\n\n---\n\n\n参照一些常用应用对UISearchBar进行UI展示自定义\n\n\n\n\n#### 前言\n\n​        系统默认的搜索栏（UISearchBar）默认样子真心不好看，而平时iOS移动项目中又缺不了搜索功能，参照一些常用应用对UISearchBar进行UI展示自定义，效果图如下：\n\n![](/post/iOS/Objective-C/rendering.gif)\n\n#### UISearchBar介绍\n\n​        如图所示，包括placeholder、textfiled、clearButton、bookmarkButton、leftView等：\n\n![](/post/iOS/Objective-C/default_1.png)\n\n>> * ① SearchBar的TextField的leftView；\n>> * ② SearchBar的TextField的placeholder；\n>> * ③ SearchBar的BookmarkIcon，默认不显示；\n\n\n\n<!-- more -->\n\n\n![](/post/iOS/Objective-C/default_2.png)\n\n>> * ④ SearchBar的搜索Text；\n>> * ⑤ SearchBar的ClearButton；\n\n#### 实现步骤\n\n* **1、修改SearchBar背景图**\n\n```objective-c\n//修改SearchBar背景（透明）图片，去除默认的黑线\n[self setBackgroundImage:[UIImage new]];\n```\n\n* **2、修改所搜索框背景图片，并切圆角**\n\n```objective-c\n//输入框背景图片\n[self setSearchFieldBackgroundImage:[self searchFieldBackgroundImage] forState:UIControlStateNormal];\n//将输入框切圆角\n[self setSearchTextBackgroundCorner];\n```\n\n![](/post/iOS/Objective-C/process_2.png)\n\n* **3、显示BookmarkButton，并设置其显示图标**\n\n```objective-c\n//显示BookmarkButton，并设置其图标（照相机）\nself.showsBookmarkButton = YES;\n[self setImage:[UIImage imageNamed:@\"ic_searchbar_camera\"] forSearchBarIcon:UISearchBarIconBookmark  state:UIControlStateNormal];\n```\n\n![](/post/iOS/Objective-C/process_3.png)\n\n* **4、设置「清空」图标图标**\n\n```objective-c\n//文本发生变更的时候，修改「清空」图标\n[self setImage:[UIImage imageNamed:@\"ic_searchbar_clear\"] forSearchBarIcon:UISearchBarIconClear  state:UIControlStateNormal];\n[self setImage:[UIImage imageNamed:@\"ic_searchbar_clear\"] forSearchBarIcon:UISearchBarIconClear  state:UIControlStateHighlighted];\n```\n\n![](/post/iOS/Objective-C/process_4.png)\n\n* **5、修改搜索框左侧的图标**\n\n```objective-c\n//搜索框左侧的搜索图标修改（默认是灰色）\nUITextField* searchField = [self valueForKey:@\"_searchField\"];\nUIImageView* searchIV = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@\"ic_searchbar_search\"]];\nsearchField.leftView = searchIV;\nsearchField.leftViewMode = UITextFieldViewModeAlways;\n```\n\n* **6、修改输入框文本颜色**\n\n```objective-c\n//改变searcher的textcolor\nsearchField.textColor = [UIColor whiteColor];\n//改变placeholder的颜色\n[searchField setValue:[UIColor whiteColor] forKeyPath:@\"_placeholderLabel.textColor\"];\n```\n\n![](/post/iOS/Objective-C/process_6.png)\n\n* **7、附上调用方法**\n\n```objective-c\n//搜索框的背景图片\n- (UIImage*) searchFieldBackgroundImage\n{\n    CGFloat height = 32.f;\n    UIColor* bgColor = [UIColor colorWithRed:47/255.0 green:123/255.0 blue:200/255.0 alpha:0.5];\n    CGRect r= CGRectMake(0.0f, 0.0f, 1.0f, height);\n    UIGraphicsBeginImageContext(r.size);\n    CGContextRef context = UIGraphicsGetCurrentContext();\n    CGContextSetFillColorWithColor(context, [bgColor CGColor]);\n    CGContextFillRect(context, r);\n    UIImage *img = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n    return img;\n}\n\n//切圆角\n-(void)setSearchTextBackgroundCorner{\n    for (UIView *subview in self.subviews) {\n        for(UIView* grandSonView in subview.subviews){\n            if ([grandSonView isKindOfClass:NSClassFromString(@\"UISearchBarBackground\")]) {\n                grandSonView.alpha = 0.0f;\n            }else if([grandSonView isKindOfClass:NSClassFromString(@\"UISearchBarTextField\")] ){\n                grandSonView.layer.cornerRadius = 5.0f;\n                grandSonView.layer.masksToBounds = YES;\n            }else{\n                grandSonView.alpha = 0.0f;\n            }\n        }\n    }\n}\n```\n\n\n\n#### 源码下载\n\nhttps://pan.baidu.com/s/1i5JiW3z\n\n\n\n#### 参考资料\n\nhttps://developer.apple.com/reference/uikit/uisearchbar\n\nhttp://stackoverflow.com/questions/2139115/uisearchbar-clear-background-color-or-set-background-image-iphone-sdk/5557255#5557255\n\n\n\n\n\n\n\n\n\n","slug":"iOS_ObjC_SearchBar","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4tr001woko8n9pud0nx","content":"<p>参照一些常用应用对UISearchBar进行UI展示自定义</p>\n<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>​        系统默认的搜索栏（UISearchBar）默认样子真心不好看，而平时iOS移动项目中又缺不了搜索功能，参照一些常用应用对UISearchBar进行UI展示自定义，效果图如下：</p>\n<p><img src=\"/post/iOS/Objective-C/rendering.gif\" alt=\"\"></p>\n<h4 id=\"UISearchBar介绍\"><a href=\"#UISearchBar介绍\" class=\"headerlink\" title=\"UISearchBar介绍\"></a>UISearchBar介绍</h4><p>​        如图所示，包括placeholder、textfiled、clearButton、bookmarkButton、leftView等：</p>\n<p><img src=\"/post/iOS/Objective-C/default_1.png\" alt=\"\"></p>\n<blockquote>\n<blockquote>\n<ul>\n<li>① SearchBar的TextField的leftView；</li>\n<li>② SearchBar的TextField的placeholder；</li>\n<li>③ SearchBar的BookmarkIcon，默认不显示；</li>\n</ul>\n</blockquote>\n</blockquote>\n<a id=\"more\"></a>\n<p><img src=\"/post/iOS/Objective-C/default_2.png\" alt=\"\"></p>\n<blockquote>\n<blockquote>\n<ul>\n<li>④ SearchBar的搜索Text；</li>\n<li>⑤ SearchBar的ClearButton；</li>\n</ul>\n</blockquote>\n</blockquote>\n<h4 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h4><ul>\n<li><strong>1、修改SearchBar背景图</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">//修改SearchBar背景（透明）图片，去除默认的黑线</div><div class=\"line\">[self setBackgroundImage:[UIImage new]];</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>2、修改所搜索框背景图片，并切圆角</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//输入框背景图片</div><div class=\"line\">[self setSearchFieldBackgroundImage:[self searchFieldBackgroundImage] forState:UIControlStateNormal];</div><div class=\"line\">//将输入框切圆角</div><div class=\"line\">[self setSearchTextBackgroundCorner];</div></pre></td></tr></table></figure>\n<p><img src=\"/post/iOS/Objective-C/process_2.png\" alt=\"\"></p>\n<ul>\n<li><strong>3、显示BookmarkButton，并设置其显示图标</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">//显示BookmarkButton，并设置其图标（照相机）</div><div class=\"line\">self.showsBookmarkButton = YES;</div><div class=\"line\">[self setImage:[UIImage imageNamed:@&quot;ic_searchbar_camera&quot;] forSearchBarIcon:UISearchBarIconBookmark  state:UIControlStateNormal];</div></pre></td></tr></table></figure>\n<p><img src=\"/post/iOS/Objective-C/process_3.png\" alt=\"\"></p>\n<ul>\n<li><strong>4、设置「清空」图标图标</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">//文本发生变更的时候，修改「清空」图标</div><div class=\"line\">[self setImage:[UIImage imageNamed:@&quot;ic_searchbar_clear&quot;] forSearchBarIcon:UISearchBarIconClear  state:UIControlStateNormal];</div><div class=\"line\">[self setImage:[UIImage imageNamed:@&quot;ic_searchbar_clear&quot;] forSearchBarIcon:UISearchBarIconClear  state:UIControlStateHighlighted];</div></pre></td></tr></table></figure>\n<p><img src=\"/post/iOS/Objective-C/process_4.png\" alt=\"\"></p>\n<ul>\n<li><strong>5、修改搜索框左侧的图标</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//搜索框左侧的搜索图标修改（默认是灰色）</div><div class=\"line\">UITextField* searchField = [self valueForKey:@&quot;_searchField&quot;];</div><div class=\"line\">UIImageView* searchIV = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;ic_searchbar_search&quot;]];</div><div class=\"line\">searchField.leftView = searchIV;</div><div class=\"line\">searchField.leftViewMode = UITextFieldViewModeAlways;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>6、修改输入框文本颜色</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//改变searcher的textcolor</div><div class=\"line\">searchField.textColor = [UIColor whiteColor];</div><div class=\"line\">//改变placeholder的颜色</div><div class=\"line\">[searchField setValue:[UIColor whiteColor] forKeyPath:@&quot;_placeholderLabel.textColor&quot;];</div></pre></td></tr></table></figure>\n<p><img src=\"/post/iOS/Objective-C/process_6.png\" alt=\"\"></p>\n<ul>\n<li><strong>7、附上调用方法</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">//搜索框的背景图片</div><div class=\"line\">- (UIImage*) searchFieldBackgroundImage</div><div class=\"line\">&#123;</div><div class=\"line\">    CGFloat height = 32.f;</div><div class=\"line\">    UIColor* bgColor = [UIColor colorWithRed:47/255.0 green:123/255.0 blue:200/255.0 alpha:0.5];</div><div class=\"line\">    CGRect r= CGRectMake(0.0f, 0.0f, 1.0f, height);</div><div class=\"line\">    UIGraphicsBeginImageContext(r.size);</div><div class=\"line\">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class=\"line\">    CGContextSetFillColorWithColor(context, [bgColor CGColor]);</div><div class=\"line\">    CGContextFillRect(context, r);</div><div class=\"line\">    UIImage *img = UIGraphicsGetImageFromCurrentImageContext();</div><div class=\"line\">    UIGraphicsEndImageContext();</div><div class=\"line\">    return img;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//切圆角</div><div class=\"line\">-(void)setSearchTextBackgroundCorner&#123;</div><div class=\"line\">    for (UIView *subview in self.subviews) &#123;</div><div class=\"line\">        for(UIView* grandSonView in subview.subviews)&#123;</div><div class=\"line\">            if ([grandSonView isKindOfClass:NSClassFromString(@&quot;UISearchBarBackground&quot;)]) &#123;</div><div class=\"line\">                grandSonView.alpha = 0.0f;</div><div class=\"line\">            &#125;else if([grandSonView isKindOfClass:NSClassFromString(@&quot;UISearchBarTextField&quot;)] )&#123;</div><div class=\"line\">                grandSonView.layer.cornerRadius = 5.0f;</div><div class=\"line\">                grandSonView.layer.masksToBounds = YES;</div><div class=\"line\">            &#125;else&#123;</div><div class=\"line\">                grandSonView.alpha = 0.0f;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"源码下载\"><a href=\"#源码下载\" class=\"headerlink\" title=\"源码下载\"></a>源码下载</h4><p><a href=\"https://pan.baidu.com/s/1i5JiW3z\" target=\"_blank\" rel=\"external\">https://pan.baidu.com/s/1i5JiW3z</a></p>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><p><a href=\"https://developer.apple.com/reference/uikit/uisearchbar\" target=\"_blank\" rel=\"external\">https://developer.apple.com/reference/uikit/uisearchbar</a></p>\n<p><a href=\"http://stackoverflow.com/questions/2139115/uisearchbar-clear-background-color-or-set-background-image-iphone-sdk/5557255#5557255\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/2139115/uisearchbar-clear-background-color-or-set-background-image-iphone-sdk/5557255#5557255</a></p>\n","site":{"data":{}},"excerpt":"<p>参照一些常用应用对UISearchBar进行UI展示自定义</p>\n<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>​        系统默认的搜索栏（UISearchBar）默认样子真心不好看，而平时iOS移动项目中又缺不了搜索功能，参照一些常用应用对UISearchBar进行UI展示自定义，效果图如下：</p>\n<p><img src=\"/post/iOS/Objective-C/rendering.gif\" alt=\"\"></p>\n<h4 id=\"UISearchBar介绍\"><a href=\"#UISearchBar介绍\" class=\"headerlink\" title=\"UISearchBar介绍\"></a>UISearchBar介绍</h4><p>​        如图所示，包括placeholder、textfiled、clearButton、bookmarkButton、leftView等：</p>\n<p><img src=\"/post/iOS/Objective-C/default_1.png\" alt=\"\"></p>\n<blockquote>\n<blockquote>\n<ul>\n<li>① SearchBar的TextField的leftView；</li>\n<li>② SearchBar的TextField的placeholder；</li>\n<li>③ SearchBar的BookmarkIcon，默认不显示；</li>\n</ul>\n</blockquote>\n</blockquote>","more":"<p><img src=\"/post/iOS/Objective-C/default_2.png\" alt=\"\"></p>\n<blockquote>\n<blockquote>\n<ul>\n<li>④ SearchBar的搜索Text；</li>\n<li>⑤ SearchBar的ClearButton；</li>\n</ul>\n</blockquote>\n</blockquote>\n<h4 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h4><ul>\n<li><strong>1、修改SearchBar背景图</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">//修改SearchBar背景（透明）图片，去除默认的黑线</div><div class=\"line\">[self setBackgroundImage:[UIImage new]];</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>2、修改所搜索框背景图片，并切圆角</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//输入框背景图片</div><div class=\"line\">[self setSearchFieldBackgroundImage:[self searchFieldBackgroundImage] forState:UIControlStateNormal];</div><div class=\"line\">//将输入框切圆角</div><div class=\"line\">[self setSearchTextBackgroundCorner];</div></pre></td></tr></table></figure>\n<p><img src=\"/post/iOS/Objective-C/process_2.png\" alt=\"\"></p>\n<ul>\n<li><strong>3、显示BookmarkButton，并设置其显示图标</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">//显示BookmarkButton，并设置其图标（照相机）</div><div class=\"line\">self.showsBookmarkButton = YES;</div><div class=\"line\">[self setImage:[UIImage imageNamed:@&quot;ic_searchbar_camera&quot;] forSearchBarIcon:UISearchBarIconBookmark  state:UIControlStateNormal];</div></pre></td></tr></table></figure>\n<p><img src=\"/post/iOS/Objective-C/process_3.png\" alt=\"\"></p>\n<ul>\n<li><strong>4、设置「清空」图标图标</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">//文本发生变更的时候，修改「清空」图标</div><div class=\"line\">[self setImage:[UIImage imageNamed:@&quot;ic_searchbar_clear&quot;] forSearchBarIcon:UISearchBarIconClear  state:UIControlStateNormal];</div><div class=\"line\">[self setImage:[UIImage imageNamed:@&quot;ic_searchbar_clear&quot;] forSearchBarIcon:UISearchBarIconClear  state:UIControlStateHighlighted];</div></pre></td></tr></table></figure>\n<p><img src=\"/post/iOS/Objective-C/process_4.png\" alt=\"\"></p>\n<ul>\n<li><strong>5、修改搜索框左侧的图标</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//搜索框左侧的搜索图标修改（默认是灰色）</div><div class=\"line\">UITextField* searchField = [self valueForKey:@&quot;_searchField&quot;];</div><div class=\"line\">UIImageView* searchIV = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;ic_searchbar_search&quot;]];</div><div class=\"line\">searchField.leftView = searchIV;</div><div class=\"line\">searchField.leftViewMode = UITextFieldViewModeAlways;</div></pre></td></tr></table></figure>\n<ul>\n<li><strong>6、修改输入框文本颜色</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//改变searcher的textcolor</div><div class=\"line\">searchField.textColor = [UIColor whiteColor];</div><div class=\"line\">//改变placeholder的颜色</div><div class=\"line\">[searchField setValue:[UIColor whiteColor] forKeyPath:@&quot;_placeholderLabel.textColor&quot;];</div></pre></td></tr></table></figure>\n<p><img src=\"/post/iOS/Objective-C/process_6.png\" alt=\"\"></p>\n<ul>\n<li><strong>7、附上调用方法</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">//搜索框的背景图片</div><div class=\"line\">- (UIImage*) searchFieldBackgroundImage</div><div class=\"line\">&#123;</div><div class=\"line\">    CGFloat height = 32.f;</div><div class=\"line\">    UIColor* bgColor = [UIColor colorWithRed:47/255.0 green:123/255.0 blue:200/255.0 alpha:0.5];</div><div class=\"line\">    CGRect r= CGRectMake(0.0f, 0.0f, 1.0f, height);</div><div class=\"line\">    UIGraphicsBeginImageContext(r.size);</div><div class=\"line\">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class=\"line\">    CGContextSetFillColorWithColor(context, [bgColor CGColor]);</div><div class=\"line\">    CGContextFillRect(context, r);</div><div class=\"line\">    UIImage *img = UIGraphicsGetImageFromCurrentImageContext();</div><div class=\"line\">    UIGraphicsEndImageContext();</div><div class=\"line\">    return img;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//切圆角</div><div class=\"line\">-(void)setSearchTextBackgroundCorner&#123;</div><div class=\"line\">    for (UIView *subview in self.subviews) &#123;</div><div class=\"line\">        for(UIView* grandSonView in subview.subviews)&#123;</div><div class=\"line\">            if ([grandSonView isKindOfClass:NSClassFromString(@&quot;UISearchBarBackground&quot;)]) &#123;</div><div class=\"line\">                grandSonView.alpha = 0.0f;</div><div class=\"line\">            &#125;else if([grandSonView isKindOfClass:NSClassFromString(@&quot;UISearchBarTextField&quot;)] )&#123;</div><div class=\"line\">                grandSonView.layer.cornerRadius = 5.0f;</div><div class=\"line\">                grandSonView.layer.masksToBounds = YES;</div><div class=\"line\">            &#125;else&#123;</div><div class=\"line\">                grandSonView.alpha = 0.0f;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"源码下载\"><a href=\"#源码下载\" class=\"headerlink\" title=\"源码下载\"></a>源码下载</h4><p><a href=\"https://pan.baidu.com/s/1i5JiW3z\" target=\"_blank\" rel=\"external\">https://pan.baidu.com/s/1i5JiW3z</a></p>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><p><a href=\"https://developer.apple.com/reference/uikit/uisearchbar\" target=\"_blank\" rel=\"external\">https://developer.apple.com/reference/uikit/uisearchbar</a></p>\n<p><a href=\"http://stackoverflow.com/questions/2139115/uisearchbar-clear-background-color-or-set-background-image-iphone-sdk/5557255#5557255\" target=\"_blank\" rel=\"external\">http://stackoverflow.com/questions/2139115/uisearchbar-clear-background-color-or-set-background-image-iphone-sdk/5557255#5557255</a></p>"},{"layout":"post","title":"文件的查看","date":"2017-06-19T13:25:19.000Z","author":"liangtong","catalog":true,"_content":"\n\n\n### 前言   \n\n对于特定格式（比如DWG等）文件的预览，没有必要耗费代价去自行开发功能，此时可能需要使用第三方应用来打开特定格式的文件。本文中记录三种方式：UIDocumentInteractionController、UIActivityViewController和特定第三方分享方式。\n\n<!-- more -->\n\n### UIDocumentInteractionController    \n\n界面表现上和AirDrop长得很像，这个也可以进行AirDrop蓝牙分享很强大的功能，与之不同的是，在与文件类型关联的备选APP列表中，会有类似 **[拷贝至 微信]** 应用的选择，如下：   \n![](/post/iOS/Objective-C/file_preview_1.png)    \n#### 创建对象   \n```Objective-C\n//引用\n@property (nonatomic, strong) UIDocumentInteractionController* docInteractionController;\n\n\n//初始化及动作定义\nNSURL* filePath = xxx;//文件路径\n_docInteractionController = [UIDocumentInteractionController  interactionControllerWithURL:filePath];\n_docInteractionController.delegate = self;\n[_docInteractionController presentOpenInMenuFromRect:CGRectZero\n                                              inView:self.view\n                                            animated:YES];\n```\n\n#### 实现常用协议\n```Objective-C\n#pragma mark - UIDocumentInteractionControllerDelegate\n-(void)documentInteractionController:(UIDocumentInteractionController *)controller willBeginSendingToApplication:(NSString *)application {//将要发送的应用\n}\n\n//下面是他的代理方法\n\n-(void)documentInteractionController:(UIDocumentInteractionController *)controller didEndSendingToApplication:(NSString *)application{//已经发送的应用\n\n}\n\n-(void)documentInteractionControllerDidDismissOpenInMenu:(UIDocumentInteractionController *)controller{//dismiss\n}\n```\n\n\n### UIActivityViewController    \n与UIDocumentInteractionController不同的是，UIActivityViewController无类似 **[拷贝至 微信]** 应用的选择。其界面和备选应用等可自行定制(屏蔽)，如下：    \n\n![](/post/iOS/Objective-C/file_preview_2.png)    \n\n```Objective-C\n    NSURL* fileURL = [NSURL URLWithString:@\"http://xxx.dwg\"];\n\n    //注：activityItems可以是包含文字、图片、URL地址的数组，至少包含一项；applicationActivities参数可以对平台进行自定义\n    UIActivityViewController *activity = [[UIActivityViewController alloc] initWithActivityItems:@[_fileURL]\n                                                                           applicationActivities:nil];\n    activity.excludedActivityTypes = @[UIActivityTypeAirDrop];//可用于屏蔽掉的应用列表，参照UIActivityType\n\n\n    UIPopoverPresentationController *popover = activity.popoverPresentationController;\n    if (popover) {\n        popover.sourceView = self.shareBtn;\n        popover.permittedArrowDirections = UIPopoverArrowDirectionUp;\n    }\n    [self presentViewController:activity animated:YES completion:nil];\n\n```   \n\n\n![](/post/iOS/Objective-C/file_preview_3.png) \n\n\n### 分享   \n\n第三方平台比如微信、新浪微博等平台的分享，集成其提供的SDK即可。此处不再赘述。若需要多分享平台集成，建议使用第三方平台比如友盟、ShareSDK等\n","source":"_posts/iOS_ObjC_file_preview.md","raw":"---\nlayout:     post\ntitle:      文件的查看\ndate:       2017-06-19 21:25:19\nauthor:     liangtong\ncatalog: true\ncategories: iOS\ntags: Note\n\n---\n\n\n\n### 前言   \n\n对于特定格式（比如DWG等）文件的预览，没有必要耗费代价去自行开发功能，此时可能需要使用第三方应用来打开特定格式的文件。本文中记录三种方式：UIDocumentInteractionController、UIActivityViewController和特定第三方分享方式。\n\n<!-- more -->\n\n### UIDocumentInteractionController    \n\n界面表现上和AirDrop长得很像，这个也可以进行AirDrop蓝牙分享很强大的功能，与之不同的是，在与文件类型关联的备选APP列表中，会有类似 **[拷贝至 微信]** 应用的选择，如下：   \n![](/post/iOS/Objective-C/file_preview_1.png)    \n#### 创建对象   \n```Objective-C\n//引用\n@property (nonatomic, strong) UIDocumentInteractionController* docInteractionController;\n\n\n//初始化及动作定义\nNSURL* filePath = xxx;//文件路径\n_docInteractionController = [UIDocumentInteractionController  interactionControllerWithURL:filePath];\n_docInteractionController.delegate = self;\n[_docInteractionController presentOpenInMenuFromRect:CGRectZero\n                                              inView:self.view\n                                            animated:YES];\n```\n\n#### 实现常用协议\n```Objective-C\n#pragma mark - UIDocumentInteractionControllerDelegate\n-(void)documentInteractionController:(UIDocumentInteractionController *)controller willBeginSendingToApplication:(NSString *)application {//将要发送的应用\n}\n\n//下面是他的代理方法\n\n-(void)documentInteractionController:(UIDocumentInteractionController *)controller didEndSendingToApplication:(NSString *)application{//已经发送的应用\n\n}\n\n-(void)documentInteractionControllerDidDismissOpenInMenu:(UIDocumentInteractionController *)controller{//dismiss\n}\n```\n\n\n### UIActivityViewController    \n与UIDocumentInteractionController不同的是，UIActivityViewController无类似 **[拷贝至 微信]** 应用的选择。其界面和备选应用等可自行定制(屏蔽)，如下：    \n\n![](/post/iOS/Objective-C/file_preview_2.png)    \n\n```Objective-C\n    NSURL* fileURL = [NSURL URLWithString:@\"http://xxx.dwg\"];\n\n    //注：activityItems可以是包含文字、图片、URL地址的数组，至少包含一项；applicationActivities参数可以对平台进行自定义\n    UIActivityViewController *activity = [[UIActivityViewController alloc] initWithActivityItems:@[_fileURL]\n                                                                           applicationActivities:nil];\n    activity.excludedActivityTypes = @[UIActivityTypeAirDrop];//可用于屏蔽掉的应用列表，参照UIActivityType\n\n\n    UIPopoverPresentationController *popover = activity.popoverPresentationController;\n    if (popover) {\n        popover.sourceView = self.shareBtn;\n        popover.permittedArrowDirections = UIPopoverArrowDirectionUp;\n    }\n    [self presentViewController:activity animated:YES completion:nil];\n\n```   \n\n\n![](/post/iOS/Objective-C/file_preview_3.png) \n\n\n### 分享   \n\n第三方平台比如微信、新浪微博等平台的分享，集成其提供的SDK即可。此处不再赘述。若需要多分享平台集成，建议使用第三方平台比如友盟、ShareSDK等\n","slug":"iOS_ObjC_file_preview","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4tu001zoko8uww46vkb","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>对于特定格式（比如DWG等）文件的预览，没有必要耗费代价去自行开发功能，此时可能需要使用第三方应用来打开特定格式的文件。本文中记录三种方式：UIDocumentInteractionController、UIActivityViewController和特定第三方分享方式。</p>\n<a id=\"more\"></a>\n<h3 id=\"UIDocumentInteractionController\"><a href=\"#UIDocumentInteractionController\" class=\"headerlink\" title=\"UIDocumentInteractionController\"></a>UIDocumentInteractionController</h3><p>界面表现上和AirDrop长得很像，这个也可以进行AirDrop蓝牙分享很强大的功能，与之不同的是，在与文件类型关联的备选APP列表中，会有类似 <strong>[拷贝至 微信]</strong> 应用的选择，如下：<br><img src=\"/post/iOS/Objective-C/file_preview_1.png\" alt=\"\">    </p>\n<h4 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">//引用</div><div class=\"line\">@property (nonatomic, strong) UIDocumentInteractionController* docInteractionController;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//初始化及动作定义</div><div class=\"line\">NSURL* filePath = xxx;//文件路径</div><div class=\"line\">_docInteractionController = [UIDocumentInteractionController  interactionControllerWithURL:filePath];</div><div class=\"line\">_docInteractionController.delegate = self;</div><div class=\"line\">[_docInteractionController presentOpenInMenuFromRect:CGRectZero</div><div class=\"line\">                                              inView:self.view</div><div class=\"line\">                                            animated:YES];</div></pre></td></tr></table></figure>\n<h4 id=\"实现常用协议\"><a href=\"#实现常用协议\" class=\"headerlink\" title=\"实现常用协议\"></a>实现常用协议</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">#pragma mark - UIDocumentInteractionControllerDelegate</div><div class=\"line\">-(void)documentInteractionController:(UIDocumentInteractionController *)controller willBeginSendingToApplication:(NSString *)application &#123;//将要发送的应用</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//下面是他的代理方法</div><div class=\"line\"></div><div class=\"line\">-(void)documentInteractionController:(UIDocumentInteractionController *)controller didEndSendingToApplication:(NSString *)application&#123;//已经发送的应用</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)documentInteractionControllerDidDismissOpenInMenu:(UIDocumentInteractionController *)controller&#123;//dismiss</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"UIActivityViewController\"><a href=\"#UIActivityViewController\" class=\"headerlink\" title=\"UIActivityViewController\"></a>UIActivityViewController</h3><p>与UIDocumentInteractionController不同的是，UIActivityViewController无类似 <strong>[拷贝至 微信]</strong> 应用的选择。其界面和备选应用等可自行定制(屏蔽)，如下：    </p>\n<p><img src=\"/post/iOS/Objective-C/file_preview_2.png\" alt=\"\">    </p>\n<pre><code class=\"Objective-C\">NSURL* fileURL = [NSURL URLWithString:@&quot;http://xxx.dwg&quot;];\n\n//注：activityItems可以是包含文字、图片、URL地址的数组，至少包含一项；applicationActivities参数可以对平台进行自定义\nUIActivityViewController *activity = [[UIActivityViewController alloc] initWithActivityItems:@[_fileURL]\n                                                                       applicationActivities:nil];\nactivity.excludedActivityTypes = @[UIActivityTypeAirDrop];//可用于屏蔽掉的应用列表，参照UIActivityType\n\n\nUIPopoverPresentationController *popover = activity.popoverPresentationController;\nif (popover) {\n    popover.sourceView = self.shareBtn;\n    popover.permittedArrowDirections = UIPopoverArrowDirectionUp;\n}\n[self presentViewController:activity animated:YES completion:nil];\n</code></pre>\n<p><img src=\"/post/iOS/Objective-C/file_preview_3.png\" alt=\"\"> </p>\n<h3 id=\"分享\"><a href=\"#分享\" class=\"headerlink\" title=\"分享\"></a>分享</h3><p>第三方平台比如微信、新浪微博等平台的分享，集成其提供的SDK即可。此处不再赘述。若需要多分享平台集成，建议使用第三方平台比如友盟、ShareSDK等</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>对于特定格式（比如DWG等）文件的预览，没有必要耗费代价去自行开发功能，此时可能需要使用第三方应用来打开特定格式的文件。本文中记录三种方式：UIDocumentInteractionController、UIActivityViewController和特定第三方分享方式。</p>","more":"<h3 id=\"UIDocumentInteractionController\"><a href=\"#UIDocumentInteractionController\" class=\"headerlink\" title=\"UIDocumentInteractionController\"></a>UIDocumentInteractionController</h3><p>界面表现上和AirDrop长得很像，这个也可以进行AirDrop蓝牙分享很强大的功能，与之不同的是，在与文件类型关联的备选APP列表中，会有类似 <strong>[拷贝至 微信]</strong> 应用的选择，如下：<br><img src=\"/post/iOS/Objective-C/file_preview_1.png\" alt=\"\">    </p>\n<h4 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">//引用</div><div class=\"line\">@property (nonatomic, strong) UIDocumentInteractionController* docInteractionController;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//初始化及动作定义</div><div class=\"line\">NSURL* filePath = xxx;//文件路径</div><div class=\"line\">_docInteractionController = [UIDocumentInteractionController  interactionControllerWithURL:filePath];</div><div class=\"line\">_docInteractionController.delegate = self;</div><div class=\"line\">[_docInteractionController presentOpenInMenuFromRect:CGRectZero</div><div class=\"line\">                                              inView:self.view</div><div class=\"line\">                                            animated:YES];</div></pre></td></tr></table></figure>\n<h4 id=\"实现常用协议\"><a href=\"#实现常用协议\" class=\"headerlink\" title=\"实现常用协议\"></a>实现常用协议</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">#pragma mark - UIDocumentInteractionControllerDelegate</div><div class=\"line\">-(void)documentInteractionController:(UIDocumentInteractionController *)controller willBeginSendingToApplication:(NSString *)application &#123;//将要发送的应用</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//下面是他的代理方法</div><div class=\"line\"></div><div class=\"line\">-(void)documentInteractionController:(UIDocumentInteractionController *)controller didEndSendingToApplication:(NSString *)application&#123;//已经发送的应用</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">-(void)documentInteractionControllerDidDismissOpenInMenu:(UIDocumentInteractionController *)controller&#123;//dismiss</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"UIActivityViewController\"><a href=\"#UIActivityViewController\" class=\"headerlink\" title=\"UIActivityViewController\"></a>UIActivityViewController</h3><p>与UIDocumentInteractionController不同的是，UIActivityViewController无类似 <strong>[拷贝至 微信]</strong> 应用的选择。其界面和备选应用等可自行定制(屏蔽)，如下：    </p>\n<p><img src=\"/post/iOS/Objective-C/file_preview_2.png\" alt=\"\">    </p>\n<pre><code class=\"Objective-C\">NSURL* fileURL = [NSURL URLWithString:@&quot;http://xxx.dwg&quot;];\n\n//注：activityItems可以是包含文字、图片、URL地址的数组，至少包含一项；applicationActivities参数可以对平台进行自定义\nUIActivityViewController *activity = [[UIActivityViewController alloc] initWithActivityItems:@[_fileURL]\n                                                                       applicationActivities:nil];\nactivity.excludedActivityTypes = @[UIActivityTypeAirDrop];//可用于屏蔽掉的应用列表，参照UIActivityType\n\n\nUIPopoverPresentationController *popover = activity.popoverPresentationController;\nif (popover) {\n    popover.sourceView = self.shareBtn;\n    popover.permittedArrowDirections = UIPopoverArrowDirectionUp;\n}\n[self presentViewController:activity animated:YES completion:nil];\n</code></pre>\n<p><img src=\"/post/iOS/Objective-C/file_preview_3.png\" alt=\"\"> </p>\n<h3 id=\"分享\"><a href=\"#分享\" class=\"headerlink\" title=\"分享\"></a>分享</h3><p>第三方平台比如微信、新浪微博等平台的分享，集成其提供的SDK即可。此处不再赘述。若需要多分享平台集成，建议使用第三方平台比如友盟、ShareSDK等</p>"},{"layout":"post","title":"Swift Access Control","date":"2016-12-04T16:20:11.000Z","author":"liangtong","catalog":true,"_content":"\n\n​\t\n​\t访问控制可以限定其他源文件或模块中的代码对你的代码的访问级别。这个特性可以让我们隐藏代码的一些实现细节，并且可以为其他人可以访问和使用的代码提供接口。\n\n\n\n\n你可以明确地给单个类型（类、结构体、枚举）设置访问级别，也可以给这些类型的属性、方法、构造器、下标等设置访问级别。协议也可以被限定在一定的范围内使用，包括协议里的全局常量、变量和函数。\nSwift 不仅提供了多种不同的访问级别，还为某些典型场景提供了默认的访问级别，这样就不需要我们在每段代码中都申明显式访问级别。其实，如果只是开发一个单一目标的应用程序，我们完全可以不用显式声明代码的访问级别。\n\n<!-- more -->\n\n### 模板和源文件\nSwift 中的访问控制模型基于模块和源文件这两个概念。\n模块指的是独立的代码单元，框架或应用程序会作为一个独立的模块来构建和发布。在 Swift 中，一个模块可以使用 import 关键字导入另外一个模块。\n在 Swift 中，Xcode 的每个目标（例如框架或应用程序）都被当作独立的模块处理。如果你是为了实现某个通用的功能，或者是为了封装一些常用方法而将代码打包成独立的框架，这个框架就是 Swift 中的一个模块。当它被导入到某个应用程序或者其他框架时，框架内容都将属于这个独立的模块。\n源文件就是 Swift 中的源代码文件，它通常属于一个模块，即一个应用程序或者框架。尽管我们一般会将不同的类型分别定义在不同的源文件中，但是同一个源文件也可以包含多个类型、函数之类的定义。\n\n### 访问级别\nSwift 为代码中的实体提供了五种不同的访问级别。这些访问级别不仅与源文件中定义的实体相关，同时也与源文件所属的模块相关。\n\n * 开放访问和公开访问可以访问同一模块源文件中的任何实体，在模块外也可以通过导入该模块来访问源文件里的所有实体。通常情况下，框架中的某个接口可以被任何人使用时，你可以将其设置为开放或者公开访问。\n * 内部访问可以访问同一模块源文件中的任何实体，但是不能从模块外访问该模块源文件中的实体。通常情况下，某个接口只在应用程序或框架内部使用时，你可以将其设置为内部访问。\n * 文件私有访问限制实体只能被所定义的文件内部访问。当需要把这些细节被整个文件使用的时候，使用文件私有访问隐藏了一些特定功能的实现细节。\n * 私有访问限制实体只能在所定义的作用域内使用。需要把这些细节被整个作用域使用的时候，使用文件私有访问隐藏了一些特定功能的实现细节。\n \n开放访问为最高（限制最少）访问级别，私有访问为最低（限制最多）访问级别。\n开放访问只作用于类类型和类的成员，它和公开访问的区别如下：\n\n * 公开访问或者其他更严访问级别的类，只能在它们定义的模块内部被继承。\n * 公开访问或者其他更严访问级别的类成员，只能在它们定义的模块内部的子类中重写。\n * 开放访问的类，可以在它们定义的模块中被继承，也可以在引用它们的模块中被继承。\n * 开放访问的类成员，可以在它们定义的模块中子类中重写，也可以在引用它们的模块中的子类重写。\n \n把一个类标记为开放，显式地表明，你认为其他模块中的代码使用此类作为父类，然后你已经设计好了你的类的代码了。\n\n#### 访问级别基本原则\nSwift 中的访问级别遵循一个基本原则：不可以在某个实体中定义访问级别更低（更严格）的实体。例如：\n\n * 一个公开访问级别的变量，其类型的访问级别不能是内部，文件私有或是私有类型的。因为无法保证变量的类型在使用变量的地方也具有访问权限。\n * 函数的访问级别不能高于它的参数类型和返回类型的访问级别。因为这样就会出现函数可以在任何地方被访问，但是它的参数类型和返回类型却不可以的情况。\n\n#### 默认访问级别\n如果你不为代码中的实体显式指定访问级别，那么它们默认为 internal 级别（有一些例外情况，稍后会进行说明）。因此，在大多数情况下，我们不需要显式指定实体的访问级别。\n\n#### 单目标应用程序的访问级别\n当你编写一个单目标应用程序时，应用的所有功能都是为该应用服务，而不需要提供给其他应用或者模块使用，所以我们不需要明确设置访问级别，使用默认的访问级别 internal 即可。但是，你也可以使用文件私有访问或私有访问级别，用于隐藏一些功能的实现细节。\n\n#### 框架的访问级别\n当你开发框架时，就需要把一些对外的接口定义为开放访问或公开访问级别，以便使用者导入该框架后可以正常使用其功能。这些被你定义为对外的接口，就是这个框架的 API。\n\t框架依然会使用默认的内部访问级别，也可以指定为文件私有访问或者私有访问级别。当你想把某个实体作为框架的 API 的时候，需显式为其指定开放访问或公开访问级别。\n\n#### 单元测试目标的访问级别\n当你的应用程序包含单元测试目标时，为了测试，测试模块需要访问应用程序模块中的代码。默认情况下只有开放访问或公开访问级别级别的实体才可以被其他模块访问。然而，如果在导入应用程序模块的语句前使用 @testable 特性，然后在允许测试的编译设置（Build Options -> Enable Testability）下编译这个应用程序模块，单元测试目标就可以访问应用程序模块中所有内部级别的实体。\n\n### 访问控制语法\n通过修饰符 `open`，`public`，`internal`，`filepart`，`private` 来声明实体的访问级别：\n\n```Swift\npublic class SomePublicClass {}\ninternal class SomeInternalClass {}\nfileprivate class SomeFilePrivateClass {}\nprivate class SomePrivateClass {}\n \npublic var somePublicVariable = 0\ninternal let someInternalConstant = 0\nfileprivate func someFilePrivateFunction() {}\nprivate func somePrivateFunction() {}\n```\n\n\t默认情况下，否则实体默认的访问级别为内部访问级别\n\n\n### 自定义类型\n如果想为一个自定义类型指定访问级别，在定义类型时进行指定即可。新类型只能在它的访问级别限制范围内使用。例如，你定义了一个文件私有级别的类，那这个类就只能在定义它的源文件中使用，可以作为属性类型、函数参数类型或者返回类型，等等。\n一个类型的访问级别也会影响到类型成员（属性、方法、构造器、下标）的默认访问级别。如果你将类型指定为私有或者文件私有级别，那么该类型的所有成员的默认访问级别也会变成私有或者文件私有级别。如果你将类型指定为公开或者内部访问级别（或者不明确指定访问级别，而使用默认的内部访问级别），那么该类型的所有成员的默认访问级别将是内部访问。\n\t一个公开类型的所有成员的访问级别默认为内部访问级别，而不是公开级别。如果你想将某个成员指定为公开访问级别，那么你必须显式指定。这样做的好处是，在你定义公共接口的时候，可以明确地选择哪些接口是需要公开的，哪些是内部使用的，避免不小心将内部使用的接口公开。\n\n\n```Swift\npublic class SomePublicClass {                  // explicitly public class\n    public var somePublicProperty = 0            // explicitly public class member\n    var someInternalProperty = 0                 // implicitly internal class member\n    fileprivate func someFilePrivateMethod() {}  // explicitly file-private class member\n    private func somePrivateMethod() {}          // explicitly private class member\n}\n \nclass SomeInternalClass {                       // implicitly internal class\n    var someInternalProperty = 0                 // implicitly internal class member\n    fileprivate func someFilePrivateMethod() {}  // explicitly file-private class member\n    private func somePrivateMethod() {}          // explicitly private class member\n}\n \nfileprivate class SomeFilePrivateClass {        // explicitly file-private class\n    func someFilePrivateMethod() {}              // implicitly file-private class member\n    private func somePrivateMethod() {}          // explicitly private class member\n}\n \nprivate class SomePrivateClass {                // explicitly private class\n    func somePrivateMethod() {}                  // implicitly private class member\n}\n```\n\n#### 元组类型\n元组的访问级别将由元组中访问级别最严格的类型来决定。例如，如果你构建了一个包含两种不同类型的元组，其中一个类型为内部访问级别，另一个类型为私有访问级别，那么这个元组的访问级别为私有访问级别。\n\t元组不同于类、结构体、枚举、函数那样有单独的定义。元组的访问级别是在它被使用时自动推断出的，而无法明确指定。\n\n\n#### 函数类型\n函数的访问级别根据访问级别最严格的参数类型或返回类型的访问级别来决定。但是，如果这种访问级别不符合函数定义所在环境的默认访问级别，那么就需要明确地指定该函数的访问级别。\n下面的例子定义了一个名为 someFunction() 的全局函数，并且没有明确地指定其访问级别。也许你会认为该函数应该拥有默认的访问级别 internal，但事实并非如此。事实上，如果按下面这种写法，代码将无法通过编译：\n\n```Swift\nfunc someFunction() -> (SomeInternalClass, SomePrivateClass) {\n    // function implementation goes here\n}\n```\n\n我们可以看到，这个函数的返回类型是一个元组，该元组中包含两个自定义的类（可查阅自定义类型）。其中一个类的访问级别是 internal，另一个的访问级别是 private，所以根据元组访问级别的原则，该元组的访问级别是 private（元组的访问级别与元组中访问级别最低的类型一致）。\n因为该函数返回类型的访问级别是 private，所以你必须使用 private 修饰符，明确指定该函数的访问级别：\n\n```Swift\nprivate func someFunction() -> (SomeInternalClass, SomePrivateClass) {\n    // function implementation goes here\n}\n```\n\n将该函数指定为 public 或 internal，或者使用默认的访问级别 internal 都是错误的，因为如果把该函数当做 public 或 internal 级别来使用的话，可能会无法访问 private 级别的返回值。\n\n#### 枚举类型\n枚举成员的访问级别和该枚举类型相同，你不能为枚举成员单独指定不同的访问级别。\n比如下面的例子，枚举 CompassPoint 被明确指定为 public 级别，那么它的成员 North、South、East、West 的访问级别同样也是 public：\n\n```Swift\npublic enum CompassPoint {\n    case north\n    case south\n    case east\n    case west\n}\n```\n\n##### 原始值和关联值\n枚举定义中的任何原始值或关联值的类型的访问级别至少不能低于枚举类型的访问级别。例如，你不能在一个 internal 访问级别的枚举中定义 private 级别的原始值类型。\n\n#### 嵌套类型\n如果在 private 级别的类型中定义嵌套类型，那么该嵌套类型就自动拥有 private 访问级别。如果在 public 或者 internal 级别的类型中定义嵌套类型，那么该嵌套类型自动拥有 internal 访问级别。如果想让嵌套类型拥有 public 访问级别，那么需要明确指定该嵌套类型的访问级别。\n\n### 子类\n子类的访问级别不得高于父类的访问级别。例如，父类的访问级别是 internal，子类的访问级别就不能是 public。\n此外，你可以在符合当前访问级别的条件下重写任意类成员（方法、属性、构造器、下标等）。\n可以通过重写为继承来的类成员提供更高的访问级别。下面的例子中，类 A 的访问级别是 public，它包含一个方法 someMethod()，访问级别为 private。类 B 继承自类 A，访问级别为 internal，但是在类 B 中重写了类 A 中访问级别为 private 的方法 someMethod()，并重新指定为 internal 级别。通过这种方式，我们就可以将某类中 private 级别的类成员重新指定为更高的访问级别，以便其他人使用：\n\n```Swift\npublic class A {\n    fileprivate func someMethod() {}\n}\n \ninternal class B: A {\n    override internal func someMethod() {}\n}\n```\n\n我们甚至可以在子类中，用子类成员去访问访问级别更低的父类成员，只要这一操作在相应访问级别的限制范围内（也就是说，在同一源文件中访问父类 private 级别的成员，在同一模块内访问父类 internal 级别的成员）：\n\n```Swift\npublic class A {\n    fileprivate func someMethod() {}\n}\n \ninternal class B: A {\n    override internal func someMethod() {\n        super.someMethod()\n    }\n}\n```\n\n因为父类 A 和子类 B 定义在同一个源文件中，所以在子类 B 可以在重写的 someMethod() 方法中调用 super.someMethod()。\n\n### 常量、变量、属性、下标\n常量、变量、属性不能拥有比它们的类型更高的访问级别。例如，你不能定义一个 public 级别的属性，但是它的类型却是 private 级别的。同样，下标也不能拥有比索引类型或返回类型更高的访问级别。\n如果常量、变量、属性、下标的类型是 private 级别的，那么它们必须明确指定访问级别为 private：\n\n```Swift\nprivate var privateInstance = SomePrivateClass()\n```\n\n#### Getter 和 Setter\n常量、变量、属性、下标的 Getters 和 Setters 的访问级别和它们所属类型的访问级别相同。\nSetter 的访问级别可以低于对应的 Getter 的访问级别，这样就可以控制变量、属性或下标的读写权限。在 var 或 subscript 关键字之前，你可以通过 fileprivate(set)，private(set) 或 internal(set) 为它们的写入权限指定更低的访问级别。\n\t这个规则同时适用于存储型属性和计算型属性。即使你不明确指定存储型属性的 Getter 和 Setter，Swift 也会隐式地为其创建 Getter 和 Setter，用于访问该属性的后备存储。使用 fileprivate(set)，private(set) 和 internal(set) 可以改变 Setter 的访问级别，这对计算型属性也同样适用。\n\n下面的例子中定义了一个名为 TrackedString 的结构体，它记录了 value 属性被修改的次数：\n\n```Swift\nstruct TrackedString {\n    private(set) var numberOfEdits = 0\n    var value: String = \"\" {\n        didSet {\n            numberOfEdits += 1\n        }\n    }\n}\n```\n\nTrackedString 结构体定义了一个用于存储 String 值的属性 value，并将初始值设为 \"\"（一个空字符串）。该结构体还定义了另一个用于存储 Int 值的属性 numberOfEdits，它用于记录属性 value 被修改的次数。这个功能通过属性 value 的 didSet 观察器实现，每当给 value 赋新值时就会调用 didSet 方法，然后将 numberOfEdits 的值加一。\n结构体 TrackedString 和它的属性 value 均没有显式指定访问级别，所以它们都拥有默认的访问级别 internal。但是该结构体的 numberOfEdits 属性使用了 private(set) 修饰符，这意味着 numberOfEdits 属性只能在定义该结构体的源文件中赋值。numberOfEdits 属性的 Getter 依然是默认的访问级别 internal，但是 Setter 的访问级别是 private，这表示该属性只有在当前的源文件中是可读写的，而在当前源文件所属的模块中只是一个可读的属性。\n如果你实例化 TrackedString 结构体，并多次对 value 属性的值进行修改，你就会看到 numberOfEdits 的值会随着修改次数而变化：\n\n```Swift\nvar stringToEdit = TrackedString()\nstringToEdit.value = \"This string will be tracked.\"\nstringToEdit.value += \" This edit will increment numberOfEdits.\"\nstringToEdit.value += \" So will this one.\"\nprint(\"The number of edits is \\(stringToEdit.numberOfEdits)\")\n// Prints \"The number of edits is 3\"\n```\n\n虽然你可以在其他的源文件中实例化该结构体并且获取到 numberOfEdits 属性的值，但是你不能对其进行赋值。这一限制保护了该记录功能的实现细节，同时还提供了方便的访问方式。\n你可以在必要时为 Getter 和 Setter 显式指定访问级别。下面的例子将 TrackedString 结构体明确指定为了 public 访问级别。结构体的成员（包括 numberOfEdits 属性）拥有默认的访问级别 internal。你可以结合 public 和 private(set) 修饰符把结构体中的 numberOfEdits 属性的 Getter 的访问级别设置为 public，而 Setter 的访问级别设置为 private：\n\n```Swift\npublic struct TrackedString {\n    public private(set) var numberOfEdits = 0\n    public var value: String = \"\" {\n        didSet {\n            numberOfEdits += 1\n        }\n    }\n    public init() {}\n}\n```\n\n### 构造器\n自定义构造器的访问级别可以低于或等于其所属类型的访问级别。唯一的例外是必要构造器，它的访问级别必须和所属类型的访问级别相同。\n如同函数或方法的参数，构造器参数的访问级别也不能低于构造器本身的访问级别。\n\n#### 默认构造器\nSwift 会为结构体和类提供一个默认的无参数的构造器，只要它们为所有存储型属性设置了默认初始值，并且未提供自定义的构造器。\n默认构造器的访问级别与所属类型的访问级别相同，除非类型的访问级别是 public。如果一个类型被指定为 public 级别，那么默认构造器的访问级别将为 internal。如果你希望一个 public 级别的类型也能在其他模块中使用这种无参数的默认构造器，你只能自己提供一个 public 访问级别的无参数构造器。\n\n#### 结构体默认的成员逐一构造器\n如果结构体中任意存储型属性的访问级别为 private，那么该结构体默认的成员逐一构造器的访问级别就是 private。否则，这种构造器的访问级别依然是 internal。\n\n如同前面提到的默认构造器，如果你希望一个 public 级别的结构体也能在其他模块中使用其默认的成员逐一构造器，你依然只能自己提供一个 public 访问级别的成员逐一构造器。\n\n### 协议\n如果想为一个协议类型明确地指定访问级别，在定义协议时指定即可。这将限制该协议只能在适当的访问级别范围内被采纳。\n协议中的每一个要求都具有和该协议相同的访问级别。你不能将协议中的要求设置为其他访问级别。这样才能确保该协议的所有要求对于任意采纳者都将可用。\n\t如果你定义了一个 public 访问级别的协议，那么该协议的所有实现也会是 public 访问级别。这一点不同于其他类型，例如，当类型是 public 访问级别时，其成员的访问级别却只是 internal。\n\n\n#### 协议继承\n如果定义了一个继承自其他协议的新协议，那么新协议拥有的访问级别最高也只能和被继承协议的访问级别相同。例如，你不能将继承自 internal 协议的新协议定义为 public 协议。\n\n#### 协议一致性\n一个类型可以采纳比自身访问级别低的协议。例如，你可以定义一个 public 级别的类型，它可以在其他模块中使用，同时它也可以采纳一个 internal 级别的协议，但是只能在该协议所在的模块中作为符合该协议的类型使用。\n采纳了协议的类型的访问级别取它本身和所采纳协议两者间最低的访问级别。也就是说如果一个类型是 public 级别，采纳的协议是 internal 级别，那么采纳了这个协议后，该类型作为符合协议的类型时，其访问级别也是 internal。\n如果你采纳了协议，那么实现了协议的所有要求后，你必须确保这些实现的访问级别不能低于协议的访问级别。例如，一个 public 级别的类型，采纳了 internal 级别的协议，那么协议的实现至少也得是 internal 级别。\n\tSwift 和 Objective-C 一样，协议的一致性是全局的，也就是说，在同一程序中，一个类型不可能用两种不同的方式实现同一个协议。\n\n\n### 扩展\n你可以在访问级别允许的情况下对类、结构体、枚举进行扩展。扩展成员具有和原始类型成员一致的访问级别。例如，你扩展了一个 public 或者 internal 类型，扩展中的成员具有默认的 internal 访问级别，和原始类型中的成员一致 。如果你扩展了一个 private 类型，扩展成员则拥有默认的 private 访问级别。\n或者，你可以明确指定扩展的访问级别（例如，private extension），从而给该扩展中的所有成员指定一个新的默认访问级别。这个新的默认访问级别仍然可以被单独指定的访问级别所覆盖。\n\n#### 通过扩展添加协议一致性\n如果你通过扩展来采纳协议，那么你就不能显式指定该扩展的访问级别了。协议拥有相应的访问级别，并会为该扩展中所有协议要求的实现提供默认的访问级别。\n\n\n### 泛型\n泛型类型或泛型函数的访问级别取决于泛型类型或泛型函数本身的访问级别，还需结合类型参数的类型约束的访问级别，根据这些访问级别中的最低访问级别来确定。\n\n\n### 类型别名\n\n你定义的任何类型别名都会被当作不同的类型，以便于进行访问控制。类型别名的访问级别不可高于其表示的类型的访问级别。例如，private 级别的类型别名可以作为 private，file-private，internal，public或者open类型的别名，但是 public 级别的类型别名只能作为 public 类型的别名，不能作为 internal，file-private，或 private 类型的别名。\n\t这条规则也适用于为满足协议一致性而将类型别名用于关联类型的情况。\n\n\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html/\"> AccessControl </a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","source":"_posts/iOS_Swift_language_note_Access-Control.md","raw":"---\nlayout:     post\ntitle:      Swift Access Control\ndate:       2016-12-05 00:20:11\nauthor:     liangtong\ncatalog: true\ncategories: iOS\ntags: Swift \n\n---\n\n\n​\t\n​\t访问控制可以限定其他源文件或模块中的代码对你的代码的访问级别。这个特性可以让我们隐藏代码的一些实现细节，并且可以为其他人可以访问和使用的代码提供接口。\n\n\n\n\n你可以明确地给单个类型（类、结构体、枚举）设置访问级别，也可以给这些类型的属性、方法、构造器、下标等设置访问级别。协议也可以被限定在一定的范围内使用，包括协议里的全局常量、变量和函数。\nSwift 不仅提供了多种不同的访问级别，还为某些典型场景提供了默认的访问级别，这样就不需要我们在每段代码中都申明显式访问级别。其实，如果只是开发一个单一目标的应用程序，我们完全可以不用显式声明代码的访问级别。\n\n<!-- more -->\n\n### 模板和源文件\nSwift 中的访问控制模型基于模块和源文件这两个概念。\n模块指的是独立的代码单元，框架或应用程序会作为一个独立的模块来构建和发布。在 Swift 中，一个模块可以使用 import 关键字导入另外一个模块。\n在 Swift 中，Xcode 的每个目标（例如框架或应用程序）都被当作独立的模块处理。如果你是为了实现某个通用的功能，或者是为了封装一些常用方法而将代码打包成独立的框架，这个框架就是 Swift 中的一个模块。当它被导入到某个应用程序或者其他框架时，框架内容都将属于这个独立的模块。\n源文件就是 Swift 中的源代码文件，它通常属于一个模块，即一个应用程序或者框架。尽管我们一般会将不同的类型分别定义在不同的源文件中，但是同一个源文件也可以包含多个类型、函数之类的定义。\n\n### 访问级别\nSwift 为代码中的实体提供了五种不同的访问级别。这些访问级别不仅与源文件中定义的实体相关，同时也与源文件所属的模块相关。\n\n * 开放访问和公开访问可以访问同一模块源文件中的任何实体，在模块外也可以通过导入该模块来访问源文件里的所有实体。通常情况下，框架中的某个接口可以被任何人使用时，你可以将其设置为开放或者公开访问。\n * 内部访问可以访问同一模块源文件中的任何实体，但是不能从模块外访问该模块源文件中的实体。通常情况下，某个接口只在应用程序或框架内部使用时，你可以将其设置为内部访问。\n * 文件私有访问限制实体只能被所定义的文件内部访问。当需要把这些细节被整个文件使用的时候，使用文件私有访问隐藏了一些特定功能的实现细节。\n * 私有访问限制实体只能在所定义的作用域内使用。需要把这些细节被整个作用域使用的时候，使用文件私有访问隐藏了一些特定功能的实现细节。\n \n开放访问为最高（限制最少）访问级别，私有访问为最低（限制最多）访问级别。\n开放访问只作用于类类型和类的成员，它和公开访问的区别如下：\n\n * 公开访问或者其他更严访问级别的类，只能在它们定义的模块内部被继承。\n * 公开访问或者其他更严访问级别的类成员，只能在它们定义的模块内部的子类中重写。\n * 开放访问的类，可以在它们定义的模块中被继承，也可以在引用它们的模块中被继承。\n * 开放访问的类成员，可以在它们定义的模块中子类中重写，也可以在引用它们的模块中的子类重写。\n \n把一个类标记为开放，显式地表明，你认为其他模块中的代码使用此类作为父类，然后你已经设计好了你的类的代码了。\n\n#### 访问级别基本原则\nSwift 中的访问级别遵循一个基本原则：不可以在某个实体中定义访问级别更低（更严格）的实体。例如：\n\n * 一个公开访问级别的变量，其类型的访问级别不能是内部，文件私有或是私有类型的。因为无法保证变量的类型在使用变量的地方也具有访问权限。\n * 函数的访问级别不能高于它的参数类型和返回类型的访问级别。因为这样就会出现函数可以在任何地方被访问，但是它的参数类型和返回类型却不可以的情况。\n\n#### 默认访问级别\n如果你不为代码中的实体显式指定访问级别，那么它们默认为 internal 级别（有一些例外情况，稍后会进行说明）。因此，在大多数情况下，我们不需要显式指定实体的访问级别。\n\n#### 单目标应用程序的访问级别\n当你编写一个单目标应用程序时，应用的所有功能都是为该应用服务，而不需要提供给其他应用或者模块使用，所以我们不需要明确设置访问级别，使用默认的访问级别 internal 即可。但是，你也可以使用文件私有访问或私有访问级别，用于隐藏一些功能的实现细节。\n\n#### 框架的访问级别\n当你开发框架时，就需要把一些对外的接口定义为开放访问或公开访问级别，以便使用者导入该框架后可以正常使用其功能。这些被你定义为对外的接口，就是这个框架的 API。\n\t框架依然会使用默认的内部访问级别，也可以指定为文件私有访问或者私有访问级别。当你想把某个实体作为框架的 API 的时候，需显式为其指定开放访问或公开访问级别。\n\n#### 单元测试目标的访问级别\n当你的应用程序包含单元测试目标时，为了测试，测试模块需要访问应用程序模块中的代码。默认情况下只有开放访问或公开访问级别级别的实体才可以被其他模块访问。然而，如果在导入应用程序模块的语句前使用 @testable 特性，然后在允许测试的编译设置（Build Options -> Enable Testability）下编译这个应用程序模块，单元测试目标就可以访问应用程序模块中所有内部级别的实体。\n\n### 访问控制语法\n通过修饰符 `open`，`public`，`internal`，`filepart`，`private` 来声明实体的访问级别：\n\n```Swift\npublic class SomePublicClass {}\ninternal class SomeInternalClass {}\nfileprivate class SomeFilePrivateClass {}\nprivate class SomePrivateClass {}\n \npublic var somePublicVariable = 0\ninternal let someInternalConstant = 0\nfileprivate func someFilePrivateFunction() {}\nprivate func somePrivateFunction() {}\n```\n\n\t默认情况下，否则实体默认的访问级别为内部访问级别\n\n\n### 自定义类型\n如果想为一个自定义类型指定访问级别，在定义类型时进行指定即可。新类型只能在它的访问级别限制范围内使用。例如，你定义了一个文件私有级别的类，那这个类就只能在定义它的源文件中使用，可以作为属性类型、函数参数类型或者返回类型，等等。\n一个类型的访问级别也会影响到类型成员（属性、方法、构造器、下标）的默认访问级别。如果你将类型指定为私有或者文件私有级别，那么该类型的所有成员的默认访问级别也会变成私有或者文件私有级别。如果你将类型指定为公开或者内部访问级别（或者不明确指定访问级别，而使用默认的内部访问级别），那么该类型的所有成员的默认访问级别将是内部访问。\n\t一个公开类型的所有成员的访问级别默认为内部访问级别，而不是公开级别。如果你想将某个成员指定为公开访问级别，那么你必须显式指定。这样做的好处是，在你定义公共接口的时候，可以明确地选择哪些接口是需要公开的，哪些是内部使用的，避免不小心将内部使用的接口公开。\n\n\n```Swift\npublic class SomePublicClass {                  // explicitly public class\n    public var somePublicProperty = 0            // explicitly public class member\n    var someInternalProperty = 0                 // implicitly internal class member\n    fileprivate func someFilePrivateMethod() {}  // explicitly file-private class member\n    private func somePrivateMethod() {}          // explicitly private class member\n}\n \nclass SomeInternalClass {                       // implicitly internal class\n    var someInternalProperty = 0                 // implicitly internal class member\n    fileprivate func someFilePrivateMethod() {}  // explicitly file-private class member\n    private func somePrivateMethod() {}          // explicitly private class member\n}\n \nfileprivate class SomeFilePrivateClass {        // explicitly file-private class\n    func someFilePrivateMethod() {}              // implicitly file-private class member\n    private func somePrivateMethod() {}          // explicitly private class member\n}\n \nprivate class SomePrivateClass {                // explicitly private class\n    func somePrivateMethod() {}                  // implicitly private class member\n}\n```\n\n#### 元组类型\n元组的访问级别将由元组中访问级别最严格的类型来决定。例如，如果你构建了一个包含两种不同类型的元组，其中一个类型为内部访问级别，另一个类型为私有访问级别，那么这个元组的访问级别为私有访问级别。\n\t元组不同于类、结构体、枚举、函数那样有单独的定义。元组的访问级别是在它被使用时自动推断出的，而无法明确指定。\n\n\n#### 函数类型\n函数的访问级别根据访问级别最严格的参数类型或返回类型的访问级别来决定。但是，如果这种访问级别不符合函数定义所在环境的默认访问级别，那么就需要明确地指定该函数的访问级别。\n下面的例子定义了一个名为 someFunction() 的全局函数，并且没有明确地指定其访问级别。也许你会认为该函数应该拥有默认的访问级别 internal，但事实并非如此。事实上，如果按下面这种写法，代码将无法通过编译：\n\n```Swift\nfunc someFunction() -> (SomeInternalClass, SomePrivateClass) {\n    // function implementation goes here\n}\n```\n\n我们可以看到，这个函数的返回类型是一个元组，该元组中包含两个自定义的类（可查阅自定义类型）。其中一个类的访问级别是 internal，另一个的访问级别是 private，所以根据元组访问级别的原则，该元组的访问级别是 private（元组的访问级别与元组中访问级别最低的类型一致）。\n因为该函数返回类型的访问级别是 private，所以你必须使用 private 修饰符，明确指定该函数的访问级别：\n\n```Swift\nprivate func someFunction() -> (SomeInternalClass, SomePrivateClass) {\n    // function implementation goes here\n}\n```\n\n将该函数指定为 public 或 internal，或者使用默认的访问级别 internal 都是错误的，因为如果把该函数当做 public 或 internal 级别来使用的话，可能会无法访问 private 级别的返回值。\n\n#### 枚举类型\n枚举成员的访问级别和该枚举类型相同，你不能为枚举成员单独指定不同的访问级别。\n比如下面的例子，枚举 CompassPoint 被明确指定为 public 级别，那么它的成员 North、South、East、West 的访问级别同样也是 public：\n\n```Swift\npublic enum CompassPoint {\n    case north\n    case south\n    case east\n    case west\n}\n```\n\n##### 原始值和关联值\n枚举定义中的任何原始值或关联值的类型的访问级别至少不能低于枚举类型的访问级别。例如，你不能在一个 internal 访问级别的枚举中定义 private 级别的原始值类型。\n\n#### 嵌套类型\n如果在 private 级别的类型中定义嵌套类型，那么该嵌套类型就自动拥有 private 访问级别。如果在 public 或者 internal 级别的类型中定义嵌套类型，那么该嵌套类型自动拥有 internal 访问级别。如果想让嵌套类型拥有 public 访问级别，那么需要明确指定该嵌套类型的访问级别。\n\n### 子类\n子类的访问级别不得高于父类的访问级别。例如，父类的访问级别是 internal，子类的访问级别就不能是 public。\n此外，你可以在符合当前访问级别的条件下重写任意类成员（方法、属性、构造器、下标等）。\n可以通过重写为继承来的类成员提供更高的访问级别。下面的例子中，类 A 的访问级别是 public，它包含一个方法 someMethod()，访问级别为 private。类 B 继承自类 A，访问级别为 internal，但是在类 B 中重写了类 A 中访问级别为 private 的方法 someMethod()，并重新指定为 internal 级别。通过这种方式，我们就可以将某类中 private 级别的类成员重新指定为更高的访问级别，以便其他人使用：\n\n```Swift\npublic class A {\n    fileprivate func someMethod() {}\n}\n \ninternal class B: A {\n    override internal func someMethod() {}\n}\n```\n\n我们甚至可以在子类中，用子类成员去访问访问级别更低的父类成员，只要这一操作在相应访问级别的限制范围内（也就是说，在同一源文件中访问父类 private 级别的成员，在同一模块内访问父类 internal 级别的成员）：\n\n```Swift\npublic class A {\n    fileprivate func someMethod() {}\n}\n \ninternal class B: A {\n    override internal func someMethod() {\n        super.someMethod()\n    }\n}\n```\n\n因为父类 A 和子类 B 定义在同一个源文件中，所以在子类 B 可以在重写的 someMethod() 方法中调用 super.someMethod()。\n\n### 常量、变量、属性、下标\n常量、变量、属性不能拥有比它们的类型更高的访问级别。例如，你不能定义一个 public 级别的属性，但是它的类型却是 private 级别的。同样，下标也不能拥有比索引类型或返回类型更高的访问级别。\n如果常量、变量、属性、下标的类型是 private 级别的，那么它们必须明确指定访问级别为 private：\n\n```Swift\nprivate var privateInstance = SomePrivateClass()\n```\n\n#### Getter 和 Setter\n常量、变量、属性、下标的 Getters 和 Setters 的访问级别和它们所属类型的访问级别相同。\nSetter 的访问级别可以低于对应的 Getter 的访问级别，这样就可以控制变量、属性或下标的读写权限。在 var 或 subscript 关键字之前，你可以通过 fileprivate(set)，private(set) 或 internal(set) 为它们的写入权限指定更低的访问级别。\n\t这个规则同时适用于存储型属性和计算型属性。即使你不明确指定存储型属性的 Getter 和 Setter，Swift 也会隐式地为其创建 Getter 和 Setter，用于访问该属性的后备存储。使用 fileprivate(set)，private(set) 和 internal(set) 可以改变 Setter 的访问级别，这对计算型属性也同样适用。\n\n下面的例子中定义了一个名为 TrackedString 的结构体，它记录了 value 属性被修改的次数：\n\n```Swift\nstruct TrackedString {\n    private(set) var numberOfEdits = 0\n    var value: String = \"\" {\n        didSet {\n            numberOfEdits += 1\n        }\n    }\n}\n```\n\nTrackedString 结构体定义了一个用于存储 String 值的属性 value，并将初始值设为 \"\"（一个空字符串）。该结构体还定义了另一个用于存储 Int 值的属性 numberOfEdits，它用于记录属性 value 被修改的次数。这个功能通过属性 value 的 didSet 观察器实现，每当给 value 赋新值时就会调用 didSet 方法，然后将 numberOfEdits 的值加一。\n结构体 TrackedString 和它的属性 value 均没有显式指定访问级别，所以它们都拥有默认的访问级别 internal。但是该结构体的 numberOfEdits 属性使用了 private(set) 修饰符，这意味着 numberOfEdits 属性只能在定义该结构体的源文件中赋值。numberOfEdits 属性的 Getter 依然是默认的访问级别 internal，但是 Setter 的访问级别是 private，这表示该属性只有在当前的源文件中是可读写的，而在当前源文件所属的模块中只是一个可读的属性。\n如果你实例化 TrackedString 结构体，并多次对 value 属性的值进行修改，你就会看到 numberOfEdits 的值会随着修改次数而变化：\n\n```Swift\nvar stringToEdit = TrackedString()\nstringToEdit.value = \"This string will be tracked.\"\nstringToEdit.value += \" This edit will increment numberOfEdits.\"\nstringToEdit.value += \" So will this one.\"\nprint(\"The number of edits is \\(stringToEdit.numberOfEdits)\")\n// Prints \"The number of edits is 3\"\n```\n\n虽然你可以在其他的源文件中实例化该结构体并且获取到 numberOfEdits 属性的值，但是你不能对其进行赋值。这一限制保护了该记录功能的实现细节，同时还提供了方便的访问方式。\n你可以在必要时为 Getter 和 Setter 显式指定访问级别。下面的例子将 TrackedString 结构体明确指定为了 public 访问级别。结构体的成员（包括 numberOfEdits 属性）拥有默认的访问级别 internal。你可以结合 public 和 private(set) 修饰符把结构体中的 numberOfEdits 属性的 Getter 的访问级别设置为 public，而 Setter 的访问级别设置为 private：\n\n```Swift\npublic struct TrackedString {\n    public private(set) var numberOfEdits = 0\n    public var value: String = \"\" {\n        didSet {\n            numberOfEdits += 1\n        }\n    }\n    public init() {}\n}\n```\n\n### 构造器\n自定义构造器的访问级别可以低于或等于其所属类型的访问级别。唯一的例外是必要构造器，它的访问级别必须和所属类型的访问级别相同。\n如同函数或方法的参数，构造器参数的访问级别也不能低于构造器本身的访问级别。\n\n#### 默认构造器\nSwift 会为结构体和类提供一个默认的无参数的构造器，只要它们为所有存储型属性设置了默认初始值，并且未提供自定义的构造器。\n默认构造器的访问级别与所属类型的访问级别相同，除非类型的访问级别是 public。如果一个类型被指定为 public 级别，那么默认构造器的访问级别将为 internal。如果你希望一个 public 级别的类型也能在其他模块中使用这种无参数的默认构造器，你只能自己提供一个 public 访问级别的无参数构造器。\n\n#### 结构体默认的成员逐一构造器\n如果结构体中任意存储型属性的访问级别为 private，那么该结构体默认的成员逐一构造器的访问级别就是 private。否则，这种构造器的访问级别依然是 internal。\n\n如同前面提到的默认构造器，如果你希望一个 public 级别的结构体也能在其他模块中使用其默认的成员逐一构造器，你依然只能自己提供一个 public 访问级别的成员逐一构造器。\n\n### 协议\n如果想为一个协议类型明确地指定访问级别，在定义协议时指定即可。这将限制该协议只能在适当的访问级别范围内被采纳。\n协议中的每一个要求都具有和该协议相同的访问级别。你不能将协议中的要求设置为其他访问级别。这样才能确保该协议的所有要求对于任意采纳者都将可用。\n\t如果你定义了一个 public 访问级别的协议，那么该协议的所有实现也会是 public 访问级别。这一点不同于其他类型，例如，当类型是 public 访问级别时，其成员的访问级别却只是 internal。\n\n\n#### 协议继承\n如果定义了一个继承自其他协议的新协议，那么新协议拥有的访问级别最高也只能和被继承协议的访问级别相同。例如，你不能将继承自 internal 协议的新协议定义为 public 协议。\n\n#### 协议一致性\n一个类型可以采纳比自身访问级别低的协议。例如，你可以定义一个 public 级别的类型，它可以在其他模块中使用，同时它也可以采纳一个 internal 级别的协议，但是只能在该协议所在的模块中作为符合该协议的类型使用。\n采纳了协议的类型的访问级别取它本身和所采纳协议两者间最低的访问级别。也就是说如果一个类型是 public 级别，采纳的协议是 internal 级别，那么采纳了这个协议后，该类型作为符合协议的类型时，其访问级别也是 internal。\n如果你采纳了协议，那么实现了协议的所有要求后，你必须确保这些实现的访问级别不能低于协议的访问级别。例如，一个 public 级别的类型，采纳了 internal 级别的协议，那么协议的实现至少也得是 internal 级别。\n\tSwift 和 Objective-C 一样，协议的一致性是全局的，也就是说，在同一程序中，一个类型不可能用两种不同的方式实现同一个协议。\n\n\n### 扩展\n你可以在访问级别允许的情况下对类、结构体、枚举进行扩展。扩展成员具有和原始类型成员一致的访问级别。例如，你扩展了一个 public 或者 internal 类型，扩展中的成员具有默认的 internal 访问级别，和原始类型中的成员一致 。如果你扩展了一个 private 类型，扩展成员则拥有默认的 private 访问级别。\n或者，你可以明确指定扩展的访问级别（例如，private extension），从而给该扩展中的所有成员指定一个新的默认访问级别。这个新的默认访问级别仍然可以被单独指定的访问级别所覆盖。\n\n#### 通过扩展添加协议一致性\n如果你通过扩展来采纳协议，那么你就不能显式指定该扩展的访问级别了。协议拥有相应的访问级别，并会为该扩展中所有协议要求的实现提供默认的访问级别。\n\n\n### 泛型\n泛型类型或泛型函数的访问级别取决于泛型类型或泛型函数本身的访问级别，还需结合类型参数的类型约束的访问级别，根据这些访问级别中的最低访问级别来确定。\n\n\n### 类型别名\n\n你定义的任何类型别名都会被当作不同的类型，以便于进行访问控制。类型别名的访问级别不可高于其表示的类型的访问级别。例如，private 级别的类型别名可以作为 private，file-private，internal，public或者open类型的别名，但是 public 级别的类型别名只能作为 public 类型的别名，不能作为 internal，file-private，或 private 类型的别名。\n\t这条规则也适用于为满足协议一致性而将类型别名用于关联类型的情况。\n\n\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html/\"> AccessControl </a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","slug":"iOS_Swift_language_note_Access-Control","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4tv0022oko8opwvlpth","content":"<p>​<br>​    访问控制可以限定其他源文件或模块中的代码对你的代码的访问级别。这个特性可以让我们隐藏代码的一些实现细节，并且可以为其他人可以访问和使用的代码提供接口。</p>\n<p>你可以明确地给单个类型（类、结构体、枚举）设置访问级别，也可以给这些类型的属性、方法、构造器、下标等设置访问级别。协议也可以被限定在一定的范围内使用，包括协议里的全局常量、变量和函数。<br>Swift 不仅提供了多种不同的访问级别，还为某些典型场景提供了默认的访问级别，这样就不需要我们在每段代码中都申明显式访问级别。其实，如果只是开发一个单一目标的应用程序，我们完全可以不用显式声明代码的访问级别。</p>\n<a id=\"more\"></a>\n<h3 id=\"模板和源文件\"><a href=\"#模板和源文件\" class=\"headerlink\" title=\"模板和源文件\"></a>模板和源文件</h3><p>Swift 中的访问控制模型基于模块和源文件这两个概念。<br>模块指的是独立的代码单元，框架或应用程序会作为一个独立的模块来构建和发布。在 Swift 中，一个模块可以使用 import 关键字导入另外一个模块。<br>在 Swift 中，Xcode 的每个目标（例如框架或应用程序）都被当作独立的模块处理。如果你是为了实现某个通用的功能，或者是为了封装一些常用方法而将代码打包成独立的框架，这个框架就是 Swift 中的一个模块。当它被导入到某个应用程序或者其他框架时，框架内容都将属于这个独立的模块。<br>源文件就是 Swift 中的源代码文件，它通常属于一个模块，即一个应用程序或者框架。尽管我们一般会将不同的类型分别定义在不同的源文件中，但是同一个源文件也可以包含多个类型、函数之类的定义。</p>\n<h3 id=\"访问级别\"><a href=\"#访问级别\" class=\"headerlink\" title=\"访问级别\"></a>访问级别</h3><p>Swift 为代码中的实体提供了五种不同的访问级别。这些访问级别不仅与源文件中定义的实体相关，同时也与源文件所属的模块相关。</p>\n<ul>\n<li>开放访问和公开访问可以访问同一模块源文件中的任何实体，在模块外也可以通过导入该模块来访问源文件里的所有实体。通常情况下，框架中的某个接口可以被任何人使用时，你可以将其设置为开放或者公开访问。</li>\n<li>内部访问可以访问同一模块源文件中的任何实体，但是不能从模块外访问该模块源文件中的实体。通常情况下，某个接口只在应用程序或框架内部使用时，你可以将其设置为内部访问。</li>\n<li>文件私有访问限制实体只能被所定义的文件内部访问。当需要把这些细节被整个文件使用的时候，使用文件私有访问隐藏了一些特定功能的实现细节。</li>\n<li>私有访问限制实体只能在所定义的作用域内使用。需要把这些细节被整个作用域使用的时候，使用文件私有访问隐藏了一些特定功能的实现细节。</li>\n</ul>\n<p>开放访问为最高（限制最少）访问级别，私有访问为最低（限制最多）访问级别。<br>开放访问只作用于类类型和类的成员，它和公开访问的区别如下：</p>\n<ul>\n<li>公开访问或者其他更严访问级别的类，只能在它们定义的模块内部被继承。</li>\n<li>公开访问或者其他更严访问级别的类成员，只能在它们定义的模块内部的子类中重写。</li>\n<li>开放访问的类，可以在它们定义的模块中被继承，也可以在引用它们的模块中被继承。</li>\n<li>开放访问的类成员，可以在它们定义的模块中子类中重写，也可以在引用它们的模块中的子类重写。</li>\n</ul>\n<p>把一个类标记为开放，显式地表明，你认为其他模块中的代码使用此类作为父类，然后你已经设计好了你的类的代码了。</p>\n<h4 id=\"访问级别基本原则\"><a href=\"#访问级别基本原则\" class=\"headerlink\" title=\"访问级别基本原则\"></a>访问级别基本原则</h4><p>Swift 中的访问级别遵循一个基本原则：不可以在某个实体中定义访问级别更低（更严格）的实体。例如：</p>\n<ul>\n<li>一个公开访问级别的变量，其类型的访问级别不能是内部，文件私有或是私有类型的。因为无法保证变量的类型在使用变量的地方也具有访问权限。</li>\n<li>函数的访问级别不能高于它的参数类型和返回类型的访问级别。因为这样就会出现函数可以在任何地方被访问，但是它的参数类型和返回类型却不可以的情况。</li>\n</ul>\n<h4 id=\"默认访问级别\"><a href=\"#默认访问级别\" class=\"headerlink\" title=\"默认访问级别\"></a>默认访问级别</h4><p>如果你不为代码中的实体显式指定访问级别，那么它们默认为 internal 级别（有一些例外情况，稍后会进行说明）。因此，在大多数情况下，我们不需要显式指定实体的访问级别。</p>\n<h4 id=\"单目标应用程序的访问级别\"><a href=\"#单目标应用程序的访问级别\" class=\"headerlink\" title=\"单目标应用程序的访问级别\"></a>单目标应用程序的访问级别</h4><p>当你编写一个单目标应用程序时，应用的所有功能都是为该应用服务，而不需要提供给其他应用或者模块使用，所以我们不需要明确设置访问级别，使用默认的访问级别 internal 即可。但是，你也可以使用文件私有访问或私有访问级别，用于隐藏一些功能的实现细节。</p>\n<h4 id=\"框架的访问级别\"><a href=\"#框架的访问级别\" class=\"headerlink\" title=\"框架的访问级别\"></a>框架的访问级别</h4><p>当你开发框架时，就需要把一些对外的接口定义为开放访问或公开访问级别，以便使用者导入该框架后可以正常使用其功能。这些被你定义为对外的接口，就是这个框架的 API。<br>    框架依然会使用默认的内部访问级别，也可以指定为文件私有访问或者私有访问级别。当你想把某个实体作为框架的 API 的时候，需显式为其指定开放访问或公开访问级别。</p>\n<h4 id=\"单元测试目标的访问级别\"><a href=\"#单元测试目标的访问级别\" class=\"headerlink\" title=\"单元测试目标的访问级别\"></a>单元测试目标的访问级别</h4><p>当你的应用程序包含单元测试目标时，为了测试，测试模块需要访问应用程序模块中的代码。默认情况下只有开放访问或公开访问级别级别的实体才可以被其他模块访问。然而，如果在导入应用程序模块的语句前使用 @testable 特性，然后在允许测试的编译设置（Build Options -&gt; Enable Testability）下编译这个应用程序模块，单元测试目标就可以访问应用程序模块中所有内部级别的实体。</p>\n<h3 id=\"访问控制语法\"><a href=\"#访问控制语法\" class=\"headerlink\" title=\"访问控制语法\"></a>访问控制语法</h3><p>通过修饰符 <code>open</code>，<code>public</code>，<code>internal</code>，<code>filepart</code>，<code>private</code> 来声明实体的访问级别：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomePublicClass</span> </span>&#123;&#125;</div><div class=\"line\"><span class=\"keyword\">internal</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeInternalClass</span> </span>&#123;&#125;</div><div class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeFilePrivateClass</span> </span>&#123;&#125;</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomePrivateClass</span> </span>&#123;&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> somePublicVariable = <span class=\"number\">0</span></div><div class=\"line\"><span class=\"keyword\">internal</span> <span class=\"keyword\">let</span> someInternalConstant = <span class=\"number\">0</span></div><div class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someFilePrivateFunction</span><span class=\"params\">()</span></span> &#123;&#125;</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">somePrivateFunction</span><span class=\"params\">()</span></span> &#123;&#125;</div></pre></td></tr></table></figure>\n<pre><code>默认情况下，否则实体默认的访问级别为内部访问级别\n</code></pre><h3 id=\"自定义类型\"><a href=\"#自定义类型\" class=\"headerlink\" title=\"自定义类型\"></a>自定义类型</h3><p>如果想为一个自定义类型指定访问级别，在定义类型时进行指定即可。新类型只能在它的访问级别限制范围内使用。例如，你定义了一个文件私有级别的类，那这个类就只能在定义它的源文件中使用，可以作为属性类型、函数参数类型或者返回类型，等等。<br>一个类型的访问级别也会影响到类型成员（属性、方法、构造器、下标）的默认访问级别。如果你将类型指定为私有或者文件私有级别，那么该类型的所有成员的默认访问级别也会变成私有或者文件私有级别。如果你将类型指定为公开或者内部访问级别（或者不明确指定访问级别，而使用默认的内部访问级别），那么该类型的所有成员的默认访问级别将是内部访问。<br>    一个公开类型的所有成员的访问级别默认为内部访问级别，而不是公开级别。如果你想将某个成员指定为公开访问级别，那么你必须显式指定。这样做的好处是，在你定义公共接口的时候，可以明确地选择哪些接口是需要公开的，哪些是内部使用的，避免不小心将内部使用的接口公开。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomePublicClass</span> </span>&#123;                  <span class=\"comment\">// explicitly public class</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> somePublicProperty = <span class=\"number\">0</span>            <span class=\"comment\">// explicitly public class member</span></div><div class=\"line\">    <span class=\"keyword\">var</span> someInternalProperty = <span class=\"number\">0</span>                 <span class=\"comment\">// implicitly internal class member</span></div><div class=\"line\">    <span class=\"keyword\">fileprivate</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someFilePrivateMethod</span><span class=\"params\">()</span></span> &#123;&#125;  <span class=\"comment\">// explicitly file-private class member</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">somePrivateMethod</span><span class=\"params\">()</span></span> &#123;&#125;          <span class=\"comment\">// explicitly private class member</span></div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeInternalClass</span> </span>&#123;                       <span class=\"comment\">// implicitly internal class</span></div><div class=\"line\">    <span class=\"keyword\">var</span> someInternalProperty = <span class=\"number\">0</span>                 <span class=\"comment\">// implicitly internal class member</span></div><div class=\"line\">    <span class=\"keyword\">fileprivate</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someFilePrivateMethod</span><span class=\"params\">()</span></span> &#123;&#125;  <span class=\"comment\">// explicitly file-private class member</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">somePrivateMethod</span><span class=\"params\">()</span></span> &#123;&#125;          <span class=\"comment\">// explicitly private class member</span></div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeFilePrivateClass</span> </span>&#123;        <span class=\"comment\">// explicitly file-private class</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someFilePrivateMethod</span><span class=\"params\">()</span></span> &#123;&#125;              <span class=\"comment\">// implicitly file-private class member</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">somePrivateMethod</span><span class=\"params\">()</span></span> &#123;&#125;          <span class=\"comment\">// explicitly private class member</span></div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomePrivateClass</span> </span>&#123;                <span class=\"comment\">// explicitly private class</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">somePrivateMethod</span><span class=\"params\">()</span></span> &#123;&#125;                  <span class=\"comment\">// implicitly private class member</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"元组类型\"><a href=\"#元组类型\" class=\"headerlink\" title=\"元组类型\"></a>元组类型</h4><p>元组的访问级别将由元组中访问级别最严格的类型来决定。例如，如果你构建了一个包含两种不同类型的元组，其中一个类型为内部访问级别，另一个类型为私有访问级别，那么这个元组的访问级别为私有访问级别。<br>    元组不同于类、结构体、枚举、函数那样有单独的定义。元组的访问级别是在它被使用时自动推断出的，而无法明确指定。</p>\n<h4 id=\"函数类型\"><a href=\"#函数类型\" class=\"headerlink\" title=\"函数类型\"></a>函数类型</h4><p>函数的访问级别根据访问级别最严格的参数类型或返回类型的访问级别来决定。但是，如果这种访问级别不符合函数定义所在环境的默认访问级别，那么就需要明确地指定该函数的访问级别。<br>下面的例子定义了一个名为 someFunction() 的全局函数，并且没有明确地指定其访问级别。也许你会认为该函数应该拥有默认的访问级别 internal，但事实并非如此。事实上，如果按下面这种写法，代码将无法通过编译：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someFunction</span><span class=\"params\">()</span></span> -&gt; (<span class=\"type\">SomeInternalClass</span>, <span class=\"type\">SomePrivateClass</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// function implementation goes here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以看到，这个函数的返回类型是一个元组，该元组中包含两个自定义的类（可查阅自定义类型）。其中一个类的访问级别是 internal，另一个的访问级别是 private，所以根据元组访问级别的原则，该元组的访问级别是 private（元组的访问级别与元组中访问级别最低的类型一致）。<br>因为该函数返回类型的访问级别是 private，所以你必须使用 private 修饰符，明确指定该函数的访问级别：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someFunction</span><span class=\"params\">()</span></span> -&gt; (<span class=\"type\">SomeInternalClass</span>, <span class=\"type\">SomePrivateClass</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// function implementation goes here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>将该函数指定为 public 或 internal，或者使用默认的访问级别 internal 都是错误的，因为如果把该函数当做 public 或 internal 级别来使用的话，可能会无法访问 private 级别的返回值。</p>\n<h4 id=\"枚举类型\"><a href=\"#枚举类型\" class=\"headerlink\" title=\"枚举类型\"></a>枚举类型</h4><p>枚举成员的访问级别和该枚举类型相同，你不能为枚举成员单独指定不同的访问级别。<br>比如下面的例子，枚举 CompassPoint 被明确指定为 public 级别，那么它的成员 North、South、East、West 的访问级别同样也是 public：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">CompassPoint</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> north</div><div class=\"line\">    <span class=\"keyword\">case</span> south</div><div class=\"line\">    <span class=\"keyword\">case</span> east</div><div class=\"line\">    <span class=\"keyword\">case</span> west</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"原始值和关联值\"><a href=\"#原始值和关联值\" class=\"headerlink\" title=\"原始值和关联值\"></a>原始值和关联值</h5><p>枚举定义中的任何原始值或关联值的类型的访问级别至少不能低于枚举类型的访问级别。例如，你不能在一个 internal 访问级别的枚举中定义 private 级别的原始值类型。</p>\n<h4 id=\"嵌套类型\"><a href=\"#嵌套类型\" class=\"headerlink\" title=\"嵌套类型\"></a>嵌套类型</h4><p>如果在 private 级别的类型中定义嵌套类型，那么该嵌套类型就自动拥有 private 访问级别。如果在 public 或者 internal 级别的类型中定义嵌套类型，那么该嵌套类型自动拥有 internal 访问级别。如果想让嵌套类型拥有 public 访问级别，那么需要明确指定该嵌套类型的访问级别。</p>\n<h3 id=\"子类\"><a href=\"#子类\" class=\"headerlink\" title=\"子类\"></a>子类</h3><p>子类的访问级别不得高于父类的访问级别。例如，父类的访问级别是 internal，子类的访问级别就不能是 public。<br>此外，你可以在符合当前访问级别的条件下重写任意类成员（方法、属性、构造器、下标等）。<br>可以通过重写为继承来的类成员提供更高的访问级别。下面的例子中，类 A 的访问级别是 public，它包含一个方法 someMethod()，访问级别为 private。类 B 继承自类 A，访问级别为 internal，但是在类 B 中重写了类 A 中访问级别为 private 的方法 someMethod()，并重新指定为 internal 级别。通过这种方式，我们就可以将某类中 private 级别的类成员重新指定为更高的访问级别，以便其他人使用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">fileprivate</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someMethod</span><span class=\"params\">()</span></span> &#123;&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">internal</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>: <span class=\"title\">A</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">internal</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someMethod</span><span class=\"params\">()</span></span> &#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们甚至可以在子类中，用子类成员去访问访问级别更低的父类成员，只要这一操作在相应访问级别的限制范围内（也就是说，在同一源文件中访问父类 private 级别的成员，在同一模块内访问父类 internal 级别的成员）：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">fileprivate</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someMethod</span><span class=\"params\">()</span></span> &#123;&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">internal</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>: <span class=\"title\">A</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">internal</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someMethod</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.someMethod()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>因为父类 A 和子类 B 定义在同一个源文件中，所以在子类 B 可以在重写的 someMethod() 方法中调用 super.someMethod()。</p>\n<h3 id=\"常量、变量、属性、下标\"><a href=\"#常量、变量、属性、下标\" class=\"headerlink\" title=\"常量、变量、属性、下标\"></a>常量、变量、属性、下标</h3><p>常量、变量、属性不能拥有比它们的类型更高的访问级别。例如，你不能定义一个 public 级别的属性，但是它的类型却是 private 级别的。同样，下标也不能拥有比索引类型或返回类型更高的访问级别。<br>如果常量、变量、属性、下标的类型是 private 级别的，那么它们必须明确指定访问级别为 private：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">var</span> privateInstance = <span class=\"type\">SomePrivateClass</span>()</div></pre></td></tr></table></figure>\n<h4 id=\"Getter-和-Setter\"><a href=\"#Getter-和-Setter\" class=\"headerlink\" title=\"Getter 和 Setter\"></a>Getter 和 Setter</h4><p>常量、变量、属性、下标的 Getters 和 Setters 的访问级别和它们所属类型的访问级别相同。<br>Setter 的访问级别可以低于对应的 Getter 的访问级别，这样就可以控制变量、属性或下标的读写权限。在 var 或 subscript 关键字之前，你可以通过 fileprivate(set)，private(set) 或 internal(set) 为它们的写入权限指定更低的访问级别。<br>    这个规则同时适用于存储型属性和计算型属性。即使你不明确指定存储型属性的 Getter 和 Setter，Swift 也会隐式地为其创建 Getter 和 Setter，用于访问该属性的后备存储。使用 fileprivate(set)，private(set) 和 internal(set) 可以改变 Setter 的访问级别，这对计算型属性也同样适用。</p>\n<p>下面的例子中定义了一个名为 TrackedString 的结构体，它记录了 value 属性被修改的次数：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TrackedString</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span>(<span class=\"keyword\">set</span>) <span class=\"keyword\">var</span> numberOfEdits = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">var</span> value: <span class=\"type\">String</span> = <span class=\"string\">\"\"</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">didSet</span> &#123;</div><div class=\"line\">            numberOfEdits += <span class=\"number\">1</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>TrackedString 结构体定义了一个用于存储 String 值的属性 value，并将初始值设为 “”（一个空字符串）。该结构体还定义了另一个用于存储 Int 值的属性 numberOfEdits，它用于记录属性 value 被修改的次数。这个功能通过属性 value 的 didSet 观察器实现，每当给 value 赋新值时就会调用 didSet 方法，然后将 numberOfEdits 的值加一。<br>结构体 TrackedString 和它的属性 value 均没有显式指定访问级别，所以它们都拥有默认的访问级别 internal。但是该结构体的 numberOfEdits 属性使用了 private(set) 修饰符，这意味着 numberOfEdits 属性只能在定义该结构体的源文件中赋值。numberOfEdits 属性的 Getter 依然是默认的访问级别 internal，但是 Setter 的访问级别是 private，这表示该属性只有在当前的源文件中是可读写的，而在当前源文件所属的模块中只是一个可读的属性。<br>如果你实例化 TrackedString 结构体，并多次对 value 属性的值进行修改，你就会看到 numberOfEdits 的值会随着修改次数而变化：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> stringToEdit = <span class=\"type\">TrackedString</span>()</div><div class=\"line\">stringToEdit.value = <span class=\"string\">\"This string will be tracked.\"</span></div><div class=\"line\">stringToEdit.value += <span class=\"string\">\" This edit will increment numberOfEdits.\"</span></div><div class=\"line\">stringToEdit.value += <span class=\"string\">\" So will this one.\"</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The number of edits is <span class=\"subst\">\\(stringToEdit.numberOfEdits)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"The number of edits is 3\"</span></div></pre></td></tr></table></figure>\n<p>虽然你可以在其他的源文件中实例化该结构体并且获取到 numberOfEdits 属性的值，但是你不能对其进行赋值。这一限制保护了该记录功能的实现细节，同时还提供了方便的访问方式。<br>你可以在必要时为 Getter 和 Setter 显式指定访问级别。下面的例子将 TrackedString 结构体明确指定为了 public 访问级别。结构体的成员（包括 numberOfEdits 属性）拥有默认的访问级别 internal。你可以结合 public 和 private(set) 修饰符把结构体中的 numberOfEdits 属性的 Getter 的访问级别设置为 public，而 Setter 的访问级别设置为 private：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TrackedString</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">private</span>(<span class=\"keyword\">set</span>) <span class=\"keyword\">var</span> numberOfEdits = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> value: <span class=\"type\">String</span> = <span class=\"string\">\"\"</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">didSet</span> &#123;</div><div class=\"line\">            numberOfEdits += <span class=\"number\">1</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">init</span>() &#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"构造器\"><a href=\"#构造器\" class=\"headerlink\" title=\"构造器\"></a>构造器</h3><p>自定义构造器的访问级别可以低于或等于其所属类型的访问级别。唯一的例外是必要构造器，它的访问级别必须和所属类型的访问级别相同。<br>如同函数或方法的参数，构造器参数的访问级别也不能低于构造器本身的访问级别。</p>\n<h4 id=\"默认构造器\"><a href=\"#默认构造器\" class=\"headerlink\" title=\"默认构造器\"></a>默认构造器</h4><p>Swift 会为结构体和类提供一个默认的无参数的构造器，只要它们为所有存储型属性设置了默认初始值，并且未提供自定义的构造器。<br>默认构造器的访问级别与所属类型的访问级别相同，除非类型的访问级别是 public。如果一个类型被指定为 public 级别，那么默认构造器的访问级别将为 internal。如果你希望一个 public 级别的类型也能在其他模块中使用这种无参数的默认构造器，你只能自己提供一个 public 访问级别的无参数构造器。</p>\n<h4 id=\"结构体默认的成员逐一构造器\"><a href=\"#结构体默认的成员逐一构造器\" class=\"headerlink\" title=\"结构体默认的成员逐一构造器\"></a>结构体默认的成员逐一构造器</h4><p>如果结构体中任意存储型属性的访问级别为 private，那么该结构体默认的成员逐一构造器的访问级别就是 private。否则，这种构造器的访问级别依然是 internal。</p>\n<p>如同前面提到的默认构造器，如果你希望一个 public 级别的结构体也能在其他模块中使用其默认的成员逐一构造器，你依然只能自己提供一个 public 访问级别的成员逐一构造器。</p>\n<h3 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h3><p>如果想为一个协议类型明确地指定访问级别，在定义协议时指定即可。这将限制该协议只能在适当的访问级别范围内被采纳。<br>协议中的每一个要求都具有和该协议相同的访问级别。你不能将协议中的要求设置为其他访问级别。这样才能确保该协议的所有要求对于任意采纳者都将可用。<br>    如果你定义了一个 public 访问级别的协议，那么该协议的所有实现也会是 public 访问级别。这一点不同于其他类型，例如，当类型是 public 访问级别时，其成员的访问级别却只是 internal。</p>\n<h4 id=\"协议继承\"><a href=\"#协议继承\" class=\"headerlink\" title=\"协议继承\"></a>协议继承</h4><p>如果定义了一个继承自其他协议的新协议，那么新协议拥有的访问级别最高也只能和被继承协议的访问级别相同。例如，你不能将继承自 internal 协议的新协议定义为 public 协议。</p>\n<h4 id=\"协议一致性\"><a href=\"#协议一致性\" class=\"headerlink\" title=\"协议一致性\"></a>协议一致性</h4><p>一个类型可以采纳比自身访问级别低的协议。例如，你可以定义一个 public 级别的类型，它可以在其他模块中使用，同时它也可以采纳一个 internal 级别的协议，但是只能在该协议所在的模块中作为符合该协议的类型使用。<br>采纳了协议的类型的访问级别取它本身和所采纳协议两者间最低的访问级别。也就是说如果一个类型是 public 级别，采纳的协议是 internal 级别，那么采纳了这个协议后，该类型作为符合协议的类型时，其访问级别也是 internal。<br>如果你采纳了协议，那么实现了协议的所有要求后，你必须确保这些实现的访问级别不能低于协议的访问级别。例如，一个 public 级别的类型，采纳了 internal 级别的协议，那么协议的实现至少也得是 internal 级别。<br>    Swift 和 Objective-C 一样，协议的一致性是全局的，也就是说，在同一程序中，一个类型不可能用两种不同的方式实现同一个协议。</p>\n<h3 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h3><p>你可以在访问级别允许的情况下对类、结构体、枚举进行扩展。扩展成员具有和原始类型成员一致的访问级别。例如，你扩展了一个 public 或者 internal 类型，扩展中的成员具有默认的 internal 访问级别，和原始类型中的成员一致 。如果你扩展了一个 private 类型，扩展成员则拥有默认的 private 访问级别。<br>或者，你可以明确指定扩展的访问级别（例如，private extension），从而给该扩展中的所有成员指定一个新的默认访问级别。这个新的默认访问级别仍然可以被单独指定的访问级别所覆盖。</p>\n<h4 id=\"通过扩展添加协议一致性\"><a href=\"#通过扩展添加协议一致性\" class=\"headerlink\" title=\"通过扩展添加协议一致性\"></a>通过扩展添加协议一致性</h4><p>如果你通过扩展来采纳协议，那么你就不能显式指定该扩展的访问级别了。协议拥有相应的访问级别，并会为该扩展中所有协议要求的实现提供默认的访问级别。</p>\n<h3 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h3><p>泛型类型或泛型函数的访问级别取决于泛型类型或泛型函数本身的访问级别，还需结合类型参数的类型约束的访问级别，根据这些访问级别中的最低访问级别来确定。</p>\n<h3 id=\"类型别名\"><a href=\"#类型别名\" class=\"headerlink\" title=\"类型别名\"></a>类型别名</h3><p>你定义的任何类型别名都会被当作不同的类型，以便于进行访问控制。类型别名的访问级别不可高于其表示的类型的访问级别。例如，private 级别的类型别名可以作为 private，file-private，internal，public或者open类型的别名，但是 public 级别的类型别名只能作为 public 类型的别名，不能作为 internal，file-private，或 private 类型的别名。<br>    这条规则也适用于为满足协议一致性而将类型别名用于关联类型的情况。</p>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html/\" target=\"_blank\" rel=\"external\"> AccessControl </a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>​<br>​    访问控制可以限定其他源文件或模块中的代码对你的代码的访问级别。这个特性可以让我们隐藏代码的一些实现细节，并且可以为其他人可以访问和使用的代码提供接口。</p>\n<p>你可以明确地给单个类型（类、结构体、枚举）设置访问级别，也可以给这些类型的属性、方法、构造器、下标等设置访问级别。协议也可以被限定在一定的范围内使用，包括协议里的全局常量、变量和函数。<br>Swift 不仅提供了多种不同的访问级别，还为某些典型场景提供了默认的访问级别，这样就不需要我们在每段代码中都申明显式访问级别。其实，如果只是开发一个单一目标的应用程序，我们完全可以不用显式声明代码的访问级别。</p>","more":"<h3 id=\"模板和源文件\"><a href=\"#模板和源文件\" class=\"headerlink\" title=\"模板和源文件\"></a>模板和源文件</h3><p>Swift 中的访问控制模型基于模块和源文件这两个概念。<br>模块指的是独立的代码单元，框架或应用程序会作为一个独立的模块来构建和发布。在 Swift 中，一个模块可以使用 import 关键字导入另外一个模块。<br>在 Swift 中，Xcode 的每个目标（例如框架或应用程序）都被当作独立的模块处理。如果你是为了实现某个通用的功能，或者是为了封装一些常用方法而将代码打包成独立的框架，这个框架就是 Swift 中的一个模块。当它被导入到某个应用程序或者其他框架时，框架内容都将属于这个独立的模块。<br>源文件就是 Swift 中的源代码文件，它通常属于一个模块，即一个应用程序或者框架。尽管我们一般会将不同的类型分别定义在不同的源文件中，但是同一个源文件也可以包含多个类型、函数之类的定义。</p>\n<h3 id=\"访问级别\"><a href=\"#访问级别\" class=\"headerlink\" title=\"访问级别\"></a>访问级别</h3><p>Swift 为代码中的实体提供了五种不同的访问级别。这些访问级别不仅与源文件中定义的实体相关，同时也与源文件所属的模块相关。</p>\n<ul>\n<li>开放访问和公开访问可以访问同一模块源文件中的任何实体，在模块外也可以通过导入该模块来访问源文件里的所有实体。通常情况下，框架中的某个接口可以被任何人使用时，你可以将其设置为开放或者公开访问。</li>\n<li>内部访问可以访问同一模块源文件中的任何实体，但是不能从模块外访问该模块源文件中的实体。通常情况下，某个接口只在应用程序或框架内部使用时，你可以将其设置为内部访问。</li>\n<li>文件私有访问限制实体只能被所定义的文件内部访问。当需要把这些细节被整个文件使用的时候，使用文件私有访问隐藏了一些特定功能的实现细节。</li>\n<li>私有访问限制实体只能在所定义的作用域内使用。需要把这些细节被整个作用域使用的时候，使用文件私有访问隐藏了一些特定功能的实现细节。</li>\n</ul>\n<p>开放访问为最高（限制最少）访问级别，私有访问为最低（限制最多）访问级别。<br>开放访问只作用于类类型和类的成员，它和公开访问的区别如下：</p>\n<ul>\n<li>公开访问或者其他更严访问级别的类，只能在它们定义的模块内部被继承。</li>\n<li>公开访问或者其他更严访问级别的类成员，只能在它们定义的模块内部的子类中重写。</li>\n<li>开放访问的类，可以在它们定义的模块中被继承，也可以在引用它们的模块中被继承。</li>\n<li>开放访问的类成员，可以在它们定义的模块中子类中重写，也可以在引用它们的模块中的子类重写。</li>\n</ul>\n<p>把一个类标记为开放，显式地表明，你认为其他模块中的代码使用此类作为父类，然后你已经设计好了你的类的代码了。</p>\n<h4 id=\"访问级别基本原则\"><a href=\"#访问级别基本原则\" class=\"headerlink\" title=\"访问级别基本原则\"></a>访问级别基本原则</h4><p>Swift 中的访问级别遵循一个基本原则：不可以在某个实体中定义访问级别更低（更严格）的实体。例如：</p>\n<ul>\n<li>一个公开访问级别的变量，其类型的访问级别不能是内部，文件私有或是私有类型的。因为无法保证变量的类型在使用变量的地方也具有访问权限。</li>\n<li>函数的访问级别不能高于它的参数类型和返回类型的访问级别。因为这样就会出现函数可以在任何地方被访问，但是它的参数类型和返回类型却不可以的情况。</li>\n</ul>\n<h4 id=\"默认访问级别\"><a href=\"#默认访问级别\" class=\"headerlink\" title=\"默认访问级别\"></a>默认访问级别</h4><p>如果你不为代码中的实体显式指定访问级别，那么它们默认为 internal 级别（有一些例外情况，稍后会进行说明）。因此，在大多数情况下，我们不需要显式指定实体的访问级别。</p>\n<h4 id=\"单目标应用程序的访问级别\"><a href=\"#单目标应用程序的访问级别\" class=\"headerlink\" title=\"单目标应用程序的访问级别\"></a>单目标应用程序的访问级别</h4><p>当你编写一个单目标应用程序时，应用的所有功能都是为该应用服务，而不需要提供给其他应用或者模块使用，所以我们不需要明确设置访问级别，使用默认的访问级别 internal 即可。但是，你也可以使用文件私有访问或私有访问级别，用于隐藏一些功能的实现细节。</p>\n<h4 id=\"框架的访问级别\"><a href=\"#框架的访问级别\" class=\"headerlink\" title=\"框架的访问级别\"></a>框架的访问级别</h4><p>当你开发框架时，就需要把一些对外的接口定义为开放访问或公开访问级别，以便使用者导入该框架后可以正常使用其功能。这些被你定义为对外的接口，就是这个框架的 API。<br>    框架依然会使用默认的内部访问级别，也可以指定为文件私有访问或者私有访问级别。当你想把某个实体作为框架的 API 的时候，需显式为其指定开放访问或公开访问级别。</p>\n<h4 id=\"单元测试目标的访问级别\"><a href=\"#单元测试目标的访问级别\" class=\"headerlink\" title=\"单元测试目标的访问级别\"></a>单元测试目标的访问级别</h4><p>当你的应用程序包含单元测试目标时，为了测试，测试模块需要访问应用程序模块中的代码。默认情况下只有开放访问或公开访问级别级别的实体才可以被其他模块访问。然而，如果在导入应用程序模块的语句前使用 @testable 特性，然后在允许测试的编译设置（Build Options -&gt; Enable Testability）下编译这个应用程序模块，单元测试目标就可以访问应用程序模块中所有内部级别的实体。</p>\n<h3 id=\"访问控制语法\"><a href=\"#访问控制语法\" class=\"headerlink\" title=\"访问控制语法\"></a>访问控制语法</h3><p>通过修饰符 <code>open</code>，<code>public</code>，<code>internal</code>，<code>filepart</code>，<code>private</code> 来声明实体的访问级别：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomePublicClass</span> </span>&#123;&#125;</div><div class=\"line\"><span class=\"keyword\">internal</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeInternalClass</span> </span>&#123;&#125;</div><div class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeFilePrivateClass</span> </span>&#123;&#125;</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomePrivateClass</span> </span>&#123;&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> somePublicVariable = <span class=\"number\">0</span></div><div class=\"line\"><span class=\"keyword\">internal</span> <span class=\"keyword\">let</span> someInternalConstant = <span class=\"number\">0</span></div><div class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someFilePrivateFunction</span><span class=\"params\">()</span></span> &#123;&#125;</div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">somePrivateFunction</span><span class=\"params\">()</span></span> &#123;&#125;</div></pre></td></tr></table></figure>\n<pre><code>默认情况下，否则实体默认的访问级别为内部访问级别\n</code></pre><h3 id=\"自定义类型\"><a href=\"#自定义类型\" class=\"headerlink\" title=\"自定义类型\"></a>自定义类型</h3><p>如果想为一个自定义类型指定访问级别，在定义类型时进行指定即可。新类型只能在它的访问级别限制范围内使用。例如，你定义了一个文件私有级别的类，那这个类就只能在定义它的源文件中使用，可以作为属性类型、函数参数类型或者返回类型，等等。<br>一个类型的访问级别也会影响到类型成员（属性、方法、构造器、下标）的默认访问级别。如果你将类型指定为私有或者文件私有级别，那么该类型的所有成员的默认访问级别也会变成私有或者文件私有级别。如果你将类型指定为公开或者内部访问级别（或者不明确指定访问级别，而使用默认的内部访问级别），那么该类型的所有成员的默认访问级别将是内部访问。<br>    一个公开类型的所有成员的访问级别默认为内部访问级别，而不是公开级别。如果你想将某个成员指定为公开访问级别，那么你必须显式指定。这样做的好处是，在你定义公共接口的时候，可以明确地选择哪些接口是需要公开的，哪些是内部使用的，避免不小心将内部使用的接口公开。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomePublicClass</span> </span>&#123;                  <span class=\"comment\">// explicitly public class</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> somePublicProperty = <span class=\"number\">0</span>            <span class=\"comment\">// explicitly public class member</span></div><div class=\"line\">    <span class=\"keyword\">var</span> someInternalProperty = <span class=\"number\">0</span>                 <span class=\"comment\">// implicitly internal class member</span></div><div class=\"line\">    <span class=\"keyword\">fileprivate</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someFilePrivateMethod</span><span class=\"params\">()</span></span> &#123;&#125;  <span class=\"comment\">// explicitly file-private class member</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">somePrivateMethod</span><span class=\"params\">()</span></span> &#123;&#125;          <span class=\"comment\">// explicitly private class member</span></div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeInternalClass</span> </span>&#123;                       <span class=\"comment\">// implicitly internal class</span></div><div class=\"line\">    <span class=\"keyword\">var</span> someInternalProperty = <span class=\"number\">0</span>                 <span class=\"comment\">// implicitly internal class member</span></div><div class=\"line\">    <span class=\"keyword\">fileprivate</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someFilePrivateMethod</span><span class=\"params\">()</span></span> &#123;&#125;  <span class=\"comment\">// explicitly file-private class member</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">somePrivateMethod</span><span class=\"params\">()</span></span> &#123;&#125;          <span class=\"comment\">// explicitly private class member</span></div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">fileprivate</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeFilePrivateClass</span> </span>&#123;        <span class=\"comment\">// explicitly file-private class</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someFilePrivateMethod</span><span class=\"params\">()</span></span> &#123;&#125;              <span class=\"comment\">// implicitly file-private class member</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">somePrivateMethod</span><span class=\"params\">()</span></span> &#123;&#125;          <span class=\"comment\">// explicitly private class member</span></div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomePrivateClass</span> </span>&#123;                <span class=\"comment\">// explicitly private class</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">somePrivateMethod</span><span class=\"params\">()</span></span> &#123;&#125;                  <span class=\"comment\">// implicitly private class member</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"元组类型\"><a href=\"#元组类型\" class=\"headerlink\" title=\"元组类型\"></a>元组类型</h4><p>元组的访问级别将由元组中访问级别最严格的类型来决定。例如，如果你构建了一个包含两种不同类型的元组，其中一个类型为内部访问级别，另一个类型为私有访问级别，那么这个元组的访问级别为私有访问级别。<br>    元组不同于类、结构体、枚举、函数那样有单独的定义。元组的访问级别是在它被使用时自动推断出的，而无法明确指定。</p>\n<h4 id=\"函数类型\"><a href=\"#函数类型\" class=\"headerlink\" title=\"函数类型\"></a>函数类型</h4><p>函数的访问级别根据访问级别最严格的参数类型或返回类型的访问级别来决定。但是，如果这种访问级别不符合函数定义所在环境的默认访问级别，那么就需要明确地指定该函数的访问级别。<br>下面的例子定义了一个名为 someFunction() 的全局函数，并且没有明确地指定其访问级别。也许你会认为该函数应该拥有默认的访问级别 internal，但事实并非如此。事实上，如果按下面这种写法，代码将无法通过编译：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someFunction</span><span class=\"params\">()</span></span> -&gt; (<span class=\"type\">SomeInternalClass</span>, <span class=\"type\">SomePrivateClass</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// function implementation goes here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以看到，这个函数的返回类型是一个元组，该元组中包含两个自定义的类（可查阅自定义类型）。其中一个类的访问级别是 internal，另一个的访问级别是 private，所以根据元组访问级别的原则，该元组的访问级别是 private（元组的访问级别与元组中访问级别最低的类型一致）。<br>因为该函数返回类型的访问级别是 private，所以你必须使用 private 修饰符，明确指定该函数的访问级别：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someFunction</span><span class=\"params\">()</span></span> -&gt; (<span class=\"type\">SomeInternalClass</span>, <span class=\"type\">SomePrivateClass</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// function implementation goes here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>将该函数指定为 public 或 internal，或者使用默认的访问级别 internal 都是错误的，因为如果把该函数当做 public 或 internal 级别来使用的话，可能会无法访问 private 级别的返回值。</p>\n<h4 id=\"枚举类型\"><a href=\"#枚举类型\" class=\"headerlink\" title=\"枚举类型\"></a>枚举类型</h4><p>枚举成员的访问级别和该枚举类型相同，你不能为枚举成员单独指定不同的访问级别。<br>比如下面的例子，枚举 CompassPoint 被明确指定为 public 级别，那么它的成员 North、South、East、West 的访问级别同样也是 public：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">CompassPoint</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> north</div><div class=\"line\">    <span class=\"keyword\">case</span> south</div><div class=\"line\">    <span class=\"keyword\">case</span> east</div><div class=\"line\">    <span class=\"keyword\">case</span> west</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"原始值和关联值\"><a href=\"#原始值和关联值\" class=\"headerlink\" title=\"原始值和关联值\"></a>原始值和关联值</h5><p>枚举定义中的任何原始值或关联值的类型的访问级别至少不能低于枚举类型的访问级别。例如，你不能在一个 internal 访问级别的枚举中定义 private 级别的原始值类型。</p>\n<h4 id=\"嵌套类型\"><a href=\"#嵌套类型\" class=\"headerlink\" title=\"嵌套类型\"></a>嵌套类型</h4><p>如果在 private 级别的类型中定义嵌套类型，那么该嵌套类型就自动拥有 private 访问级别。如果在 public 或者 internal 级别的类型中定义嵌套类型，那么该嵌套类型自动拥有 internal 访问级别。如果想让嵌套类型拥有 public 访问级别，那么需要明确指定该嵌套类型的访问级别。</p>\n<h3 id=\"子类\"><a href=\"#子类\" class=\"headerlink\" title=\"子类\"></a>子类</h3><p>子类的访问级别不得高于父类的访问级别。例如，父类的访问级别是 internal，子类的访问级别就不能是 public。<br>此外，你可以在符合当前访问级别的条件下重写任意类成员（方法、属性、构造器、下标等）。<br>可以通过重写为继承来的类成员提供更高的访问级别。下面的例子中，类 A 的访问级别是 public，它包含一个方法 someMethod()，访问级别为 private。类 B 继承自类 A，访问级别为 internal，但是在类 B 中重写了类 A 中访问级别为 private 的方法 someMethod()，并重新指定为 internal 级别。通过这种方式，我们就可以将某类中 private 级别的类成员重新指定为更高的访问级别，以便其他人使用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">fileprivate</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someMethod</span><span class=\"params\">()</span></span> &#123;&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">internal</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>: <span class=\"title\">A</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">internal</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someMethod</span><span class=\"params\">()</span></span> &#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们甚至可以在子类中，用子类成员去访问访问级别更低的父类成员，只要这一操作在相应访问级别的限制范围内（也就是说，在同一源文件中访问父类 private 级别的成员，在同一模块内访问父类 internal 级别的成员）：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">fileprivate</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someMethod</span><span class=\"params\">()</span></span> &#123;&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">internal</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>: <span class=\"title\">A</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">internal</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someMethod</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.someMethod()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>因为父类 A 和子类 B 定义在同一个源文件中，所以在子类 B 可以在重写的 someMethod() 方法中调用 super.someMethod()。</p>\n<h3 id=\"常量、变量、属性、下标\"><a href=\"#常量、变量、属性、下标\" class=\"headerlink\" title=\"常量、变量、属性、下标\"></a>常量、变量、属性、下标</h3><p>常量、变量、属性不能拥有比它们的类型更高的访问级别。例如，你不能定义一个 public 级别的属性，但是它的类型却是 private 级别的。同样，下标也不能拥有比索引类型或返回类型更高的访问级别。<br>如果常量、变量、属性、下标的类型是 private 级别的，那么它们必须明确指定访问级别为 private：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">var</span> privateInstance = <span class=\"type\">SomePrivateClass</span>()</div></pre></td></tr></table></figure>\n<h4 id=\"Getter-和-Setter\"><a href=\"#Getter-和-Setter\" class=\"headerlink\" title=\"Getter 和 Setter\"></a>Getter 和 Setter</h4><p>常量、变量、属性、下标的 Getters 和 Setters 的访问级别和它们所属类型的访问级别相同。<br>Setter 的访问级别可以低于对应的 Getter 的访问级别，这样就可以控制变量、属性或下标的读写权限。在 var 或 subscript 关键字之前，你可以通过 fileprivate(set)，private(set) 或 internal(set) 为它们的写入权限指定更低的访问级别。<br>    这个规则同时适用于存储型属性和计算型属性。即使你不明确指定存储型属性的 Getter 和 Setter，Swift 也会隐式地为其创建 Getter 和 Setter，用于访问该属性的后备存储。使用 fileprivate(set)，private(set) 和 internal(set) 可以改变 Setter 的访问级别，这对计算型属性也同样适用。</p>\n<p>下面的例子中定义了一个名为 TrackedString 的结构体，它记录了 value 属性被修改的次数：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TrackedString</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span>(<span class=\"keyword\">set</span>) <span class=\"keyword\">var</span> numberOfEdits = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">var</span> value: <span class=\"type\">String</span> = <span class=\"string\">\"\"</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">didSet</span> &#123;</div><div class=\"line\">            numberOfEdits += <span class=\"number\">1</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>TrackedString 结构体定义了一个用于存储 String 值的属性 value，并将初始值设为 “”（一个空字符串）。该结构体还定义了另一个用于存储 Int 值的属性 numberOfEdits，它用于记录属性 value 被修改的次数。这个功能通过属性 value 的 didSet 观察器实现，每当给 value 赋新值时就会调用 didSet 方法，然后将 numberOfEdits 的值加一。<br>结构体 TrackedString 和它的属性 value 均没有显式指定访问级别，所以它们都拥有默认的访问级别 internal。但是该结构体的 numberOfEdits 属性使用了 private(set) 修饰符，这意味着 numberOfEdits 属性只能在定义该结构体的源文件中赋值。numberOfEdits 属性的 Getter 依然是默认的访问级别 internal，但是 Setter 的访问级别是 private，这表示该属性只有在当前的源文件中是可读写的，而在当前源文件所属的模块中只是一个可读的属性。<br>如果你实例化 TrackedString 结构体，并多次对 value 属性的值进行修改，你就会看到 numberOfEdits 的值会随着修改次数而变化：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> stringToEdit = <span class=\"type\">TrackedString</span>()</div><div class=\"line\">stringToEdit.value = <span class=\"string\">\"This string will be tracked.\"</span></div><div class=\"line\">stringToEdit.value += <span class=\"string\">\" This edit will increment numberOfEdits.\"</span></div><div class=\"line\">stringToEdit.value += <span class=\"string\">\" So will this one.\"</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The number of edits is <span class=\"subst\">\\(stringToEdit.numberOfEdits)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"The number of edits is 3\"</span></div></pre></td></tr></table></figure>\n<p>虽然你可以在其他的源文件中实例化该结构体并且获取到 numberOfEdits 属性的值，但是你不能对其进行赋值。这一限制保护了该记录功能的实现细节，同时还提供了方便的访问方式。<br>你可以在必要时为 Getter 和 Setter 显式指定访问级别。下面的例子将 TrackedString 结构体明确指定为了 public 访问级别。结构体的成员（包括 numberOfEdits 属性）拥有默认的访问级别 internal。你可以结合 public 和 private(set) 修饰符把结构体中的 numberOfEdits 属性的 Getter 的访问级别设置为 public，而 Setter 的访问级别设置为 private：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TrackedString</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">private</span>(<span class=\"keyword\">set</span>) <span class=\"keyword\">var</span> numberOfEdits = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> value: <span class=\"type\">String</span> = <span class=\"string\">\"\"</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">didSet</span> &#123;</div><div class=\"line\">            numberOfEdits += <span class=\"number\">1</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">init</span>() &#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"构造器\"><a href=\"#构造器\" class=\"headerlink\" title=\"构造器\"></a>构造器</h3><p>自定义构造器的访问级别可以低于或等于其所属类型的访问级别。唯一的例外是必要构造器，它的访问级别必须和所属类型的访问级别相同。<br>如同函数或方法的参数，构造器参数的访问级别也不能低于构造器本身的访问级别。</p>\n<h4 id=\"默认构造器\"><a href=\"#默认构造器\" class=\"headerlink\" title=\"默认构造器\"></a>默认构造器</h4><p>Swift 会为结构体和类提供一个默认的无参数的构造器，只要它们为所有存储型属性设置了默认初始值，并且未提供自定义的构造器。<br>默认构造器的访问级别与所属类型的访问级别相同，除非类型的访问级别是 public。如果一个类型被指定为 public 级别，那么默认构造器的访问级别将为 internal。如果你希望一个 public 级别的类型也能在其他模块中使用这种无参数的默认构造器，你只能自己提供一个 public 访问级别的无参数构造器。</p>\n<h4 id=\"结构体默认的成员逐一构造器\"><a href=\"#结构体默认的成员逐一构造器\" class=\"headerlink\" title=\"结构体默认的成员逐一构造器\"></a>结构体默认的成员逐一构造器</h4><p>如果结构体中任意存储型属性的访问级别为 private，那么该结构体默认的成员逐一构造器的访问级别就是 private。否则，这种构造器的访问级别依然是 internal。</p>\n<p>如同前面提到的默认构造器，如果你希望一个 public 级别的结构体也能在其他模块中使用其默认的成员逐一构造器，你依然只能自己提供一个 public 访问级别的成员逐一构造器。</p>\n<h3 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h3><p>如果想为一个协议类型明确地指定访问级别，在定义协议时指定即可。这将限制该协议只能在适当的访问级别范围内被采纳。<br>协议中的每一个要求都具有和该协议相同的访问级别。你不能将协议中的要求设置为其他访问级别。这样才能确保该协议的所有要求对于任意采纳者都将可用。<br>    如果你定义了一个 public 访问级别的协议，那么该协议的所有实现也会是 public 访问级别。这一点不同于其他类型，例如，当类型是 public 访问级别时，其成员的访问级别却只是 internal。</p>\n<h4 id=\"协议继承\"><a href=\"#协议继承\" class=\"headerlink\" title=\"协议继承\"></a>协议继承</h4><p>如果定义了一个继承自其他协议的新协议，那么新协议拥有的访问级别最高也只能和被继承协议的访问级别相同。例如，你不能将继承自 internal 协议的新协议定义为 public 协议。</p>\n<h4 id=\"协议一致性\"><a href=\"#协议一致性\" class=\"headerlink\" title=\"协议一致性\"></a>协议一致性</h4><p>一个类型可以采纳比自身访问级别低的协议。例如，你可以定义一个 public 级别的类型，它可以在其他模块中使用，同时它也可以采纳一个 internal 级别的协议，但是只能在该协议所在的模块中作为符合该协议的类型使用。<br>采纳了协议的类型的访问级别取它本身和所采纳协议两者间最低的访问级别。也就是说如果一个类型是 public 级别，采纳的协议是 internal 级别，那么采纳了这个协议后，该类型作为符合协议的类型时，其访问级别也是 internal。<br>如果你采纳了协议，那么实现了协议的所有要求后，你必须确保这些实现的访问级别不能低于协议的访问级别。例如，一个 public 级别的类型，采纳了 internal 级别的协议，那么协议的实现至少也得是 internal 级别。<br>    Swift 和 Objective-C 一样，协议的一致性是全局的，也就是说，在同一程序中，一个类型不可能用两种不同的方式实现同一个协议。</p>\n<h3 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h3><p>你可以在访问级别允许的情况下对类、结构体、枚举进行扩展。扩展成员具有和原始类型成员一致的访问级别。例如，你扩展了一个 public 或者 internal 类型，扩展中的成员具有默认的 internal 访问级别，和原始类型中的成员一致 。如果你扩展了一个 private 类型，扩展成员则拥有默认的 private 访问级别。<br>或者，你可以明确指定扩展的访问级别（例如，private extension），从而给该扩展中的所有成员指定一个新的默认访问级别。这个新的默认访问级别仍然可以被单独指定的访问级别所覆盖。</p>\n<h4 id=\"通过扩展添加协议一致性\"><a href=\"#通过扩展添加协议一致性\" class=\"headerlink\" title=\"通过扩展添加协议一致性\"></a>通过扩展添加协议一致性</h4><p>如果你通过扩展来采纳协议，那么你就不能显式指定该扩展的访问级别了。协议拥有相应的访问级别，并会为该扩展中所有协议要求的实现提供默认的访问级别。</p>\n<h3 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h3><p>泛型类型或泛型函数的访问级别取决于泛型类型或泛型函数本身的访问级别，还需结合类型参数的类型约束的访问级别，根据这些访问级别中的最低访问级别来确定。</p>\n<h3 id=\"类型别名\"><a href=\"#类型别名\" class=\"headerlink\" title=\"类型别名\"></a>类型别名</h3><p>你定义的任何类型别名都会被当作不同的类型，以便于进行访问控制。类型别名的访问级别不可高于其表示的类型的访问级别。例如，private 级别的类型别名可以作为 private，file-private，internal，public或者open类型的别名，但是 public 级别的类型别名只能作为 public 类型的别名，不能作为 internal，file-private，或 private 类型的别名。<br>    这条规则也适用于为满足协议一致性而将类型别名用于关联类型的情况。</p>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html/\" target=\"_blank\" rel=\"external\"> AccessControl </a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>"},{"layout":"post","title":"Swift ARC","date":"2016-11-28T19:20:11.000Z","author":"liangtong","catalog":true,"_content":"\n\n\n​\tSwift 使用自动引用计数（ARC）机制来跟踪和管理你的应用程序的内存。通常情况下，Swift 内存管理机制会一直起作用，你无须自己来考虑内存的管理。ARC 会在类的实例不再被使用时，自动释放其占用的内存。然而在少数情况下，为了能帮助你管理内存，ARC 需要更多的，代码之间关系的信息。在 Swift 使用 ARC 与在 Obejctive-C 中使用 ARC 非常类似\n\t引用计数仅仅应用于类的实例。结构体和枚举类型是值类型，不是引用类型，也不是通过引用的方式存储和传递。\n\n\n\n### ARC工作机制\n当你每次创建一个类的新的实例的时候，ARC 会分配一块内存来储存该实例信息。内存中会包含实例的类型信息，以及这个实例所有相关的存储型属性的值。\n当实例不再被使用时，ARC 释放实例所占用的内存，并让释放的内存能挪作他用。这确保了不再被使用的实例，不会一直占用内存空间。\n\n<!-- more -->\n\n然而，当 ARC 收回和释放了正在被使用中的实例，该实例的属性和方法将不能再被访问和调用。实际上，如果你试图访问这个实例，你的应用程序很可能会崩溃。\n为了确保使用中的实例不会被销毁，ARC 会跟踪和计算每一个实例正在被多少属性，常量和变量所引用。哪怕实例的引用数为1，ARC都不会销毁这个实例。\n\n为了使上述成为可能，无论你将实例赋值给属性、常量或变量，它们都会创建此实例的强引用。之所以称之为“强”引用，是因为它会将实例牢牢地保持住，只要强引用还在，实例是不允许被销毁的。\n\n### ARC实践\n下面的例子展示了自动引用计数的工作机制。例子以一个简单的Person类开始，并定义了一个叫name的常量属性：\n\n```Swift\nclass Person {\n    let name: String\n    init(name: String) {\n        self.name = name\n        print(\"\\(name) is being initialized\")\n    }\n    deinit {\n        print(\"\\(name) is being deinitialized\")\n    }\n}\n```\n\nPerson类有一个构造函数，此构造函数为实例的name属性赋值，并打印一条消息以表明初始化过程生效。Person类也拥有一个析构函数，这个析构函数会在实例被销毁时打印一条消息。\n\n接下来的代码片段定义了三个类型为Person?的变量，用来按照代码片段中的顺序，为新的Person实例建立多个引用。由于这些变量是被定义为可选类型（Person?，而不是Person），它们的值会被自动初始化为nil，目前还不会引用到Person类的实例。\n\n```Swift\nvar reference1: Person?\nvar reference2: Person?\nvar reference3: Person?\n\nreference1 = Person(name: \"John Appleseed\")\n// Prints \"John Appleseed is being initialized\"\n```\n\n由于Person类的新实例被赋值给了reference1变量，所以reference1到Person类的新实例之间建立了一个强引用。正是因为这一个强引用，ARC 会保证Person实例被保持在内存中不被销毁。如果你将同一个Person实例也赋值给其他两个变量，该实例又会多出两个强引用：\n\n```Swift\nreference2 = reference1\nreference3 = reference1\n```\n\n现在这一个Person实例已经有三个强引用了。如果你通过给其中两个变量赋值nil的方式断开两个强引用（包括最先的那个强引用），只留下一个强引用，Person实例不会被销毁：\n\n```Swift\nreference1 = nil\nreference2 = nil\n```\n\n在你清楚地表明不再使用这个Person实例时，即第三个也就是最后一个强引用被断开时，ARC 会销毁它：\n\n```Swift\nreference3 = nil\n// Prints \"John Appleseed is being deinitialized\"\n```\n\n### 类实例之间的循环强引用\n在上面的例子中，ARC 会跟踪你所新创建的Person实例的引用数量，并且会在Person实例不再被需要时销毁它。\n然而，我们可能会写出一个类实例的强引用数永远不能变成0的代码。如果两个类实例互相持有对方的强引用，因而每个实例都让对方一直存在，就是这种情况。这就是所谓的循环强引用。\n你可以通过定义类之间的关系为弱 `weak` 引用或无主 `unowned` 引用，以替代强引用，从而解决循环强引用的问题。\n\n下面展示了一个不经意产生循环强引用的例子。例子定义了两个类：Person和Apartment，用来建模公寓和它其中的居民：\n\n```Swift\nclass Person {\n    let name: String\n    init(name: String) { self.name = name }\n    var apartment: Apartment?\n    deinit { print(\"\\(name) is being deinitialized\") }\n}\n \nclass Apartment {\n    let unit: String\n    init(unit: String) { self.unit = unit }\n    var tenant: Person?\n    deinit { print(\"Apartment \\(unit) is being deinitialized\") }\n}\n```\n\n每一个Person实例有一个类型为String，名字为name的属性，并有一个可选的初始化为nil的apartment属性。apartment属性是可选的，因为一个人并不总是拥有公寓。\n类似的，每个Apartment实例有一个叫unit，类型为String的属性，并有一个可选的初始化为nil的tenant属性。tenant属性是可选的，因为一栋公寓并不总是有居民。\n这两个类都定义了析构函数，用以在类实例被析构的时候输出信息。这让你能够知晓Person和Apartment的实例是否像预期的那样被销毁。\n\n接下来的代码片段定义了两个可选类型的变量john和unit4A，并分别被设定为下面的Apartment和Person的实例。这两个变量都被初始化为nil，这正是可选类型的优点：\n\n```Swift\nvar john: Person?\nvar unit4A: Apartment?\n\njohn = Person(name: \"John Appleseed\")\nunit4A = Apartment(unit: \"4A\")\n```\n\n在两个实例被创建和赋值后，下图表现了强引用的关系。变量john现在有一个指向Person实例的强引用，而变量unit4A有一个指向Apartment实例的强引用：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle01_2x.png)\n现在你能够将这两个实例关联在一起，这样人就能有公寓住了，而公寓也有了房客。注意感叹号(`!`)是用来展开(解包)和访问可选变量john和unit4A中的实例，这样实例的属性才能被赋值：\n\n```Swift\njohn!.apartment = unit4A\nunit4A!.tenant = john\n```\n\n在将两个实例联系在一起之后，强引用的关系如图所示：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle02_2x.png)\n不幸的是，这两个实例关联后会产生一个循环强引用。Person实例现在有了一个指向Apartment实例的强引用，而Apartment实例也有了一个指向Person实例的强引用。因此，当你断开john和unit4A变量所持有的强引用时，引用计数并不会降为0，实例也不会被 ARC 销毁：\n\n```Swift\njohn = nil\nunit4A = nil\n```\n\n注意，当你把这两个变量设为nil时，没有任何一个析构函数被调用。循环强引用会一直阻止Person和Apartment类实例的销毁，这就在你的应用程序中造成了内存泄漏。在你将john和unit4A赋值为nil后，强引用关系如下图：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle03_2x.png)\nPerson和Apartment实例之间的强引用关系保留了下来并且不会被断开。\n\n### 解决实例的循环强引用问题\nSwift 提供了两种办法用来解决你在使用类的属性时所遇到的循环强引用问题：弱引用（`weak reference`）和无主引用（`unowned reference`）。\n弱引用和无主引用允许循环引用中的一个实例引用而另外一个实例不保持强引用。这样实例能够互相引用而不产生循环强引用。\n\n当其他的实例有更短的生命周期时，使用弱引用，也就是说，当其他实例析构在先时。在上面公寓的例子中，很显然一个公寓在它的生命周期内会在某个时间段没有它的主人，所以一个弱引用就加在公寓类里面，避免循环引用。相比之下，当其他实例有相同的或者更长生命周期时，请使用无主引用。\n\n#### 弱引用\n弱引用不会对其引用的实例保持强引用，因而不会阻止 ARC 销毁被引用的实例。这个特性阻止了引用变为循环强引用。声明属性或者变量时，在前面加上 `weak` 关键字表明这是一个弱引用。\n\n因为弱引用不会保持所引用的实例，即使引用存在，实例也有可能被销毁。因此，ARC 会在引用的实例被销毁后自动将其赋值为nil。并且因为弱引用可以允许它们的值在运行时被赋值为nil，所以它们会被定义为可选类型变量，而不是常量。\n你可以像其他可选值一样，检查弱引用的值是否存在，你将永远不会访问已销毁的实例的引用。\n\t当 ARC 设置弱引用为nil时，属性观察不会被触发。\n\n下面的例子跟上面Person和Apartment的例子一致，但是有一个重要的区别。这一次，Apartment的tenant属性被声明为弱引用：\n\n```Swift\nclass Person {\n    let name: String\n    init(name: String) { self.name = name }\n    var apartment: Apartment?\n    deinit { print(\"\\(name) is being deinitialized\") }\n}\n \nclass Apartment {\n    let unit: String\n    init(unit: String) { self.unit = unit }\n    weak var tenant: Person?\n    deinit { print(\"Apartment \\(unit) is being deinitialized\") }\n}\n```\n\n然后跟之前一样，建立两个变量（john和unit4A）之间的强引用，并关联两个实例：\n\n```Swift\nvar john: Person?\nvar unit4A: Apartment?\n \njohn = Person(name: \"John Appleseed\")\nunit4A = Apartment(unit: \"4A\")\n \njohn!.apartment = unit4A\nunit4A!.tenant = john\n```\n\n现在，两个关联在一起的实例的引用关系如下图所示：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference01_2x.png)\nPerson实例依然保持对Apartment实例的强引用，但是Apartment实例只持有对Person实例的弱引用。这意味着当你断开john变量所保持的强引用时，再也没有指向Person实例的强引用了：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference02_2x.png)\n由于再也没有指向Person实例的强引用，该实例会被销毁：\n\n```Swift\njohn = nil\n// Prints \"John Appleseed is being deinitialized\"\n```\n\n唯一剩下的指向Apartment实例的强引用来自于变量unit4A。如果你断开这个强引用，再也没有指向Apartment实例的强引用了：\n\n```Swift\nunit4A = nil\n// Prints \"Apartment 4A is being deinitialized\"\n```\n\n由于再也没有指向Apartment实例的强引用，该实例也会被销毁：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference03_2x.png)\n\t在使用垃圾收集的系统里，弱指针有时用来实现简单的缓冲机制，因为没有强引用的对象只会在内存压力触发垃圾收集时才被销毁。但是在 ARC 中，一旦值的最后一个强引用被移除，就会被立即销毁，这导致弱引用并不适合上面的用途。\n\n#### 无主引用\n和弱引用类似，无主引用不会牢牢保持住引用的实例。和弱引用不同的是，无主引用在其他实例有相同或者更长的生命周期时使用。你可以在声明属性或者变量时，在前面加上关键字unowned表示这是一个无主引用。\n无主引用通常都被期望拥有值。不过 ARC 无法在实例被销毁后将无主引用设为nil，这意味着无主引用明确使用非可选类型\n\t使用无主引用，你必须确保引用始终指向一个未销毁的实例。\n如果你试图在实例被销毁后，访问该实例的无主引用，会触发运行时错误。\n\n下面的例子定义了两个类，Customer和CreditCard，模拟了银行客户和客户的信用卡。这两个类中，每一个都将另外一个类的实例作为自身的属性。这种关系可能会造成循环强引用。\nCustomer和CreditCard之间的关系与前面弱引用例子中Apartment和Person的关系略微不同。在这个数据模型中，一个客户可能有或者没有信用卡，但是一张信用卡总是关联着一个客户。为了表示这种关系，Customer类有一个可选类型的card属性，但是CreditCard类有一个非可选类型的customer属性。\n此外，只能通过将一个number值和customer实例传递给CreditCard构造函数的方式来创建CreditCard实例。这样可以确保当创建CreditCard实例时总是有一个customer实例与之关联。\n由于信用卡总是关联着一个客户，因此将customer属性定义为无主引用，用以避免循环强引用：\n\n```Swift\nclass Customer {\n    let name: String\n    var card: CreditCard?\n    init(name: String) {\n        self.name = name\n    }\n    deinit { print(\"\\(name) is being deinitialized\") }\n}\n \nclass CreditCard {\n    let number: UInt64\n    unowned let customer: Customer\n    init(number: UInt64, customer: Customer) {\n        self.number = number\n        self.customer = customer\n    }\n    deinit { print(\"Card #\\(number) is being deinitialized\") }\n}\n```\n\n下面的代码片段定义了一个叫john的可选类型Customer变量，用来保存某个特定客户的引用。由于是可选类型，所以变量被初始化为nil：\n\n```Swift\nvar john: Customer?\n```\n\n现在你可以创建Customer类的实例，用它初始化CreditCard实例，并将新创建的CreditCard实例赋值为客户的card属性：\n\n```Swift\njohn = Customer(name: \"John Appleseed\")\njohn!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)\n```\n\n在你关联两个实例后，它们的引用关系如下图所示：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference01_2x.png)\n\nCustomer实例持有对CreditCard实例的强引用，而CreditCard实例持有对Customer实例的无主引用。\n由于customer的无主引用，当你断开john变量持有的强引用时，再也没有指向Customer实例的强引用了：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference02_2x.png)\n由于再也没有指向Customer实例的强引用，该实例被销毁了。其后，再也没有指向CreditCard实例的强引用，该实例也随之被销毁了：\n\n```Swift\njohn = nil\n// Prints \"John Appleseed is being deinitialized\"\n// Prints \"Card #1234567890123456 is being deinitialized\"\n```\n\n\t上面的例子展示了如何使用安全的无主引用。对于需要禁用运行时的安全检查的情况（例如，出于性能方面的原因），Swift还提供了不安全的无主引用。与所有不安全的操作一样，你需要负责检查代码以确保其安全性。 你可以通过unowned(unsafe)来声明不安全无主引用。如果你试图在实例被销毁后，访问该实例的不安全无主引用，你的程序会尝试访问该实例之前所在的内存地址，这是一个不安全的操作。\n\n\n#### 无主引用以及隐式解析可选属性\n上面弱引用和无主引用的例子涵盖了两种常用的需要打破循环强引用的场景。\n\nPerson和Apartment的例子展示了两个属性的值都允许为nil，并会潜在的产生循环强引用。这种场景最适合用弱引用来解决。\nCustomer和CreditCard的例子展示了一个属性的值允许为nil，而另一个属性的值不允许为nil，这也可能会产生循环强引用。这种场景最适合通过无主引用来解决。\n\n然而，存在着第三种场景，在这种场景中，两个属性都必须有值，并且初始化完成后永远不会为nil。在这种场景中，需要一个类使用无主属性，而另外一个类使用隐式解析可选属性。\n这使两个属性在初始化完成后能被直接访问（不需要可选展开），同时避免了循环引用。这一节将为你展示如何建立这种关系。\n下面的例子定义了两个类，Country和City，每个类将另外一个类的实例保存为属性。在这个模型中，每个国家必须有首都，每个城市必须属于一个国家。为了实现这种关系，Country类拥有一个capitalCity属性，而City类有一个country属性：\n\n```Swift\nclass Country {\n    let name: String\n    var capitalCity: City!\n    init(name: String, capitalName: String) {\n        self.name = name\n        self.capitalCity = City(name: capitalName, country: self)\n    }\n}\n \nclass City {\n    let name: String\n    unowned let country: Country\n    init(name: String, country: Country) {\n        self.name = name\n        self.country = country\n    }\n}\n```\n\n为了建立两个类的依赖关系，City的构造函数接受一个Country实例作为参数，并且将实例保存到country属性。\n\nCountry的构造函数调用了City的构造函数。然而，只有Country的实例完全初始化后，Country的构造函数才能把self传给City的构造函数。在两段式构造过程中有具体描述。\n为了满足这种需求，通过在类型结尾处加上感叹号（City!）的方式，将Country的capitalCity属性声明为隐式解析可选类型的属性。这意味着像其他可选类型一样，capitalCity属性的默认值为nil，但是不需要展开它的值就能访问它。在隐式解析可选类型中有描述。\n\n由于capitalCity默认值为nil，一旦Country的实例在构造函数中给name属性赋值后，整个初始化过程就完成了。这意味着一旦name属性被赋值后，Country的构造函数就能引用并传递隐式的self。Country的构造函数在赋值capitalCity时，就能将self作为参数传递给City的构造函数。\n\n以上的意义在于你可以通过一条语句同时创建Country和City的实例，而不产生循环强引用，并且capitalCity的属性能被直接访问，而不需要通过感叹号来展开它的可选值：\n\n```Swift\nvar country = Country(name: \"Canada\", capitalName: \"Ottawa\")\nprint(\"\\(country.name)'s capital city is called \\(country.capitalCity.name)\")\n// Prints \"Canada's capital city is called Ottawa\"\n```\n\n在上面的例子中，使用隐式解析可选值意味着满足了类的构造函数的两个构造阶段的要求。capitalCity属性在初始化完成后，能像非可选值一样使用和存取，同时还避免了循环强引用。\n\n### 闭包的循环强引用\n前面我们看到了循环强引用是在两个类实例属性互相保持对方的强引用时产生的，还知道了如何用弱引用和无主引用来打破这些循环强引用。\n\n循环强引用还会发生在当你将一个闭包赋值给类实例的某个属性，并且这个闭包体中又使用了这个类实例时。这个闭包体中可能访问了实例的某个属性，例如self.someProperty，或者闭包中调用了实例的某个方法，例如self.someMethod()。这两种情况都导致了闭包“捕获”self，从而产生了循环强引用。\n\n循环强引用的产生，是因为闭包和类相似，都是引用类型。当你把一个闭包赋值给某个属性时，你是将这个闭包的引用赋值给了属性。实质上，这跟之前的问题是一样的——两个强引用让彼此一直有效。但是，和两个类实例不同，这次一个是类实例，另一个是闭包。\n\nSwift 提供了一种优雅的方法来解决这个问题，称之为闭包捕获列表（closure capture list）。同样的，在学习如何用闭包捕获列表打破循环强引用之前，先来了解一下这里的循环强引用是如何产生的，这对我们很有帮助。\n\n下面的例子为你展示了当一个闭包引用了self后是如何产生一个循环强引用的。例子中定义了一个叫HTMLElement的类，用一种简单的模型表示 HTML 文档中的一个单独的元素：\n\n```Swift\nclass HTMLElement {\n    \n    let name: String\n    let text: String?\n    \n    lazy var asHTML: () -> String = {\n        if let text = self.text {\n            return \"<\\(self.name)>\\(text)</\\(self.name)>\"\n        } else {\n            return \"<\\(self.name) />\"\n        }\n    }\n    \n    init(name: String, text: String? = nil) {\n        self.name = name\n        self.text = text\n    }\n    \n    deinit {\n        print(\"\\(name) is being deinitialized\")\n    }\n    \n}\n```\n\nHTMLElement类定义了一个name属性来表示这个元素的名称，例如代表头部元素的\"h1\"，代表段落的“p”，或者代表换行的“br”。HTMLElement还定义了一个可选属性text，用来设置 HTML 元素呈现的文本。\n\n除了上面的两个属性，HTMLElement还定义了一个lazy属性asHTML。这个属性引用了一个将name和text组合成 HTML 字符串片段的闭包。该属性是Void -> String类型，或者可以理解为“一个没有参数，返回String的函数”。\n\n默认情况下，闭包赋值给了asHTML属性，这个闭包返回一个代表 HTML 标签的字符串。如果text值存在，该标签就包含可选值text；如果text不存在，该标签就不包含文本。对于段落元素，根据text是“some text”还是nil，闭包会返回\"<p>some text</p>\"或者\"<p />\"。\n\n可以像实例方法那样去命名、使用asHTML属性。然而，由于asHTML是闭包而不是实例方法，如果你想改变特定 HTML 元素的处理方式的话，可以用自定义的闭包来取代默认值。\n\n例如，可以将一个闭包赋值给asHTML属性，这个闭包能在text属性是nil时使用默认文本，这是为了避免返回一个空的 HTML 标签：\n\n```Swift\nlet heading = HTMLElement(name: \"h1\")\nlet defaultText = \"some default text\"\nheading.asHTML = {\n    return \"<\\(heading.name)>\\(heading.text ?? defaultText)</\\(heading.name)>\"\n}\nprint(heading.asHTML())\n// Prints \"<h1>some default text</h1>\"\n```\n\tasHTML声明为lazy属性，因为只有当元素确实需要被处理为 HTML 输出的字符串时，才需要使用asHTML。也就是说，在默认的闭包中可以使用self，因为只有当初始化完成以及self确实存在后，才能访问lazy属性。\n\nHTMLElement类只提供了一个构造函数，通过name和text（如果有的话）参数来初始化一个新元素。该类也定义了一个析构函数，当HTMLElement实例被销毁时，打印一条消息。\n\n```Swift\nvar paragraph: HTMLElement? = HTMLElement(name: \"p\", text: \"hello, world\")\nprint(paragraph!.asHTML())\n// Prints \"<p>hello, world</p>\"\n```\n\n不幸的是，上面写的HTMLElement类产生了类实例和作为asHTML默认值的闭包之间的循环强引用。循环强引用如下图所示：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle01_2x.png)\n实例的asHTML属性持有闭包的强引用。但是，闭包在其闭包体内使用了self（引用了self.name和self.text），因此闭包捕获了self，这意味着闭包又反过来持有了HTMLElement实例的强引用。这样两个对象就产生了循环强引用。\n\t虽然闭包多次使用了self，它只捕获HTMLElement实例的一个强引用。\n\n如果设置paragraph变量为nil，打破它持有的HTMLElement实例的强引用，HTMLElement实例和它的闭包都不会被销毁，HTMLElement的析构函数中的消息并没有被打印。也是因为循环强引用：\n\n```Swift\nparagraph = nil\n```\n\n\n### 解决闭包的循环强引用问题\n在定义闭包时同时定义捕获列表作为闭包的一部分，通过这种方式可以解决闭包和类实例之间的循环强引用。捕获列表定义了闭包体内捕获一个或者多个引用类型的规则。跟解决两个类实例间的循环强引用一样，声明每个捕获的引用为弱引用或无主引用，而不是强引用。应当根据代码关系来决定使用弱引用还是无主引用。\n\tSwift 有如下要求：只要在闭包内使用self的成员，就要用self.someProperty或者self.someMethod()（而不只是someProperty或someMethod()）。这提醒你可能会一不小心就捕获了self。\n\n#### 定义捕获列表\n捕获列表中的每一项都由一对元素组成，一个元素是weak或unowned关键字，另一个元素是类实例的引用（例如self）或初始化过的变量（如delegate = self.delegate!）。这些项在方括号中用逗号分开。\n如果闭包有参数列表和返回类型，把捕获列表放在它们前面：\n\n```Swift\nlazy var someClosure: (Int, String) -> String = {\n    [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -> String in\n    // closure body goes here\n}\n```\n\n如果闭包没有指明参数列表或者返回类型，即它们会通过上下文推断，那么可以把捕获列表和关键字in放在闭包最开始的地方：\n\n```Swift\nlazy var someClosure: () -> String = {\n    [unowned self, weak delegate = self.delegate!] in\n    // closure body goes here\n}\n```\n\n#### 弱引用和无主引用\n在闭包和捕获的实例总是互相引用并且总是同时销毁时，将闭包内的捕获定义为 `无主引用`。\n相反的，在被捕获的引用可能会变为nil时，将闭包内的捕获定义为 `弱引用` 。弱引用总是可选类型，并且当引用的实例被销毁后，弱引用的值会自动置为nil。这使我们可以在闭包体内检查它们是否存在。\n\t如果被捕获的引用不会变为nil，应该用无主引用，而不是弱引用。\n\n前面的HTMLElement例子中，无主引用是正确的解决循环强引用的方法。这样编写HTMLElement类来避免循环强引用：\n\n```Swift\nclass HTMLElement {\n    \n    let name: String\n    let text: String?\n    \n    lazy var asHTML: () -> String = {\n        [unowned self] in\n        if let text = self.text {\n            return \"<\\(self.name)>\\(text)</\\(self.name)>\"\n        } else {\n            return \"<\\(self.name) />\"\n        }\n    }\n    \n    init(name: String, text: String? = nil) {\n        self.name = name\n        self.text = text\n    }\n    \n    deinit {\n        print(\"\\(name) is being deinitialized\")\n    }\n    \n}\n```\n\n上面的HTMLElement实现和之前的实现一致，除了在asHTML闭包中多了一个捕获列表。这里，捕获列表是[unowned self]，表示“将self捕获为无主引用而不是强引用”。\n和之前一样，我们可以创建并打印HTMLElement实例：\n\n```Swift\nvar paragraph: HTMLElement? = HTMLElement(name: \"p\", text: \"hello, world\")\nprint(paragraph!.asHTML())\n// Prints \"<p>hello, world</p>\"\n```\n\n使用捕获列表后引用关系如下图所示：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle02_2x.png)\n此时，闭包以无主引用的形式捕获self，并不会持有HTMLElement实例的强引用。如果将paragraph赋值为nil，HTMLElement实例将会被销毁，并能看到它的析构函数打印出的消息：\n\n```Swift\nparagraph = nil\n// Prints \"p is being deinitialized\"\n```\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html/\"> AutomaticReferenceCounting </a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","source":"_posts/iOS_Swift_language_note_ARC.md","raw":"---\nlayout:     post\ntitle:      Swift ARC\ndate:       2016-11-29 03:20:11\nauthor:     liangtong\ncatalog: true\ncategories: iOS\ntags: Swift \n\n---\n\n\n\n​\tSwift 使用自动引用计数（ARC）机制来跟踪和管理你的应用程序的内存。通常情况下，Swift 内存管理机制会一直起作用，你无须自己来考虑内存的管理。ARC 会在类的实例不再被使用时，自动释放其占用的内存。然而在少数情况下，为了能帮助你管理内存，ARC 需要更多的，代码之间关系的信息。在 Swift 使用 ARC 与在 Obejctive-C 中使用 ARC 非常类似\n\t引用计数仅仅应用于类的实例。结构体和枚举类型是值类型，不是引用类型，也不是通过引用的方式存储和传递。\n\n\n\n### ARC工作机制\n当你每次创建一个类的新的实例的时候，ARC 会分配一块内存来储存该实例信息。内存中会包含实例的类型信息，以及这个实例所有相关的存储型属性的值。\n当实例不再被使用时，ARC 释放实例所占用的内存，并让释放的内存能挪作他用。这确保了不再被使用的实例，不会一直占用内存空间。\n\n<!-- more -->\n\n然而，当 ARC 收回和释放了正在被使用中的实例，该实例的属性和方法将不能再被访问和调用。实际上，如果你试图访问这个实例，你的应用程序很可能会崩溃。\n为了确保使用中的实例不会被销毁，ARC 会跟踪和计算每一个实例正在被多少属性，常量和变量所引用。哪怕实例的引用数为1，ARC都不会销毁这个实例。\n\n为了使上述成为可能，无论你将实例赋值给属性、常量或变量，它们都会创建此实例的强引用。之所以称之为“强”引用，是因为它会将实例牢牢地保持住，只要强引用还在，实例是不允许被销毁的。\n\n### ARC实践\n下面的例子展示了自动引用计数的工作机制。例子以一个简单的Person类开始，并定义了一个叫name的常量属性：\n\n```Swift\nclass Person {\n    let name: String\n    init(name: String) {\n        self.name = name\n        print(\"\\(name) is being initialized\")\n    }\n    deinit {\n        print(\"\\(name) is being deinitialized\")\n    }\n}\n```\n\nPerson类有一个构造函数，此构造函数为实例的name属性赋值，并打印一条消息以表明初始化过程生效。Person类也拥有一个析构函数，这个析构函数会在实例被销毁时打印一条消息。\n\n接下来的代码片段定义了三个类型为Person?的变量，用来按照代码片段中的顺序，为新的Person实例建立多个引用。由于这些变量是被定义为可选类型（Person?，而不是Person），它们的值会被自动初始化为nil，目前还不会引用到Person类的实例。\n\n```Swift\nvar reference1: Person?\nvar reference2: Person?\nvar reference3: Person?\n\nreference1 = Person(name: \"John Appleseed\")\n// Prints \"John Appleseed is being initialized\"\n```\n\n由于Person类的新实例被赋值给了reference1变量，所以reference1到Person类的新实例之间建立了一个强引用。正是因为这一个强引用，ARC 会保证Person实例被保持在内存中不被销毁。如果你将同一个Person实例也赋值给其他两个变量，该实例又会多出两个强引用：\n\n```Swift\nreference2 = reference1\nreference3 = reference1\n```\n\n现在这一个Person实例已经有三个强引用了。如果你通过给其中两个变量赋值nil的方式断开两个强引用（包括最先的那个强引用），只留下一个强引用，Person实例不会被销毁：\n\n```Swift\nreference1 = nil\nreference2 = nil\n```\n\n在你清楚地表明不再使用这个Person实例时，即第三个也就是最后一个强引用被断开时，ARC 会销毁它：\n\n```Swift\nreference3 = nil\n// Prints \"John Appleseed is being deinitialized\"\n```\n\n### 类实例之间的循环强引用\n在上面的例子中，ARC 会跟踪你所新创建的Person实例的引用数量，并且会在Person实例不再被需要时销毁它。\n然而，我们可能会写出一个类实例的强引用数永远不能变成0的代码。如果两个类实例互相持有对方的强引用，因而每个实例都让对方一直存在，就是这种情况。这就是所谓的循环强引用。\n你可以通过定义类之间的关系为弱 `weak` 引用或无主 `unowned` 引用，以替代强引用，从而解决循环强引用的问题。\n\n下面展示了一个不经意产生循环强引用的例子。例子定义了两个类：Person和Apartment，用来建模公寓和它其中的居民：\n\n```Swift\nclass Person {\n    let name: String\n    init(name: String) { self.name = name }\n    var apartment: Apartment?\n    deinit { print(\"\\(name) is being deinitialized\") }\n}\n \nclass Apartment {\n    let unit: String\n    init(unit: String) { self.unit = unit }\n    var tenant: Person?\n    deinit { print(\"Apartment \\(unit) is being deinitialized\") }\n}\n```\n\n每一个Person实例有一个类型为String，名字为name的属性，并有一个可选的初始化为nil的apartment属性。apartment属性是可选的，因为一个人并不总是拥有公寓。\n类似的，每个Apartment实例有一个叫unit，类型为String的属性，并有一个可选的初始化为nil的tenant属性。tenant属性是可选的，因为一栋公寓并不总是有居民。\n这两个类都定义了析构函数，用以在类实例被析构的时候输出信息。这让你能够知晓Person和Apartment的实例是否像预期的那样被销毁。\n\n接下来的代码片段定义了两个可选类型的变量john和unit4A，并分别被设定为下面的Apartment和Person的实例。这两个变量都被初始化为nil，这正是可选类型的优点：\n\n```Swift\nvar john: Person?\nvar unit4A: Apartment?\n\njohn = Person(name: \"John Appleseed\")\nunit4A = Apartment(unit: \"4A\")\n```\n\n在两个实例被创建和赋值后，下图表现了强引用的关系。变量john现在有一个指向Person实例的强引用，而变量unit4A有一个指向Apartment实例的强引用：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle01_2x.png)\n现在你能够将这两个实例关联在一起，这样人就能有公寓住了，而公寓也有了房客。注意感叹号(`!`)是用来展开(解包)和访问可选变量john和unit4A中的实例，这样实例的属性才能被赋值：\n\n```Swift\njohn!.apartment = unit4A\nunit4A!.tenant = john\n```\n\n在将两个实例联系在一起之后，强引用的关系如图所示：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle02_2x.png)\n不幸的是，这两个实例关联后会产生一个循环强引用。Person实例现在有了一个指向Apartment实例的强引用，而Apartment实例也有了一个指向Person实例的强引用。因此，当你断开john和unit4A变量所持有的强引用时，引用计数并不会降为0，实例也不会被 ARC 销毁：\n\n```Swift\njohn = nil\nunit4A = nil\n```\n\n注意，当你把这两个变量设为nil时，没有任何一个析构函数被调用。循环强引用会一直阻止Person和Apartment类实例的销毁，这就在你的应用程序中造成了内存泄漏。在你将john和unit4A赋值为nil后，强引用关系如下图：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle03_2x.png)\nPerson和Apartment实例之间的强引用关系保留了下来并且不会被断开。\n\n### 解决实例的循环强引用问题\nSwift 提供了两种办法用来解决你在使用类的属性时所遇到的循环强引用问题：弱引用（`weak reference`）和无主引用（`unowned reference`）。\n弱引用和无主引用允许循环引用中的一个实例引用而另外一个实例不保持强引用。这样实例能够互相引用而不产生循环强引用。\n\n当其他的实例有更短的生命周期时，使用弱引用，也就是说，当其他实例析构在先时。在上面公寓的例子中，很显然一个公寓在它的生命周期内会在某个时间段没有它的主人，所以一个弱引用就加在公寓类里面，避免循环引用。相比之下，当其他实例有相同的或者更长生命周期时，请使用无主引用。\n\n#### 弱引用\n弱引用不会对其引用的实例保持强引用，因而不会阻止 ARC 销毁被引用的实例。这个特性阻止了引用变为循环强引用。声明属性或者变量时，在前面加上 `weak` 关键字表明这是一个弱引用。\n\n因为弱引用不会保持所引用的实例，即使引用存在，实例也有可能被销毁。因此，ARC 会在引用的实例被销毁后自动将其赋值为nil。并且因为弱引用可以允许它们的值在运行时被赋值为nil，所以它们会被定义为可选类型变量，而不是常量。\n你可以像其他可选值一样，检查弱引用的值是否存在，你将永远不会访问已销毁的实例的引用。\n\t当 ARC 设置弱引用为nil时，属性观察不会被触发。\n\n下面的例子跟上面Person和Apartment的例子一致，但是有一个重要的区别。这一次，Apartment的tenant属性被声明为弱引用：\n\n```Swift\nclass Person {\n    let name: String\n    init(name: String) { self.name = name }\n    var apartment: Apartment?\n    deinit { print(\"\\(name) is being deinitialized\") }\n}\n \nclass Apartment {\n    let unit: String\n    init(unit: String) { self.unit = unit }\n    weak var tenant: Person?\n    deinit { print(\"Apartment \\(unit) is being deinitialized\") }\n}\n```\n\n然后跟之前一样，建立两个变量（john和unit4A）之间的强引用，并关联两个实例：\n\n```Swift\nvar john: Person?\nvar unit4A: Apartment?\n \njohn = Person(name: \"John Appleseed\")\nunit4A = Apartment(unit: \"4A\")\n \njohn!.apartment = unit4A\nunit4A!.tenant = john\n```\n\n现在，两个关联在一起的实例的引用关系如下图所示：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference01_2x.png)\nPerson实例依然保持对Apartment实例的强引用，但是Apartment实例只持有对Person实例的弱引用。这意味着当你断开john变量所保持的强引用时，再也没有指向Person实例的强引用了：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference02_2x.png)\n由于再也没有指向Person实例的强引用，该实例会被销毁：\n\n```Swift\njohn = nil\n// Prints \"John Appleseed is being deinitialized\"\n```\n\n唯一剩下的指向Apartment实例的强引用来自于变量unit4A。如果你断开这个强引用，再也没有指向Apartment实例的强引用了：\n\n```Swift\nunit4A = nil\n// Prints \"Apartment 4A is being deinitialized\"\n```\n\n由于再也没有指向Apartment实例的强引用，该实例也会被销毁：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference03_2x.png)\n\t在使用垃圾收集的系统里，弱指针有时用来实现简单的缓冲机制，因为没有强引用的对象只会在内存压力触发垃圾收集时才被销毁。但是在 ARC 中，一旦值的最后一个强引用被移除，就会被立即销毁，这导致弱引用并不适合上面的用途。\n\n#### 无主引用\n和弱引用类似，无主引用不会牢牢保持住引用的实例。和弱引用不同的是，无主引用在其他实例有相同或者更长的生命周期时使用。你可以在声明属性或者变量时，在前面加上关键字unowned表示这是一个无主引用。\n无主引用通常都被期望拥有值。不过 ARC 无法在实例被销毁后将无主引用设为nil，这意味着无主引用明确使用非可选类型\n\t使用无主引用，你必须确保引用始终指向一个未销毁的实例。\n如果你试图在实例被销毁后，访问该实例的无主引用，会触发运行时错误。\n\n下面的例子定义了两个类，Customer和CreditCard，模拟了银行客户和客户的信用卡。这两个类中，每一个都将另外一个类的实例作为自身的属性。这种关系可能会造成循环强引用。\nCustomer和CreditCard之间的关系与前面弱引用例子中Apartment和Person的关系略微不同。在这个数据模型中，一个客户可能有或者没有信用卡，但是一张信用卡总是关联着一个客户。为了表示这种关系，Customer类有一个可选类型的card属性，但是CreditCard类有一个非可选类型的customer属性。\n此外，只能通过将一个number值和customer实例传递给CreditCard构造函数的方式来创建CreditCard实例。这样可以确保当创建CreditCard实例时总是有一个customer实例与之关联。\n由于信用卡总是关联着一个客户，因此将customer属性定义为无主引用，用以避免循环强引用：\n\n```Swift\nclass Customer {\n    let name: String\n    var card: CreditCard?\n    init(name: String) {\n        self.name = name\n    }\n    deinit { print(\"\\(name) is being deinitialized\") }\n}\n \nclass CreditCard {\n    let number: UInt64\n    unowned let customer: Customer\n    init(number: UInt64, customer: Customer) {\n        self.number = number\n        self.customer = customer\n    }\n    deinit { print(\"Card #\\(number) is being deinitialized\") }\n}\n```\n\n下面的代码片段定义了一个叫john的可选类型Customer变量，用来保存某个特定客户的引用。由于是可选类型，所以变量被初始化为nil：\n\n```Swift\nvar john: Customer?\n```\n\n现在你可以创建Customer类的实例，用它初始化CreditCard实例，并将新创建的CreditCard实例赋值为客户的card属性：\n\n```Swift\njohn = Customer(name: \"John Appleseed\")\njohn!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)\n```\n\n在你关联两个实例后，它们的引用关系如下图所示：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference01_2x.png)\n\nCustomer实例持有对CreditCard实例的强引用，而CreditCard实例持有对Customer实例的无主引用。\n由于customer的无主引用，当你断开john变量持有的强引用时，再也没有指向Customer实例的强引用了：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference02_2x.png)\n由于再也没有指向Customer实例的强引用，该实例被销毁了。其后，再也没有指向CreditCard实例的强引用，该实例也随之被销毁了：\n\n```Swift\njohn = nil\n// Prints \"John Appleseed is being deinitialized\"\n// Prints \"Card #1234567890123456 is being deinitialized\"\n```\n\n\t上面的例子展示了如何使用安全的无主引用。对于需要禁用运行时的安全检查的情况（例如，出于性能方面的原因），Swift还提供了不安全的无主引用。与所有不安全的操作一样，你需要负责检查代码以确保其安全性。 你可以通过unowned(unsafe)来声明不安全无主引用。如果你试图在实例被销毁后，访问该实例的不安全无主引用，你的程序会尝试访问该实例之前所在的内存地址，这是一个不安全的操作。\n\n\n#### 无主引用以及隐式解析可选属性\n上面弱引用和无主引用的例子涵盖了两种常用的需要打破循环强引用的场景。\n\nPerson和Apartment的例子展示了两个属性的值都允许为nil，并会潜在的产生循环强引用。这种场景最适合用弱引用来解决。\nCustomer和CreditCard的例子展示了一个属性的值允许为nil，而另一个属性的值不允许为nil，这也可能会产生循环强引用。这种场景最适合通过无主引用来解决。\n\n然而，存在着第三种场景，在这种场景中，两个属性都必须有值，并且初始化完成后永远不会为nil。在这种场景中，需要一个类使用无主属性，而另外一个类使用隐式解析可选属性。\n这使两个属性在初始化完成后能被直接访问（不需要可选展开），同时避免了循环引用。这一节将为你展示如何建立这种关系。\n下面的例子定义了两个类，Country和City，每个类将另外一个类的实例保存为属性。在这个模型中，每个国家必须有首都，每个城市必须属于一个国家。为了实现这种关系，Country类拥有一个capitalCity属性，而City类有一个country属性：\n\n```Swift\nclass Country {\n    let name: String\n    var capitalCity: City!\n    init(name: String, capitalName: String) {\n        self.name = name\n        self.capitalCity = City(name: capitalName, country: self)\n    }\n}\n \nclass City {\n    let name: String\n    unowned let country: Country\n    init(name: String, country: Country) {\n        self.name = name\n        self.country = country\n    }\n}\n```\n\n为了建立两个类的依赖关系，City的构造函数接受一个Country实例作为参数，并且将实例保存到country属性。\n\nCountry的构造函数调用了City的构造函数。然而，只有Country的实例完全初始化后，Country的构造函数才能把self传给City的构造函数。在两段式构造过程中有具体描述。\n为了满足这种需求，通过在类型结尾处加上感叹号（City!）的方式，将Country的capitalCity属性声明为隐式解析可选类型的属性。这意味着像其他可选类型一样，capitalCity属性的默认值为nil，但是不需要展开它的值就能访问它。在隐式解析可选类型中有描述。\n\n由于capitalCity默认值为nil，一旦Country的实例在构造函数中给name属性赋值后，整个初始化过程就完成了。这意味着一旦name属性被赋值后，Country的构造函数就能引用并传递隐式的self。Country的构造函数在赋值capitalCity时，就能将self作为参数传递给City的构造函数。\n\n以上的意义在于你可以通过一条语句同时创建Country和City的实例，而不产生循环强引用，并且capitalCity的属性能被直接访问，而不需要通过感叹号来展开它的可选值：\n\n```Swift\nvar country = Country(name: \"Canada\", capitalName: \"Ottawa\")\nprint(\"\\(country.name)'s capital city is called \\(country.capitalCity.name)\")\n// Prints \"Canada's capital city is called Ottawa\"\n```\n\n在上面的例子中，使用隐式解析可选值意味着满足了类的构造函数的两个构造阶段的要求。capitalCity属性在初始化完成后，能像非可选值一样使用和存取，同时还避免了循环强引用。\n\n### 闭包的循环强引用\n前面我们看到了循环强引用是在两个类实例属性互相保持对方的强引用时产生的，还知道了如何用弱引用和无主引用来打破这些循环强引用。\n\n循环强引用还会发生在当你将一个闭包赋值给类实例的某个属性，并且这个闭包体中又使用了这个类实例时。这个闭包体中可能访问了实例的某个属性，例如self.someProperty，或者闭包中调用了实例的某个方法，例如self.someMethod()。这两种情况都导致了闭包“捕获”self，从而产生了循环强引用。\n\n循环强引用的产生，是因为闭包和类相似，都是引用类型。当你把一个闭包赋值给某个属性时，你是将这个闭包的引用赋值给了属性。实质上，这跟之前的问题是一样的——两个强引用让彼此一直有效。但是，和两个类实例不同，这次一个是类实例，另一个是闭包。\n\nSwift 提供了一种优雅的方法来解决这个问题，称之为闭包捕获列表（closure capture list）。同样的，在学习如何用闭包捕获列表打破循环强引用之前，先来了解一下这里的循环强引用是如何产生的，这对我们很有帮助。\n\n下面的例子为你展示了当一个闭包引用了self后是如何产生一个循环强引用的。例子中定义了一个叫HTMLElement的类，用一种简单的模型表示 HTML 文档中的一个单独的元素：\n\n```Swift\nclass HTMLElement {\n    \n    let name: String\n    let text: String?\n    \n    lazy var asHTML: () -> String = {\n        if let text = self.text {\n            return \"<\\(self.name)>\\(text)</\\(self.name)>\"\n        } else {\n            return \"<\\(self.name) />\"\n        }\n    }\n    \n    init(name: String, text: String? = nil) {\n        self.name = name\n        self.text = text\n    }\n    \n    deinit {\n        print(\"\\(name) is being deinitialized\")\n    }\n    \n}\n```\n\nHTMLElement类定义了一个name属性来表示这个元素的名称，例如代表头部元素的\"h1\"，代表段落的“p”，或者代表换行的“br”。HTMLElement还定义了一个可选属性text，用来设置 HTML 元素呈现的文本。\n\n除了上面的两个属性，HTMLElement还定义了一个lazy属性asHTML。这个属性引用了一个将name和text组合成 HTML 字符串片段的闭包。该属性是Void -> String类型，或者可以理解为“一个没有参数，返回String的函数”。\n\n默认情况下，闭包赋值给了asHTML属性，这个闭包返回一个代表 HTML 标签的字符串。如果text值存在，该标签就包含可选值text；如果text不存在，该标签就不包含文本。对于段落元素，根据text是“some text”还是nil，闭包会返回\"<p>some text</p>\"或者\"<p />\"。\n\n可以像实例方法那样去命名、使用asHTML属性。然而，由于asHTML是闭包而不是实例方法，如果你想改变特定 HTML 元素的处理方式的话，可以用自定义的闭包来取代默认值。\n\n例如，可以将一个闭包赋值给asHTML属性，这个闭包能在text属性是nil时使用默认文本，这是为了避免返回一个空的 HTML 标签：\n\n```Swift\nlet heading = HTMLElement(name: \"h1\")\nlet defaultText = \"some default text\"\nheading.asHTML = {\n    return \"<\\(heading.name)>\\(heading.text ?? defaultText)</\\(heading.name)>\"\n}\nprint(heading.asHTML())\n// Prints \"<h1>some default text</h1>\"\n```\n\tasHTML声明为lazy属性，因为只有当元素确实需要被处理为 HTML 输出的字符串时，才需要使用asHTML。也就是说，在默认的闭包中可以使用self，因为只有当初始化完成以及self确实存在后，才能访问lazy属性。\n\nHTMLElement类只提供了一个构造函数，通过name和text（如果有的话）参数来初始化一个新元素。该类也定义了一个析构函数，当HTMLElement实例被销毁时，打印一条消息。\n\n```Swift\nvar paragraph: HTMLElement? = HTMLElement(name: \"p\", text: \"hello, world\")\nprint(paragraph!.asHTML())\n// Prints \"<p>hello, world</p>\"\n```\n\n不幸的是，上面写的HTMLElement类产生了类实例和作为asHTML默认值的闭包之间的循环强引用。循环强引用如下图所示：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle01_2x.png)\n实例的asHTML属性持有闭包的强引用。但是，闭包在其闭包体内使用了self（引用了self.name和self.text），因此闭包捕获了self，这意味着闭包又反过来持有了HTMLElement实例的强引用。这样两个对象就产生了循环强引用。\n\t虽然闭包多次使用了self，它只捕获HTMLElement实例的一个强引用。\n\n如果设置paragraph变量为nil，打破它持有的HTMLElement实例的强引用，HTMLElement实例和它的闭包都不会被销毁，HTMLElement的析构函数中的消息并没有被打印。也是因为循环强引用：\n\n```Swift\nparagraph = nil\n```\n\n\n### 解决闭包的循环强引用问题\n在定义闭包时同时定义捕获列表作为闭包的一部分，通过这种方式可以解决闭包和类实例之间的循环强引用。捕获列表定义了闭包体内捕获一个或者多个引用类型的规则。跟解决两个类实例间的循环强引用一样，声明每个捕获的引用为弱引用或无主引用，而不是强引用。应当根据代码关系来决定使用弱引用还是无主引用。\n\tSwift 有如下要求：只要在闭包内使用self的成员，就要用self.someProperty或者self.someMethod()（而不只是someProperty或someMethod()）。这提醒你可能会一不小心就捕获了self。\n\n#### 定义捕获列表\n捕获列表中的每一项都由一对元素组成，一个元素是weak或unowned关键字，另一个元素是类实例的引用（例如self）或初始化过的变量（如delegate = self.delegate!）。这些项在方括号中用逗号分开。\n如果闭包有参数列表和返回类型，把捕获列表放在它们前面：\n\n```Swift\nlazy var someClosure: (Int, String) -> String = {\n    [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -> String in\n    // closure body goes here\n}\n```\n\n如果闭包没有指明参数列表或者返回类型，即它们会通过上下文推断，那么可以把捕获列表和关键字in放在闭包最开始的地方：\n\n```Swift\nlazy var someClosure: () -> String = {\n    [unowned self, weak delegate = self.delegate!] in\n    // closure body goes here\n}\n```\n\n#### 弱引用和无主引用\n在闭包和捕获的实例总是互相引用并且总是同时销毁时，将闭包内的捕获定义为 `无主引用`。\n相反的，在被捕获的引用可能会变为nil时，将闭包内的捕获定义为 `弱引用` 。弱引用总是可选类型，并且当引用的实例被销毁后，弱引用的值会自动置为nil。这使我们可以在闭包体内检查它们是否存在。\n\t如果被捕获的引用不会变为nil，应该用无主引用，而不是弱引用。\n\n前面的HTMLElement例子中，无主引用是正确的解决循环强引用的方法。这样编写HTMLElement类来避免循环强引用：\n\n```Swift\nclass HTMLElement {\n    \n    let name: String\n    let text: String?\n    \n    lazy var asHTML: () -> String = {\n        [unowned self] in\n        if let text = self.text {\n            return \"<\\(self.name)>\\(text)</\\(self.name)>\"\n        } else {\n            return \"<\\(self.name) />\"\n        }\n    }\n    \n    init(name: String, text: String? = nil) {\n        self.name = name\n        self.text = text\n    }\n    \n    deinit {\n        print(\"\\(name) is being deinitialized\")\n    }\n    \n}\n```\n\n上面的HTMLElement实现和之前的实现一致，除了在asHTML闭包中多了一个捕获列表。这里，捕获列表是[unowned self]，表示“将self捕获为无主引用而不是强引用”。\n和之前一样，我们可以创建并打印HTMLElement实例：\n\n```Swift\nvar paragraph: HTMLElement? = HTMLElement(name: \"p\", text: \"hello, world\")\nprint(paragraph!.asHTML())\n// Prints \"<p>hello, world</p>\"\n```\n\n使用捕获列表后引用关系如下图所示：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle02_2x.png)\n此时，闭包以无主引用的形式捕获self，并不会持有HTMLElement实例的强引用。如果将paragraph赋值为nil，HTMLElement实例将会被销毁，并能看到它的析构函数打印出的消息：\n\n```Swift\nparagraph = nil\n// Prints \"p is being deinitialized\"\n```\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html/\"> AutomaticReferenceCounting </a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","slug":"iOS_Swift_language_note_ARC","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4tw0025oko8w21mz95n","content":"<p>​    Swift 使用自动引用计数（ARC）机制来跟踪和管理你的应用程序的内存。通常情况下，Swift 内存管理机制会一直起作用，你无须自己来考虑内存的管理。ARC 会在类的实例不再被使用时，自动释放其占用的内存。然而在少数情况下，为了能帮助你管理内存，ARC 需要更多的，代码之间关系的信息。在 Swift 使用 ARC 与在 Obejctive-C 中使用 ARC 非常类似<br>    引用计数仅仅应用于类的实例。结构体和枚举类型是值类型，不是引用类型，也不是通过引用的方式存储和传递。</p>\n<h3 id=\"ARC工作机制\"><a href=\"#ARC工作机制\" class=\"headerlink\" title=\"ARC工作机制\"></a>ARC工作机制</h3><p>当你每次创建一个类的新的实例的时候，ARC 会分配一块内存来储存该实例信息。内存中会包含实例的类型信息，以及这个实例所有相关的存储型属性的值。<br>当实例不再被使用时，ARC 释放实例所占用的内存，并让释放的内存能挪作他用。这确保了不再被使用的实例，不会一直占用内存空间。</p>\n<a id=\"more\"></a>\n<p>然而，当 ARC 收回和释放了正在被使用中的实例，该实例的属性和方法将不能再被访问和调用。实际上，如果你试图访问这个实例，你的应用程序很可能会崩溃。<br>为了确保使用中的实例不会被销毁，ARC 会跟踪和计算每一个实例正在被多少属性，常量和变量所引用。哪怕实例的引用数为1，ARC都不会销毁这个实例。</p>\n<p>为了使上述成为可能，无论你将实例赋值给属性、常量或变量，它们都会创建此实例的强引用。之所以称之为“强”引用，是因为它会将实例牢牢地保持住，只要强引用还在，实例是不允许被销毁的。</p>\n<h3 id=\"ARC实践\"><a href=\"#ARC实践\" class=\"headerlink\" title=\"ARC实践\"></a>ARC实践</h3><p>下面的例子展示了自动引用计数的工作机制。例子以一个简单的Person类开始，并定义了一个叫name的常量属性：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> name: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.name = name</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(name)</span> is being initialized\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">deinit</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(name)</span> is being deinitialized\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Person类有一个构造函数，此构造函数为实例的name属性赋值，并打印一条消息以表明初始化过程生效。Person类也拥有一个析构函数，这个析构函数会在实例被销毁时打印一条消息。</p>\n<p>接下来的代码片段定义了三个类型为Person?的变量，用来按照代码片段中的顺序，为新的Person实例建立多个引用。由于这些变量是被定义为可选类型（Person?，而不是Person），它们的值会被自动初始化为nil，目前还不会引用到Person类的实例。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reference1: <span class=\"type\">Person</span>?</div><div class=\"line\"><span class=\"keyword\">var</span> reference2: <span class=\"type\">Person</span>?</div><div class=\"line\"><span class=\"keyword\">var</span> reference3: <span class=\"type\">Person</span>?</div><div class=\"line\"></div><div class=\"line\">reference1 = <span class=\"type\">Person</span>(name: <span class=\"string\">\"John Appleseed\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"John Appleseed is being initialized\"</span></div></pre></td></tr></table></figure>\n<p>由于Person类的新实例被赋值给了reference1变量，所以reference1到Person类的新实例之间建立了一个强引用。正是因为这一个强引用，ARC 会保证Person实例被保持在内存中不被销毁。如果你将同一个Person实例也赋值给其他两个变量，该实例又会多出两个强引用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">reference2 = reference1</div><div class=\"line\">reference3 = reference1</div></pre></td></tr></table></figure>\n<p>现在这一个Person实例已经有三个强引用了。如果你通过给其中两个变量赋值nil的方式断开两个强引用（包括最先的那个强引用），只留下一个强引用，Person实例不会被销毁：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">reference1 = <span class=\"literal\">nil</span></div><div class=\"line\">reference2 = <span class=\"literal\">nil</span></div></pre></td></tr></table></figure>\n<p>在你清楚地表明不再使用这个Person实例时，即第三个也就是最后一个强引用被断开时，ARC 会销毁它：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">reference3 = <span class=\"literal\">nil</span></div><div class=\"line\"><span class=\"comment\">// Prints \"John Appleseed is being deinitialized\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"类实例之间的循环强引用\"><a href=\"#类实例之间的循环强引用\" class=\"headerlink\" title=\"类实例之间的循环强引用\"></a>类实例之间的循环强引用</h3><p>在上面的例子中，ARC 会跟踪你所新创建的Person实例的引用数量，并且会在Person实例不再被需要时销毁它。<br>然而，我们可能会写出一个类实例的强引用数永远不能变成0的代码。如果两个类实例互相持有对方的强引用，因而每个实例都让对方一直存在，就是这种情况。这就是所谓的循环强引用。<br>你可以通过定义类之间的关系为弱 <code>weak</code> 引用或无主 <code>unowned</code> 引用，以替代强引用，从而解决循环强引用的问题。</p>\n<p>下面展示了一个不经意产生循环强引用的例子。例子定义了两个类：Person和Apartment，用来建模公寓和它其中的居民：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> name: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>) &#123; <span class=\"keyword\">self</span>.name = name &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> apartment: <span class=\"type\">Apartment</span>?</div><div class=\"line\">    <span class=\"keyword\">deinit</span> &#123; <span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(name)</span> is being deinitialized\"</span>) &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Apartment</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> unit: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(unit: <span class=\"type\">String</span>) &#123; <span class=\"keyword\">self</span>.unit = unit &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> tenant: <span class=\"type\">Person</span>?</div><div class=\"line\">    <span class=\"keyword\">deinit</span> &#123; <span class=\"built_in\">print</span>(<span class=\"string\">\"Apartment <span class=\"subst\">\\(unit)</span> is being deinitialized\"</span>) &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>每一个Person实例有一个类型为String，名字为name的属性，并有一个可选的初始化为nil的apartment属性。apartment属性是可选的，因为一个人并不总是拥有公寓。<br>类似的，每个Apartment实例有一个叫unit，类型为String的属性，并有一个可选的初始化为nil的tenant属性。tenant属性是可选的，因为一栋公寓并不总是有居民。<br>这两个类都定义了析构函数，用以在类实例被析构的时候输出信息。这让你能够知晓Person和Apartment的实例是否像预期的那样被销毁。</p>\n<p>接下来的代码片段定义了两个可选类型的变量john和unit4A，并分别被设定为下面的Apartment和Person的实例。这两个变量都被初始化为nil，这正是可选类型的优点：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> john: <span class=\"type\">Person</span>?</div><div class=\"line\"><span class=\"keyword\">var</span> unit4A: <span class=\"type\">Apartment</span>?</div><div class=\"line\"></div><div class=\"line\">john = <span class=\"type\">Person</span>(name: <span class=\"string\">\"John Appleseed\"</span>)</div><div class=\"line\">unit4A = <span class=\"type\">Apartment</span>(unit: <span class=\"string\">\"4A\"</span>)</div></pre></td></tr></table></figure>\n<p>在两个实例被创建和赋值后，下图表现了强引用的关系。变量john现在有一个指向Person实例的强引用，而变量unit4A有一个指向Apartment实例的强引用：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle01_2x.png\" alt=\"\"><br>现在你能够将这两个实例关联在一起，这样人就能有公寓住了，而公寓也有了房客。注意感叹号(<code>!</code>)是用来展开(解包)和访问可选变量john和unit4A中的实例，这样实例的属性才能被赋值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">john!.apartment = unit4A</div><div class=\"line\">unit4A!.tenant = john</div></pre></td></tr></table></figure>\n<p>在将两个实例联系在一起之后，强引用的关系如图所示：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle02_2x.png\" alt=\"\"><br>不幸的是，这两个实例关联后会产生一个循环强引用。Person实例现在有了一个指向Apartment实例的强引用，而Apartment实例也有了一个指向Person实例的强引用。因此，当你断开john和unit4A变量所持有的强引用时，引用计数并不会降为0，实例也不会被 ARC 销毁：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">john = <span class=\"literal\">nil</span></div><div class=\"line\">unit4A = <span class=\"literal\">nil</span></div></pre></td></tr></table></figure>\n<p>注意，当你把这两个变量设为nil时，没有任何一个析构函数被调用。循环强引用会一直阻止Person和Apartment类实例的销毁，这就在你的应用程序中造成了内存泄漏。在你将john和unit4A赋值为nil后，强引用关系如下图：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle03_2x.png\" alt=\"\"><br>Person和Apartment实例之间的强引用关系保留了下来并且不会被断开。</p>\n<h3 id=\"解决实例的循环强引用问题\"><a href=\"#解决实例的循环强引用问题\" class=\"headerlink\" title=\"解决实例的循环强引用问题\"></a>解决实例的循环强引用问题</h3><p>Swift 提供了两种办法用来解决你在使用类的属性时所遇到的循环强引用问题：弱引用（<code>weak reference</code>）和无主引用（<code>unowned reference</code>）。<br>弱引用和无主引用允许循环引用中的一个实例引用而另外一个实例不保持强引用。这样实例能够互相引用而不产生循环强引用。</p>\n<p>当其他的实例有更短的生命周期时，使用弱引用，也就是说，当其他实例析构在先时。在上面公寓的例子中，很显然一个公寓在它的生命周期内会在某个时间段没有它的主人，所以一个弱引用就加在公寓类里面，避免循环引用。相比之下，当其他实例有相同的或者更长生命周期时，请使用无主引用。</p>\n<h4 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h4><p>弱引用不会对其引用的实例保持强引用，因而不会阻止 ARC 销毁被引用的实例。这个特性阻止了引用变为循环强引用。声明属性或者变量时，在前面加上 <code>weak</code> 关键字表明这是一个弱引用。</p>\n<p>因为弱引用不会保持所引用的实例，即使引用存在，实例也有可能被销毁。因此，ARC 会在引用的实例被销毁后自动将其赋值为nil。并且因为弱引用可以允许它们的值在运行时被赋值为nil，所以它们会被定义为可选类型变量，而不是常量。<br>你可以像其他可选值一样，检查弱引用的值是否存在，你将永远不会访问已销毁的实例的引用。<br>    当 ARC 设置弱引用为nil时，属性观察不会被触发。</p>\n<p>下面的例子跟上面Person和Apartment的例子一致，但是有一个重要的区别。这一次，Apartment的tenant属性被声明为弱引用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> name: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>) &#123; <span class=\"keyword\">self</span>.name = name &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> apartment: <span class=\"type\">Apartment</span>?</div><div class=\"line\">    <span class=\"keyword\">deinit</span> &#123; <span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(name)</span> is being deinitialized\"</span>) &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Apartment</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> unit: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(unit: <span class=\"type\">String</span>) &#123; <span class=\"keyword\">self</span>.unit = unit &#125;</div><div class=\"line\">    <span class=\"keyword\">weak</span> <span class=\"keyword\">var</span> tenant: <span class=\"type\">Person</span>?</div><div class=\"line\">    <span class=\"keyword\">deinit</span> &#123; <span class=\"built_in\">print</span>(<span class=\"string\">\"Apartment <span class=\"subst\">\\(unit)</span> is being deinitialized\"</span>) &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后跟之前一样，建立两个变量（john和unit4A）之间的强引用，并关联两个实例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> john: <span class=\"type\">Person</span>?</div><div class=\"line\"><span class=\"keyword\">var</span> unit4A: <span class=\"type\">Apartment</span>?</div><div class=\"line\"> </div><div class=\"line\">john = <span class=\"type\">Person</span>(name: <span class=\"string\">\"John Appleseed\"</span>)</div><div class=\"line\">unit4A = <span class=\"type\">Apartment</span>(unit: <span class=\"string\">\"4A\"</span>)</div><div class=\"line\"> </div><div class=\"line\">john!.apartment = unit4A</div><div class=\"line\">unit4A!.tenant = john</div></pre></td></tr></table></figure>\n<p>现在，两个关联在一起的实例的引用关系如下图所示：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference01_2x.png\" alt=\"\"><br>Person实例依然保持对Apartment实例的强引用，但是Apartment实例只持有对Person实例的弱引用。这意味着当你断开john变量所保持的强引用时，再也没有指向Person实例的强引用了：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference02_2x.png\" alt=\"\"><br>由于再也没有指向Person实例的强引用，该实例会被销毁：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">john = <span class=\"literal\">nil</span></div><div class=\"line\"><span class=\"comment\">// Prints \"John Appleseed is being deinitialized\"</span></div></pre></td></tr></table></figure>\n<p>唯一剩下的指向Apartment实例的强引用来自于变量unit4A。如果你断开这个强引用，再也没有指向Apartment实例的强引用了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">unit4A = <span class=\"literal\">nil</span></div><div class=\"line\"><span class=\"comment\">// Prints \"Apartment 4A is being deinitialized\"</span></div></pre></td></tr></table></figure>\n<p>由于再也没有指向Apartment实例的强引用，该实例也会被销毁：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference03_2x.png\" alt=\"\"><br>    在使用垃圾收集的系统里，弱指针有时用来实现简单的缓冲机制，因为没有强引用的对象只会在内存压力触发垃圾收集时才被销毁。但是在 ARC 中，一旦值的最后一个强引用被移除，就会被立即销毁，这导致弱引用并不适合上面的用途。</p>\n<h4 id=\"无主引用\"><a href=\"#无主引用\" class=\"headerlink\" title=\"无主引用\"></a>无主引用</h4><p>和弱引用类似，无主引用不会牢牢保持住引用的实例。和弱引用不同的是，无主引用在其他实例有相同或者更长的生命周期时使用。你可以在声明属性或者变量时，在前面加上关键字unowned表示这是一个无主引用。<br>无主引用通常都被期望拥有值。不过 ARC 无法在实例被销毁后将无主引用设为nil，这意味着无主引用明确使用非可选类型<br>    使用无主引用，你必须确保引用始终指向一个未销毁的实例。<br>如果你试图在实例被销毁后，访问该实例的无主引用，会触发运行时错误。</p>\n<p>下面的例子定义了两个类，Customer和CreditCard，模拟了银行客户和客户的信用卡。这两个类中，每一个都将另外一个类的实例作为自身的属性。这种关系可能会造成循环强引用。<br>Customer和CreditCard之间的关系与前面弱引用例子中Apartment和Person的关系略微不同。在这个数据模型中，一个客户可能有或者没有信用卡，但是一张信用卡总是关联着一个客户。为了表示这种关系，Customer类有一个可选类型的card属性，但是CreditCard类有一个非可选类型的customer属性。<br>此外，只能通过将一个number值和customer实例传递给CreditCard构造函数的方式来创建CreditCard实例。这样可以确保当创建CreditCard实例时总是有一个customer实例与之关联。<br>由于信用卡总是关联着一个客户，因此将customer属性定义为无主引用，用以避免循环强引用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> name: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">var</span> card: <span class=\"type\">CreditCard</span>?</div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.name = name</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">deinit</span> &#123; <span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(name)</span> is being deinitialized\"</span>) &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CreditCard</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> number: <span class=\"type\">UInt64</span></div><div class=\"line\">    <span class=\"keyword\">unowned</span> <span class=\"keyword\">let</span> customer: <span class=\"type\">Customer</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(number: <span class=\"type\">UInt64</span>, customer: <span class=\"type\">Customer</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.number = number</div><div class=\"line\">        <span class=\"keyword\">self</span>.customer = customer</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">deinit</span> &#123; <span class=\"built_in\">print</span>(<span class=\"string\">\"Card #<span class=\"subst\">\\(number)</span> is being deinitialized\"</span>) &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下面的代码片段定义了一个叫john的可选类型Customer变量，用来保存某个特定客户的引用。由于是可选类型，所以变量被初始化为nil：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> john: <span class=\"type\">Customer</span>?</div></pre></td></tr></table></figure>\n<p>现在你可以创建Customer类的实例，用它初始化CreditCard实例，并将新创建的CreditCard实例赋值为客户的card属性：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">john = <span class=\"type\">Customer</span>(name: <span class=\"string\">\"John Appleseed\"</span>)</div><div class=\"line\">john!.card = <span class=\"type\">CreditCard</span>(number: <span class=\"number\">1234_5678_9012_3456</span>, customer: john!)</div></pre></td></tr></table></figure>\n<p>在你关联两个实例后，它们的引用关系如下图所示：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference01_2x.png\" alt=\"\"></p>\n<p>Customer实例持有对CreditCard实例的强引用，而CreditCard实例持有对Customer实例的无主引用。<br>由于customer的无主引用，当你断开john变量持有的强引用时，再也没有指向Customer实例的强引用了：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference02_2x.png\" alt=\"\"><br>由于再也没有指向Customer实例的强引用，该实例被销毁了。其后，再也没有指向CreditCard实例的强引用，该实例也随之被销毁了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">john = <span class=\"literal\">nil</span></div><div class=\"line\"><span class=\"comment\">// Prints \"John Appleseed is being deinitialized\"</span></div><div class=\"line\"><span class=\"comment\">// Prints \"Card #1234567890123456 is being deinitialized\"</span></div></pre></td></tr></table></figure>\n<pre><code>上面的例子展示了如何使用安全的无主引用。对于需要禁用运行时的安全检查的情况（例如，出于性能方面的原因），Swift还提供了不安全的无主引用。与所有不安全的操作一样，你需要负责检查代码以确保其安全性。 你可以通过unowned(unsafe)来声明不安全无主引用。如果你试图在实例被销毁后，访问该实例的不安全无主引用，你的程序会尝试访问该实例之前所在的内存地址，这是一个不安全的操作。\n</code></pre><h4 id=\"无主引用以及隐式解析可选属性\"><a href=\"#无主引用以及隐式解析可选属性\" class=\"headerlink\" title=\"无主引用以及隐式解析可选属性\"></a>无主引用以及隐式解析可选属性</h4><p>上面弱引用和无主引用的例子涵盖了两种常用的需要打破循环强引用的场景。</p>\n<p>Person和Apartment的例子展示了两个属性的值都允许为nil，并会潜在的产生循环强引用。这种场景最适合用弱引用来解决。<br>Customer和CreditCard的例子展示了一个属性的值允许为nil，而另一个属性的值不允许为nil，这也可能会产生循环强引用。这种场景最适合通过无主引用来解决。</p>\n<p>然而，存在着第三种场景，在这种场景中，两个属性都必须有值，并且初始化完成后永远不会为nil。在这种场景中，需要一个类使用无主属性，而另外一个类使用隐式解析可选属性。<br>这使两个属性在初始化完成后能被直接访问（不需要可选展开），同时避免了循环引用。这一节将为你展示如何建立这种关系。<br>下面的例子定义了两个类，Country和City，每个类将另外一个类的实例保存为属性。在这个模型中，每个国家必须有首都，每个城市必须属于一个国家。为了实现这种关系，Country类拥有一个capitalCity属性，而City类有一个country属性：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Country</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> name: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">var</span> capitalCity: <span class=\"type\">City</span>!</div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>, capitalName: <span class=\"type\">String</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.name = name</div><div class=\"line\">        <span class=\"keyword\">self</span>.capitalCity = <span class=\"type\">City</span>(name: capitalName, country: <span class=\"keyword\">self</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">City</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> name: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">unowned</span> <span class=\"keyword\">let</span> country: <span class=\"type\">Country</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>, country: <span class=\"type\">Country</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.name = name</div><div class=\"line\">        <span class=\"keyword\">self</span>.country = country</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>为了建立两个类的依赖关系，City的构造函数接受一个Country实例作为参数，并且将实例保存到country属性。</p>\n<p>Country的构造函数调用了City的构造函数。然而，只有Country的实例完全初始化后，Country的构造函数才能把self传给City的构造函数。在两段式构造过程中有具体描述。<br>为了满足这种需求，通过在类型结尾处加上感叹号（City!）的方式，将Country的capitalCity属性声明为隐式解析可选类型的属性。这意味着像其他可选类型一样，capitalCity属性的默认值为nil，但是不需要展开它的值就能访问它。在隐式解析可选类型中有描述。</p>\n<p>由于capitalCity默认值为nil，一旦Country的实例在构造函数中给name属性赋值后，整个初始化过程就完成了。这意味着一旦name属性被赋值后，Country的构造函数就能引用并传递隐式的self。Country的构造函数在赋值capitalCity时，就能将self作为参数传递给City的构造函数。</p>\n<p>以上的意义在于你可以通过一条语句同时创建Country和City的实例，而不产生循环强引用，并且capitalCity的属性能被直接访问，而不需要通过感叹号来展开它的可选值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> country = <span class=\"type\">Country</span>(name: <span class=\"string\">\"Canada\"</span>, capitalName: <span class=\"string\">\"Ottawa\"</span>)</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(country.name)</span>'s capital city is called <span class=\"subst\">\\(country.capitalCity.name)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"Canada's capital city is called Ottawa\"</span></div></pre></td></tr></table></figure>\n<p>在上面的例子中，使用隐式解析可选值意味着满足了类的构造函数的两个构造阶段的要求。capitalCity属性在初始化完成后，能像非可选值一样使用和存取，同时还避免了循环强引用。</p>\n<h3 id=\"闭包的循环强引用\"><a href=\"#闭包的循环强引用\" class=\"headerlink\" title=\"闭包的循环强引用\"></a>闭包的循环强引用</h3><p>前面我们看到了循环强引用是在两个类实例属性互相保持对方的强引用时产生的，还知道了如何用弱引用和无主引用来打破这些循环强引用。</p>\n<p>循环强引用还会发生在当你将一个闭包赋值给类实例的某个属性，并且这个闭包体中又使用了这个类实例时。这个闭包体中可能访问了实例的某个属性，例如self.someProperty，或者闭包中调用了实例的某个方法，例如self.someMethod()。这两种情况都导致了闭包“捕获”self，从而产生了循环强引用。</p>\n<p>循环强引用的产生，是因为闭包和类相似，都是引用类型。当你把一个闭包赋值给某个属性时，你是将这个闭包的引用赋值给了属性。实质上，这跟之前的问题是一样的——两个强引用让彼此一直有效。但是，和两个类实例不同，这次一个是类实例，另一个是闭包。</p>\n<p>Swift 提供了一种优雅的方法来解决这个问题，称之为闭包捕获列表（closure capture list）。同样的，在学习如何用闭包捕获列表打破循环强引用之前，先来了解一下这里的循环强引用是如何产生的，这对我们很有帮助。</p>\n<p>下面的例子为你展示了当一个闭包引用了self后是如何产生一个循环强引用的。例子中定义了一个叫HTMLElement的类，用一种简单的模型表示 HTML 文档中的一个单独的元素：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HTMLElement</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">let</span> name: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">let</span> text: <span class=\"type\">String</span>?</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">lazy</span> <span class=\"keyword\">var</span> asHTML: () -&gt; <span class=\"type\">String</span> = &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> text = <span class=\"keyword\">self</span>.text &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"&lt;<span class=\"subst\">\\(<span class=\"keyword\">self</span>.name)</span>&gt;<span class=\"subst\">\\(text)</span>&lt;/<span class=\"subst\">\\(<span class=\"keyword\">self</span>.name)</span>&gt;\"</span></div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"&lt;<span class=\"subst\">\\(<span class=\"keyword\">self</span>.name)</span> /&gt;\"</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>, text: <span class=\"type\">String</span>? = <span class=\"literal\">nil</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.name = name</div><div class=\"line\">        <span class=\"keyword\">self</span>.text = text</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">deinit</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(name)</span> is being deinitialized\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>HTMLElement类定义了一个name属性来表示这个元素的名称，例如代表头部元素的”h1”，代表段落的“p”，或者代表换行的“br”。HTMLElement还定义了一个可选属性text，用来设置 HTML 元素呈现的文本。</p>\n<p>除了上面的两个属性，HTMLElement还定义了一个lazy属性asHTML。这个属性引用了一个将name和text组合成 HTML 字符串片段的闭包。该属性是Void -&gt; String类型，或者可以理解为“一个没有参数，返回String的函数”。</p>\n<p>默认情况下，闭包赋值给了asHTML属性，这个闭包返回一个代表 HTML 标签的字符串。如果text值存在，该标签就包含可选值text；如果text不存在，该标签就不包含文本。对于段落元素，根据text是“some text”还是nil，闭包会返回”</p><p>some text</p>“或者”<p>“。</p>\n<p>可以像实例方法那样去命名、使用asHTML属性。然而，由于asHTML是闭包而不是实例方法，如果你想改变特定 HTML 元素的处理方式的话，可以用自定义的闭包来取代默认值。</p>\n<p>例如，可以将一个闭包赋值给asHTML属性，这个闭包能在text属性是nil时使用默认文本，这是为了避免返回一个空的 HTML 标签：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> heading = <span class=\"type\">HTMLElement</span>(name: <span class=\"string\">\"h1\"</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> defaultText = <span class=\"string\">\"some default text\"</span></div><div class=\"line\">heading.asHTML = &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"&lt;<span class=\"subst\">\\(heading.name)</span>&gt;<span class=\"subst\">\\(heading.text ?? defaultText)</span>&lt;/<span class=\"subst\">\\(heading.name)</span>&gt;\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">print</span>(heading.asHTML())</div><div class=\"line\"><span class=\"comment\">// Prints \"&lt;h1&gt;some default text&lt;/h1&gt;\"</span></div></pre></td></tr></table></figure>\n<pre><code>asHTML声明为lazy属性，因为只有当元素确实需要被处理为 HTML 输出的字符串时，才需要使用asHTML。也就是说，在默认的闭包中可以使用self，因为只有当初始化完成以及self确实存在后，才能访问lazy属性。\n</code></pre><p>HTMLElement类只提供了一个构造函数，通过name和text（如果有的话）参数来初始化一个新元素。该类也定义了一个析构函数，当HTMLElement实例被销毁时，打印一条消息。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> paragraph: <span class=\"type\">HTMLElement</span>? = <span class=\"type\">HTMLElement</span>(name: <span class=\"string\">\"p\"</span>, text: <span class=\"string\">\"hello, world\"</span>)</div><div class=\"line\"><span class=\"built_in\">print</span>(paragraph!.asHTML())</div><div class=\"line\"><span class=\"comment\">// Prints \"&lt;p&gt;hello, world&lt;/p&gt;\"</span></div></pre></td></tr></table></figure>\n<p>不幸的是，上面写的HTMLElement类产生了类实例和作为asHTML默认值的闭包之间的循环强引用。循环强引用如下图所示：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle01_2x.png\" alt=\"\"><br>实例的asHTML属性持有闭包的强引用。但是，闭包在其闭包体内使用了self（引用了self.name和self.text），因此闭包捕获了self，这意味着闭包又反过来持有了HTMLElement实例的强引用。这样两个对象就产生了循环强引用。<br>    虽然闭包多次使用了self，它只捕获HTMLElement实例的一个强引用。</p>\n<p>如果设置paragraph变量为nil，打破它持有的HTMLElement实例的强引用，HTMLElement实例和它的闭包都不会被销毁，HTMLElement的析构函数中的消息并没有被打印。也是因为循环强引用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">paragraph = <span class=\"literal\">nil</span></div></pre></td></tr></table></figure>\n<h3 id=\"解决闭包的循环强引用问题\"><a href=\"#解决闭包的循环强引用问题\" class=\"headerlink\" title=\"解决闭包的循环强引用问题\"></a>解决闭包的循环强引用问题</h3><p>在定义闭包时同时定义捕获列表作为闭包的一部分，通过这种方式可以解决闭包和类实例之间的循环强引用。捕获列表定义了闭包体内捕获一个或者多个引用类型的规则。跟解决两个类实例间的循环强引用一样，声明每个捕获的引用为弱引用或无主引用，而不是强引用。应当根据代码关系来决定使用弱引用还是无主引用。<br>    Swift 有如下要求：只要在闭包内使用self的成员，就要用self.someProperty或者self.someMethod()（而不只是someProperty或someMethod()）。这提醒你可能会一不小心就捕获了self。</p>\n<h4 id=\"定义捕获列表\"><a href=\"#定义捕获列表\" class=\"headerlink\" title=\"定义捕获列表\"></a>定义捕获列表</h4><p>捕获列表中的每一项都由一对元素组成，一个元素是weak或unowned关键字，另一个元素是类实例的引用（例如self）或初始化过的变量（如delegate = self.delegate!）。这些项在方括号中用逗号分开。<br>如果闭包有参数列表和返回类型，把捕获列表放在它们前面：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">lazy</span> <span class=\"keyword\">var</span> someClosure: (<span class=\"type\">Int</span>, <span class=\"type\">String</span>) -&gt; <span class=\"type\">String</span> = &#123;</div><div class=\"line\">    [<span class=\"keyword\">unowned</span> <span class=\"keyword\">self</span>, <span class=\"keyword\">weak</span> delegate = <span class=\"keyword\">self</span>.delegate!] (index: <span class=\"type\">Int</span>, stringToProcess: <span class=\"type\">String</span>) -&gt; <span class=\"type\">String</span> <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"comment\">// closure body goes here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果闭包没有指明参数列表或者返回类型，即它们会通过上下文推断，那么可以把捕获列表和关键字in放在闭包最开始的地方：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">lazy</span> <span class=\"keyword\">var</span> someClosure: () -&gt; <span class=\"type\">String</span> = &#123;</div><div class=\"line\">    [<span class=\"keyword\">unowned</span> <span class=\"keyword\">self</span>, <span class=\"keyword\">weak</span> delegate = <span class=\"keyword\">self</span>.delegate!] <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"comment\">// closure body goes here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"弱引用和无主引用\"><a href=\"#弱引用和无主引用\" class=\"headerlink\" title=\"弱引用和无主引用\"></a>弱引用和无主引用</h4><p>在闭包和捕获的实例总是互相引用并且总是同时销毁时，将闭包内的捕获定义为 <code>无主引用</code>。<br>相反的，在被捕获的引用可能会变为nil时，将闭包内的捕获定义为 <code>弱引用</code> 。弱引用总是可选类型，并且当引用的实例被销毁后，弱引用的值会自动置为nil。这使我们可以在闭包体内检查它们是否存在。<br>    如果被捕获的引用不会变为nil，应该用无主引用，而不是弱引用。</p>\n<p>前面的HTMLElement例子中，无主引用是正确的解决循环强引用的方法。这样编写HTMLElement类来避免循环强引用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HTMLElement</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">let</span> name: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">let</span> text: <span class=\"type\">String</span>?</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">lazy</span> <span class=\"keyword\">var</span> asHTML: () -&gt; <span class=\"type\">String</span> = &#123;</div><div class=\"line\">        [<span class=\"keyword\">unowned</span> <span class=\"keyword\">self</span>] <span class=\"keyword\">in</span></div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> text = <span class=\"keyword\">self</span>.text &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"&lt;<span class=\"subst\">\\(<span class=\"keyword\">self</span>.name)</span>&gt;<span class=\"subst\">\\(text)</span>&lt;/<span class=\"subst\">\\(<span class=\"keyword\">self</span>.name)</span>&gt;\"</span></div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"&lt;<span class=\"subst\">\\(<span class=\"keyword\">self</span>.name)</span> /&gt;\"</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>, text: <span class=\"type\">String</span>? = <span class=\"literal\">nil</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.name = name</div><div class=\"line\">        <span class=\"keyword\">self</span>.text = text</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">deinit</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(name)</span> is being deinitialized\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的HTMLElement实现和之前的实现一致，除了在asHTML闭包中多了一个捕获列表。这里，捕获列表是[unowned self]，表示“将self捕获为无主引用而不是强引用”。<br>和之前一样，我们可以创建并打印HTMLElement实例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> paragraph: <span class=\"type\">HTMLElement</span>? = <span class=\"type\">HTMLElement</span>(name: <span class=\"string\">\"p\"</span>, text: <span class=\"string\">\"hello, world\"</span>)</div><div class=\"line\"><span class=\"built_in\">print</span>(paragraph!.asHTML())</div><div class=\"line\"><span class=\"comment\">// Prints \"&lt;p&gt;hello, world&lt;/p&gt;\"</span></div></pre></td></tr></table></figure>\n<p>使用捕获列表后引用关系如下图所示：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle02_2x.png\" alt=\"\"><br>此时，闭包以无主引用的形式捕获self，并不会持有HTMLElement实例的强引用。如果将paragraph赋值为nil，HTMLElement实例将会被销毁，并能看到它的析构函数打印出的消息：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">paragraph = <span class=\"literal\">nil</span></div><div class=\"line\"><span class=\"comment\">// Prints \"p is being deinitialized\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html/\" target=\"_blank\" rel=\"external\"> AutomaticReferenceCounting </a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>​    Swift 使用自动引用计数（ARC）机制来跟踪和管理你的应用程序的内存。通常情况下，Swift 内存管理机制会一直起作用，你无须自己来考虑内存的管理。ARC 会在类的实例不再被使用时，自动释放其占用的内存。然而在少数情况下，为了能帮助你管理内存，ARC 需要更多的，代码之间关系的信息。在 Swift 使用 ARC 与在 Obejctive-C 中使用 ARC 非常类似<br>    引用计数仅仅应用于类的实例。结构体和枚举类型是值类型，不是引用类型，也不是通过引用的方式存储和传递。</p>\n<h3 id=\"ARC工作机制\"><a href=\"#ARC工作机制\" class=\"headerlink\" title=\"ARC工作机制\"></a>ARC工作机制</h3><p>当你每次创建一个类的新的实例的时候，ARC 会分配一块内存来储存该实例信息。内存中会包含实例的类型信息，以及这个实例所有相关的存储型属性的值。<br>当实例不再被使用时，ARC 释放实例所占用的内存，并让释放的内存能挪作他用。这确保了不再被使用的实例，不会一直占用内存空间。</p>","more":"<p>然而，当 ARC 收回和释放了正在被使用中的实例，该实例的属性和方法将不能再被访问和调用。实际上，如果你试图访问这个实例，你的应用程序很可能会崩溃。<br>为了确保使用中的实例不会被销毁，ARC 会跟踪和计算每一个实例正在被多少属性，常量和变量所引用。哪怕实例的引用数为1，ARC都不会销毁这个实例。</p>\n<p>为了使上述成为可能，无论你将实例赋值给属性、常量或变量，它们都会创建此实例的强引用。之所以称之为“强”引用，是因为它会将实例牢牢地保持住，只要强引用还在，实例是不允许被销毁的。</p>\n<h3 id=\"ARC实践\"><a href=\"#ARC实践\" class=\"headerlink\" title=\"ARC实践\"></a>ARC实践</h3><p>下面的例子展示了自动引用计数的工作机制。例子以一个简单的Person类开始，并定义了一个叫name的常量属性：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> name: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.name = name</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(name)</span> is being initialized\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">deinit</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(name)</span> is being deinitialized\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Person类有一个构造函数，此构造函数为实例的name属性赋值，并打印一条消息以表明初始化过程生效。Person类也拥有一个析构函数，这个析构函数会在实例被销毁时打印一条消息。</p>\n<p>接下来的代码片段定义了三个类型为Person?的变量，用来按照代码片段中的顺序，为新的Person实例建立多个引用。由于这些变量是被定义为可选类型（Person?，而不是Person），它们的值会被自动初始化为nil，目前还不会引用到Person类的实例。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> reference1: <span class=\"type\">Person</span>?</div><div class=\"line\"><span class=\"keyword\">var</span> reference2: <span class=\"type\">Person</span>?</div><div class=\"line\"><span class=\"keyword\">var</span> reference3: <span class=\"type\">Person</span>?</div><div class=\"line\"></div><div class=\"line\">reference1 = <span class=\"type\">Person</span>(name: <span class=\"string\">\"John Appleseed\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"John Appleseed is being initialized\"</span></div></pre></td></tr></table></figure>\n<p>由于Person类的新实例被赋值给了reference1变量，所以reference1到Person类的新实例之间建立了一个强引用。正是因为这一个强引用，ARC 会保证Person实例被保持在内存中不被销毁。如果你将同一个Person实例也赋值给其他两个变量，该实例又会多出两个强引用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">reference2 = reference1</div><div class=\"line\">reference3 = reference1</div></pre></td></tr></table></figure>\n<p>现在这一个Person实例已经有三个强引用了。如果你通过给其中两个变量赋值nil的方式断开两个强引用（包括最先的那个强引用），只留下一个强引用，Person实例不会被销毁：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">reference1 = <span class=\"literal\">nil</span></div><div class=\"line\">reference2 = <span class=\"literal\">nil</span></div></pre></td></tr></table></figure>\n<p>在你清楚地表明不再使用这个Person实例时，即第三个也就是最后一个强引用被断开时，ARC 会销毁它：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">reference3 = <span class=\"literal\">nil</span></div><div class=\"line\"><span class=\"comment\">// Prints \"John Appleseed is being deinitialized\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"类实例之间的循环强引用\"><a href=\"#类实例之间的循环强引用\" class=\"headerlink\" title=\"类实例之间的循环强引用\"></a>类实例之间的循环强引用</h3><p>在上面的例子中，ARC 会跟踪你所新创建的Person实例的引用数量，并且会在Person实例不再被需要时销毁它。<br>然而，我们可能会写出一个类实例的强引用数永远不能变成0的代码。如果两个类实例互相持有对方的强引用，因而每个实例都让对方一直存在，就是这种情况。这就是所谓的循环强引用。<br>你可以通过定义类之间的关系为弱 <code>weak</code> 引用或无主 <code>unowned</code> 引用，以替代强引用，从而解决循环强引用的问题。</p>\n<p>下面展示了一个不经意产生循环强引用的例子。例子定义了两个类：Person和Apartment，用来建模公寓和它其中的居民：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> name: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>) &#123; <span class=\"keyword\">self</span>.name = name &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> apartment: <span class=\"type\">Apartment</span>?</div><div class=\"line\">    <span class=\"keyword\">deinit</span> &#123; <span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(name)</span> is being deinitialized\"</span>) &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Apartment</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> unit: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(unit: <span class=\"type\">String</span>) &#123; <span class=\"keyword\">self</span>.unit = unit &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> tenant: <span class=\"type\">Person</span>?</div><div class=\"line\">    <span class=\"keyword\">deinit</span> &#123; <span class=\"built_in\">print</span>(<span class=\"string\">\"Apartment <span class=\"subst\">\\(unit)</span> is being deinitialized\"</span>) &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>每一个Person实例有一个类型为String，名字为name的属性，并有一个可选的初始化为nil的apartment属性。apartment属性是可选的，因为一个人并不总是拥有公寓。<br>类似的，每个Apartment实例有一个叫unit，类型为String的属性，并有一个可选的初始化为nil的tenant属性。tenant属性是可选的，因为一栋公寓并不总是有居民。<br>这两个类都定义了析构函数，用以在类实例被析构的时候输出信息。这让你能够知晓Person和Apartment的实例是否像预期的那样被销毁。</p>\n<p>接下来的代码片段定义了两个可选类型的变量john和unit4A，并分别被设定为下面的Apartment和Person的实例。这两个变量都被初始化为nil，这正是可选类型的优点：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> john: <span class=\"type\">Person</span>?</div><div class=\"line\"><span class=\"keyword\">var</span> unit4A: <span class=\"type\">Apartment</span>?</div><div class=\"line\"></div><div class=\"line\">john = <span class=\"type\">Person</span>(name: <span class=\"string\">\"John Appleseed\"</span>)</div><div class=\"line\">unit4A = <span class=\"type\">Apartment</span>(unit: <span class=\"string\">\"4A\"</span>)</div></pre></td></tr></table></figure>\n<p>在两个实例被创建和赋值后，下图表现了强引用的关系。变量john现在有一个指向Person实例的强引用，而变量unit4A有一个指向Apartment实例的强引用：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle01_2x.png\" alt=\"\"><br>现在你能够将这两个实例关联在一起，这样人就能有公寓住了，而公寓也有了房客。注意感叹号(<code>!</code>)是用来展开(解包)和访问可选变量john和unit4A中的实例，这样实例的属性才能被赋值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">john!.apartment = unit4A</div><div class=\"line\">unit4A!.tenant = john</div></pre></td></tr></table></figure>\n<p>在将两个实例联系在一起之后，强引用的关系如图所示：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle02_2x.png\" alt=\"\"><br>不幸的是，这两个实例关联后会产生一个循环强引用。Person实例现在有了一个指向Apartment实例的强引用，而Apartment实例也有了一个指向Person实例的强引用。因此，当你断开john和unit4A变量所持有的强引用时，引用计数并不会降为0，实例也不会被 ARC 销毁：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">john = <span class=\"literal\">nil</span></div><div class=\"line\">unit4A = <span class=\"literal\">nil</span></div></pre></td></tr></table></figure>\n<p>注意，当你把这两个变量设为nil时，没有任何一个析构函数被调用。循环强引用会一直阻止Person和Apartment类实例的销毁，这就在你的应用程序中造成了内存泄漏。在你将john和unit4A赋值为nil后，强引用关系如下图：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle03_2x.png\" alt=\"\"><br>Person和Apartment实例之间的强引用关系保留了下来并且不会被断开。</p>\n<h3 id=\"解决实例的循环强引用问题\"><a href=\"#解决实例的循环强引用问题\" class=\"headerlink\" title=\"解决实例的循环强引用问题\"></a>解决实例的循环强引用问题</h3><p>Swift 提供了两种办法用来解决你在使用类的属性时所遇到的循环强引用问题：弱引用（<code>weak reference</code>）和无主引用（<code>unowned reference</code>）。<br>弱引用和无主引用允许循环引用中的一个实例引用而另外一个实例不保持强引用。这样实例能够互相引用而不产生循环强引用。</p>\n<p>当其他的实例有更短的生命周期时，使用弱引用，也就是说，当其他实例析构在先时。在上面公寓的例子中，很显然一个公寓在它的生命周期内会在某个时间段没有它的主人，所以一个弱引用就加在公寓类里面，避免循环引用。相比之下，当其他实例有相同的或者更长生命周期时，请使用无主引用。</p>\n<h4 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h4><p>弱引用不会对其引用的实例保持强引用，因而不会阻止 ARC 销毁被引用的实例。这个特性阻止了引用变为循环强引用。声明属性或者变量时，在前面加上 <code>weak</code> 关键字表明这是一个弱引用。</p>\n<p>因为弱引用不会保持所引用的实例，即使引用存在，实例也有可能被销毁。因此，ARC 会在引用的实例被销毁后自动将其赋值为nil。并且因为弱引用可以允许它们的值在运行时被赋值为nil，所以它们会被定义为可选类型变量，而不是常量。<br>你可以像其他可选值一样，检查弱引用的值是否存在，你将永远不会访问已销毁的实例的引用。<br>    当 ARC 设置弱引用为nil时，属性观察不会被触发。</p>\n<p>下面的例子跟上面Person和Apartment的例子一致，但是有一个重要的区别。这一次，Apartment的tenant属性被声明为弱引用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> name: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>) &#123; <span class=\"keyword\">self</span>.name = name &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> apartment: <span class=\"type\">Apartment</span>?</div><div class=\"line\">    <span class=\"keyword\">deinit</span> &#123; <span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(name)</span> is being deinitialized\"</span>) &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Apartment</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> unit: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(unit: <span class=\"type\">String</span>) &#123; <span class=\"keyword\">self</span>.unit = unit &#125;</div><div class=\"line\">    <span class=\"keyword\">weak</span> <span class=\"keyword\">var</span> tenant: <span class=\"type\">Person</span>?</div><div class=\"line\">    <span class=\"keyword\">deinit</span> &#123; <span class=\"built_in\">print</span>(<span class=\"string\">\"Apartment <span class=\"subst\">\\(unit)</span> is being deinitialized\"</span>) &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后跟之前一样，建立两个变量（john和unit4A）之间的强引用，并关联两个实例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> john: <span class=\"type\">Person</span>?</div><div class=\"line\"><span class=\"keyword\">var</span> unit4A: <span class=\"type\">Apartment</span>?</div><div class=\"line\"> </div><div class=\"line\">john = <span class=\"type\">Person</span>(name: <span class=\"string\">\"John Appleseed\"</span>)</div><div class=\"line\">unit4A = <span class=\"type\">Apartment</span>(unit: <span class=\"string\">\"4A\"</span>)</div><div class=\"line\"> </div><div class=\"line\">john!.apartment = unit4A</div><div class=\"line\">unit4A!.tenant = john</div></pre></td></tr></table></figure>\n<p>现在，两个关联在一起的实例的引用关系如下图所示：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference01_2x.png\" alt=\"\"><br>Person实例依然保持对Apartment实例的强引用，但是Apartment实例只持有对Person实例的弱引用。这意味着当你断开john变量所保持的强引用时，再也没有指向Person实例的强引用了：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference02_2x.png\" alt=\"\"><br>由于再也没有指向Person实例的强引用，该实例会被销毁：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">john = <span class=\"literal\">nil</span></div><div class=\"line\"><span class=\"comment\">// Prints \"John Appleseed is being deinitialized\"</span></div></pre></td></tr></table></figure>\n<p>唯一剩下的指向Apartment实例的强引用来自于变量unit4A。如果你断开这个强引用，再也没有指向Apartment实例的强引用了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">unit4A = <span class=\"literal\">nil</span></div><div class=\"line\"><span class=\"comment\">// Prints \"Apartment 4A is being deinitialized\"</span></div></pre></td></tr></table></figure>\n<p>由于再也没有指向Apartment实例的强引用，该实例也会被销毁：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference03_2x.png\" alt=\"\"><br>    在使用垃圾收集的系统里，弱指针有时用来实现简单的缓冲机制，因为没有强引用的对象只会在内存压力触发垃圾收集时才被销毁。但是在 ARC 中，一旦值的最后一个强引用被移除，就会被立即销毁，这导致弱引用并不适合上面的用途。</p>\n<h4 id=\"无主引用\"><a href=\"#无主引用\" class=\"headerlink\" title=\"无主引用\"></a>无主引用</h4><p>和弱引用类似，无主引用不会牢牢保持住引用的实例。和弱引用不同的是，无主引用在其他实例有相同或者更长的生命周期时使用。你可以在声明属性或者变量时，在前面加上关键字unowned表示这是一个无主引用。<br>无主引用通常都被期望拥有值。不过 ARC 无法在实例被销毁后将无主引用设为nil，这意味着无主引用明确使用非可选类型<br>    使用无主引用，你必须确保引用始终指向一个未销毁的实例。<br>如果你试图在实例被销毁后，访问该实例的无主引用，会触发运行时错误。</p>\n<p>下面的例子定义了两个类，Customer和CreditCard，模拟了银行客户和客户的信用卡。这两个类中，每一个都将另外一个类的实例作为自身的属性。这种关系可能会造成循环强引用。<br>Customer和CreditCard之间的关系与前面弱引用例子中Apartment和Person的关系略微不同。在这个数据模型中，一个客户可能有或者没有信用卡，但是一张信用卡总是关联着一个客户。为了表示这种关系，Customer类有一个可选类型的card属性，但是CreditCard类有一个非可选类型的customer属性。<br>此外，只能通过将一个number值和customer实例传递给CreditCard构造函数的方式来创建CreditCard实例。这样可以确保当创建CreditCard实例时总是有一个customer实例与之关联。<br>由于信用卡总是关联着一个客户，因此将customer属性定义为无主引用，用以避免循环强引用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> name: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">var</span> card: <span class=\"type\">CreditCard</span>?</div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.name = name</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">deinit</span> &#123; <span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(name)</span> is being deinitialized\"</span>) &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CreditCard</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> number: <span class=\"type\">UInt64</span></div><div class=\"line\">    <span class=\"keyword\">unowned</span> <span class=\"keyword\">let</span> customer: <span class=\"type\">Customer</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(number: <span class=\"type\">UInt64</span>, customer: <span class=\"type\">Customer</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.number = number</div><div class=\"line\">        <span class=\"keyword\">self</span>.customer = customer</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">deinit</span> &#123; <span class=\"built_in\">print</span>(<span class=\"string\">\"Card #<span class=\"subst\">\\(number)</span> is being deinitialized\"</span>) &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下面的代码片段定义了一个叫john的可选类型Customer变量，用来保存某个特定客户的引用。由于是可选类型，所以变量被初始化为nil：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> john: <span class=\"type\">Customer</span>?</div></pre></td></tr></table></figure>\n<p>现在你可以创建Customer类的实例，用它初始化CreditCard实例，并将新创建的CreditCard实例赋值为客户的card属性：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">john = <span class=\"type\">Customer</span>(name: <span class=\"string\">\"John Appleseed\"</span>)</div><div class=\"line\">john!.card = <span class=\"type\">CreditCard</span>(number: <span class=\"number\">1234_5678_9012_3456</span>, customer: john!)</div></pre></td></tr></table></figure>\n<p>在你关联两个实例后，它们的引用关系如下图所示：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference01_2x.png\" alt=\"\"></p>\n<p>Customer实例持有对CreditCard实例的强引用，而CreditCard实例持有对Customer实例的无主引用。<br>由于customer的无主引用，当你断开john变量持有的强引用时，再也没有指向Customer实例的强引用了：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference02_2x.png\" alt=\"\"><br>由于再也没有指向Customer实例的强引用，该实例被销毁了。其后，再也没有指向CreditCard实例的强引用，该实例也随之被销毁了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">john = <span class=\"literal\">nil</span></div><div class=\"line\"><span class=\"comment\">// Prints \"John Appleseed is being deinitialized\"</span></div><div class=\"line\"><span class=\"comment\">// Prints \"Card #1234567890123456 is being deinitialized\"</span></div></pre></td></tr></table></figure>\n<pre><code>上面的例子展示了如何使用安全的无主引用。对于需要禁用运行时的安全检查的情况（例如，出于性能方面的原因），Swift还提供了不安全的无主引用。与所有不安全的操作一样，你需要负责检查代码以确保其安全性。 你可以通过unowned(unsafe)来声明不安全无主引用。如果你试图在实例被销毁后，访问该实例的不安全无主引用，你的程序会尝试访问该实例之前所在的内存地址，这是一个不安全的操作。\n</code></pre><h4 id=\"无主引用以及隐式解析可选属性\"><a href=\"#无主引用以及隐式解析可选属性\" class=\"headerlink\" title=\"无主引用以及隐式解析可选属性\"></a>无主引用以及隐式解析可选属性</h4><p>上面弱引用和无主引用的例子涵盖了两种常用的需要打破循环强引用的场景。</p>\n<p>Person和Apartment的例子展示了两个属性的值都允许为nil，并会潜在的产生循环强引用。这种场景最适合用弱引用来解决。<br>Customer和CreditCard的例子展示了一个属性的值允许为nil，而另一个属性的值不允许为nil，这也可能会产生循环强引用。这种场景最适合通过无主引用来解决。</p>\n<p>然而，存在着第三种场景，在这种场景中，两个属性都必须有值，并且初始化完成后永远不会为nil。在这种场景中，需要一个类使用无主属性，而另外一个类使用隐式解析可选属性。<br>这使两个属性在初始化完成后能被直接访问（不需要可选展开），同时避免了循环引用。这一节将为你展示如何建立这种关系。<br>下面的例子定义了两个类，Country和City，每个类将另外一个类的实例保存为属性。在这个模型中，每个国家必须有首都，每个城市必须属于一个国家。为了实现这种关系，Country类拥有一个capitalCity属性，而City类有一个country属性：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Country</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> name: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">var</span> capitalCity: <span class=\"type\">City</span>!</div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>, capitalName: <span class=\"type\">String</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.name = name</div><div class=\"line\">        <span class=\"keyword\">self</span>.capitalCity = <span class=\"type\">City</span>(name: capitalName, country: <span class=\"keyword\">self</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">City</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> name: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">unowned</span> <span class=\"keyword\">let</span> country: <span class=\"type\">Country</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>, country: <span class=\"type\">Country</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.name = name</div><div class=\"line\">        <span class=\"keyword\">self</span>.country = country</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>为了建立两个类的依赖关系，City的构造函数接受一个Country实例作为参数，并且将实例保存到country属性。</p>\n<p>Country的构造函数调用了City的构造函数。然而，只有Country的实例完全初始化后，Country的构造函数才能把self传给City的构造函数。在两段式构造过程中有具体描述。<br>为了满足这种需求，通过在类型结尾处加上感叹号（City!）的方式，将Country的capitalCity属性声明为隐式解析可选类型的属性。这意味着像其他可选类型一样，capitalCity属性的默认值为nil，但是不需要展开它的值就能访问它。在隐式解析可选类型中有描述。</p>\n<p>由于capitalCity默认值为nil，一旦Country的实例在构造函数中给name属性赋值后，整个初始化过程就完成了。这意味着一旦name属性被赋值后，Country的构造函数就能引用并传递隐式的self。Country的构造函数在赋值capitalCity时，就能将self作为参数传递给City的构造函数。</p>\n<p>以上的意义在于你可以通过一条语句同时创建Country和City的实例，而不产生循环强引用，并且capitalCity的属性能被直接访问，而不需要通过感叹号来展开它的可选值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> country = <span class=\"type\">Country</span>(name: <span class=\"string\">\"Canada\"</span>, capitalName: <span class=\"string\">\"Ottawa\"</span>)</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(country.name)</span>'s capital city is called <span class=\"subst\">\\(country.capitalCity.name)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"Canada's capital city is called Ottawa\"</span></div></pre></td></tr></table></figure>\n<p>在上面的例子中，使用隐式解析可选值意味着满足了类的构造函数的两个构造阶段的要求。capitalCity属性在初始化完成后，能像非可选值一样使用和存取，同时还避免了循环强引用。</p>\n<h3 id=\"闭包的循环强引用\"><a href=\"#闭包的循环强引用\" class=\"headerlink\" title=\"闭包的循环强引用\"></a>闭包的循环强引用</h3><p>前面我们看到了循环强引用是在两个类实例属性互相保持对方的强引用时产生的，还知道了如何用弱引用和无主引用来打破这些循环强引用。</p>\n<p>循环强引用还会发生在当你将一个闭包赋值给类实例的某个属性，并且这个闭包体中又使用了这个类实例时。这个闭包体中可能访问了实例的某个属性，例如self.someProperty，或者闭包中调用了实例的某个方法，例如self.someMethod()。这两种情况都导致了闭包“捕获”self，从而产生了循环强引用。</p>\n<p>循环强引用的产生，是因为闭包和类相似，都是引用类型。当你把一个闭包赋值给某个属性时，你是将这个闭包的引用赋值给了属性。实质上，这跟之前的问题是一样的——两个强引用让彼此一直有效。但是，和两个类实例不同，这次一个是类实例，另一个是闭包。</p>\n<p>Swift 提供了一种优雅的方法来解决这个问题，称之为闭包捕获列表（closure capture list）。同样的，在学习如何用闭包捕获列表打破循环强引用之前，先来了解一下这里的循环强引用是如何产生的，这对我们很有帮助。</p>\n<p>下面的例子为你展示了当一个闭包引用了self后是如何产生一个循环强引用的。例子中定义了一个叫HTMLElement的类，用一种简单的模型表示 HTML 文档中的一个单独的元素：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HTMLElement</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">let</span> name: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">let</span> text: <span class=\"type\">String</span>?</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">lazy</span> <span class=\"keyword\">var</span> asHTML: () -&gt; <span class=\"type\">String</span> = &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> text = <span class=\"keyword\">self</span>.text &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"&lt;<span class=\"subst\">\\(<span class=\"keyword\">self</span>.name)</span>&gt;<span class=\"subst\">\\(text)</span>&lt;/<span class=\"subst\">\\(<span class=\"keyword\">self</span>.name)</span>&gt;\"</span></div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"&lt;<span class=\"subst\">\\(<span class=\"keyword\">self</span>.name)</span> /&gt;\"</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>, text: <span class=\"type\">String</span>? = <span class=\"literal\">nil</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.name = name</div><div class=\"line\">        <span class=\"keyword\">self</span>.text = text</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">deinit</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(name)</span> is being deinitialized\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>HTMLElement类定义了一个name属性来表示这个元素的名称，例如代表头部元素的”h1”，代表段落的“p”，或者代表换行的“br”。HTMLElement还定义了一个可选属性text，用来设置 HTML 元素呈现的文本。</p>\n<p>除了上面的两个属性，HTMLElement还定义了一个lazy属性asHTML。这个属性引用了一个将name和text组合成 HTML 字符串片段的闭包。该属性是Void -&gt; String类型，或者可以理解为“一个没有参数，返回String的函数”。</p>\n<p>默认情况下，闭包赋值给了asHTML属性，这个闭包返回一个代表 HTML 标签的字符串。如果text值存在，该标签就包含可选值text；如果text不存在，该标签就不包含文本。对于段落元素，根据text是“some text”还是nil，闭包会返回”</p><p>some text</p>“或者”<p>“。</p>\n<p>可以像实例方法那样去命名、使用asHTML属性。然而，由于asHTML是闭包而不是实例方法，如果你想改变特定 HTML 元素的处理方式的话，可以用自定义的闭包来取代默认值。</p>\n<p>例如，可以将一个闭包赋值给asHTML属性，这个闭包能在text属性是nil时使用默认文本，这是为了避免返回一个空的 HTML 标签：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> heading = <span class=\"type\">HTMLElement</span>(name: <span class=\"string\">\"h1\"</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> defaultText = <span class=\"string\">\"some default text\"</span></div><div class=\"line\">heading.asHTML = &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"&lt;<span class=\"subst\">\\(heading.name)</span>&gt;<span class=\"subst\">\\(heading.text ?? defaultText)</span>&lt;/<span class=\"subst\">\\(heading.name)</span>&gt;\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">print</span>(heading.asHTML())</div><div class=\"line\"><span class=\"comment\">// Prints \"&lt;h1&gt;some default text&lt;/h1&gt;\"</span></div></pre></td></tr></table></figure>\n<pre><code>asHTML声明为lazy属性，因为只有当元素确实需要被处理为 HTML 输出的字符串时，才需要使用asHTML。也就是说，在默认的闭包中可以使用self，因为只有当初始化完成以及self确实存在后，才能访问lazy属性。\n</code></pre><p>HTMLElement类只提供了一个构造函数，通过name和text（如果有的话）参数来初始化一个新元素。该类也定义了一个析构函数，当HTMLElement实例被销毁时，打印一条消息。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> paragraph: <span class=\"type\">HTMLElement</span>? = <span class=\"type\">HTMLElement</span>(name: <span class=\"string\">\"p\"</span>, text: <span class=\"string\">\"hello, world\"</span>)</div><div class=\"line\"><span class=\"built_in\">print</span>(paragraph!.asHTML())</div><div class=\"line\"><span class=\"comment\">// Prints \"&lt;p&gt;hello, world&lt;/p&gt;\"</span></div></pre></td></tr></table></figure>\n<p>不幸的是，上面写的HTMLElement类产生了类实例和作为asHTML默认值的闭包之间的循环强引用。循环强引用如下图所示：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle01_2x.png\" alt=\"\"><br>实例的asHTML属性持有闭包的强引用。但是，闭包在其闭包体内使用了self（引用了self.name和self.text），因此闭包捕获了self，这意味着闭包又反过来持有了HTMLElement实例的强引用。这样两个对象就产生了循环强引用。<br>    虽然闭包多次使用了self，它只捕获HTMLElement实例的一个强引用。</p>\n<p>如果设置paragraph变量为nil，打破它持有的HTMLElement实例的强引用，HTMLElement实例和它的闭包都不会被销毁，HTMLElement的析构函数中的消息并没有被打印。也是因为循环强引用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">paragraph = <span class=\"literal\">nil</span></div></pre></td></tr></table></figure>\n<h3 id=\"解决闭包的循环强引用问题\"><a href=\"#解决闭包的循环强引用问题\" class=\"headerlink\" title=\"解决闭包的循环强引用问题\"></a>解决闭包的循环强引用问题</h3><p>在定义闭包时同时定义捕获列表作为闭包的一部分，通过这种方式可以解决闭包和类实例之间的循环强引用。捕获列表定义了闭包体内捕获一个或者多个引用类型的规则。跟解决两个类实例间的循环强引用一样，声明每个捕获的引用为弱引用或无主引用，而不是强引用。应当根据代码关系来决定使用弱引用还是无主引用。<br>    Swift 有如下要求：只要在闭包内使用self的成员，就要用self.someProperty或者self.someMethod()（而不只是someProperty或someMethod()）。这提醒你可能会一不小心就捕获了self。</p>\n<h4 id=\"定义捕获列表\"><a href=\"#定义捕获列表\" class=\"headerlink\" title=\"定义捕获列表\"></a>定义捕获列表</h4><p>捕获列表中的每一项都由一对元素组成，一个元素是weak或unowned关键字，另一个元素是类实例的引用（例如self）或初始化过的变量（如delegate = self.delegate!）。这些项在方括号中用逗号分开。<br>如果闭包有参数列表和返回类型，把捕获列表放在它们前面：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">lazy</span> <span class=\"keyword\">var</span> someClosure: (<span class=\"type\">Int</span>, <span class=\"type\">String</span>) -&gt; <span class=\"type\">String</span> = &#123;</div><div class=\"line\">    [<span class=\"keyword\">unowned</span> <span class=\"keyword\">self</span>, <span class=\"keyword\">weak</span> delegate = <span class=\"keyword\">self</span>.delegate!] (index: <span class=\"type\">Int</span>, stringToProcess: <span class=\"type\">String</span>) -&gt; <span class=\"type\">String</span> <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"comment\">// closure body goes here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果闭包没有指明参数列表或者返回类型，即它们会通过上下文推断，那么可以把捕获列表和关键字in放在闭包最开始的地方：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">lazy</span> <span class=\"keyword\">var</span> someClosure: () -&gt; <span class=\"type\">String</span> = &#123;</div><div class=\"line\">    [<span class=\"keyword\">unowned</span> <span class=\"keyword\">self</span>, <span class=\"keyword\">weak</span> delegate = <span class=\"keyword\">self</span>.delegate!] <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"comment\">// closure body goes here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"弱引用和无主引用\"><a href=\"#弱引用和无主引用\" class=\"headerlink\" title=\"弱引用和无主引用\"></a>弱引用和无主引用</h4><p>在闭包和捕获的实例总是互相引用并且总是同时销毁时，将闭包内的捕获定义为 <code>无主引用</code>。<br>相反的，在被捕获的引用可能会变为nil时，将闭包内的捕获定义为 <code>弱引用</code> 。弱引用总是可选类型，并且当引用的实例被销毁后，弱引用的值会自动置为nil。这使我们可以在闭包体内检查它们是否存在。<br>    如果被捕获的引用不会变为nil，应该用无主引用，而不是弱引用。</p>\n<p>前面的HTMLElement例子中，无主引用是正确的解决循环强引用的方法。这样编写HTMLElement类来避免循环强引用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HTMLElement</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">let</span> name: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">let</span> text: <span class=\"type\">String</span>?</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">lazy</span> <span class=\"keyword\">var</span> asHTML: () -&gt; <span class=\"type\">String</span> = &#123;</div><div class=\"line\">        [<span class=\"keyword\">unowned</span> <span class=\"keyword\">self</span>] <span class=\"keyword\">in</span></div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> text = <span class=\"keyword\">self</span>.text &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"&lt;<span class=\"subst\">\\(<span class=\"keyword\">self</span>.name)</span>&gt;<span class=\"subst\">\\(text)</span>&lt;/<span class=\"subst\">\\(<span class=\"keyword\">self</span>.name)</span>&gt;\"</span></div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"&lt;<span class=\"subst\">\\(<span class=\"keyword\">self</span>.name)</span> /&gt;\"</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>, text: <span class=\"type\">String</span>? = <span class=\"literal\">nil</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.name = name</div><div class=\"line\">        <span class=\"keyword\">self</span>.text = text</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">deinit</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(name)</span> is being deinitialized\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的HTMLElement实现和之前的实现一致，除了在asHTML闭包中多了一个捕获列表。这里，捕获列表是[unowned self]，表示“将self捕获为无主引用而不是强引用”。<br>和之前一样，我们可以创建并打印HTMLElement实例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> paragraph: <span class=\"type\">HTMLElement</span>? = <span class=\"type\">HTMLElement</span>(name: <span class=\"string\">\"p\"</span>, text: <span class=\"string\">\"hello, world\"</span>)</div><div class=\"line\"><span class=\"built_in\">print</span>(paragraph!.asHTML())</div><div class=\"line\"><span class=\"comment\">// Prints \"&lt;p&gt;hello, world&lt;/p&gt;\"</span></div></pre></td></tr></table></figure>\n<p>使用捕获列表后引用关系如下图所示：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle02_2x.png\" alt=\"\"><br>此时，闭包以无主引用的形式捕获self，并不会持有HTMLElement实例的强引用。如果将paragraph赋值为nil，HTMLElement实例将会被销毁，并能看到它的析构函数打印出的消息：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">paragraph = <span class=\"literal\">nil</span></div><div class=\"line\"><span class=\"comment\">// Prints \"p is being deinitialized\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html/\" target=\"_blank\" rel=\"external\"> AutomaticReferenceCounting </a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>"},{"layout":"post","title":"Swift Basic Operators","date":"2016-11-03T16:00:00.000Z","author":"liangtong","catalog":true,"_content":"\n\n\n​\tSwift支持绝大部分的标准C语言操作符，并且增强了几个操作符的功能以消除常犯的编码错误。例如：赋值运算符(`=`)不再拥有返回值来阻止被错误的使用在比较运算符(`==`)的场合；算术运算符(`+, -, *, /, % 等`)会对数据进行检查，阻止数据溢出。Swift也提供了两个C语言中没有的范围运算符(`a..<b`和` a...b`)，用来快捷表达一个区域范围值。\n\n\n\n<!-- more -->\n\n### 赋值运算符\n​\t用来初始化或者更新左值\n```Swift\nvar a = 5 \nlet (x, y) = (1, 2) // x is equal to 1, and y is equal to 2\nif x = y {\n    // 存在语法错误，因为赋值运算符没有返回值\n}\n```\n\n### 算术运算符\n​\tSwift支持四个标准的算术运算符`+, -, *, /`；与其他语言不同的是，这些运算符默认情况下不允许被重写。另外`+`运算符也支持字符串连接。\n\n##### 取模运算符\n​\t与其他语言一样，注意一点：`a % b`的符号与`a`相同\n\n##### 单目运算符\n​\t包括单目`+`运算符和单目`-`运算符\n\n##### 复合赋值运算符\n​\t和C相同，Swift允许使用一个运算符和赋值运算符(`=`)来快捷组合，比如`+=, -=`。复合运算符也没有返回值。\n\n##### 比较运算符\n​\tSwift支持所有标准C语言的比较运算符：`a == b, a != b, a > b, a < b, a >= b, a <= b`。另外，Swift还提供了’=== 和 !==’运算符来判断两个对象是否引用了同一个对象。比较运算符会返回布尔Bool类型值。\n也可以对元组类型使用比较运算符，元组的比较从左向右，每次比较一个元素。\n\n> 注：Bool类型不能比较，Swift标准库中比较运算符元组为少于7个元素的元组，如果元素个数不符合条件，则需要自己实现比较运算符。\n\n##### 三目运算符\n​\t同其它语言一样，格式为`question ? answer1 : answer2`。\n\n##### Nil-Coalescing运算符\n​\t格式为：(`a ?? b`)，解包’可选类型’a如果a包含一个值，则返回改值；否则返回默认值b。该运算符可以更加形象地用三目运算符表示：`a != nil ? a! : b`。且该运算符也有短路运算的特点。使用时需要注意有两点：\n\n >* a必须是可选类型 \n >* b的类型必须和a解包后的类型匹配\n\n### 范围运算符\n​\t封闭范围运算符 `(a…b)` 包含边界`a`和`b`，其中必须满足`a <= b`；半封闭范围运算符`(a..<b)`包含`a`，但不包含`b`。其中必须满足`a < b`。\n\n### 逻辑运算符\n​\t三个C标准的逻辑运算符`!a , a && b , a || b`，从左至右，有短路运算的特点。为了方便阅读，多逻辑运算符组合出现的时候建议多加括号`(`，`)`。\n\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html/\">BasicOperators</a> \n\n>\n>\n>\n>\n>\n>\n>​Copyright (c) liangtong. All rights reserved.\n>\n\n\n","source":"_posts/iOS_Swift_language_note_Basic-Operators.md","raw":"---\nlayout:     post\ntitle:      Swift Basic Operators\ndate:       2016-11-04\nauthor:     liangtong\ncatalog: true\ncategories: iOS\ntags: Swift \n\n---\n\n\n\n​\tSwift支持绝大部分的标准C语言操作符，并且增强了几个操作符的功能以消除常犯的编码错误。例如：赋值运算符(`=`)不再拥有返回值来阻止被错误的使用在比较运算符(`==`)的场合；算术运算符(`+, -, *, /, % 等`)会对数据进行检查，阻止数据溢出。Swift也提供了两个C语言中没有的范围运算符(`a..<b`和` a...b`)，用来快捷表达一个区域范围值。\n\n\n\n<!-- more -->\n\n### 赋值运算符\n​\t用来初始化或者更新左值\n```Swift\nvar a = 5 \nlet (x, y) = (1, 2) // x is equal to 1, and y is equal to 2\nif x = y {\n    // 存在语法错误，因为赋值运算符没有返回值\n}\n```\n\n### 算术运算符\n​\tSwift支持四个标准的算术运算符`+, -, *, /`；与其他语言不同的是，这些运算符默认情况下不允许被重写。另外`+`运算符也支持字符串连接。\n\n##### 取模运算符\n​\t与其他语言一样，注意一点：`a % b`的符号与`a`相同\n\n##### 单目运算符\n​\t包括单目`+`运算符和单目`-`运算符\n\n##### 复合赋值运算符\n​\t和C相同，Swift允许使用一个运算符和赋值运算符(`=`)来快捷组合，比如`+=, -=`。复合运算符也没有返回值。\n\n##### 比较运算符\n​\tSwift支持所有标准C语言的比较运算符：`a == b, a != b, a > b, a < b, a >= b, a <= b`。另外，Swift还提供了’=== 和 !==’运算符来判断两个对象是否引用了同一个对象。比较运算符会返回布尔Bool类型值。\n也可以对元组类型使用比较运算符，元组的比较从左向右，每次比较一个元素。\n\n> 注：Bool类型不能比较，Swift标准库中比较运算符元组为少于7个元素的元组，如果元素个数不符合条件，则需要自己实现比较运算符。\n\n##### 三目运算符\n​\t同其它语言一样，格式为`question ? answer1 : answer2`。\n\n##### Nil-Coalescing运算符\n​\t格式为：(`a ?? b`)，解包’可选类型’a如果a包含一个值，则返回改值；否则返回默认值b。该运算符可以更加形象地用三目运算符表示：`a != nil ? a! : b`。且该运算符也有短路运算的特点。使用时需要注意有两点：\n\n >* a必须是可选类型 \n >* b的类型必须和a解包后的类型匹配\n\n### 范围运算符\n​\t封闭范围运算符 `(a…b)` 包含边界`a`和`b`，其中必须满足`a <= b`；半封闭范围运算符`(a..<b)`包含`a`，但不包含`b`。其中必须满足`a < b`。\n\n### 逻辑运算符\n​\t三个C标准的逻辑运算符`!a , a && b , a || b`，从左至右，有短路运算的特点。为了方便阅读，多逻辑运算符组合出现的时候建议多加括号`(`，`)`。\n\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html/\">BasicOperators</a> \n\n>\n>\n>\n>\n>\n>\n>​Copyright (c) liangtong. All rights reserved.\n>\n\n\n","slug":"iOS_Swift_language_note_Basic-Operators","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4u00027oko80x2bdqub","content":"<p>​    Swift支持绝大部分的标准C语言操作符，并且增强了几个操作符的功能以消除常犯的编码错误。例如：赋值运算符(<code>=</code>)不再拥有返回值来阻止被错误的使用在比较运算符(<code>==</code>)的场合；算术运算符(<code>+, -, *, /, % 等</code>)会对数据进行检查，阻止数据溢出。Swift也提供了两个C语言中没有的范围运算符(<code>a..&lt;b</code>和<code>a...b</code>)，用来快捷表达一个区域范围值。</p>\n<a id=\"more\"></a>\n<h3 id=\"赋值运算符\"><a href=\"#赋值运算符\" class=\"headerlink\" title=\"赋值运算符\"></a>赋值运算符</h3><p>​    用来初始化或者更新左值<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">5</span> </div><div class=\"line\"><span class=\"keyword\">let</span> (x, y) = (<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// x is equal to 1, and y is equal to 2</span></div><div class=\"line\"><span class=\"keyword\">if</span> x = y &#123;</div><div class=\"line\">    <span class=\"comment\">// 存在语法错误，因为赋值运算符没有返回值</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"算术运算符\"><a href=\"#算术运算符\" class=\"headerlink\" title=\"算术运算符\"></a>算术运算符</h3><p>​    Swift支持四个标准的算术运算符<code>+, -, *, /</code>；与其他语言不同的是，这些运算符默认情况下不允许被重写。另外<code>+</code>运算符也支持字符串连接。</p>\n<h5 id=\"取模运算符\"><a href=\"#取模运算符\" class=\"headerlink\" title=\"取模运算符\"></a>取模运算符</h5><p>​    与其他语言一样，注意一点：<code>a % b</code>的符号与<code>a</code>相同</p>\n<h5 id=\"单目运算符\"><a href=\"#单目运算符\" class=\"headerlink\" title=\"单目运算符\"></a>单目运算符</h5><p>​    包括单目<code>+</code>运算符和单目<code>-</code>运算符</p>\n<h5 id=\"复合赋值运算符\"><a href=\"#复合赋值运算符\" class=\"headerlink\" title=\"复合赋值运算符\"></a>复合赋值运算符</h5><p>​    和C相同，Swift允许使用一个运算符和赋值运算符(<code>=</code>)来快捷组合，比如<code>+=, -=</code>。复合运算符也没有返回值。</p>\n<h5 id=\"比较运算符\"><a href=\"#比较运算符\" class=\"headerlink\" title=\"比较运算符\"></a>比较运算符</h5><p>​    Swift支持所有标准C语言的比较运算符：<code>a == b, a != b, a &gt; b, a &lt; b, a &gt;= b, a &lt;= b</code>。另外，Swift还提供了’=== 和 !==’运算符来判断两个对象是否引用了同一个对象。比较运算符会返回布尔Bool类型值。<br>也可以对元组类型使用比较运算符，元组的比较从左向右，每次比较一个元素。</p>\n<blockquote>\n<p>注：Bool类型不能比较，Swift标准库中比较运算符元组为少于7个元素的元组，如果元素个数不符合条件，则需要自己实现比较运算符。</p>\n</blockquote>\n<h5 id=\"三目运算符\"><a href=\"#三目运算符\" class=\"headerlink\" title=\"三目运算符\"></a>三目运算符</h5><p>​    同其它语言一样，格式为<code>question ? answer1 : answer2</code>。</p>\n<h5 id=\"Nil-Coalescing运算符\"><a href=\"#Nil-Coalescing运算符\" class=\"headerlink\" title=\"Nil-Coalescing运算符\"></a>Nil-Coalescing运算符</h5><p>​    格式为：(<code>a ?? b</code>)，解包’可选类型’a如果a包含一个值，则返回改值；否则返回默认值b。该运算符可以更加形象地用三目运算符表示：<code>a != nil ? a! : b</code>。且该运算符也有短路运算的特点。使用时需要注意有两点：</p>\n<blockquote>\n<ul>\n<li>a必须是可选类型 </li>\n<li>b的类型必须和a解包后的类型匹配</li>\n</ul>\n</blockquote>\n<h3 id=\"范围运算符\"><a href=\"#范围运算符\" class=\"headerlink\" title=\"范围运算符\"></a>范围运算符</h3><p>​    封闭范围运算符 <code>(a…b)</code> 包含边界<code>a</code>和<code>b</code>，其中必须满足<code>a &lt;= b</code>；半封闭范围运算符<code>(a..&lt;b)</code>包含<code>a</code>，但不包含<code>b</code>。其中必须满足<code>a &lt; b</code>。</p>\n<h3 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h3><p>​    三个C标准的逻辑运算符<code>!a , a &amp;&amp; b , a || b</code>，从左至右，有短路运算的特点。为了方便阅读，多逻辑运算符组合出现的时候建议多加括号<code>(</code>，<code>)</code>。</p>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html/\" target=\"_blank\" rel=\"external\">BasicOperators</a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;</p>\n<blockquote>\n<p>​Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>​    Swift支持绝大部分的标准C语言操作符，并且增强了几个操作符的功能以消除常犯的编码错误。例如：赋值运算符(<code>=</code>)不再拥有返回值来阻止被错误的使用在比较运算符(<code>==</code>)的场合；算术运算符(<code>+, -, *, /, % 等</code>)会对数据进行检查，阻止数据溢出。Swift也提供了两个C语言中没有的范围运算符(<code>a..&lt;b</code>和<code>a...b</code>)，用来快捷表达一个区域范围值。</p>","more":"<h3 id=\"赋值运算符\"><a href=\"#赋值运算符\" class=\"headerlink\" title=\"赋值运算符\"></a>赋值运算符</h3><p>​    用来初始化或者更新左值<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">5</span> </div><div class=\"line\"><span class=\"keyword\">let</span> (x, y) = (<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// x is equal to 1, and y is equal to 2</span></div><div class=\"line\"><span class=\"keyword\">if</span> x = y &#123;</div><div class=\"line\">    <span class=\"comment\">// 存在语法错误，因为赋值运算符没有返回值</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"算术运算符\"><a href=\"#算术运算符\" class=\"headerlink\" title=\"算术运算符\"></a>算术运算符</h3><p>​    Swift支持四个标准的算术运算符<code>+, -, *, /</code>；与其他语言不同的是，这些运算符默认情况下不允许被重写。另外<code>+</code>运算符也支持字符串连接。</p>\n<h5 id=\"取模运算符\"><a href=\"#取模运算符\" class=\"headerlink\" title=\"取模运算符\"></a>取模运算符</h5><p>​    与其他语言一样，注意一点：<code>a % b</code>的符号与<code>a</code>相同</p>\n<h5 id=\"单目运算符\"><a href=\"#单目运算符\" class=\"headerlink\" title=\"单目运算符\"></a>单目运算符</h5><p>​    包括单目<code>+</code>运算符和单目<code>-</code>运算符</p>\n<h5 id=\"复合赋值运算符\"><a href=\"#复合赋值运算符\" class=\"headerlink\" title=\"复合赋值运算符\"></a>复合赋值运算符</h5><p>​    和C相同，Swift允许使用一个运算符和赋值运算符(<code>=</code>)来快捷组合，比如<code>+=, -=</code>。复合运算符也没有返回值。</p>\n<h5 id=\"比较运算符\"><a href=\"#比较运算符\" class=\"headerlink\" title=\"比较运算符\"></a>比较运算符</h5><p>​    Swift支持所有标准C语言的比较运算符：<code>a == b, a != b, a &gt; b, a &lt; b, a &gt;= b, a &lt;= b</code>。另外，Swift还提供了’=== 和 !==’运算符来判断两个对象是否引用了同一个对象。比较运算符会返回布尔Bool类型值。<br>也可以对元组类型使用比较运算符，元组的比较从左向右，每次比较一个元素。</p>\n<blockquote>\n<p>注：Bool类型不能比较，Swift标准库中比较运算符元组为少于7个元素的元组，如果元素个数不符合条件，则需要自己实现比较运算符。</p>\n</blockquote>\n<h5 id=\"三目运算符\"><a href=\"#三目运算符\" class=\"headerlink\" title=\"三目运算符\"></a>三目运算符</h5><p>​    同其它语言一样，格式为<code>question ? answer1 : answer2</code>。</p>\n<h5 id=\"Nil-Coalescing运算符\"><a href=\"#Nil-Coalescing运算符\" class=\"headerlink\" title=\"Nil-Coalescing运算符\"></a>Nil-Coalescing运算符</h5><p>​    格式为：(<code>a ?? b</code>)，解包’可选类型’a如果a包含一个值，则返回改值；否则返回默认值b。该运算符可以更加形象地用三目运算符表示：<code>a != nil ? a! : b</code>。且该运算符也有短路运算的特点。使用时需要注意有两点：</p>\n<blockquote>\n<ul>\n<li>a必须是可选类型 </li>\n<li>b的类型必须和a解包后的类型匹配</li>\n</ul>\n</blockquote>\n<h3 id=\"范围运算符\"><a href=\"#范围运算符\" class=\"headerlink\" title=\"范围运算符\"></a>范围运算符</h3><p>​    封闭范围运算符 <code>(a…b)</code> 包含边界<code>a</code>和<code>b</code>，其中必须满足<code>a &lt;= b</code>；半封闭范围运算符<code>(a..&lt;b)</code>包含<code>a</code>，但不包含<code>b</code>。其中必须满足<code>a &lt; b</code>。</p>\n<h3 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h3><p>​    三个C标准的逻辑运算符<code>!a , a &amp;&amp; b , a || b</code>，从左至右，有短路运算的特点。为了方便阅读，多逻辑运算符组合出现的时候建议多加括号<code>(</code>，<code>)</code>。</p>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html/\" target=\"_blank\" rel=\"external\">BasicOperators</a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;</p>\n<blockquote>\n<p>​Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>"},{"layout":"post","title":"Swift Classes and Structures","date":"2016-11-23T16:20:11.000Z","author":"liangtong","catalog":true,"_content":"\n\n\n​\t类和结构体是人们构建代码所用的一种通用且灵活的构造体。你可以使用几乎完全相同的语法规则给类和结构体定义属性、添加方法。与其他语言不同的是，Swift不需要你为自定义类和结构体去独立创建接口和实现文件。在Swwift中，你只需要使用一个单独的文件来定义类和结构体，系统会自动生成面向其他代码的外部接口。\n\t通常类的实例被称为对象，Swift中类和结构体的关系比在其他语言中要密切\n\n\n\n### 类和结构体的对比\n类和结构体在Swift中有很多共同点，例如：\n\n * 定义属性用于存储值\n * 定义方法用于提供功能\n *  定义下标操作涌来通过下标语法来访问实例存储的值\n *  定义构造函数用于初始化值\n *  通过扩展来增加其功能的实现\n *  实现协议以提供某种标准功能\n\n<!-- more -->\n\n与结构体相比，类还有如下额外功能：\n\n *  继承允许一个类继承另一个类的特征\n *  类型转换允许在运行时检查和解释一个类实例等类型\n *  析构器允许一个类释放其所被分配到资源\n *  引用计数允许一个类被多次引用。\n\n\t注意：结构体通常是通过值传递，而不使用引用计数\n\n#### 定义语法\n类和结构体有相似的定义语法，通过关键字`class`定义类，`struct`定义结构体，在一对大括号中定义它们的具体内容：\n\n```Swift\nclass SomeClass {\n    // class definition goes here\n}\nstruct SomeStructure {\n    // structure definition goes here\n}\n```\n\n当你定义了类或者结构体的时候，确切的讲是定义了一个新类型。使用UpperCamelCase这种方式来命名（如SomeClass和SomeStructure等），相反的，请使用lowerCamelCase这种方式为属性和方法命名（如framerate和incrementCount），以便和类型名区分。\n\n以下是定义结构体和类的示例：\n\n```Swift\nstruct Resolution {\n    var width = 0\n    var height = 0\n}\nclass VideoMode {\n    var resolution = Resolution()\n    var interlaced = false\n    var frameRate = 0.0\n    var name: String?\n}\n```\n\n#### 类和结构体实例\n生成类和结构体实例等语法很相似，例如：\n\n\n```Swift\nlet someResolution = Resolution()\nlet someVideoMode = VideoMode()\n```\n\n结构体和类都使用构造器语法来生成新的实例。构造器语法的最简单形式是在结构体或者类的类型名称后跟随一对空括号，如Resolution()或VideoMode()。通过这种方式所创建的类或者结构体实例，其属性均会被初始化为默认值。\n\n#### 属性访问\n通过使用点语法，你可以访问实例的属性。其语法规则是，实例名后面紧跟属性名，两者通过点号(.)连接，不能有空格：\n\n\n```Swift\nprint(\"The width of someResolution is \\(someResolution.width)\")\n// Prints \"The width of someResolution is 0\"\n\nprint(\"The width of someVideoMode is \\(someVideoMode.resolution.width)\")\n// Prints \"The width of someVideoMode is 0\"\n```\n\n也可以使用点语法为变量属性赋值，例如：\n\n```Swift\nsomeVideoMode.resolution.width = 1280\nprint(\"The width of someVideoMode is now \\(someVideoMode.resolution.width)\")\n// Prints \"The width of someVideoMode is now 1280\"\n```\n\n\t与 Objective-C 语言不同的是，Swift 允许直接设置结构体属性的子属性。上面的最后一个例子，就是直接设置了someVideoMode中resolution属性的width这个子属性，以上操作并不需要重新为整个resolution属性设置新值。\n\n#### 结构体成员逐一构造函数\n所有结构体都有一个自动生成的成员逐一构造器，用于初始化新结构体实例中成员的属性。新实例中各个属性的初始值可以通过属性的名称传递到成员逐一构造器之中：\n\n```Swift\nlet vga = Resolution(width: 640, height: 480)\n```\n\n\t与结构体不同的是，类实例没有默认的成员逐一构造器\n\n### 结构体和枚举是值类型\n值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝。\n在Swift中，所有的基本类型：整数（Integer）、浮点数（floating-point）、布尔值（Boolean）、字符串（string)、数组（array）和字典（dictionary），都是值类型，并且在底层都是以结构体的形式所实现。\n在 Swift 中，所有的结构体和枚举类型都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型属性，在代码中传递的时候都会被复制。例如：\n\n```Swift\nlet hd = Resolution(width: 1920, height: 1080)\nvar cinema = hd\n```\n\n声明一个名为hd的常量，初始值宽高分别为1920和1080，然后声明一个名为cinema的变量，并将hd赋值给它。由于Resolution是结构体类型，所以cinema的值其实是hd的一个拷贝副本，而不是hd本身。尽管它们两个的值相同，但是是两个不同的实例。例如以下修改后，hd的值不变：\n\n```Swift\ncinema.width = 2048\n\nprint(\"cinema is now \\(cinema.width) pixels wide\")\n// Prints \"cinema is now 2048 pixels wide\"\n\nprint(\"hd is still \\(hd.width) pixels wide\")\n// Prints \"hd is still 1920 pixels wide\"\n```\n\n枚举也遵循相同的行为标准\n\n```Swift\nenum CompassPoint {\n    case north, south, east, west\n}\nvar currentDirection = CompassPoint.west\nlet rememberedDirection = currentDirection\ncurrentDirection = .east\nif rememberedDirection == .west {\n    print(\"The remembered direction is still .west\")\n}\n// Prints \"The remembered direction is still .west\"\n```\n\n### 类是引用类型\n与值类型不同，引用类型在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，引用的是已存在的实例本身而不是其拷贝。\n例如，实例化一个类VideoMode的对象，并为其属性赋值：\n\n```Swift\nlet tenEighty = VideoMode()\ntenEighty.resolution = hd\ntenEighty.interlaced = true\ntenEighty.name = \"1080i\"\ntenEighty.frameRate = 25.0\n```\n\n然后将其赋值给一个新变量，同时对新变量进行修改\n\n```Swift\nlet alsoTenEighty = tenEighty\nalsoTenEighty.frameRate = 30.0\n```\n\n因为类是引用类型，所以tenEight和alsoTenEight实际上引用的是相同的VideoMode实例。换句话说，它们是同一个实例的两种叫法。\n\n```Swift\nprint(\"The frameRate property of tenEighty is now \\(tenEighty.frameRate)\")\n// Prints \"The frameRate property of tenEighty is now 30.0\"\n```\n\n\t需要注意的是tenEighty和alsoTenEighty被声明为常量而不是变量。然而你依然可以改变tenEighty.frameRate和alsoTenEighty.frameRate，因为tenEighty和alsoTenEighty这两个常量的值并未改变。它们并不“存储”这个VideoMode实例，而仅仅是对VideoMode实例的引用。所以，改变的是被引用的VideoMode的frameRate属性，而不是引用VideoMode的常量的值。\n\n#### 恒等运算符\n因为类是引用类型，有可能有多个常量和变量在幕后同时引用同一个类实例。（对于结构体和枚举来说，这并不成立。因为它们作为值类型，在被赋予到常量、变量或者传递到函数时，其值总是会被拷贝。）\n如果能够判定两个常量或者变量是否引用同一个类实例将会很有帮助。为了达到这个目的，Swift 内建了两个恒等运算符：\n\n *  === 等价于\n *  !== 不等价于\n\n运用这两个运算符可以检查两个变量或者常量是否引用同一个实例：\n\n```Swift\nif tenEighty === alsoTenEighty {\n    print(\"tenEighty and alsoTenEighty refer to the same VideoMode instance.\")\n}\n// Prints \"tenEighty and alsoTenEighty refer to the same VideoMode instance.\"\n```\n\n\t注意`=== 等价于`和`== 等于`的区别：一个是判断引用相同的类实例，一个是判断值相等\n\n#### 指针\n在C、C++、ObjC中，使用指针类引用内存中的地址，Swift中某个引用类型的常量或者变量和其他语言中的指针类似，但不是直接指向内存地址，也不要求你使用星号（*）来表明你在创建一个引用。Swift 中的这些引用与其它的常量或变量的定义方式相同。\n\n### 类和结构体的选择\n你可以使用类或结构体来定义你自己的数据类型。但是结构体总是通过值传递，类是引用传递。这意味着两者适用不同的任务。当你在考虑一个工程项目的数据结构和功能的时候，你需要决定每个数据结构是定义成类还是结构体。\n\n按照通用的准则，如果符合以下一条或者多条时，可以使用结构体：\n\n *  该数据结构的主要目的是用来封装少量相关简单数据值。\n *  有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。\n *  该数据结构中储存的值类型属性，也应该被拷贝，而不是被引用。\n *  该数据结构不需要去继承另一个既有类型的属性或者行为。\n\n### 字符串、数组、和字典类型的赋值与复制行为\nSwift 中，许多基本类型，诸如String，Array和Dictionary类型均以结构体的形式实现。这意味着被赋值给新的常量或变量，或者被传入函数或方法中时，它们的值会被拷贝。\n\nObjective-C 中NSString，NSArray和NSDictionary类型均以类的形式实现，而并非结构体。它们在被赋值或者被传入函数或方法时，不会发生值拷贝，而是传递现有实例的引用。\n\n以上是对字符串、数组、字典的“拷贝”行为的描述。在你的代码中，拷贝行为看起来似乎总会发生。\n然而，Swift 在幕后只在绝对必要时才执行实际的拷贝。Swift 管理所有的值拷贝以确保性能最优化，所以你没必要去回避赋值来保证性能最优化。\t\n\n\n\n\n\n\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html/\">ClassesAndStructures</a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","source":"_posts/iOS_Swift_language_note_Classes and Structures.md","raw":"---\nlayout:     post\ntitle:      Swift Classes and Structures\ndate:       2016-11-24 00:20:11\nauthor:     liangtong\ncatalog: true\ncategories: iOS\ntags: Swift \n\n---\n\n\n\n​\t类和结构体是人们构建代码所用的一种通用且灵活的构造体。你可以使用几乎完全相同的语法规则给类和结构体定义属性、添加方法。与其他语言不同的是，Swift不需要你为自定义类和结构体去独立创建接口和实现文件。在Swwift中，你只需要使用一个单独的文件来定义类和结构体，系统会自动生成面向其他代码的外部接口。\n\t通常类的实例被称为对象，Swift中类和结构体的关系比在其他语言中要密切\n\n\n\n### 类和结构体的对比\n类和结构体在Swift中有很多共同点，例如：\n\n * 定义属性用于存储值\n * 定义方法用于提供功能\n *  定义下标操作涌来通过下标语法来访问实例存储的值\n *  定义构造函数用于初始化值\n *  通过扩展来增加其功能的实现\n *  实现协议以提供某种标准功能\n\n<!-- more -->\n\n与结构体相比，类还有如下额外功能：\n\n *  继承允许一个类继承另一个类的特征\n *  类型转换允许在运行时检查和解释一个类实例等类型\n *  析构器允许一个类释放其所被分配到资源\n *  引用计数允许一个类被多次引用。\n\n\t注意：结构体通常是通过值传递，而不使用引用计数\n\n#### 定义语法\n类和结构体有相似的定义语法，通过关键字`class`定义类，`struct`定义结构体，在一对大括号中定义它们的具体内容：\n\n```Swift\nclass SomeClass {\n    // class definition goes here\n}\nstruct SomeStructure {\n    // structure definition goes here\n}\n```\n\n当你定义了类或者结构体的时候，确切的讲是定义了一个新类型。使用UpperCamelCase这种方式来命名（如SomeClass和SomeStructure等），相反的，请使用lowerCamelCase这种方式为属性和方法命名（如framerate和incrementCount），以便和类型名区分。\n\n以下是定义结构体和类的示例：\n\n```Swift\nstruct Resolution {\n    var width = 0\n    var height = 0\n}\nclass VideoMode {\n    var resolution = Resolution()\n    var interlaced = false\n    var frameRate = 0.0\n    var name: String?\n}\n```\n\n#### 类和结构体实例\n生成类和结构体实例等语法很相似，例如：\n\n\n```Swift\nlet someResolution = Resolution()\nlet someVideoMode = VideoMode()\n```\n\n结构体和类都使用构造器语法来生成新的实例。构造器语法的最简单形式是在结构体或者类的类型名称后跟随一对空括号，如Resolution()或VideoMode()。通过这种方式所创建的类或者结构体实例，其属性均会被初始化为默认值。\n\n#### 属性访问\n通过使用点语法，你可以访问实例的属性。其语法规则是，实例名后面紧跟属性名，两者通过点号(.)连接，不能有空格：\n\n\n```Swift\nprint(\"The width of someResolution is \\(someResolution.width)\")\n// Prints \"The width of someResolution is 0\"\n\nprint(\"The width of someVideoMode is \\(someVideoMode.resolution.width)\")\n// Prints \"The width of someVideoMode is 0\"\n```\n\n也可以使用点语法为变量属性赋值，例如：\n\n```Swift\nsomeVideoMode.resolution.width = 1280\nprint(\"The width of someVideoMode is now \\(someVideoMode.resolution.width)\")\n// Prints \"The width of someVideoMode is now 1280\"\n```\n\n\t与 Objective-C 语言不同的是，Swift 允许直接设置结构体属性的子属性。上面的最后一个例子，就是直接设置了someVideoMode中resolution属性的width这个子属性，以上操作并不需要重新为整个resolution属性设置新值。\n\n#### 结构体成员逐一构造函数\n所有结构体都有一个自动生成的成员逐一构造器，用于初始化新结构体实例中成员的属性。新实例中各个属性的初始值可以通过属性的名称传递到成员逐一构造器之中：\n\n```Swift\nlet vga = Resolution(width: 640, height: 480)\n```\n\n\t与结构体不同的是，类实例没有默认的成员逐一构造器\n\n### 结构体和枚举是值类型\n值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝。\n在Swift中，所有的基本类型：整数（Integer）、浮点数（floating-point）、布尔值（Boolean）、字符串（string)、数组（array）和字典（dictionary），都是值类型，并且在底层都是以结构体的形式所实现。\n在 Swift 中，所有的结构体和枚举类型都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型属性，在代码中传递的时候都会被复制。例如：\n\n```Swift\nlet hd = Resolution(width: 1920, height: 1080)\nvar cinema = hd\n```\n\n声明一个名为hd的常量，初始值宽高分别为1920和1080，然后声明一个名为cinema的变量，并将hd赋值给它。由于Resolution是结构体类型，所以cinema的值其实是hd的一个拷贝副本，而不是hd本身。尽管它们两个的值相同，但是是两个不同的实例。例如以下修改后，hd的值不变：\n\n```Swift\ncinema.width = 2048\n\nprint(\"cinema is now \\(cinema.width) pixels wide\")\n// Prints \"cinema is now 2048 pixels wide\"\n\nprint(\"hd is still \\(hd.width) pixels wide\")\n// Prints \"hd is still 1920 pixels wide\"\n```\n\n枚举也遵循相同的行为标准\n\n```Swift\nenum CompassPoint {\n    case north, south, east, west\n}\nvar currentDirection = CompassPoint.west\nlet rememberedDirection = currentDirection\ncurrentDirection = .east\nif rememberedDirection == .west {\n    print(\"The remembered direction is still .west\")\n}\n// Prints \"The remembered direction is still .west\"\n```\n\n### 类是引用类型\n与值类型不同，引用类型在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，引用的是已存在的实例本身而不是其拷贝。\n例如，实例化一个类VideoMode的对象，并为其属性赋值：\n\n```Swift\nlet tenEighty = VideoMode()\ntenEighty.resolution = hd\ntenEighty.interlaced = true\ntenEighty.name = \"1080i\"\ntenEighty.frameRate = 25.0\n```\n\n然后将其赋值给一个新变量，同时对新变量进行修改\n\n```Swift\nlet alsoTenEighty = tenEighty\nalsoTenEighty.frameRate = 30.0\n```\n\n因为类是引用类型，所以tenEight和alsoTenEight实际上引用的是相同的VideoMode实例。换句话说，它们是同一个实例的两种叫法。\n\n```Swift\nprint(\"The frameRate property of tenEighty is now \\(tenEighty.frameRate)\")\n// Prints \"The frameRate property of tenEighty is now 30.0\"\n```\n\n\t需要注意的是tenEighty和alsoTenEighty被声明为常量而不是变量。然而你依然可以改变tenEighty.frameRate和alsoTenEighty.frameRate，因为tenEighty和alsoTenEighty这两个常量的值并未改变。它们并不“存储”这个VideoMode实例，而仅仅是对VideoMode实例的引用。所以，改变的是被引用的VideoMode的frameRate属性，而不是引用VideoMode的常量的值。\n\n#### 恒等运算符\n因为类是引用类型，有可能有多个常量和变量在幕后同时引用同一个类实例。（对于结构体和枚举来说，这并不成立。因为它们作为值类型，在被赋予到常量、变量或者传递到函数时，其值总是会被拷贝。）\n如果能够判定两个常量或者变量是否引用同一个类实例将会很有帮助。为了达到这个目的，Swift 内建了两个恒等运算符：\n\n *  === 等价于\n *  !== 不等价于\n\n运用这两个运算符可以检查两个变量或者常量是否引用同一个实例：\n\n```Swift\nif tenEighty === alsoTenEighty {\n    print(\"tenEighty and alsoTenEighty refer to the same VideoMode instance.\")\n}\n// Prints \"tenEighty and alsoTenEighty refer to the same VideoMode instance.\"\n```\n\n\t注意`=== 等价于`和`== 等于`的区别：一个是判断引用相同的类实例，一个是判断值相等\n\n#### 指针\n在C、C++、ObjC中，使用指针类引用内存中的地址，Swift中某个引用类型的常量或者变量和其他语言中的指针类似，但不是直接指向内存地址，也不要求你使用星号（*）来表明你在创建一个引用。Swift 中的这些引用与其它的常量或变量的定义方式相同。\n\n### 类和结构体的选择\n你可以使用类或结构体来定义你自己的数据类型。但是结构体总是通过值传递，类是引用传递。这意味着两者适用不同的任务。当你在考虑一个工程项目的数据结构和功能的时候，你需要决定每个数据结构是定义成类还是结构体。\n\n按照通用的准则，如果符合以下一条或者多条时，可以使用结构体：\n\n *  该数据结构的主要目的是用来封装少量相关简单数据值。\n *  有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。\n *  该数据结构中储存的值类型属性，也应该被拷贝，而不是被引用。\n *  该数据结构不需要去继承另一个既有类型的属性或者行为。\n\n### 字符串、数组、和字典类型的赋值与复制行为\nSwift 中，许多基本类型，诸如String，Array和Dictionary类型均以结构体的形式实现。这意味着被赋值给新的常量或变量，或者被传入函数或方法中时，它们的值会被拷贝。\n\nObjective-C 中NSString，NSArray和NSDictionary类型均以类的形式实现，而并非结构体。它们在被赋值或者被传入函数或方法时，不会发生值拷贝，而是传递现有实例的引用。\n\n以上是对字符串、数组、字典的“拷贝”行为的描述。在你的代码中，拷贝行为看起来似乎总会发生。\n然而，Swift 在幕后只在绝对必要时才执行实际的拷贝。Swift 管理所有的值拷贝以确保性能最优化，所以你没必要去回避赋值来保证性能最优化。\t\n\n\n\n\n\n\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html/\">ClassesAndStructures</a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","slug":"iOS_Swift_language_note_Classes and Structures","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4u2002boko853zqhjqk","content":"<p>​    类和结构体是人们构建代码所用的一种通用且灵活的构造体。你可以使用几乎完全相同的语法规则给类和结构体定义属性、添加方法。与其他语言不同的是，Swift不需要你为自定义类和结构体去独立创建接口和实现文件。在Swwift中，你只需要使用一个单独的文件来定义类和结构体，系统会自动生成面向其他代码的外部接口。<br>    通常类的实例被称为对象，Swift中类和结构体的关系比在其他语言中要密切</p>\n<h3 id=\"类和结构体的对比\"><a href=\"#类和结构体的对比\" class=\"headerlink\" title=\"类和结构体的对比\"></a>类和结构体的对比</h3><p>类和结构体在Swift中有很多共同点，例如：</p>\n<ul>\n<li>定义属性用于存储值</li>\n<li>定义方法用于提供功能</li>\n<li>定义下标操作涌来通过下标语法来访问实例存储的值</li>\n<li>定义构造函数用于初始化值</li>\n<li>通过扩展来增加其功能的实现</li>\n<li>实现协议以提供某种标准功能</li>\n</ul>\n<a id=\"more\"></a>\n<p>与结构体相比，类还有如下额外功能：</p>\n<ul>\n<li>继承允许一个类继承另一个类的特征</li>\n<li>类型转换允许在运行时检查和解释一个类实例等类型</li>\n<li>析构器允许一个类释放其所被分配到资源</li>\n<li><p>引用计数允许一个类被多次引用。</p>\n<p>注意：结构体通常是通过值传递，而不使用引用计数</p>\n</li>\n</ul>\n<h4 id=\"定义语法\"><a href=\"#定义语法\" class=\"headerlink\" title=\"定义语法\"></a>定义语法</h4><p>类和结构体有相似的定义语法，通过关键字<code>class</code>定义类，<code>struct</code>定义结构体，在一对大括号中定义它们的具体内容：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClass</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// class definition goes here</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SomeStructure</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// structure definition goes here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当你定义了类或者结构体的时候，确切的讲是定义了一个新类型。使用UpperCamelCase这种方式来命名（如SomeClass和SomeStructure等），相反的，请使用lowerCamelCase这种方式为属性和方法命名（如framerate和incrementCount），以便和类型名区分。</p>\n<p>以下是定义结构体和类的示例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Resolution</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> width = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">var</span> height = <span class=\"number\">0</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VideoMode</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> resolution = <span class=\"type\">Resolution</span>()</div><div class=\"line\">    <span class=\"keyword\">var</span> interlaced = <span class=\"literal\">false</span></div><div class=\"line\">    <span class=\"keyword\">var</span> frameRate = <span class=\"number\">0.0</span></div><div class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span>?</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"类和结构体实例\"><a href=\"#类和结构体实例\" class=\"headerlink\" title=\"类和结构体实例\"></a>类和结构体实例</h4><p>生成类和结构体实例等语法很相似，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> someResolution = <span class=\"type\">Resolution</span>()</div><div class=\"line\"><span class=\"keyword\">let</span> someVideoMode = <span class=\"type\">VideoMode</span>()</div></pre></td></tr></table></figure>\n<p>结构体和类都使用构造器语法来生成新的实例。构造器语法的最简单形式是在结构体或者类的类型名称后跟随一对空括号，如Resolution()或VideoMode()。通过这种方式所创建的类或者结构体实例，其属性均会被初始化为默认值。</p>\n<h4 id=\"属性访问\"><a href=\"#属性访问\" class=\"headerlink\" title=\"属性访问\"></a>属性访问</h4><p>通过使用点语法，你可以访问实例的属性。其语法规则是，实例名后面紧跟属性名，两者通过点号(.)连接，不能有空格：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The width of someResolution is <span class=\"subst\">\\(someResolution.width)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"The width of someResolution is 0\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The width of someVideoMode is <span class=\"subst\">\\(someVideoMode.resolution.width)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"The width of someVideoMode is 0\"</span></div></pre></td></tr></table></figure>\n<p>也可以使用点语法为变量属性赋值，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">someVideoMode.resolution.width = <span class=\"number\">1280</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The width of someVideoMode is now <span class=\"subst\">\\(someVideoMode.resolution.width)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"The width of someVideoMode is now 1280\"</span></div></pre></td></tr></table></figure>\n<pre><code>与 Objective-C 语言不同的是，Swift 允许直接设置结构体属性的子属性。上面的最后一个例子，就是直接设置了someVideoMode中resolution属性的width这个子属性，以上操作并不需要重新为整个resolution属性设置新值。\n</code></pre><h4 id=\"结构体成员逐一构造函数\"><a href=\"#结构体成员逐一构造函数\" class=\"headerlink\" title=\"结构体成员逐一构造函数\"></a>结构体成员逐一构造函数</h4><p>所有结构体都有一个自动生成的成员逐一构造器，用于初始化新结构体实例中成员的属性。新实例中各个属性的初始值可以通过属性的名称传递到成员逐一构造器之中：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> vga = <span class=\"type\">Resolution</span>(width: <span class=\"number\">640</span>, height: <span class=\"number\">480</span>)</div></pre></td></tr></table></figure>\n<pre><code>与结构体不同的是，类实例没有默认的成员逐一构造器\n</code></pre><h3 id=\"结构体和枚举是值类型\"><a href=\"#结构体和枚举是值类型\" class=\"headerlink\" title=\"结构体和枚举是值类型\"></a>结构体和枚举是值类型</h3><p>值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝。<br>在Swift中，所有的基本类型：整数（Integer）、浮点数（floating-point）、布尔值（Boolean）、字符串（string)、数组（array）和字典（dictionary），都是值类型，并且在底层都是以结构体的形式所实现。<br>在 Swift 中，所有的结构体和枚举类型都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型属性，在代码中传递的时候都会被复制。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> hd = <span class=\"type\">Resolution</span>(width: <span class=\"number\">1920</span>, height: <span class=\"number\">1080</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> cinema = hd</div></pre></td></tr></table></figure>\n<p>声明一个名为hd的常量，初始值宽高分别为1920和1080，然后声明一个名为cinema的变量，并将hd赋值给它。由于Resolution是结构体类型，所以cinema的值其实是hd的一个拷贝副本，而不是hd本身。尽管它们两个的值相同，但是是两个不同的实例。例如以下修改后，hd的值不变：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">cinema.width = <span class=\"number\">2048</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"cinema is now <span class=\"subst\">\\(cinema.width)</span> pixels wide\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"cinema is now 2048 pixels wide\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"hd is still <span class=\"subst\">\\(hd.width)</span> pixels wide\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"hd is still 1920 pixels wide\"</span></div></pre></td></tr></table></figure>\n<p>枚举也遵循相同的行为标准</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">CompassPoint</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> north, south, east, west</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> currentDirection = <span class=\"type\">CompassPoint</span>.west</div><div class=\"line\"><span class=\"keyword\">let</span> rememberedDirection = currentDirection</div><div class=\"line\">currentDirection = .east</div><div class=\"line\"><span class=\"keyword\">if</span> rememberedDirection == .west &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The remembered direction is still .west\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"The remembered direction is still .west\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"类是引用类型\"><a href=\"#类是引用类型\" class=\"headerlink\" title=\"类是引用类型\"></a>类是引用类型</h3><p>与值类型不同，引用类型在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，引用的是已存在的实例本身而不是其拷贝。<br>例如，实例化一个类VideoMode的对象，并为其属性赋值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> tenEighty = <span class=\"type\">VideoMode</span>()</div><div class=\"line\">tenEighty.resolution = hd</div><div class=\"line\">tenEighty.interlaced = <span class=\"literal\">true</span></div><div class=\"line\">tenEighty.name = <span class=\"string\">\"1080i\"</span></div><div class=\"line\">tenEighty.frameRate = <span class=\"number\">25.0</span></div></pre></td></tr></table></figure>\n<p>然后将其赋值给一个新变量，同时对新变量进行修改</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> alsoTenEighty = tenEighty</div><div class=\"line\">alsoTenEighty.frameRate = <span class=\"number\">30.0</span></div></pre></td></tr></table></figure>\n<p>因为类是引用类型，所以tenEight和alsoTenEight实际上引用的是相同的VideoMode实例。换句话说，它们是同一个实例的两种叫法。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The frameRate property of tenEighty is now <span class=\"subst\">\\(tenEighty.frameRate)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"The frameRate property of tenEighty is now 30.0\"</span></div></pre></td></tr></table></figure>\n<pre><code>需要注意的是tenEighty和alsoTenEighty被声明为常量而不是变量。然而你依然可以改变tenEighty.frameRate和alsoTenEighty.frameRate，因为tenEighty和alsoTenEighty这两个常量的值并未改变。它们并不“存储”这个VideoMode实例，而仅仅是对VideoMode实例的引用。所以，改变的是被引用的VideoMode的frameRate属性，而不是引用VideoMode的常量的值。\n</code></pre><h4 id=\"恒等运算符\"><a href=\"#恒等运算符\" class=\"headerlink\" title=\"恒等运算符\"></a>恒等运算符</h4><p>因为类是引用类型，有可能有多个常量和变量在幕后同时引用同一个类实例。（对于结构体和枚举来说，这并不成立。因为它们作为值类型，在被赋予到常量、变量或者传递到函数时，其值总是会被拷贝。）<br>如果能够判定两个常量或者变量是否引用同一个类实例将会很有帮助。为了达到这个目的，Swift 内建了两个恒等运算符：</p>\n<ul>\n<li>=== 等价于</li>\n<li>!== 不等价于</li>\n</ul>\n<p>运用这两个运算符可以检查两个变量或者常量是否引用同一个实例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> tenEighty === alsoTenEighty &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"tenEighty and alsoTenEighty refer to the same VideoMode instance.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"tenEighty and alsoTenEighty refer to the same VideoMode instance.\"</span></div></pre></td></tr></table></figure>\n<pre><code>注意`=== 等价于`和`== 等于`的区别：一个是判断引用相同的类实例，一个是判断值相等\n</code></pre><h4 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h4><p>在C、C++、ObjC中，使用指针类引用内存中的地址，Swift中某个引用类型的常量或者变量和其他语言中的指针类似，但不是直接指向内存地址，也不要求你使用星号（*）来表明你在创建一个引用。Swift 中的这些引用与其它的常量或变量的定义方式相同。</p>\n<h3 id=\"类和结构体的选择\"><a href=\"#类和结构体的选择\" class=\"headerlink\" title=\"类和结构体的选择\"></a>类和结构体的选择</h3><p>你可以使用类或结构体来定义你自己的数据类型。但是结构体总是通过值传递，类是引用传递。这意味着两者适用不同的任务。当你在考虑一个工程项目的数据结构和功能的时候，你需要决定每个数据结构是定义成类还是结构体。</p>\n<p>按照通用的准则，如果符合以下一条或者多条时，可以使用结构体：</p>\n<ul>\n<li>该数据结构的主要目的是用来封装少量相关简单数据值。</li>\n<li>有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。</li>\n<li>该数据结构中储存的值类型属性，也应该被拷贝，而不是被引用。</li>\n<li>该数据结构不需要去继承另一个既有类型的属性或者行为。</li>\n</ul>\n<h3 id=\"字符串、数组、和字典类型的赋值与复制行为\"><a href=\"#字符串、数组、和字典类型的赋值与复制行为\" class=\"headerlink\" title=\"字符串、数组、和字典类型的赋值与复制行为\"></a>字符串、数组、和字典类型的赋值与复制行为</h3><p>Swift 中，许多基本类型，诸如String，Array和Dictionary类型均以结构体的形式实现。这意味着被赋值给新的常量或变量，或者被传入函数或方法中时，它们的值会被拷贝。</p>\n<p>Objective-C 中NSString，NSArray和NSDictionary类型均以类的形式实现，而并非结构体。它们在被赋值或者被传入函数或方法时，不会发生值拷贝，而是传递现有实例的引用。</p>\n<p>以上是对字符串、数组、字典的“拷贝”行为的描述。在你的代码中，拷贝行为看起来似乎总会发生。<br>然而，Swift 在幕后只在绝对必要时才执行实际的拷贝。Swift 管理所有的值拷贝以确保性能最优化，所以你没必要去回避赋值来保证性能最优化。    </p>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html/\" target=\"_blank\" rel=\"external\">ClassesAndStructures</a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>​    类和结构体是人们构建代码所用的一种通用且灵活的构造体。你可以使用几乎完全相同的语法规则给类和结构体定义属性、添加方法。与其他语言不同的是，Swift不需要你为自定义类和结构体去独立创建接口和实现文件。在Swwift中，你只需要使用一个单独的文件来定义类和结构体，系统会自动生成面向其他代码的外部接口。<br>    通常类的实例被称为对象，Swift中类和结构体的关系比在其他语言中要密切</p>\n<h3 id=\"类和结构体的对比\"><a href=\"#类和结构体的对比\" class=\"headerlink\" title=\"类和结构体的对比\"></a>类和结构体的对比</h3><p>类和结构体在Swift中有很多共同点，例如：</p>\n<ul>\n<li>定义属性用于存储值</li>\n<li>定义方法用于提供功能</li>\n<li>定义下标操作涌来通过下标语法来访问实例存储的值</li>\n<li>定义构造函数用于初始化值</li>\n<li>通过扩展来增加其功能的实现</li>\n<li>实现协议以提供某种标准功能</li>\n</ul>","more":"<p>与结构体相比，类还有如下额外功能：</p>\n<ul>\n<li>继承允许一个类继承另一个类的特征</li>\n<li>类型转换允许在运行时检查和解释一个类实例等类型</li>\n<li>析构器允许一个类释放其所被分配到资源</li>\n<li><p>引用计数允许一个类被多次引用。</p>\n<p>注意：结构体通常是通过值传递，而不使用引用计数</p>\n</li>\n</ul>\n<h4 id=\"定义语法\"><a href=\"#定义语法\" class=\"headerlink\" title=\"定义语法\"></a>定义语法</h4><p>类和结构体有相似的定义语法，通过关键字<code>class</code>定义类，<code>struct</code>定义结构体，在一对大括号中定义它们的具体内容：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClass</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// class definition goes here</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SomeStructure</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// structure definition goes here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当你定义了类或者结构体的时候，确切的讲是定义了一个新类型。使用UpperCamelCase这种方式来命名（如SomeClass和SomeStructure等），相反的，请使用lowerCamelCase这种方式为属性和方法命名（如framerate和incrementCount），以便和类型名区分。</p>\n<p>以下是定义结构体和类的示例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Resolution</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> width = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">var</span> height = <span class=\"number\">0</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VideoMode</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> resolution = <span class=\"type\">Resolution</span>()</div><div class=\"line\">    <span class=\"keyword\">var</span> interlaced = <span class=\"literal\">false</span></div><div class=\"line\">    <span class=\"keyword\">var</span> frameRate = <span class=\"number\">0.0</span></div><div class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span>?</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"类和结构体实例\"><a href=\"#类和结构体实例\" class=\"headerlink\" title=\"类和结构体实例\"></a>类和结构体实例</h4><p>生成类和结构体实例等语法很相似，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> someResolution = <span class=\"type\">Resolution</span>()</div><div class=\"line\"><span class=\"keyword\">let</span> someVideoMode = <span class=\"type\">VideoMode</span>()</div></pre></td></tr></table></figure>\n<p>结构体和类都使用构造器语法来生成新的实例。构造器语法的最简单形式是在结构体或者类的类型名称后跟随一对空括号，如Resolution()或VideoMode()。通过这种方式所创建的类或者结构体实例，其属性均会被初始化为默认值。</p>\n<h4 id=\"属性访问\"><a href=\"#属性访问\" class=\"headerlink\" title=\"属性访问\"></a>属性访问</h4><p>通过使用点语法，你可以访问实例的属性。其语法规则是，实例名后面紧跟属性名，两者通过点号(.)连接，不能有空格：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The width of someResolution is <span class=\"subst\">\\(someResolution.width)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"The width of someResolution is 0\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The width of someVideoMode is <span class=\"subst\">\\(someVideoMode.resolution.width)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"The width of someVideoMode is 0\"</span></div></pre></td></tr></table></figure>\n<p>也可以使用点语法为变量属性赋值，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">someVideoMode.resolution.width = <span class=\"number\">1280</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The width of someVideoMode is now <span class=\"subst\">\\(someVideoMode.resolution.width)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"The width of someVideoMode is now 1280\"</span></div></pre></td></tr></table></figure>\n<pre><code>与 Objective-C 语言不同的是，Swift 允许直接设置结构体属性的子属性。上面的最后一个例子，就是直接设置了someVideoMode中resolution属性的width这个子属性，以上操作并不需要重新为整个resolution属性设置新值。\n</code></pre><h4 id=\"结构体成员逐一构造函数\"><a href=\"#结构体成员逐一构造函数\" class=\"headerlink\" title=\"结构体成员逐一构造函数\"></a>结构体成员逐一构造函数</h4><p>所有结构体都有一个自动生成的成员逐一构造器，用于初始化新结构体实例中成员的属性。新实例中各个属性的初始值可以通过属性的名称传递到成员逐一构造器之中：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> vga = <span class=\"type\">Resolution</span>(width: <span class=\"number\">640</span>, height: <span class=\"number\">480</span>)</div></pre></td></tr></table></figure>\n<pre><code>与结构体不同的是，类实例没有默认的成员逐一构造器\n</code></pre><h3 id=\"结构体和枚举是值类型\"><a href=\"#结构体和枚举是值类型\" class=\"headerlink\" title=\"结构体和枚举是值类型\"></a>结构体和枚举是值类型</h3><p>值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝。<br>在Swift中，所有的基本类型：整数（Integer）、浮点数（floating-point）、布尔值（Boolean）、字符串（string)、数组（array）和字典（dictionary），都是值类型，并且在底层都是以结构体的形式所实现。<br>在 Swift 中，所有的结构体和枚举类型都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型属性，在代码中传递的时候都会被复制。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> hd = <span class=\"type\">Resolution</span>(width: <span class=\"number\">1920</span>, height: <span class=\"number\">1080</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> cinema = hd</div></pre></td></tr></table></figure>\n<p>声明一个名为hd的常量，初始值宽高分别为1920和1080，然后声明一个名为cinema的变量，并将hd赋值给它。由于Resolution是结构体类型，所以cinema的值其实是hd的一个拷贝副本，而不是hd本身。尽管它们两个的值相同，但是是两个不同的实例。例如以下修改后，hd的值不变：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">cinema.width = <span class=\"number\">2048</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"cinema is now <span class=\"subst\">\\(cinema.width)</span> pixels wide\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"cinema is now 2048 pixels wide\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"hd is still <span class=\"subst\">\\(hd.width)</span> pixels wide\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"hd is still 1920 pixels wide\"</span></div></pre></td></tr></table></figure>\n<p>枚举也遵循相同的行为标准</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">CompassPoint</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> north, south, east, west</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> currentDirection = <span class=\"type\">CompassPoint</span>.west</div><div class=\"line\"><span class=\"keyword\">let</span> rememberedDirection = currentDirection</div><div class=\"line\">currentDirection = .east</div><div class=\"line\"><span class=\"keyword\">if</span> rememberedDirection == .west &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The remembered direction is still .west\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"The remembered direction is still .west\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"类是引用类型\"><a href=\"#类是引用类型\" class=\"headerlink\" title=\"类是引用类型\"></a>类是引用类型</h3><p>与值类型不同，引用类型在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，引用的是已存在的实例本身而不是其拷贝。<br>例如，实例化一个类VideoMode的对象，并为其属性赋值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> tenEighty = <span class=\"type\">VideoMode</span>()</div><div class=\"line\">tenEighty.resolution = hd</div><div class=\"line\">tenEighty.interlaced = <span class=\"literal\">true</span></div><div class=\"line\">tenEighty.name = <span class=\"string\">\"1080i\"</span></div><div class=\"line\">tenEighty.frameRate = <span class=\"number\">25.0</span></div></pre></td></tr></table></figure>\n<p>然后将其赋值给一个新变量，同时对新变量进行修改</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> alsoTenEighty = tenEighty</div><div class=\"line\">alsoTenEighty.frameRate = <span class=\"number\">30.0</span></div></pre></td></tr></table></figure>\n<p>因为类是引用类型，所以tenEight和alsoTenEight实际上引用的是相同的VideoMode实例。换句话说，它们是同一个实例的两种叫法。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The frameRate property of tenEighty is now <span class=\"subst\">\\(tenEighty.frameRate)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"The frameRate property of tenEighty is now 30.0\"</span></div></pre></td></tr></table></figure>\n<pre><code>需要注意的是tenEighty和alsoTenEighty被声明为常量而不是变量。然而你依然可以改变tenEighty.frameRate和alsoTenEighty.frameRate，因为tenEighty和alsoTenEighty这两个常量的值并未改变。它们并不“存储”这个VideoMode实例，而仅仅是对VideoMode实例的引用。所以，改变的是被引用的VideoMode的frameRate属性，而不是引用VideoMode的常量的值。\n</code></pre><h4 id=\"恒等运算符\"><a href=\"#恒等运算符\" class=\"headerlink\" title=\"恒等运算符\"></a>恒等运算符</h4><p>因为类是引用类型，有可能有多个常量和变量在幕后同时引用同一个类实例。（对于结构体和枚举来说，这并不成立。因为它们作为值类型，在被赋予到常量、变量或者传递到函数时，其值总是会被拷贝。）<br>如果能够判定两个常量或者变量是否引用同一个类实例将会很有帮助。为了达到这个目的，Swift 内建了两个恒等运算符：</p>\n<ul>\n<li>=== 等价于</li>\n<li>!== 不等价于</li>\n</ul>\n<p>运用这两个运算符可以检查两个变量或者常量是否引用同一个实例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> tenEighty === alsoTenEighty &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"tenEighty and alsoTenEighty refer to the same VideoMode instance.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"tenEighty and alsoTenEighty refer to the same VideoMode instance.\"</span></div></pre></td></tr></table></figure>\n<pre><code>注意`=== 等价于`和`== 等于`的区别：一个是判断引用相同的类实例，一个是判断值相等\n</code></pre><h4 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h4><p>在C、C++、ObjC中，使用指针类引用内存中的地址，Swift中某个引用类型的常量或者变量和其他语言中的指针类似，但不是直接指向内存地址，也不要求你使用星号（*）来表明你在创建一个引用。Swift 中的这些引用与其它的常量或变量的定义方式相同。</p>\n<h3 id=\"类和结构体的选择\"><a href=\"#类和结构体的选择\" class=\"headerlink\" title=\"类和结构体的选择\"></a>类和结构体的选择</h3><p>你可以使用类或结构体来定义你自己的数据类型。但是结构体总是通过值传递，类是引用传递。这意味着两者适用不同的任务。当你在考虑一个工程项目的数据结构和功能的时候，你需要决定每个数据结构是定义成类还是结构体。</p>\n<p>按照通用的准则，如果符合以下一条或者多条时，可以使用结构体：</p>\n<ul>\n<li>该数据结构的主要目的是用来封装少量相关简单数据值。</li>\n<li>有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。</li>\n<li>该数据结构中储存的值类型属性，也应该被拷贝，而不是被引用。</li>\n<li>该数据结构不需要去继承另一个既有类型的属性或者行为。</li>\n</ul>\n<h3 id=\"字符串、数组、和字典类型的赋值与复制行为\"><a href=\"#字符串、数组、和字典类型的赋值与复制行为\" class=\"headerlink\" title=\"字符串、数组、和字典类型的赋值与复制行为\"></a>字符串、数组、和字典类型的赋值与复制行为</h3><p>Swift 中，许多基本类型，诸如String，Array和Dictionary类型均以结构体的形式实现。这意味着被赋值给新的常量或变量，或者被传入函数或方法中时，它们的值会被拷贝。</p>\n<p>Objective-C 中NSString，NSArray和NSDictionary类型均以类的形式实现，而并非结构体。它们在被赋值或者被传入函数或方法时，不会发生值拷贝，而是传递现有实例的引用。</p>\n<p>以上是对字符串、数组、字典的“拷贝”行为的描述。在你的代码中，拷贝行为看起来似乎总会发生。<br>然而，Swift 在幕后只在绝对必要时才执行实际的拷贝。Swift 管理所有的值拷贝以确保性能最优化，所以你没必要去回避赋值来保证性能最优化。    </p>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html/\" target=\"_blank\" rel=\"external\">ClassesAndStructures</a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>"},{"layout":"post","title":"Swift Closures","date":"2016-11-21T16:20:11.000Z","author":"liangtong","catalog":true,"_content":"\n\n\n​\t闭包是一种可以在代码中传递和使用的自包含代码块。Swift中的闭包盒C／ObjC中的闭包与其它语言中的lambdas表达式类似。闭包可用捕获其被定义的上下文中的变量或常量。Swift会为你处理所有的通过捕获的内存管理。函数章节介绍的全局／嵌套函数，是闭包的特殊形式，闭包采取以下三种形式之一\n\n > * 全局函数是一个有名字且不捕获任何值的闭包\n > * 嵌套函数是一个有名字且可用捕获其封闭函数作用域内值的闭包\n > * 闭包表达式是一个利用轻量级语法所写的可用捕获所在上下文中值（变量／常量）的没有名字的闭包\n\nSwift中的闭包表达式拥有清晰、简洁的风格，在以下常见的场景中实现闭包优化：\n\n > * 根据上下文怼参数和返回值进行类型推断\n > * 单表达式闭包可用省略return关键字\n > * 参数名称可用缩写\n > * Trailing闭包语法\n\n\n\n<!-- more -->\n\n### 闭包表达式\n嵌套函数是一种在较复杂函数中方便进行命名和定义自包含代码模块的方式，但是有时候编写一个不需要名字和参数的简洁版本更有用，尤其是在将函数作为参数传递给另一个函数的时候。\n闭包表达式是一种利用简洁语法构建内联闭包的方式。闭包表达式提供了一些语法优化，使得撰写闭包变得简单明了。下面闭包表达式的例子通过使用几次迭代展示了 sort 函数定义和语法优化的方式。 每一次迭代都用更简洁的方式描述了相同的功能。\n\n#### 排序方法\nSwift标准库提供的一个排序方法`sorted(by:)`会根据你提供的排序闭包对已知类型的数组的值进行排序，排序完成后会返回一个同源数组大小相同的排序后的数组。例如一个原始数组如下：\n\n```Swift\nlet names = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]\n```\n\n排序方法`sorted(by:)`接受一个包含两个数组内值相同类型参数并返回一个Bool值来表明顺序的闭包，闭包回返回true如果要求第一个值在排序的结果中靠前，否则返回false。例子中闭包表达式类型为：\n\n```Swift\n(String, String) -> Bool\n```\n\n可以通过普通函数，作为参数传递，例如：\n\n```Swift\nfunc backward(_ s1: String, _ s2: String) -> Bool {\n    return s1 > s2\n}\nvar reversedNames = names.sorted(by: backward)\n// reversedNames is equal to [\"Ewa\", \"Daniella\", \"Chris\", \"Barry\", \"Alex\"]\n```\n\n#### 闭包表达式语法\n闭包表达式一般语法如下：\n\n```Swift\n{ (parameters) -> return type in\n    statements\n}\n```\n\n闭包表达式的参数可以是`in-out`类型，但是不能有默认值，也可以是可变参数，也支持元组类型参数或者返回值，例如上述操作可以简化为：\n\n```Swift\nreversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in\n    return s1 > s2\n})\n```\n\n#### 根据上下文推断类型\n因为排序闭包是作为参数传递的，Swift可以推断出闭包的参数类型和返回值类型。因为所有的类型都可以被推断，所以这里具体类型没有必要提供。返回值和参数周围的括号也可以被省略，例如：\n\n```Swift\nreversedNames = names.sorted(by: { s1, s2 in return s1 > s2 } )\n```\n\n实际上，在内连闭包表达式构造的闭包作为参数传递给函数时，都可以推断出参数和返回值类型，这意味着你几乎不需要写完整的闭包格式。然而，你仍然可以使用明确的类型来消除阅读的歧义，并且这是被建议使用的方式。\n\n#### 单行闭包表达式可以省略return\n单行表达式闭包可以通过隐藏 return 关键字来隐式返回单行表达式的结果，如上版本的例子可以改写为：\n\n```Swift\nreversed = sort(names, { s1, s2 in s1 > s2 } ) \n```\n\n#### 参数名缩写\nSwift自动提供了参数名称缩写功能，可以直接使用`$0, $1, $2,`等来引用闭包中的参数。数量和类型可以被推断，当时用参数名称缩写的时候，参数列表定义部分可以省略，in关键字也可以省略。此事闭包表达式完全由闭包函数体构成：\n\n```Swift\nreversed = sort(names, { $0 > $1 } ) \n```\n\n#### 运算符方法\n有一种更简洁的方法来写上述例子中的闭包表达式。Swift中的String类型定义了操作符`>`的实现。因此可以简单的传递一个符号。例如：\n\n```Swift\nreversed = sort(names, { $0 > $1 } ) \n```\n\n### Trailing闭包\n当闭包作为一个拥有很多参数函数的最后一个参数时，可以使用Trailing闭包来增强函数的可读性。Trailing闭包是一个书写在函数括号之外的闭包表达式（尽管闭包仍然是函数的参数）。当使用Trailing闭包语法时，不写闭包对应的函数参数标签。例如：\n\n```Swift\nfunc someFunctionThatTakesAClosure(closure: () -> Void) {\n    // function body goes here\n}\n \n// Here's how you call this function without using a trailing closure:\n \nsomeFunctionThatTakesAClosure(closure: {\n    // closure's body goes here\n})\n \n// Here's how you call this function with a trailing closure instead:\n \nsomeFunctionThatTakesAClosure() {\n    // trailing closure's body goes here\n}\n```\n\n上述排序例子可以简写为：\n\n```Swift\nreversedNames = names.sorted() { $0 > $1 }\n```\n\n除了闭包外无其他参数，小括号也可以省略，例如：\n\n```Swift\nreversedNames = names.sorted { $0 > $1 }\n```\n\n当闭包非常长的时候，Trailing 闭包就变得非常有用。例如Swift的Array类型有一个map方法`map(_:)`，其接收一个闭包表达式作为唯一的参数，对于数组中的每一个元素会调用该闭包一次，并返回该元素映射的值，具体映射方式和返回值类型由闭包来指定，当提供给数组该闭包函数后，map方法将返回一个新的包含了与原数组一一对应映射关系的数组。例如以下例子讲述如何使用该闭包：\n\n```Swift\nlet digitNames = [\n    0: \"Zero\", 1: \"One\", 2: \"Two\",   3: \"Three\", 4: \"Four\",\n    5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"\n]\nlet numbers = [16, 58, 510]\n\nlet strings = numbers.map {\n    (number) -> String in\n    var number = number\n    var output = \"\"\n    repeat {\n        output = digitNames[number % 10]! + output\n        number /= 10\n    } while number > 0\n    return output\n}\n// strings is inferred to be of type [String]\n// its value is [\"OneSix\", \"FiveEight\", \"FiveOneZero\"]\n```\n\n### 捕获值\n闭包可以捕获其定义的上下文中的常量或变量，即使定义这些变量或者常量的作用域已经不存在，闭包仍然可以在闭包体内引用(和修改)这些值。在Swift中，最简单的闭包形式是嵌套函数，也就是定义在函数体内的函数。嵌套函数可以捕获外部函数的参数以及所有定义在外部函数体内的变量和常量。\n下边是一个嵌套函数的例子：\n\n```Swift\nfunc makeIncrementer(forIncrement amount: Int) -> () -> Int {\n    var runningTotal = 0\n    func incrementer() -> Int {\n        runningTotal += amount\n        return runningTotal\n    }\n    return incrementer\n}\n```\n\n注意：Swift会`自动持有被截获的变量的引用`，这样就可以在block内部直接修改变量。Swift会自动判断你是否在闭包中或闭包外改变了变量。如果没有改变，闭包会直接持有变量，即使你没有显式的把它卸载捕获列表中。以下摘自苹果官方文档：\n\n```Swift\nAs an optimization, Swift may instead capture and store a copy of a value if that value is not mutated by a closure, and if the value is not mutated after the closure is created.\n```\n\n### 闭包是引用类型\n如果将闭包赋值给一个变量和常量，那么赋值后的变量和常量会引用同一个闭包，例如\n\n```Swift\nlet alsoIncrementByTen = incrementByTen\nalsoIncrementByTen()\n```\n\n\n### 逃避闭包(Escaping Closures)\n当闭包作为函数的参数传入时，很有可能这个闭包在函数返回之后才会被执行，这就是逃逸闭包。在Swift中可以在参数名前标注 @noescape 来指明这个闭包是不允许逃逸出这个函数的。因为非逃逸闭包只能在函数体中被执行，不能脱离函数体执行，所以这使得编译器可以明确的知道运行时的上下文环境，进而做出优化。\n一般情况下，一些异步函数会使用逃逸闭包。这类函数会在异步操作开始之后立刻返回，但是闭包直到异步操作结束后才会被调用。比如网络请求中处理服务器返回请求的闭包。例如：\n\n```Swift\nvar completionHandlers: [() -> Void] = []\nfunc someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {\n    completionHandlers.append(completionHandler)\n}\n```\n\n如果需要引用自身self，因为编译器知晓非逃逸闭包的上下文环境，所以非逃逸闭包中可以不写 self (隐式的存在)。但是逃逸闭包必须明确写self。例如：\n\n```Swift\nclass SomeClass {\n    var x = 10\n    func doSomething() {\n        someFunctionWithEscapingClosure { self.x = 100 }\n        someFunctionWithNonescapingClosure { x = 200 }\n    }\n}\n```\n\n### 自动闭包(Autoclosures)\n自动闭包是自动创建的包含一个语句的闭包，作为参数传递给函数。自动闭包不接受任何参数，被调用时会返回被包装在其中的表达式的值。\n自动闭包是延迟求值，因为闭包中的代码直到你调用闭包的时候才会执行。延迟求值对一些可能存在副作用的代码来说很有用，通过延迟求值你可以控制代码的执行时机。例如：\n\n```Swift\nvar customersInLine = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]\nprint(customersInLine.count)\n// Prints \"5\"\n \nlet customerProvider = { customersInLine.remove(at: 0) }\nprint(customersInLine.count)\n// Prints \"5\"\n \nprint(\"Now serving \\(customerProvider())!\")\n// Prints \"Now serving Chris!\"\nprint(customersInLine.count)\n// Prints \"4\"\n```\n\n即使闭包代码中将数组中的第一个元素移除了，但是闭包代码不会执行直到闭包被调用。如果闭包不被调用，那么闭包内的移除代码就不会调用。当你做微函数参数传递的时候你也是同样的道理\n\n```Swift\n// customersInLine is [\"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]\nfunc serve(customer customerProvider: () -> String) {\n    print(\"Now serving \\(customerProvider())!\")\n}\nserve(customer: { customersInLine.remove(at: 0) } )\n// Prints \"Now serving Alex!\"\n```\n\n以上例子中的serve函数接受一个明确的闭包（返回一个顾客的名字），下边这个例子和上边效果一样，不过是接收一个自动闭包。\n\n```Swift\n// customersInLine is [\"Ewa\", \"Barry\", \"Daniella\"]\nfunc serve(customer customerProvider: @autoclosure () -> String) {\n    print(\"Now serving \\(customerProvider())!\")\n}\nserve(customer: customersInLine.remove(at: 0))\n// Prints \"Now serving Ewa!\"\n```\n\n如果一个自动闭包需要逃逸，使用两个修饰符`@autoclosure`和`@escaping`：\n\n```Swift\n// customersInLine is [\"Barry\", \"Daniella\"]\nvar customerProviders: [() -> String] = []\nfunc collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -> String) {\n    customerProviders.append(customerProvider)\n}\ncollectCustomerProviders(customersInLine.remove(at: 0))\ncollectCustomerProviders(customersInLine.remove(at: 0))\n \nprint(\"Collected \\(customerProviders.count) closures.\")\n// Prints \"Collected 2 closures.\"\nfor customerProvider in customerProviders {\n    print(\"Now serving \\(customerProvider())!\")\n}\n// Prints \"Now serving Barry!\"\n// Prints \"Now serving Daniella!\"\n```\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html/\">Control Flow</a> \n\n>* <a href=\"http://www.jianshu.com/p/d0d7b519fec1/\">OC与Swift闭包对比总结</a> \n\n>* <a href=\"http://www.tuicool.com/articles/MRJ3me7/\">浅谈iOS中的闭包</a> \n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","source":"_posts/iOS_Swift_language_note_Closures.md","raw":"---\nlayout:     post\ntitle:      Swift Closures\ndate:       2016-11-22 00:20:11\nauthor:     liangtong\ncatalog: true\ncategories: iOS\ntags: Swift \n\n---\n\n\n\n​\t闭包是一种可以在代码中传递和使用的自包含代码块。Swift中的闭包盒C／ObjC中的闭包与其它语言中的lambdas表达式类似。闭包可用捕获其被定义的上下文中的变量或常量。Swift会为你处理所有的通过捕获的内存管理。函数章节介绍的全局／嵌套函数，是闭包的特殊形式，闭包采取以下三种形式之一\n\n > * 全局函数是一个有名字且不捕获任何值的闭包\n > * 嵌套函数是一个有名字且可用捕获其封闭函数作用域内值的闭包\n > * 闭包表达式是一个利用轻量级语法所写的可用捕获所在上下文中值（变量／常量）的没有名字的闭包\n\nSwift中的闭包表达式拥有清晰、简洁的风格，在以下常见的场景中实现闭包优化：\n\n > * 根据上下文怼参数和返回值进行类型推断\n > * 单表达式闭包可用省略return关键字\n > * 参数名称可用缩写\n > * Trailing闭包语法\n\n\n\n<!-- more -->\n\n### 闭包表达式\n嵌套函数是一种在较复杂函数中方便进行命名和定义自包含代码模块的方式，但是有时候编写一个不需要名字和参数的简洁版本更有用，尤其是在将函数作为参数传递给另一个函数的时候。\n闭包表达式是一种利用简洁语法构建内联闭包的方式。闭包表达式提供了一些语法优化，使得撰写闭包变得简单明了。下面闭包表达式的例子通过使用几次迭代展示了 sort 函数定义和语法优化的方式。 每一次迭代都用更简洁的方式描述了相同的功能。\n\n#### 排序方法\nSwift标准库提供的一个排序方法`sorted(by:)`会根据你提供的排序闭包对已知类型的数组的值进行排序，排序完成后会返回一个同源数组大小相同的排序后的数组。例如一个原始数组如下：\n\n```Swift\nlet names = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]\n```\n\n排序方法`sorted(by:)`接受一个包含两个数组内值相同类型参数并返回一个Bool值来表明顺序的闭包，闭包回返回true如果要求第一个值在排序的结果中靠前，否则返回false。例子中闭包表达式类型为：\n\n```Swift\n(String, String) -> Bool\n```\n\n可以通过普通函数，作为参数传递，例如：\n\n```Swift\nfunc backward(_ s1: String, _ s2: String) -> Bool {\n    return s1 > s2\n}\nvar reversedNames = names.sorted(by: backward)\n// reversedNames is equal to [\"Ewa\", \"Daniella\", \"Chris\", \"Barry\", \"Alex\"]\n```\n\n#### 闭包表达式语法\n闭包表达式一般语法如下：\n\n```Swift\n{ (parameters) -> return type in\n    statements\n}\n```\n\n闭包表达式的参数可以是`in-out`类型，但是不能有默认值，也可以是可变参数，也支持元组类型参数或者返回值，例如上述操作可以简化为：\n\n```Swift\nreversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in\n    return s1 > s2\n})\n```\n\n#### 根据上下文推断类型\n因为排序闭包是作为参数传递的，Swift可以推断出闭包的参数类型和返回值类型。因为所有的类型都可以被推断，所以这里具体类型没有必要提供。返回值和参数周围的括号也可以被省略，例如：\n\n```Swift\nreversedNames = names.sorted(by: { s1, s2 in return s1 > s2 } )\n```\n\n实际上，在内连闭包表达式构造的闭包作为参数传递给函数时，都可以推断出参数和返回值类型，这意味着你几乎不需要写完整的闭包格式。然而，你仍然可以使用明确的类型来消除阅读的歧义，并且这是被建议使用的方式。\n\n#### 单行闭包表达式可以省略return\n单行表达式闭包可以通过隐藏 return 关键字来隐式返回单行表达式的结果，如上版本的例子可以改写为：\n\n```Swift\nreversed = sort(names, { s1, s2 in s1 > s2 } ) \n```\n\n#### 参数名缩写\nSwift自动提供了参数名称缩写功能，可以直接使用`$0, $1, $2,`等来引用闭包中的参数。数量和类型可以被推断，当时用参数名称缩写的时候，参数列表定义部分可以省略，in关键字也可以省略。此事闭包表达式完全由闭包函数体构成：\n\n```Swift\nreversed = sort(names, { $0 > $1 } ) \n```\n\n#### 运算符方法\n有一种更简洁的方法来写上述例子中的闭包表达式。Swift中的String类型定义了操作符`>`的实现。因此可以简单的传递一个符号。例如：\n\n```Swift\nreversed = sort(names, { $0 > $1 } ) \n```\n\n### Trailing闭包\n当闭包作为一个拥有很多参数函数的最后一个参数时，可以使用Trailing闭包来增强函数的可读性。Trailing闭包是一个书写在函数括号之外的闭包表达式（尽管闭包仍然是函数的参数）。当使用Trailing闭包语法时，不写闭包对应的函数参数标签。例如：\n\n```Swift\nfunc someFunctionThatTakesAClosure(closure: () -> Void) {\n    // function body goes here\n}\n \n// Here's how you call this function without using a trailing closure:\n \nsomeFunctionThatTakesAClosure(closure: {\n    // closure's body goes here\n})\n \n// Here's how you call this function with a trailing closure instead:\n \nsomeFunctionThatTakesAClosure() {\n    // trailing closure's body goes here\n}\n```\n\n上述排序例子可以简写为：\n\n```Swift\nreversedNames = names.sorted() { $0 > $1 }\n```\n\n除了闭包外无其他参数，小括号也可以省略，例如：\n\n```Swift\nreversedNames = names.sorted { $0 > $1 }\n```\n\n当闭包非常长的时候，Trailing 闭包就变得非常有用。例如Swift的Array类型有一个map方法`map(_:)`，其接收一个闭包表达式作为唯一的参数，对于数组中的每一个元素会调用该闭包一次，并返回该元素映射的值，具体映射方式和返回值类型由闭包来指定，当提供给数组该闭包函数后，map方法将返回一个新的包含了与原数组一一对应映射关系的数组。例如以下例子讲述如何使用该闭包：\n\n```Swift\nlet digitNames = [\n    0: \"Zero\", 1: \"One\", 2: \"Two\",   3: \"Three\", 4: \"Four\",\n    5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"\n]\nlet numbers = [16, 58, 510]\n\nlet strings = numbers.map {\n    (number) -> String in\n    var number = number\n    var output = \"\"\n    repeat {\n        output = digitNames[number % 10]! + output\n        number /= 10\n    } while number > 0\n    return output\n}\n// strings is inferred to be of type [String]\n// its value is [\"OneSix\", \"FiveEight\", \"FiveOneZero\"]\n```\n\n### 捕获值\n闭包可以捕获其定义的上下文中的常量或变量，即使定义这些变量或者常量的作用域已经不存在，闭包仍然可以在闭包体内引用(和修改)这些值。在Swift中，最简单的闭包形式是嵌套函数，也就是定义在函数体内的函数。嵌套函数可以捕获外部函数的参数以及所有定义在外部函数体内的变量和常量。\n下边是一个嵌套函数的例子：\n\n```Swift\nfunc makeIncrementer(forIncrement amount: Int) -> () -> Int {\n    var runningTotal = 0\n    func incrementer() -> Int {\n        runningTotal += amount\n        return runningTotal\n    }\n    return incrementer\n}\n```\n\n注意：Swift会`自动持有被截获的变量的引用`，这样就可以在block内部直接修改变量。Swift会自动判断你是否在闭包中或闭包外改变了变量。如果没有改变，闭包会直接持有变量，即使你没有显式的把它卸载捕获列表中。以下摘自苹果官方文档：\n\n```Swift\nAs an optimization, Swift may instead capture and store a copy of a value if that value is not mutated by a closure, and if the value is not mutated after the closure is created.\n```\n\n### 闭包是引用类型\n如果将闭包赋值给一个变量和常量，那么赋值后的变量和常量会引用同一个闭包，例如\n\n```Swift\nlet alsoIncrementByTen = incrementByTen\nalsoIncrementByTen()\n```\n\n\n### 逃避闭包(Escaping Closures)\n当闭包作为函数的参数传入时，很有可能这个闭包在函数返回之后才会被执行，这就是逃逸闭包。在Swift中可以在参数名前标注 @noescape 来指明这个闭包是不允许逃逸出这个函数的。因为非逃逸闭包只能在函数体中被执行，不能脱离函数体执行，所以这使得编译器可以明确的知道运行时的上下文环境，进而做出优化。\n一般情况下，一些异步函数会使用逃逸闭包。这类函数会在异步操作开始之后立刻返回，但是闭包直到异步操作结束后才会被调用。比如网络请求中处理服务器返回请求的闭包。例如：\n\n```Swift\nvar completionHandlers: [() -> Void] = []\nfunc someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {\n    completionHandlers.append(completionHandler)\n}\n```\n\n如果需要引用自身self，因为编译器知晓非逃逸闭包的上下文环境，所以非逃逸闭包中可以不写 self (隐式的存在)。但是逃逸闭包必须明确写self。例如：\n\n```Swift\nclass SomeClass {\n    var x = 10\n    func doSomething() {\n        someFunctionWithEscapingClosure { self.x = 100 }\n        someFunctionWithNonescapingClosure { x = 200 }\n    }\n}\n```\n\n### 自动闭包(Autoclosures)\n自动闭包是自动创建的包含一个语句的闭包，作为参数传递给函数。自动闭包不接受任何参数，被调用时会返回被包装在其中的表达式的值。\n自动闭包是延迟求值，因为闭包中的代码直到你调用闭包的时候才会执行。延迟求值对一些可能存在副作用的代码来说很有用，通过延迟求值你可以控制代码的执行时机。例如：\n\n```Swift\nvar customersInLine = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]\nprint(customersInLine.count)\n// Prints \"5\"\n \nlet customerProvider = { customersInLine.remove(at: 0) }\nprint(customersInLine.count)\n// Prints \"5\"\n \nprint(\"Now serving \\(customerProvider())!\")\n// Prints \"Now serving Chris!\"\nprint(customersInLine.count)\n// Prints \"4\"\n```\n\n即使闭包代码中将数组中的第一个元素移除了，但是闭包代码不会执行直到闭包被调用。如果闭包不被调用，那么闭包内的移除代码就不会调用。当你做微函数参数传递的时候你也是同样的道理\n\n```Swift\n// customersInLine is [\"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]\nfunc serve(customer customerProvider: () -> String) {\n    print(\"Now serving \\(customerProvider())!\")\n}\nserve(customer: { customersInLine.remove(at: 0) } )\n// Prints \"Now serving Alex!\"\n```\n\n以上例子中的serve函数接受一个明确的闭包（返回一个顾客的名字），下边这个例子和上边效果一样，不过是接收一个自动闭包。\n\n```Swift\n// customersInLine is [\"Ewa\", \"Barry\", \"Daniella\"]\nfunc serve(customer customerProvider: @autoclosure () -> String) {\n    print(\"Now serving \\(customerProvider())!\")\n}\nserve(customer: customersInLine.remove(at: 0))\n// Prints \"Now serving Ewa!\"\n```\n\n如果一个自动闭包需要逃逸，使用两个修饰符`@autoclosure`和`@escaping`：\n\n```Swift\n// customersInLine is [\"Barry\", \"Daniella\"]\nvar customerProviders: [() -> String] = []\nfunc collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -> String) {\n    customerProviders.append(customerProvider)\n}\ncollectCustomerProviders(customersInLine.remove(at: 0))\ncollectCustomerProviders(customersInLine.remove(at: 0))\n \nprint(\"Collected \\(customerProviders.count) closures.\")\n// Prints \"Collected 2 closures.\"\nfor customerProvider in customerProviders {\n    print(\"Now serving \\(customerProvider())!\")\n}\n// Prints \"Now serving Barry!\"\n// Prints \"Now serving Daniella!\"\n```\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html/\">Control Flow</a> \n\n>* <a href=\"http://www.jianshu.com/p/d0d7b519fec1/\">OC与Swift闭包对比总结</a> \n\n>* <a href=\"http://www.tuicool.com/articles/MRJ3me7/\">浅谈iOS中的闭包</a> \n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","slug":"iOS_Swift_language_note_Closures","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4u3002doko8whaso814","content":"<p>​    闭包是一种可以在代码中传递和使用的自包含代码块。Swift中的闭包盒C／ObjC中的闭包与其它语言中的lambdas表达式类似。闭包可用捕获其被定义的上下文中的变量或常量。Swift会为你处理所有的通过捕获的内存管理。函数章节介绍的全局／嵌套函数，是闭包的特殊形式，闭包采取以下三种形式之一</p>\n<blockquote>\n<ul>\n<li>全局函数是一个有名字且不捕获任何值的闭包</li>\n<li>嵌套函数是一个有名字且可用捕获其封闭函数作用域内值的闭包</li>\n<li>闭包表达式是一个利用轻量级语法所写的可用捕获所在上下文中值（变量／常量）的没有名字的闭包</li>\n</ul>\n</blockquote>\n<p>Swift中的闭包表达式拥有清晰、简洁的风格，在以下常见的场景中实现闭包优化：</p>\n<blockquote>\n<ul>\n<li>根据上下文怼参数和返回值进行类型推断</li>\n<li>单表达式闭包可用省略return关键字</li>\n<li>参数名称可用缩写</li>\n<li>Trailing闭包语法</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"闭包表达式\"><a href=\"#闭包表达式\" class=\"headerlink\" title=\"闭包表达式\"></a>闭包表达式</h3><p>嵌套函数是一种在较复杂函数中方便进行命名和定义自包含代码模块的方式，但是有时候编写一个不需要名字和参数的简洁版本更有用，尤其是在将函数作为参数传递给另一个函数的时候。<br>闭包表达式是一种利用简洁语法构建内联闭包的方式。闭包表达式提供了一些语法优化，使得撰写闭包变得简单明了。下面闭包表达式的例子通过使用几次迭代展示了 sort 函数定义和语法优化的方式。 每一次迭代都用更简洁的方式描述了相同的功能。</p>\n<h4 id=\"排序方法\"><a href=\"#排序方法\" class=\"headerlink\" title=\"排序方法\"></a>排序方法</h4><p>Swift标准库提供的一个排序方法<code>sorted(by:)</code>会根据你提供的排序闭包对已知类型的数组的值进行排序，排序完成后会返回一个同源数组大小相同的排序后的数组。例如一个原始数组如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> names = [<span class=\"string\">\"Chris\"</span>, <span class=\"string\">\"Alex\"</span>, <span class=\"string\">\"Ewa\"</span>, <span class=\"string\">\"Barry\"</span>, <span class=\"string\">\"Daniella\"</span>]</div></pre></td></tr></table></figure>\n<p>排序方法<code>sorted(by:)</code>接受一个包含两个数组内值相同类型参数并返回一个Bool值来表明顺序的闭包，闭包回返回true如果要求第一个值在排序的结果中靠前，否则返回false。例子中闭包表达式类型为：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"type\">String</span>, <span class=\"type\">String</span>) -&gt; <span class=\"type\">Bool</span></div></pre></td></tr></table></figure>\n<p>可以通过普通函数，作为参数传递，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">backward</span><span class=\"params\">(<span class=\"number\">_</span> s1: String, <span class=\"number\">_</span> s2: String)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> s1 &gt; s2</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> reversedNames = names.sorted(by: backward)</div><div class=\"line\"><span class=\"comment\">// reversedNames is equal to [\"Ewa\", \"Daniella\", \"Chris\", \"Barry\", \"Alex\"]</span></div></pre></td></tr></table></figure>\n<h4 id=\"闭包表达式语法\"><a href=\"#闭包表达式语法\" class=\"headerlink\" title=\"闭包表达式语法\"></a>闭包表达式语法</h4><p>闭包表达式一般语法如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123; (parameters) -&gt; <span class=\"keyword\">return</span> type <span class=\"keyword\">in</span></div><div class=\"line\">    statements</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>闭包表达式的参数可以是<code>in-out</code>类型，但是不能有默认值，也可以是可变参数，也支持元组类型参数或者返回值，例如上述操作可以简化为：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">reversedNames = names.sorted(by: &#123; (s1: <span class=\"type\">String</span>, s2: <span class=\"type\">String</span>) -&gt; <span class=\"type\">Bool</span> <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"keyword\">return</span> s1 &gt; s2</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h4 id=\"根据上下文推断类型\"><a href=\"#根据上下文推断类型\" class=\"headerlink\" title=\"根据上下文推断类型\"></a>根据上下文推断类型</h4><p>因为排序闭包是作为参数传递的，Swift可以推断出闭包的参数类型和返回值类型。因为所有的类型都可以被推断，所以这里具体类型没有必要提供。返回值和参数周围的括号也可以被省略，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">reversedNames = names.sorted(by: &#123; s1, s2 <span class=\"keyword\">in</span> <span class=\"keyword\">return</span> s1 &gt; s2 &#125; )</div></pre></td></tr></table></figure>\n<p>实际上，在内连闭包表达式构造的闭包作为参数传递给函数时，都可以推断出参数和返回值类型，这意味着你几乎不需要写完整的闭包格式。然而，你仍然可以使用明确的类型来消除阅读的歧义，并且这是被建议使用的方式。</p>\n<h4 id=\"单行闭包表达式可以省略return\"><a href=\"#单行闭包表达式可以省略return\" class=\"headerlink\" title=\"单行闭包表达式可以省略return\"></a>单行闭包表达式可以省略return</h4><p>单行表达式闭包可以通过隐藏 return 关键字来隐式返回单行表达式的结果，如上版本的例子可以改写为：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">reversed = <span class=\"built_in\">sort</span>(names, &#123; s1, s2 <span class=\"keyword\">in</span> s1 &gt; s2 &#125; )</div></pre></td></tr></table></figure>\n<h4 id=\"参数名缩写\"><a href=\"#参数名缩写\" class=\"headerlink\" title=\"参数名缩写\"></a>参数名缩写</h4><p>Swift自动提供了参数名称缩写功能，可以直接使用<code>$0, $1, $2,</code>等来引用闭包中的参数。数量和类型可以被推断，当时用参数名称缩写的时候，参数列表定义部分可以省略，in关键字也可以省略。此事闭包表达式完全由闭包函数体构成：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">reversed = <span class=\"built_in\">sort</span>(names, &#123; $<span class=\"number\">0</span> &gt; $<span class=\"number\">1</span> &#125; )</div></pre></td></tr></table></figure>\n<h4 id=\"运算符方法\"><a href=\"#运算符方法\" class=\"headerlink\" title=\"运算符方法\"></a>运算符方法</h4><p>有一种更简洁的方法来写上述例子中的闭包表达式。Swift中的String类型定义了操作符<code>&gt;</code>的实现。因此可以简单的传递一个符号。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">reversed = <span class=\"built_in\">sort</span>(names, &#123; $<span class=\"number\">0</span> &gt; $<span class=\"number\">1</span> &#125; )</div></pre></td></tr></table></figure>\n<h3 id=\"Trailing闭包\"><a href=\"#Trailing闭包\" class=\"headerlink\" title=\"Trailing闭包\"></a>Trailing闭包</h3><p>当闭包作为一个拥有很多参数函数的最后一个参数时，可以使用Trailing闭包来增强函数的可读性。Trailing闭包是一个书写在函数括号之外的闭包表达式（尽管闭包仍然是函数的参数）。当使用Trailing闭包语法时，不写闭包对应的函数参数标签。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someFunctionThatTakesAClosure</span><span class=\"params\">(closure: <span class=\"params\">()</span></span></span> -&gt; <span class=\"type\">Void</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// function body goes here</span></div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// Here's how you call this function without using a trailing closure:</span></div><div class=\"line\"> </div><div class=\"line\">someFunctionThatTakesAClosure(closure: &#123;</div><div class=\"line\">    <span class=\"comment\">// closure's body goes here</span></div><div class=\"line\">&#125;)</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// Here's how you call this function with a trailing closure instead:</span></div><div class=\"line\"> </div><div class=\"line\">someFunctionThatTakesAClosure() &#123;</div><div class=\"line\">    <span class=\"comment\">// trailing closure's body goes here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述排序例子可以简写为：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">reversedNames = names.sorted() &#123; $<span class=\"number\">0</span> &gt; $<span class=\"number\">1</span> &#125;</div></pre></td></tr></table></figure>\n<p>除了闭包外无其他参数，小括号也可以省略，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">reversedNames = names.sorted &#123; $<span class=\"number\">0</span> &gt; $<span class=\"number\">1</span> &#125;</div></pre></td></tr></table></figure>\n<p>当闭包非常长的时候，Trailing 闭包就变得非常有用。例如Swift的Array类型有一个map方法<code>map(_:)</code>，其接收一个闭包表达式作为唯一的参数，对于数组中的每一个元素会调用该闭包一次，并返回该元素映射的值，具体映射方式和返回值类型由闭包来指定，当提供给数组该闭包函数后，map方法将返回一个新的包含了与原数组一一对应映射关系的数组。例如以下例子讲述如何使用该闭包：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> digitNames = [</div><div class=\"line\">    <span class=\"number\">0</span>: <span class=\"string\">\"Zero\"</span>, <span class=\"number\">1</span>: <span class=\"string\">\"One\"</span>, <span class=\"number\">2</span>: <span class=\"string\">\"Two\"</span>,   <span class=\"number\">3</span>: <span class=\"string\">\"Three\"</span>, <span class=\"number\">4</span>: <span class=\"string\">\"Four\"</span>,</div><div class=\"line\">    <span class=\"number\">5</span>: <span class=\"string\">\"Five\"</span>, <span class=\"number\">6</span>: <span class=\"string\">\"Six\"</span>, <span class=\"number\">7</span>: <span class=\"string\">\"Seven\"</span>, <span class=\"number\">8</span>: <span class=\"string\">\"Eight\"</span>, <span class=\"number\">9</span>: <span class=\"string\">\"Nine\"</span></div><div class=\"line\">]</div><div class=\"line\"><span class=\"keyword\">let</span> numbers = [<span class=\"number\">16</span>, <span class=\"number\">58</span>, <span class=\"number\">510</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> strings = numbers.<span class=\"built_in\">map</span> &#123;</div><div class=\"line\">    (number) -&gt; <span class=\"type\">String</span> <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"keyword\">var</span> number = number</div><div class=\"line\">    <span class=\"keyword\">var</span> output = <span class=\"string\">\"\"</span></div><div class=\"line\">    <span class=\"keyword\">repeat</span> &#123;</div><div class=\"line\">        output = digitNames[number % <span class=\"number\">10</span>]! + output</div><div class=\"line\">        number /= <span class=\"number\">10</span></div><div class=\"line\">    &#125; <span class=\"keyword\">while</span> number &gt; <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">return</span> output</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// strings is inferred to be of type [String]</span></div><div class=\"line\"><span class=\"comment\">// its value is [\"OneSix\", \"FiveEight\", \"FiveOneZero\"]</span></div></pre></td></tr></table></figure>\n<h3 id=\"捕获值\"><a href=\"#捕获值\" class=\"headerlink\" title=\"捕获值\"></a>捕获值</h3><p>闭包可以捕获其定义的上下文中的常量或变量，即使定义这些变量或者常量的作用域已经不存在，闭包仍然可以在闭包体内引用(和修改)这些值。在Swift中，最简单的闭包形式是嵌套函数，也就是定义在函数体内的函数。嵌套函数可以捕获外部函数的参数以及所有定义在外部函数体内的变量和常量。<br>下边是一个嵌套函数的例子：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeIncrementer</span><span class=\"params\">(forIncrement amount: Int)</span></span> -&gt; () -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> runningTotal = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">incrementer</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">        runningTotal += amount</div><div class=\"line\">        <span class=\"keyword\">return</span> runningTotal</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> incrementer</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意：Swift会<code>自动持有被截获的变量的引用</code>，这样就可以在block内部直接修改变量。Swift会自动判断你是否在闭包中或闭包外改变了变量。如果没有改变，闭包会直接持有变量，即使你没有显式的把它卸载捕获列表中。以下摘自苹果官方文档：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"type\">As</span> an optimization, <span class=\"type\">Swift</span> may instead capture and store a copy of a value <span class=\"keyword\">if</span> that value <span class=\"keyword\">is</span> not mutated by a closure, and <span class=\"keyword\">if</span> the value <span class=\"keyword\">is</span> not mutated after the closure <span class=\"keyword\">is</span> created.</div></pre></td></tr></table></figure>\n<h3 id=\"闭包是引用类型\"><a href=\"#闭包是引用类型\" class=\"headerlink\" title=\"闭包是引用类型\"></a>闭包是引用类型</h3><p>如果将闭包赋值给一个变量和常量，那么赋值后的变量和常量会引用同一个闭包，例如</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> alsoIncrementByTen = incrementByTen</div><div class=\"line\">alsoIncrementByTen()</div></pre></td></tr></table></figure>\n<h3 id=\"逃避闭包-Escaping-Closures\"><a href=\"#逃避闭包-Escaping-Closures\" class=\"headerlink\" title=\"逃避闭包(Escaping Closures)\"></a>逃避闭包(Escaping Closures)</h3><p>当闭包作为函数的参数传入时，很有可能这个闭包在函数返回之后才会被执行，这就是逃逸闭包。在Swift中可以在参数名前标注 @noescape 来指明这个闭包是不允许逃逸出这个函数的。因为非逃逸闭包只能在函数体中被执行，不能脱离函数体执行，所以这使得编译器可以明确的知道运行时的上下文环境，进而做出优化。<br>一般情况下，一些异步函数会使用逃逸闭包。这类函数会在异步操作开始之后立刻返回，但是闭包直到异步操作结束后才会被调用。比如网络请求中处理服务器返回请求的闭包。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> completionHandlers: [() -&gt; <span class=\"type\">Void</span>] = []</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someFunctionWithEscapingClosure</span><span class=\"params\">(completionHandler: @escaping <span class=\"params\">()</span></span></span> -&gt; <span class=\"type\">Void</span>) &#123;</div><div class=\"line\">    completionHandlers.append(completionHandler)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果需要引用自身self，因为编译器知晓非逃逸闭包的上下文环境，所以非逃逸闭包中可以不写 self (隐式的存在)。但是逃逸闭包必须明确写self。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClass</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">10</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        someFunctionWithEscapingClosure &#123; <span class=\"keyword\">self</span>.x = <span class=\"number\">100</span> &#125;</div><div class=\"line\">        someFunctionWithNonescapingClosure &#123; x = <span class=\"number\">200</span> &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"自动闭包-Autoclosures\"><a href=\"#自动闭包-Autoclosures\" class=\"headerlink\" title=\"自动闭包(Autoclosures)\"></a>自动闭包(Autoclosures)</h3><p>自动闭包是自动创建的包含一个语句的闭包，作为参数传递给函数。自动闭包不接受任何参数，被调用时会返回被包装在其中的表达式的值。<br>自动闭包是延迟求值，因为闭包中的代码直到你调用闭包的时候才会执行。延迟求值对一些可能存在副作用的代码来说很有用，通过延迟求值你可以控制代码的执行时机。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> customersInLine = [<span class=\"string\">\"Chris\"</span>, <span class=\"string\">\"Alex\"</span>, <span class=\"string\">\"Ewa\"</span>, <span class=\"string\">\"Barry\"</span>, <span class=\"string\">\"Daniella\"</span>]</div><div class=\"line\"><span class=\"built_in\">print</span>(customersInLine.<span class=\"built_in\">count</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"5\"</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">let</span> customerProvider = &#123; customersInLine.remove(at: <span class=\"number\">0</span>) &#125;</div><div class=\"line\"><span class=\"built_in\">print</span>(customersInLine.<span class=\"built_in\">count</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"5\"</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Now serving <span class=\"subst\">\\(customerProvider()</span>)!\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"Now serving Chris!\"</span></div><div class=\"line\"><span class=\"built_in\">print</span>(customersInLine.<span class=\"built_in\">count</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"4\"</span></div></pre></td></tr></table></figure>\n<p>即使闭包代码中将数组中的第一个元素移除了，但是闭包代码不会执行直到闭包被调用。如果闭包不被调用，那么闭包内的移除代码就不会调用。当你做微函数参数传递的时候你也是同样的道理</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// customersInLine is [\"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">serve</span><span class=\"params\">(customer customerProvider: <span class=\"params\">()</span></span></span> -&gt; <span class=\"type\">String</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Now serving <span class=\"subst\">\\(customerProvider()</span>)!\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\">serve(customer: &#123; customersInLine.remove(at: <span class=\"number\">0</span>) &#125; )</div><div class=\"line\"><span class=\"comment\">// Prints \"Now serving Alex!\"</span></div></pre></td></tr></table></figure>\n<p>以上例子中的serve函数接受一个明确的闭包（返回一个顾客的名字），下边这个例子和上边效果一样，不过是接收一个自动闭包。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// customersInLine is [\"Ewa\", \"Barry\", \"Daniella\"]</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">serve</span><span class=\"params\">(customer customerProvider: @autoclosure <span class=\"params\">()</span></span></span> -&gt; <span class=\"type\">String</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Now serving <span class=\"subst\">\\(customerProvider()</span>)!\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\">serve(customer: customersInLine.remove(at: <span class=\"number\">0</span>))</div><div class=\"line\"><span class=\"comment\">// Prints \"Now serving Ewa!\"</span></div></pre></td></tr></table></figure>\n<p>如果一个自动闭包需要逃逸，使用两个修饰符<code>@autoclosure</code>和<code>@escaping</code>：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// customersInLine is [\"Barry\", \"Daniella\"]</span></div><div class=\"line\"><span class=\"keyword\">var</span> customerProviders: [() -&gt; <span class=\"type\">String</span>] = []</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">collectCustomerProviders</span><span class=\"params\">(<span class=\"number\">_</span> customerProvider: @autoclosure @escaping <span class=\"params\">()</span></span></span> -&gt; <span class=\"type\">String</span>) &#123;</div><div class=\"line\">    customerProviders.append(customerProvider)</div><div class=\"line\">&#125;</div><div class=\"line\">collectCustomerProviders(customersInLine.remove(at: <span class=\"number\">0</span>))</div><div class=\"line\">collectCustomerProviders(customersInLine.remove(at: <span class=\"number\">0</span>))</div><div class=\"line\"> </div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Collected <span class=\"subst\">\\(customerProviders.<span class=\"built_in\">count</span>)</span> closures.\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"Collected 2 closures.\"</span></div><div class=\"line\"><span class=\"keyword\">for</span> customerProvider <span class=\"keyword\">in</span> customerProviders &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Now serving <span class=\"subst\">\\(customerProvider()</span>)!\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"Now serving Barry!\"</span></div><div class=\"line\"><span class=\"comment\">// Prints \"Now serving Daniella!\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><p><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html/\" target=\"_blank\" rel=\"external\">Control Flow</a> </p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/d0d7b519fec1/\" target=\"_blank\" rel=\"external\">OC与Swift闭包对比总结</a> </p>\n</li>\n<li><p><a href=\"http://www.tuicool.com/articles/MRJ3me7/\" target=\"_blank\" rel=\"external\">浅谈iOS中的闭包</a> </p>\n</li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>​    闭包是一种可以在代码中传递和使用的自包含代码块。Swift中的闭包盒C／ObjC中的闭包与其它语言中的lambdas表达式类似。闭包可用捕获其被定义的上下文中的变量或常量。Swift会为你处理所有的通过捕获的内存管理。函数章节介绍的全局／嵌套函数，是闭包的特殊形式，闭包采取以下三种形式之一</p>\n<blockquote>\n<ul>\n<li>全局函数是一个有名字且不捕获任何值的闭包</li>\n<li>嵌套函数是一个有名字且可用捕获其封闭函数作用域内值的闭包</li>\n<li>闭包表达式是一个利用轻量级语法所写的可用捕获所在上下文中值（变量／常量）的没有名字的闭包</li>\n</ul>\n</blockquote>\n<p>Swift中的闭包表达式拥有清晰、简洁的风格，在以下常见的场景中实现闭包优化：</p>\n<blockquote>\n<ul>\n<li>根据上下文怼参数和返回值进行类型推断</li>\n<li>单表达式闭包可用省略return关键字</li>\n<li>参数名称可用缩写</li>\n<li>Trailing闭包语法</li>\n</ul>\n</blockquote>","more":"<h3 id=\"闭包表达式\"><a href=\"#闭包表达式\" class=\"headerlink\" title=\"闭包表达式\"></a>闭包表达式</h3><p>嵌套函数是一种在较复杂函数中方便进行命名和定义自包含代码模块的方式，但是有时候编写一个不需要名字和参数的简洁版本更有用，尤其是在将函数作为参数传递给另一个函数的时候。<br>闭包表达式是一种利用简洁语法构建内联闭包的方式。闭包表达式提供了一些语法优化，使得撰写闭包变得简单明了。下面闭包表达式的例子通过使用几次迭代展示了 sort 函数定义和语法优化的方式。 每一次迭代都用更简洁的方式描述了相同的功能。</p>\n<h4 id=\"排序方法\"><a href=\"#排序方法\" class=\"headerlink\" title=\"排序方法\"></a>排序方法</h4><p>Swift标准库提供的一个排序方法<code>sorted(by:)</code>会根据你提供的排序闭包对已知类型的数组的值进行排序，排序完成后会返回一个同源数组大小相同的排序后的数组。例如一个原始数组如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> names = [<span class=\"string\">\"Chris\"</span>, <span class=\"string\">\"Alex\"</span>, <span class=\"string\">\"Ewa\"</span>, <span class=\"string\">\"Barry\"</span>, <span class=\"string\">\"Daniella\"</span>]</div></pre></td></tr></table></figure>\n<p>排序方法<code>sorted(by:)</code>接受一个包含两个数组内值相同类型参数并返回一个Bool值来表明顺序的闭包，闭包回返回true如果要求第一个值在排序的结果中靠前，否则返回false。例子中闭包表达式类型为：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"type\">String</span>, <span class=\"type\">String</span>) -&gt; <span class=\"type\">Bool</span></div></pre></td></tr></table></figure>\n<p>可以通过普通函数，作为参数传递，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">backward</span><span class=\"params\">(<span class=\"number\">_</span> s1: String, <span class=\"number\">_</span> s2: String)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> s1 &gt; s2</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> reversedNames = names.sorted(by: backward)</div><div class=\"line\"><span class=\"comment\">// reversedNames is equal to [\"Ewa\", \"Daniella\", \"Chris\", \"Barry\", \"Alex\"]</span></div></pre></td></tr></table></figure>\n<h4 id=\"闭包表达式语法\"><a href=\"#闭包表达式语法\" class=\"headerlink\" title=\"闭包表达式语法\"></a>闭包表达式语法</h4><p>闭包表达式一般语法如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123; (parameters) -&gt; <span class=\"keyword\">return</span> type <span class=\"keyword\">in</span></div><div class=\"line\">    statements</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>闭包表达式的参数可以是<code>in-out</code>类型，但是不能有默认值，也可以是可变参数，也支持元组类型参数或者返回值，例如上述操作可以简化为：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">reversedNames = names.sorted(by: &#123; (s1: <span class=\"type\">String</span>, s2: <span class=\"type\">String</span>) -&gt; <span class=\"type\">Bool</span> <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"keyword\">return</span> s1 &gt; s2</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h4 id=\"根据上下文推断类型\"><a href=\"#根据上下文推断类型\" class=\"headerlink\" title=\"根据上下文推断类型\"></a>根据上下文推断类型</h4><p>因为排序闭包是作为参数传递的，Swift可以推断出闭包的参数类型和返回值类型。因为所有的类型都可以被推断，所以这里具体类型没有必要提供。返回值和参数周围的括号也可以被省略，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">reversedNames = names.sorted(by: &#123; s1, s2 <span class=\"keyword\">in</span> <span class=\"keyword\">return</span> s1 &gt; s2 &#125; )</div></pre></td></tr></table></figure>\n<p>实际上，在内连闭包表达式构造的闭包作为参数传递给函数时，都可以推断出参数和返回值类型，这意味着你几乎不需要写完整的闭包格式。然而，你仍然可以使用明确的类型来消除阅读的歧义，并且这是被建议使用的方式。</p>\n<h4 id=\"单行闭包表达式可以省略return\"><a href=\"#单行闭包表达式可以省略return\" class=\"headerlink\" title=\"单行闭包表达式可以省略return\"></a>单行闭包表达式可以省略return</h4><p>单行表达式闭包可以通过隐藏 return 关键字来隐式返回单行表达式的结果，如上版本的例子可以改写为：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">reversed = <span class=\"built_in\">sort</span>(names, &#123; s1, s2 <span class=\"keyword\">in</span> s1 &gt; s2 &#125; )</div></pre></td></tr></table></figure>\n<h4 id=\"参数名缩写\"><a href=\"#参数名缩写\" class=\"headerlink\" title=\"参数名缩写\"></a>参数名缩写</h4><p>Swift自动提供了参数名称缩写功能，可以直接使用<code>$0, $1, $2,</code>等来引用闭包中的参数。数量和类型可以被推断，当时用参数名称缩写的时候，参数列表定义部分可以省略，in关键字也可以省略。此事闭包表达式完全由闭包函数体构成：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">reversed = <span class=\"built_in\">sort</span>(names, &#123; $<span class=\"number\">0</span> &gt; $<span class=\"number\">1</span> &#125; )</div></pre></td></tr></table></figure>\n<h4 id=\"运算符方法\"><a href=\"#运算符方法\" class=\"headerlink\" title=\"运算符方法\"></a>运算符方法</h4><p>有一种更简洁的方法来写上述例子中的闭包表达式。Swift中的String类型定义了操作符<code>&gt;</code>的实现。因此可以简单的传递一个符号。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">reversed = <span class=\"built_in\">sort</span>(names, &#123; $<span class=\"number\">0</span> &gt; $<span class=\"number\">1</span> &#125; )</div></pre></td></tr></table></figure>\n<h3 id=\"Trailing闭包\"><a href=\"#Trailing闭包\" class=\"headerlink\" title=\"Trailing闭包\"></a>Trailing闭包</h3><p>当闭包作为一个拥有很多参数函数的最后一个参数时，可以使用Trailing闭包来增强函数的可读性。Trailing闭包是一个书写在函数括号之外的闭包表达式（尽管闭包仍然是函数的参数）。当使用Trailing闭包语法时，不写闭包对应的函数参数标签。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someFunctionThatTakesAClosure</span><span class=\"params\">(closure: <span class=\"params\">()</span></span></span> -&gt; <span class=\"type\">Void</span>) &#123;</div><div class=\"line\">    <span class=\"comment\">// function body goes here</span></div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// Here's how you call this function without using a trailing closure:</span></div><div class=\"line\"> </div><div class=\"line\">someFunctionThatTakesAClosure(closure: &#123;</div><div class=\"line\">    <span class=\"comment\">// closure's body goes here</span></div><div class=\"line\">&#125;)</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// Here's how you call this function with a trailing closure instead:</span></div><div class=\"line\"> </div><div class=\"line\">someFunctionThatTakesAClosure() &#123;</div><div class=\"line\">    <span class=\"comment\">// trailing closure's body goes here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述排序例子可以简写为：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">reversedNames = names.sorted() &#123; $<span class=\"number\">0</span> &gt; $<span class=\"number\">1</span> &#125;</div></pre></td></tr></table></figure>\n<p>除了闭包外无其他参数，小括号也可以省略，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">reversedNames = names.sorted &#123; $<span class=\"number\">0</span> &gt; $<span class=\"number\">1</span> &#125;</div></pre></td></tr></table></figure>\n<p>当闭包非常长的时候，Trailing 闭包就变得非常有用。例如Swift的Array类型有一个map方法<code>map(_:)</code>，其接收一个闭包表达式作为唯一的参数，对于数组中的每一个元素会调用该闭包一次，并返回该元素映射的值，具体映射方式和返回值类型由闭包来指定，当提供给数组该闭包函数后，map方法将返回一个新的包含了与原数组一一对应映射关系的数组。例如以下例子讲述如何使用该闭包：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> digitNames = [</div><div class=\"line\">    <span class=\"number\">0</span>: <span class=\"string\">\"Zero\"</span>, <span class=\"number\">1</span>: <span class=\"string\">\"One\"</span>, <span class=\"number\">2</span>: <span class=\"string\">\"Two\"</span>,   <span class=\"number\">3</span>: <span class=\"string\">\"Three\"</span>, <span class=\"number\">4</span>: <span class=\"string\">\"Four\"</span>,</div><div class=\"line\">    <span class=\"number\">5</span>: <span class=\"string\">\"Five\"</span>, <span class=\"number\">6</span>: <span class=\"string\">\"Six\"</span>, <span class=\"number\">7</span>: <span class=\"string\">\"Seven\"</span>, <span class=\"number\">8</span>: <span class=\"string\">\"Eight\"</span>, <span class=\"number\">9</span>: <span class=\"string\">\"Nine\"</span></div><div class=\"line\">]</div><div class=\"line\"><span class=\"keyword\">let</span> numbers = [<span class=\"number\">16</span>, <span class=\"number\">58</span>, <span class=\"number\">510</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> strings = numbers.<span class=\"built_in\">map</span> &#123;</div><div class=\"line\">    (number) -&gt; <span class=\"type\">String</span> <span class=\"keyword\">in</span></div><div class=\"line\">    <span class=\"keyword\">var</span> number = number</div><div class=\"line\">    <span class=\"keyword\">var</span> output = <span class=\"string\">\"\"</span></div><div class=\"line\">    <span class=\"keyword\">repeat</span> &#123;</div><div class=\"line\">        output = digitNames[number % <span class=\"number\">10</span>]! + output</div><div class=\"line\">        number /= <span class=\"number\">10</span></div><div class=\"line\">    &#125; <span class=\"keyword\">while</span> number &gt; <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">return</span> output</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// strings is inferred to be of type [String]</span></div><div class=\"line\"><span class=\"comment\">// its value is [\"OneSix\", \"FiveEight\", \"FiveOneZero\"]</span></div></pre></td></tr></table></figure>\n<h3 id=\"捕获值\"><a href=\"#捕获值\" class=\"headerlink\" title=\"捕获值\"></a>捕获值</h3><p>闭包可以捕获其定义的上下文中的常量或变量，即使定义这些变量或者常量的作用域已经不存在，闭包仍然可以在闭包体内引用(和修改)这些值。在Swift中，最简单的闭包形式是嵌套函数，也就是定义在函数体内的函数。嵌套函数可以捕获外部函数的参数以及所有定义在外部函数体内的变量和常量。<br>下边是一个嵌套函数的例子：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeIncrementer</span><span class=\"params\">(forIncrement amount: Int)</span></span> -&gt; () -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> runningTotal = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">incrementer</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">        runningTotal += amount</div><div class=\"line\">        <span class=\"keyword\">return</span> runningTotal</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> incrementer</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意：Swift会<code>自动持有被截获的变量的引用</code>，这样就可以在block内部直接修改变量。Swift会自动判断你是否在闭包中或闭包外改变了变量。如果没有改变，闭包会直接持有变量，即使你没有显式的把它卸载捕获列表中。以下摘自苹果官方文档：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"type\">As</span> an optimization, <span class=\"type\">Swift</span> may instead capture and store a copy of a value <span class=\"keyword\">if</span> that value <span class=\"keyword\">is</span> not mutated by a closure, and <span class=\"keyword\">if</span> the value <span class=\"keyword\">is</span> not mutated after the closure <span class=\"keyword\">is</span> created.</div></pre></td></tr></table></figure>\n<h3 id=\"闭包是引用类型\"><a href=\"#闭包是引用类型\" class=\"headerlink\" title=\"闭包是引用类型\"></a>闭包是引用类型</h3><p>如果将闭包赋值给一个变量和常量，那么赋值后的变量和常量会引用同一个闭包，例如</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> alsoIncrementByTen = incrementByTen</div><div class=\"line\">alsoIncrementByTen()</div></pre></td></tr></table></figure>\n<h3 id=\"逃避闭包-Escaping-Closures\"><a href=\"#逃避闭包-Escaping-Closures\" class=\"headerlink\" title=\"逃避闭包(Escaping Closures)\"></a>逃避闭包(Escaping Closures)</h3><p>当闭包作为函数的参数传入时，很有可能这个闭包在函数返回之后才会被执行，这就是逃逸闭包。在Swift中可以在参数名前标注 @noescape 来指明这个闭包是不允许逃逸出这个函数的。因为非逃逸闭包只能在函数体中被执行，不能脱离函数体执行，所以这使得编译器可以明确的知道运行时的上下文环境，进而做出优化。<br>一般情况下，一些异步函数会使用逃逸闭包。这类函数会在异步操作开始之后立刻返回，但是闭包直到异步操作结束后才会被调用。比如网络请求中处理服务器返回请求的闭包。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> completionHandlers: [() -&gt; <span class=\"type\">Void</span>] = []</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someFunctionWithEscapingClosure</span><span class=\"params\">(completionHandler: @escaping <span class=\"params\">()</span></span></span> -&gt; <span class=\"type\">Void</span>) &#123;</div><div class=\"line\">    completionHandlers.append(completionHandler)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果需要引用自身self，因为编译器知晓非逃逸闭包的上下文环境，所以非逃逸闭包中可以不写 self (隐式的存在)。但是逃逸闭包必须明确写self。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClass</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">10</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        someFunctionWithEscapingClosure &#123; <span class=\"keyword\">self</span>.x = <span class=\"number\">100</span> &#125;</div><div class=\"line\">        someFunctionWithNonescapingClosure &#123; x = <span class=\"number\">200</span> &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"自动闭包-Autoclosures\"><a href=\"#自动闭包-Autoclosures\" class=\"headerlink\" title=\"自动闭包(Autoclosures)\"></a>自动闭包(Autoclosures)</h3><p>自动闭包是自动创建的包含一个语句的闭包，作为参数传递给函数。自动闭包不接受任何参数，被调用时会返回被包装在其中的表达式的值。<br>自动闭包是延迟求值，因为闭包中的代码直到你调用闭包的时候才会执行。延迟求值对一些可能存在副作用的代码来说很有用，通过延迟求值你可以控制代码的执行时机。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> customersInLine = [<span class=\"string\">\"Chris\"</span>, <span class=\"string\">\"Alex\"</span>, <span class=\"string\">\"Ewa\"</span>, <span class=\"string\">\"Barry\"</span>, <span class=\"string\">\"Daniella\"</span>]</div><div class=\"line\"><span class=\"built_in\">print</span>(customersInLine.<span class=\"built_in\">count</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"5\"</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">let</span> customerProvider = &#123; customersInLine.remove(at: <span class=\"number\">0</span>) &#125;</div><div class=\"line\"><span class=\"built_in\">print</span>(customersInLine.<span class=\"built_in\">count</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"5\"</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Now serving <span class=\"subst\">\\(customerProvider()</span>)!\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"Now serving Chris!\"</span></div><div class=\"line\"><span class=\"built_in\">print</span>(customersInLine.<span class=\"built_in\">count</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"4\"</span></div></pre></td></tr></table></figure>\n<p>即使闭包代码中将数组中的第一个元素移除了，但是闭包代码不会执行直到闭包被调用。如果闭包不被调用，那么闭包内的移除代码就不会调用。当你做微函数参数传递的时候你也是同样的道理</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// customersInLine is [\"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">serve</span><span class=\"params\">(customer customerProvider: <span class=\"params\">()</span></span></span> -&gt; <span class=\"type\">String</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Now serving <span class=\"subst\">\\(customerProvider()</span>)!\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\">serve(customer: &#123; customersInLine.remove(at: <span class=\"number\">0</span>) &#125; )</div><div class=\"line\"><span class=\"comment\">// Prints \"Now serving Alex!\"</span></div></pre></td></tr></table></figure>\n<p>以上例子中的serve函数接受一个明确的闭包（返回一个顾客的名字），下边这个例子和上边效果一样，不过是接收一个自动闭包。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// customersInLine is [\"Ewa\", \"Barry\", \"Daniella\"]</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">serve</span><span class=\"params\">(customer customerProvider: @autoclosure <span class=\"params\">()</span></span></span> -&gt; <span class=\"type\">String</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Now serving <span class=\"subst\">\\(customerProvider()</span>)!\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\">serve(customer: customersInLine.remove(at: <span class=\"number\">0</span>))</div><div class=\"line\"><span class=\"comment\">// Prints \"Now serving Ewa!\"</span></div></pre></td></tr></table></figure>\n<p>如果一个自动闭包需要逃逸，使用两个修饰符<code>@autoclosure</code>和<code>@escaping</code>：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// customersInLine is [\"Barry\", \"Daniella\"]</span></div><div class=\"line\"><span class=\"keyword\">var</span> customerProviders: [() -&gt; <span class=\"type\">String</span>] = []</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">collectCustomerProviders</span><span class=\"params\">(<span class=\"number\">_</span> customerProvider: @autoclosure @escaping <span class=\"params\">()</span></span></span> -&gt; <span class=\"type\">String</span>) &#123;</div><div class=\"line\">    customerProviders.append(customerProvider)</div><div class=\"line\">&#125;</div><div class=\"line\">collectCustomerProviders(customersInLine.remove(at: <span class=\"number\">0</span>))</div><div class=\"line\">collectCustomerProviders(customersInLine.remove(at: <span class=\"number\">0</span>))</div><div class=\"line\"> </div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Collected <span class=\"subst\">\\(customerProviders.<span class=\"built_in\">count</span>)</span> closures.\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"Collected 2 closures.\"</span></div><div class=\"line\"><span class=\"keyword\">for</span> customerProvider <span class=\"keyword\">in</span> customerProviders &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Now serving <span class=\"subst\">\\(customerProvider()</span>)!\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"Now serving Barry!\"</span></div><div class=\"line\"><span class=\"comment\">// Prints \"Now serving Daniella!\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><p><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html/\" target=\"_blank\" rel=\"external\">Control Flow</a> </p>\n</li>\n<li><p><a href=\"http://www.jianshu.com/p/d0d7b519fec1/\" target=\"_blank\" rel=\"external\">OC与Swift闭包对比总结</a> </p>\n</li>\n<li><p><a href=\"http://www.tuicool.com/articles/MRJ3me7/\" target=\"_blank\" rel=\"external\">浅谈iOS中的闭包</a> </p>\n</li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>"},{"layout":"post","title":"Swift Collection Types","date":"2016-11-05T16:20:11.000Z","author":"liangtong","catalog":true,"_content":"\n\n\n​\t同其他语言类型类似，Swift提供了3个集合类型`Array`、`Set`和`Dictionary`来存储集合值。与ObjC不同的是，Swift中的集合属于范型，不能不同类型的数据添加的同一个集合类型中，且Swift中的集合类型变量都支持修改。\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/CollectionTypes_intro_2x.png)\n\n\n\n### Array\n数组类型是存储相同类型数据的有序列表，其中数组不同位置存储的数可以相同。Swift中的`Array`类型是Foundation框架中的`NSArray`类型的桥接.Swift中Array属于范型类，具体的写法是`Array<Element>`或者`[Element]`，两种写法相同。\n\n\n<!-- more -->\n\n#### 数组的创建\n可以通过`[Element](), []`的形式创建空数组，可以通过Array提供方法进行创建，当然也可以通过字面值`[value 1, value 2, value 3]`的形式创建并初始化一个数组\n\n```Swift\nvar someInts = [Int]()//创建一个空的Int数组\nsomeInts.append(3)//数组中添加一个元素\nsomeInts = []//数组被清空\n\n// threeDoubles is of type [Double], and equals [0.0, 0.0, 0.0]\nvar threeDoubles = Array(repeating: 0.0, count: 3)\n\nvar shoppingList: [String] = [\"Eggs\", \"Milk”]\n```\n\n#### 数组的组合\n可以通过操作符`+`将两个形同类型元素的数组合并到一起。\n\n```Swift\nvar anotherThreeDoubles = Array(repeating: 2.5, count: 3)\n// anotherThreeDoubles is of type [Double], and equals [2.5, 2.5, 2.5]\n \nvar sixDoubles = threeDoubles + anotherThreeDoubles\n// sixDoubles is inferred as [Double], and equals [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]\n```\n\n#### 数组元素的访问和修改\n可以通过调用数组的方法和属性来访问和修改数组元素，或者通过下标语法，比如：\n\n```Swift\n//通过数组的count属性来确定数组的元素\nprint(\"The shopping list contains \\(shoppingList.count) items.\")\n\n//通过数组的Bool属性isEmpty来判断数组是否为空\nif shoppingList.isEmpty {\n    print(\"The shopping list is empty.\")\n} else {\n    print(\"The shopping list is not empty.\")\n}\n\n//通过调用数组的append方法来给数组添加元素\nshoppingList.append(\"Flour\")\n\n//当然也可以通过操作符+=给数组添加元素（合并数组）\nshoppingList += [\"Baking Powder\"]\nshoppingList += [\"Chocolate Spread\", \"Cheese\", \"Butter\"]\n\n//通过下标访问和修改数组元素：如果越界会导致运行时错误\nvar firstItem = shoppingList[0]\nshoppingList[0] = \"Six eggs\"\n\n//当然也可以通过下标来同时修改一个范围元素，长度不相同也无所谓\nshoppingList[4...6] = [\"Bananas\", \"Apples\"]\n\n//可以通过insert方法向数组中插入元素\nshoppingList.insert(\"Maple Syrup\", at: 0)\n\n//可以通过remove方法向移除数组特定位置的元素\nlet mapleSyrup = shoppingList.remove(at: 0)\n```\n\n#### 数组的遍历\n通过使用`for-in`循环来遍历数组，当然如果需要数组对应下标值的话，可以通过`enumerated()`方法（对于数组的`enumerated()`方法，会返回一个包含整形索引和具体值的元组）。例如：\n\n```Swift\nfor item in shoppingList {\n    print(item)\n}\n\nfor (index, value) in shoppingList.enumerated() {\n    print(\"Item \\(index + 1): \\(value)\")\n}\n```\n\n### Set\nSet是用来存储不重复的相同类型元素`无序`列表；Swift中的`Set`类型是Foundation框架中的`NSSet`类型的桥接。\n\n#### Set类型的哈希值\n存储在Set类型中的元素必须是`hashable`的（用来保证存储在Set中的元素唯一）。Swift中Set类型的创建语法格式为`Set[Element]`。与其他语言一样，不再赘述\n\n > 注：可以通过实现Swfit中的`Hashable`协议来自定义存储在Set集合中的元素\n\n#### Set类型的创建\n可以通过`Set<Element>(), []`语法创建一个Set类型对象，当然也可以通过字面值`[value 1, value 2, value 3]`的形式创建并初始化一个Set对象，例如：\n\n```Swift\n//创建一个空的Character类型的Set对象\nvar letters = Set<Character>()\n\n//通过调用inset方法，向Set中添加元素\nletters.insert(\"a\")\n\n//Set被清空\nletters = []\n\n//通过字面值创建并初始化Set集合\nvar favoriteGenres: Set<String> = [\"Rock\", \"Classical\", \"Hip hop\"]\n//也可以这样写，Swift存在类型推断\nvar favoriteGenres: Set = [\"Rock\", \"Classical\", \"Hip hop\"]\n```\n\n#### Set对象的访问和修改\n可以通过调用Set的方法和属性来访问和修改Set元素，例如：\n\n```Swift\n//通过Set的count属性来确定Set的元素\nprint(\"I have \\(favoriteGenres.count) favorite music genres.\")\n\n//通过Set的Bool属性isEmpty来判断Set是否为空\nif favoriteGenres.isEmpty {\n    print(\"As far as music goes, I'm not picky.\")\n} else {\n    print(\"I have particular music preferences.\")\n}\n\n//通过调用Set的insert方法来给Set添加元素\nfavoriteGenres.insert(\"Jazz\")\n\n//可以通过remove方法向移除Set中的特定元素\nif let removedGenre = favoriteGenres.remove(\"Rock\") {\n    print(\"\\(removedGenre)? I'm over it.\")\n} else {\n    print(\"I never much cared for that.\")\n}\n\n//通过调用Set的contains方法来判断Set是否包含某个元素\nif favoriteGenres.contains(\"Funk\") {\n    print(\"I get up on the good foot.\")\n} else {\n    print(\"It's too funky in here.\")\n}\n// Prints \"It's too funky in here.\"\n\n```\n\n#### Set的遍历\n通过使用`for-in`循环来遍历Set，Set对象是无序列表，如果想要顺序访问具体对象值，可以调用Set的`sorted()`方法。例如：\n\n```Swift\nfor genre in favoriteGenres {\n    print(\"\\(genre)\")\n}\n// Jazz\n// Hip hop\n// Classical\n\nfor genre in favoriteGenres.sorted() {\n    print(\"\\(genre)\")\n}\n// Classical\n// Hip hop\n// Jazz\n```\n\n#### Set常用运算\n常用操作如下：\n\n > * operator (==) 判断是非相等\n > * isSubset(of:) 判断Set是否子集\n > * isSuperset(of:) 判断是否超级\n > * isStrictSubset(of:) 或 isStrictSuperset(of:) 判断是否是子集或者超集，但不相等\n > * isDisjoint(with:) 判断两个Set是否有相同元素\n\n再放一张图吧\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/setVennDiagram_2x.png)\n\n\n\n### Dictionary\nDictionary存储<Key,Value>键值对，其中键key值必须唯一，Swift中的`Dictionary `类型是Foundation框架中的`NSDictionary `类型的桥接。\n\n#### Dictionary的创建\n可以通过`[Key:Value](), []`的形式创建空Dictionary，也可以通过字面值`[key 1: value 1, key 2: value 2, key 3: value 3]`的形式创建。例如：\n\n```Swift\n//创建一个空字典\nvar namesOfIntegers = [Int: String]()\n\n//字典的赋值\nnamesOfIntegers[16] = \"sixteen\"\n\n//字典的清空\nnamesOfIntegers = [:]\n\n//通过字面值创建\nvar airports: [String: String] = [\"YYZ\": \"Toronto Pearson\", \"DUB\": \"Dublin\"]\n//类型推断\nvar airports = [\"YYZ\": \"Toronto Pearson\", \"DUB\": \"Dublin\"]\n\n```\n\n#### Dictionary对象的访问和修改\n可以通过调用Dictionary的方法和属性来访问和修改Dictionary元素，或者通过下标语法，例如：\n\n```Swift\n//通过Dictionary的count属性来确定Dictionary的元素个数\nprint(\"The airports dictionary contains \\(airports.count) items.\")\n\n//通过Dictionary的Bool属性isEmpty来判断Dictionary是否为空\nif airports.isEmpty {\n    print(\"The airports dictionary is empty.\")\n} else {\n    print(\"The airports dictionary is not empty.\")\n}\n\n//通过下标语法添加或者修改Dictionary中的元素\nairports[\"LHR\"] = \"London\"\n\n//可以通过updateValue(_:forKey:) 方法添加或者修改Dictionary中的元素。\n//需要注意的是如果执行更新操作，该方法会返回旧的Value值\nif let oldValue = airports.updateValue(\"Dublin Airport\", forKey: \"DUB\") {\n    print(\"The old value for DUB was \\(oldValue).\")\n}\n\n\n//可以通过下标语法来访问某个key对应的value\nif let airportName = airports[\"DUB\"] {\n    print(\"The name of the airport is \\(airportName).\")\n} else {\n    print(\"That airport is not in the airports dictionary.\")\n}\n\n//可以通过下标语法来移除某个<key,value>元素\nairports[\"APL\"] = \"Apple International\"\nairports[\"APL\"] = nil\n\n//可以通过removeValue(forKey:) 方法移除某个<key,value>元素\nif let removedValue = airports.removeValue(forKey: \"DUB\") {\n    print(\"The removed airport's name is \\(removedValue).\")\n} else {\n    print(\"The airports dictionary does not contain a value for DUB.\")\n}\n```\n\n#### Dictionary的遍历\n通过使用`for-in`循环来遍历Dictionary，每个Dictionary元素是以(key,value)元组的形式，例如：\n\n```Swift\nfor (airportCode, airportName) in airports {\n    print(\"\\(airportCode): \\(airportName)\")\n}\n// YYZ: Toronto Pearson\n// LHR: London Heathrow\n\nfor airportCode in airports.keys {\n    print(\"Airport code: \\(airportCode)\")\n}\n// Airport code: YYZ\n// Airport code: LHR\n \nfor airportName in airports.values {\n    print(\"Airport name: \\(airportName)\")\n}\n// Airport name: Toronto Pearson\n// Airport name: London Heathrow\n\n```\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/CollectionTypes.html/\">CollectionTypes</a> \n\n>\n>\n>\n>\n>\n>\n>​Copyright (c) liangtong. All rights reserved.\n>\n\n\n","source":"_posts/iOS_Swift_language_note_Collection-Types.md","raw":"---\nlayout:     post\ntitle:      Swift Collection Types\ndate:       2016-11-06 00:20:11\nauthor:     liangtong\ncatalog: true\ncategories: iOS\ntags: Swift \n\n---\n\n\n\n​\t同其他语言类型类似，Swift提供了3个集合类型`Array`、`Set`和`Dictionary`来存储集合值。与ObjC不同的是，Swift中的集合属于范型，不能不同类型的数据添加的同一个集合类型中，且Swift中的集合类型变量都支持修改。\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/CollectionTypes_intro_2x.png)\n\n\n\n### Array\n数组类型是存储相同类型数据的有序列表，其中数组不同位置存储的数可以相同。Swift中的`Array`类型是Foundation框架中的`NSArray`类型的桥接.Swift中Array属于范型类，具体的写法是`Array<Element>`或者`[Element]`，两种写法相同。\n\n\n<!-- more -->\n\n#### 数组的创建\n可以通过`[Element](), []`的形式创建空数组，可以通过Array提供方法进行创建，当然也可以通过字面值`[value 1, value 2, value 3]`的形式创建并初始化一个数组\n\n```Swift\nvar someInts = [Int]()//创建一个空的Int数组\nsomeInts.append(3)//数组中添加一个元素\nsomeInts = []//数组被清空\n\n// threeDoubles is of type [Double], and equals [0.0, 0.0, 0.0]\nvar threeDoubles = Array(repeating: 0.0, count: 3)\n\nvar shoppingList: [String] = [\"Eggs\", \"Milk”]\n```\n\n#### 数组的组合\n可以通过操作符`+`将两个形同类型元素的数组合并到一起。\n\n```Swift\nvar anotherThreeDoubles = Array(repeating: 2.5, count: 3)\n// anotherThreeDoubles is of type [Double], and equals [2.5, 2.5, 2.5]\n \nvar sixDoubles = threeDoubles + anotherThreeDoubles\n// sixDoubles is inferred as [Double], and equals [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]\n```\n\n#### 数组元素的访问和修改\n可以通过调用数组的方法和属性来访问和修改数组元素，或者通过下标语法，比如：\n\n```Swift\n//通过数组的count属性来确定数组的元素\nprint(\"The shopping list contains \\(shoppingList.count) items.\")\n\n//通过数组的Bool属性isEmpty来判断数组是否为空\nif shoppingList.isEmpty {\n    print(\"The shopping list is empty.\")\n} else {\n    print(\"The shopping list is not empty.\")\n}\n\n//通过调用数组的append方法来给数组添加元素\nshoppingList.append(\"Flour\")\n\n//当然也可以通过操作符+=给数组添加元素（合并数组）\nshoppingList += [\"Baking Powder\"]\nshoppingList += [\"Chocolate Spread\", \"Cheese\", \"Butter\"]\n\n//通过下标访问和修改数组元素：如果越界会导致运行时错误\nvar firstItem = shoppingList[0]\nshoppingList[0] = \"Six eggs\"\n\n//当然也可以通过下标来同时修改一个范围元素，长度不相同也无所谓\nshoppingList[4...6] = [\"Bananas\", \"Apples\"]\n\n//可以通过insert方法向数组中插入元素\nshoppingList.insert(\"Maple Syrup\", at: 0)\n\n//可以通过remove方法向移除数组特定位置的元素\nlet mapleSyrup = shoppingList.remove(at: 0)\n```\n\n#### 数组的遍历\n通过使用`for-in`循环来遍历数组，当然如果需要数组对应下标值的话，可以通过`enumerated()`方法（对于数组的`enumerated()`方法，会返回一个包含整形索引和具体值的元组）。例如：\n\n```Swift\nfor item in shoppingList {\n    print(item)\n}\n\nfor (index, value) in shoppingList.enumerated() {\n    print(\"Item \\(index + 1): \\(value)\")\n}\n```\n\n### Set\nSet是用来存储不重复的相同类型元素`无序`列表；Swift中的`Set`类型是Foundation框架中的`NSSet`类型的桥接。\n\n#### Set类型的哈希值\n存储在Set类型中的元素必须是`hashable`的（用来保证存储在Set中的元素唯一）。Swift中Set类型的创建语法格式为`Set[Element]`。与其他语言一样，不再赘述\n\n > 注：可以通过实现Swfit中的`Hashable`协议来自定义存储在Set集合中的元素\n\n#### Set类型的创建\n可以通过`Set<Element>(), []`语法创建一个Set类型对象，当然也可以通过字面值`[value 1, value 2, value 3]`的形式创建并初始化一个Set对象，例如：\n\n```Swift\n//创建一个空的Character类型的Set对象\nvar letters = Set<Character>()\n\n//通过调用inset方法，向Set中添加元素\nletters.insert(\"a\")\n\n//Set被清空\nletters = []\n\n//通过字面值创建并初始化Set集合\nvar favoriteGenres: Set<String> = [\"Rock\", \"Classical\", \"Hip hop\"]\n//也可以这样写，Swift存在类型推断\nvar favoriteGenres: Set = [\"Rock\", \"Classical\", \"Hip hop\"]\n```\n\n#### Set对象的访问和修改\n可以通过调用Set的方法和属性来访问和修改Set元素，例如：\n\n```Swift\n//通过Set的count属性来确定Set的元素\nprint(\"I have \\(favoriteGenres.count) favorite music genres.\")\n\n//通过Set的Bool属性isEmpty来判断Set是否为空\nif favoriteGenres.isEmpty {\n    print(\"As far as music goes, I'm not picky.\")\n} else {\n    print(\"I have particular music preferences.\")\n}\n\n//通过调用Set的insert方法来给Set添加元素\nfavoriteGenres.insert(\"Jazz\")\n\n//可以通过remove方法向移除Set中的特定元素\nif let removedGenre = favoriteGenres.remove(\"Rock\") {\n    print(\"\\(removedGenre)? I'm over it.\")\n} else {\n    print(\"I never much cared for that.\")\n}\n\n//通过调用Set的contains方法来判断Set是否包含某个元素\nif favoriteGenres.contains(\"Funk\") {\n    print(\"I get up on the good foot.\")\n} else {\n    print(\"It's too funky in here.\")\n}\n// Prints \"It's too funky in here.\"\n\n```\n\n#### Set的遍历\n通过使用`for-in`循环来遍历Set，Set对象是无序列表，如果想要顺序访问具体对象值，可以调用Set的`sorted()`方法。例如：\n\n```Swift\nfor genre in favoriteGenres {\n    print(\"\\(genre)\")\n}\n// Jazz\n// Hip hop\n// Classical\n\nfor genre in favoriteGenres.sorted() {\n    print(\"\\(genre)\")\n}\n// Classical\n// Hip hop\n// Jazz\n```\n\n#### Set常用运算\n常用操作如下：\n\n > * operator (==) 判断是非相等\n > * isSubset(of:) 判断Set是否子集\n > * isSuperset(of:) 判断是否超级\n > * isStrictSubset(of:) 或 isStrictSuperset(of:) 判断是否是子集或者超集，但不相等\n > * isDisjoint(with:) 判断两个Set是否有相同元素\n\n再放一张图吧\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/setVennDiagram_2x.png)\n\n\n\n### Dictionary\nDictionary存储<Key,Value>键值对，其中键key值必须唯一，Swift中的`Dictionary `类型是Foundation框架中的`NSDictionary `类型的桥接。\n\n#### Dictionary的创建\n可以通过`[Key:Value](), []`的形式创建空Dictionary，也可以通过字面值`[key 1: value 1, key 2: value 2, key 3: value 3]`的形式创建。例如：\n\n```Swift\n//创建一个空字典\nvar namesOfIntegers = [Int: String]()\n\n//字典的赋值\nnamesOfIntegers[16] = \"sixteen\"\n\n//字典的清空\nnamesOfIntegers = [:]\n\n//通过字面值创建\nvar airports: [String: String] = [\"YYZ\": \"Toronto Pearson\", \"DUB\": \"Dublin\"]\n//类型推断\nvar airports = [\"YYZ\": \"Toronto Pearson\", \"DUB\": \"Dublin\"]\n\n```\n\n#### Dictionary对象的访问和修改\n可以通过调用Dictionary的方法和属性来访问和修改Dictionary元素，或者通过下标语法，例如：\n\n```Swift\n//通过Dictionary的count属性来确定Dictionary的元素个数\nprint(\"The airports dictionary contains \\(airports.count) items.\")\n\n//通过Dictionary的Bool属性isEmpty来判断Dictionary是否为空\nif airports.isEmpty {\n    print(\"The airports dictionary is empty.\")\n} else {\n    print(\"The airports dictionary is not empty.\")\n}\n\n//通过下标语法添加或者修改Dictionary中的元素\nairports[\"LHR\"] = \"London\"\n\n//可以通过updateValue(_:forKey:) 方法添加或者修改Dictionary中的元素。\n//需要注意的是如果执行更新操作，该方法会返回旧的Value值\nif let oldValue = airports.updateValue(\"Dublin Airport\", forKey: \"DUB\") {\n    print(\"The old value for DUB was \\(oldValue).\")\n}\n\n\n//可以通过下标语法来访问某个key对应的value\nif let airportName = airports[\"DUB\"] {\n    print(\"The name of the airport is \\(airportName).\")\n} else {\n    print(\"That airport is not in the airports dictionary.\")\n}\n\n//可以通过下标语法来移除某个<key,value>元素\nairports[\"APL\"] = \"Apple International\"\nairports[\"APL\"] = nil\n\n//可以通过removeValue(forKey:) 方法移除某个<key,value>元素\nif let removedValue = airports.removeValue(forKey: \"DUB\") {\n    print(\"The removed airport's name is \\(removedValue).\")\n} else {\n    print(\"The airports dictionary does not contain a value for DUB.\")\n}\n```\n\n#### Dictionary的遍历\n通过使用`for-in`循环来遍历Dictionary，每个Dictionary元素是以(key,value)元组的形式，例如：\n\n```Swift\nfor (airportCode, airportName) in airports {\n    print(\"\\(airportCode): \\(airportName)\")\n}\n// YYZ: Toronto Pearson\n// LHR: London Heathrow\n\nfor airportCode in airports.keys {\n    print(\"Airport code: \\(airportCode)\")\n}\n// Airport code: YYZ\n// Airport code: LHR\n \nfor airportName in airports.values {\n    print(\"Airport name: \\(airportName)\")\n}\n// Airport name: Toronto Pearson\n// Airport name: London Heathrow\n\n```\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/CollectionTypes.html/\">CollectionTypes</a> \n\n>\n>\n>\n>\n>\n>\n>​Copyright (c) liangtong. All rights reserved.\n>\n\n\n","slug":"iOS_Swift_language_note_Collection-Types","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4u5002hoko8fqjh1ct2","content":"<p>​    同其他语言类型类似，Swift提供了3个集合类型<code>Array</code>、<code>Set</code>和<code>Dictionary</code>来存储集合值。与ObjC不同的是，Swift中的集合属于范型，不能不同类型的数据添加的同一个集合类型中，且Swift中的集合类型变量都支持修改。<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/CollectionTypes_intro_2x.png\" alt=\"\"></p>\n<h3 id=\"Array\"><a href=\"#Array\" class=\"headerlink\" title=\"Array\"></a>Array</h3><p>数组类型是存储相同类型数据的有序列表，其中数组不同位置存储的数可以相同。Swift中的<code>Array</code>类型是Foundation框架中的<code>NSArray</code>类型的桥接.Swift中Array属于范型类，具体的写法是<code>Array&lt;Element&gt;</code>或者<code>[Element]</code>，两种写法相同。</p>\n<a id=\"more\"></a>\n<h4 id=\"数组的创建\"><a href=\"#数组的创建\" class=\"headerlink\" title=\"数组的创建\"></a>数组的创建</h4><p>可以通过<code>[Element](), []</code>的形式创建空数组，可以通过Array提供方法进行创建，当然也可以通过字面值<code>[value 1, value 2, value 3]</code>的形式创建并初始化一个数组</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> someInts = [<span class=\"type\">Int</span>]()<span class=\"comment\">//创建一个空的Int数组</span></div><div class=\"line\">someInts.append(<span class=\"number\">3</span>)<span class=\"comment\">//数组中添加一个元素</span></div><div class=\"line\">someInts = []<span class=\"comment\">//数组被清空</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// threeDoubles is of type [Double], and equals [0.0, 0.0, 0.0]</span></div><div class=\"line\"><span class=\"keyword\">var</span> threeDoubles = <span class=\"type\">Array</span>(repeating: <span class=\"number\">0.0</span>, <span class=\"built_in\">count</span>: <span class=\"number\">3</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> shoppingList: [<span class=\"type\">String</span>] = [<span class=\"string\">\"Eggs\"</span>, <span class=\"string\">\"Milk”]</span></div></pre></td></tr></table></figure>\n<h4 id=\"数组的组合\"><a href=\"#数组的组合\" class=\"headerlink\" title=\"数组的组合\"></a>数组的组合</h4><p>可以通过操作符<code>+</code>将两个形同类型元素的数组合并到一起。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> anotherThreeDoubles = <span class=\"type\">Array</span>(repeating: <span class=\"number\">2.5</span>, <span class=\"built_in\">count</span>: <span class=\"number\">3</span>)</div><div class=\"line\"><span class=\"comment\">// anotherThreeDoubles is of type [Double], and equals [2.5, 2.5, 2.5]</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">var</span> sixDoubles = threeDoubles + anotherThreeDoubles</div><div class=\"line\"><span class=\"comment\">// sixDoubles is inferred as [Double], and equals [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]</span></div></pre></td></tr></table></figure>\n<h4 id=\"数组元素的访问和修改\"><a href=\"#数组元素的访问和修改\" class=\"headerlink\" title=\"数组元素的访问和修改\"></a>数组元素的访问和修改</h4><p>可以通过调用数组的方法和属性来访问和修改数组元素，或者通过下标语法，比如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//通过数组的count属性来确定数组的元素</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The shopping list contains <span class=\"subst\">\\(shoppingList.<span class=\"built_in\">count</span>)</span> items.\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//通过数组的Bool属性isEmpty来判断数组是否为空</span></div><div class=\"line\"><span class=\"keyword\">if</span> shoppingList.isEmpty &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The shopping list is empty.\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The shopping list is not empty.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//通过调用数组的append方法来给数组添加元素</span></div><div class=\"line\">shoppingList.append(<span class=\"string\">\"Flour\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//当然也可以通过操作符+=给数组添加元素（合并数组）</span></div><div class=\"line\">shoppingList += [<span class=\"string\">\"Baking Powder\"</span>]</div><div class=\"line\">shoppingList += [<span class=\"string\">\"Chocolate Spread\"</span>, <span class=\"string\">\"Cheese\"</span>, <span class=\"string\">\"Butter\"</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//通过下标访问和修改数组元素：如果越界会导致运行时错误</span></div><div class=\"line\"><span class=\"keyword\">var</span> firstItem = shoppingList[<span class=\"number\">0</span>]</div><div class=\"line\">shoppingList[<span class=\"number\">0</span>] = <span class=\"string\">\"Six eggs\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//当然也可以通过下标来同时修改一个范围元素，长度不相同也无所谓</span></div><div class=\"line\">shoppingList[<span class=\"number\">4</span>...<span class=\"number\">6</span>] = [<span class=\"string\">\"Bananas\"</span>, <span class=\"string\">\"Apples\"</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//可以通过insert方法向数组中插入元素</span></div><div class=\"line\">shoppingList.insert(<span class=\"string\">\"Maple Syrup\"</span>, at: <span class=\"number\">0</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//可以通过remove方法向移除数组特定位置的元素</span></div><div class=\"line\"><span class=\"keyword\">let</span> mapleSyrup = shoppingList.remove(at: <span class=\"number\">0</span>)</div></pre></td></tr></table></figure>\n<h4 id=\"数组的遍历\"><a href=\"#数组的遍历\" class=\"headerlink\" title=\"数组的遍历\"></a>数组的遍历</h4><p>通过使用<code>for-in</code>循环来遍历数组，当然如果需要数组对应下标值的话，可以通过<code>enumerated()</code>方法（对于数组的<code>enumerated()</code>方法，会返回一个包含整形索引和具体值的元组）。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> shoppingList &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(item)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (index, value) <span class=\"keyword\">in</span> shoppingList.enumerated() &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Item <span class=\"subst\">\\(index + <span class=\"number\">1</span>)</span>: <span class=\"subst\">\\(value)</span>\"</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><p>Set是用来存储不重复的相同类型元素<code>无序</code>列表；Swift中的<code>Set</code>类型是Foundation框架中的<code>NSSet</code>类型的桥接。</p>\n<h4 id=\"Set类型的哈希值\"><a href=\"#Set类型的哈希值\" class=\"headerlink\" title=\"Set类型的哈希值\"></a>Set类型的哈希值</h4><p>存储在Set类型中的元素必须是<code>hashable</code>的（用来保证存储在Set中的元素唯一）。Swift中Set类型的创建语法格式为<code>Set[Element]</code>。与其他语言一样，不再赘述</p>\n<blockquote>\n<p>注：可以通过实现Swfit中的<code>Hashable</code>协议来自定义存储在Set集合中的元素</p>\n</blockquote>\n<h4 id=\"Set类型的创建\"><a href=\"#Set类型的创建\" class=\"headerlink\" title=\"Set类型的创建\"></a>Set类型的创建</h4><p>可以通过<code>Set&lt;Element&gt;(), []</code>语法创建一个Set类型对象，当然也可以通过字面值<code>[value 1, value 2, value 3]</code>的形式创建并初始化一个Set对象，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建一个空的Character类型的Set对象</span></div><div class=\"line\"><span class=\"keyword\">var</span> letters = <span class=\"type\">Set</span>&lt;<span class=\"type\">Character</span>&gt;()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//通过调用inset方法，向Set中添加元素</span></div><div class=\"line\">letters.insert(<span class=\"string\">\"a\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Set被清空</span></div><div class=\"line\">letters = []</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//通过字面值创建并初始化Set集合</span></div><div class=\"line\"><span class=\"keyword\">var</span> favoriteGenres: <span class=\"type\">Set</span>&lt;<span class=\"type\">String</span>&gt; = [<span class=\"string\">\"Rock\"</span>, <span class=\"string\">\"Classical\"</span>, <span class=\"string\">\"Hip hop\"</span>]</div><div class=\"line\"><span class=\"comment\">//也可以这样写，Swift存在类型推断</span></div><div class=\"line\"><span class=\"keyword\">var</span> favoriteGenres: <span class=\"type\">Set</span> = [<span class=\"string\">\"Rock\"</span>, <span class=\"string\">\"Classical\"</span>, <span class=\"string\">\"Hip hop\"</span>]</div></pre></td></tr></table></figure>\n<h4 id=\"Set对象的访问和修改\"><a href=\"#Set对象的访问和修改\" class=\"headerlink\" title=\"Set对象的访问和修改\"></a>Set对象的访问和修改</h4><p>可以通过调用Set的方法和属性来访问和修改Set元素，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//通过Set的count属性来确定Set的元素</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"I have <span class=\"subst\">\\(favoriteGenres.<span class=\"built_in\">count</span>)</span> favorite music genres.\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//通过Set的Bool属性isEmpty来判断Set是否为空</span></div><div class=\"line\"><span class=\"keyword\">if</span> favoriteGenres.isEmpty &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"As far as music goes, I'm not picky.\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"I have particular music preferences.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//通过调用Set的insert方法来给Set添加元素</span></div><div class=\"line\">favoriteGenres.insert(<span class=\"string\">\"Jazz\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//可以通过remove方法向移除Set中的特定元素</span></div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> removedGenre = favoriteGenres.remove(<span class=\"string\">\"Rock\"</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(removedGenre)</span>? I'm over it.\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"I never much cared for that.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//通过调用Set的contains方法来判断Set是否包含某个元素</span></div><div class=\"line\"><span class=\"keyword\">if</span> favoriteGenres.<span class=\"built_in\">contains</span>(<span class=\"string\">\"Funk\"</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"I get up on the good foot.\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"It's too funky in here.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"It's too funky in here.\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"Set的遍历\"><a href=\"#Set的遍历\" class=\"headerlink\" title=\"Set的遍历\"></a>Set的遍历</h4><p>通过使用<code>for-in</code>循环来遍历Set，Set对象是无序列表，如果想要顺序访问具体对象值，可以调用Set的<code>sorted()</code>方法。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> genre <span class=\"keyword\">in</span> favoriteGenres &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(genre)</span>\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Jazz</span></div><div class=\"line\"><span class=\"comment\">// Hip hop</span></div><div class=\"line\"><span class=\"comment\">// Classical</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> genre <span class=\"keyword\">in</span> favoriteGenres.sorted() &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(genre)</span>\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Classical</span></div><div class=\"line\"><span class=\"comment\">// Hip hop</span></div><div class=\"line\"><span class=\"comment\">// Jazz</span></div></pre></td></tr></table></figure>\n<h4 id=\"Set常用运算\"><a href=\"#Set常用运算\" class=\"headerlink\" title=\"Set常用运算\"></a>Set常用运算</h4><p>常用操作如下：</p>\n<blockquote>\n<ul>\n<li>operator (==) 判断是非相等</li>\n<li>isSubset(of:) 判断Set是否子集</li>\n<li>isSuperset(of:) 判断是否超级</li>\n<li>isStrictSubset(of:) 或 isStrictSuperset(of:) 判断是否是子集或者超集，但不相等</li>\n<li>isDisjoint(with:) 判断两个Set是否有相同元素</li>\n</ul>\n</blockquote>\n<p>再放一张图吧<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/setVennDiagram_2x.png\" alt=\"\"></p>\n<h3 id=\"Dictionary\"><a href=\"#Dictionary\" class=\"headerlink\" title=\"Dictionary\"></a>Dictionary</h3><p>Dictionary存储<key,value>键值对，其中键key值必须唯一，Swift中的<code>Dictionary</code>类型是Foundation框架中的<code>NSDictionary</code>类型的桥接。</key,value></p>\n<h4 id=\"Dictionary的创建\"><a href=\"#Dictionary的创建\" class=\"headerlink\" title=\"Dictionary的创建\"></a>Dictionary的创建</h4><p>可以通过<code>[Key:Value](), []</code>的形式创建空Dictionary，也可以通过字面值<code>[key 1: value 1, key 2: value 2, key 3: value 3]</code>的形式创建。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建一个空字典</span></div><div class=\"line\"><span class=\"keyword\">var</span> namesOfIntegers = [<span class=\"type\">Int</span>: <span class=\"type\">String</span>]()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//字典的赋值</span></div><div class=\"line\">namesOfIntegers[<span class=\"number\">16</span>] = <span class=\"string\">\"sixteen\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//字典的清空</span></div><div class=\"line\">namesOfIntegers = [:]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//通过字面值创建</span></div><div class=\"line\"><span class=\"keyword\">var</span> airports: [<span class=\"type\">String</span>: <span class=\"type\">String</span>] = [<span class=\"string\">\"YYZ\"</span>: <span class=\"string\">\"Toronto Pearson\"</span>, <span class=\"string\">\"DUB\"</span>: <span class=\"string\">\"Dublin\"</span>]</div><div class=\"line\"><span class=\"comment\">//类型推断</span></div><div class=\"line\"><span class=\"keyword\">var</span> airports = [<span class=\"string\">\"YYZ\"</span>: <span class=\"string\">\"Toronto Pearson\"</span>, <span class=\"string\">\"DUB\"</span>: <span class=\"string\">\"Dublin\"</span>]</div></pre></td></tr></table></figure>\n<h4 id=\"Dictionary对象的访问和修改\"><a href=\"#Dictionary对象的访问和修改\" class=\"headerlink\" title=\"Dictionary对象的访问和修改\"></a>Dictionary对象的访问和修改</h4><p>可以通过调用Dictionary的方法和属性来访问和修改Dictionary元素，或者通过下标语法，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//通过Dictionary的count属性来确定Dictionary的元素个数</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The airports dictionary contains <span class=\"subst\">\\(airports.<span class=\"built_in\">count</span>)</span> items.\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//通过Dictionary的Bool属性isEmpty来判断Dictionary是否为空</span></div><div class=\"line\"><span class=\"keyword\">if</span> airports.isEmpty &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The airports dictionary is empty.\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The airports dictionary is not empty.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//通过下标语法添加或者修改Dictionary中的元素</span></div><div class=\"line\">airports[<span class=\"string\">\"LHR\"</span>] = <span class=\"string\">\"London\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//可以通过updateValue(_:forKey:) 方法添加或者修改Dictionary中的元素。</span></div><div class=\"line\"><span class=\"comment\">//需要注意的是如果执行更新操作，该方法会返回旧的Value值</span></div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> oldValue = airports.updateValue(<span class=\"string\">\"Dublin Airport\"</span>, forKey: <span class=\"string\">\"DUB\"</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The old value for DUB was <span class=\"subst\">\\(oldValue)</span>.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//可以通过下标语法来访问某个key对应的value</span></div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> airportName = airports[<span class=\"string\">\"DUB\"</span>] &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The name of the airport is <span class=\"subst\">\\(airportName)</span>.\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"That airport is not in the airports dictionary.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//可以通过下标语法来移除某个&lt;key,value&gt;元素</span></div><div class=\"line\">airports[<span class=\"string\">\"APL\"</span>] = <span class=\"string\">\"Apple International\"</span></div><div class=\"line\">airports[<span class=\"string\">\"APL\"</span>] = <span class=\"literal\">nil</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//可以通过removeValue(forKey:) 方法移除某个&lt;key,value&gt;元素</span></div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> removedValue = airports.removeValue(forKey: <span class=\"string\">\"DUB\"</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The removed airport's name is <span class=\"subst\">\\(removedValue)</span>.\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The airports dictionary does not contain a value for DUB.\"</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"Dictionary的遍历\"><a href=\"#Dictionary的遍历\" class=\"headerlink\" title=\"Dictionary的遍历\"></a>Dictionary的遍历</h4><p>通过使用<code>for-in</code>循环来遍历Dictionary，每个Dictionary元素是以(key,value)元组的形式，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (airportCode, airportName) <span class=\"keyword\">in</span> airports &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(airportCode)</span>: <span class=\"subst\">\\(airportName)</span>\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// YYZ: Toronto Pearson</span></div><div class=\"line\"><span class=\"comment\">// LHR: London Heathrow</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> airportCode <span class=\"keyword\">in</span> airports.keys &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Airport code: <span class=\"subst\">\\(airportCode)</span>\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Airport code: YYZ</span></div><div class=\"line\"><span class=\"comment\">// Airport code: LHR</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">for</span> airportName <span class=\"keyword\">in</span> airports.values &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Airport name: <span class=\"subst\">\\(airportName)</span>\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Airport name: Toronto Pearson</span></div><div class=\"line\"><span class=\"comment\">// Airport name: London Heathrow</span></div></pre></td></tr></table></figure>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/CollectionTypes.html/\" target=\"_blank\" rel=\"external\">CollectionTypes</a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;</p>\n<blockquote>\n<p>​Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>​    同其他语言类型类似，Swift提供了3个集合类型<code>Array</code>、<code>Set</code>和<code>Dictionary</code>来存储集合值。与ObjC不同的是，Swift中的集合属于范型，不能不同类型的数据添加的同一个集合类型中，且Swift中的集合类型变量都支持修改。<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/CollectionTypes_intro_2x.png\" alt=\"\"></p>\n<h3 id=\"Array\"><a href=\"#Array\" class=\"headerlink\" title=\"Array\"></a>Array</h3><p>数组类型是存储相同类型数据的有序列表，其中数组不同位置存储的数可以相同。Swift中的<code>Array</code>类型是Foundation框架中的<code>NSArray</code>类型的桥接.Swift中Array属于范型类，具体的写法是<code>Array&lt;Element&gt;</code>或者<code>[Element]</code>，两种写法相同。</p>","more":"<h4 id=\"数组的创建\"><a href=\"#数组的创建\" class=\"headerlink\" title=\"数组的创建\"></a>数组的创建</h4><p>可以通过<code>[Element](), []</code>的形式创建空数组，可以通过Array提供方法进行创建，当然也可以通过字面值<code>[value 1, value 2, value 3]</code>的形式创建并初始化一个数组</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> someInts = [<span class=\"type\">Int</span>]()<span class=\"comment\">//创建一个空的Int数组</span></div><div class=\"line\">someInts.append(<span class=\"number\">3</span>)<span class=\"comment\">//数组中添加一个元素</span></div><div class=\"line\">someInts = []<span class=\"comment\">//数组被清空</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// threeDoubles is of type [Double], and equals [0.0, 0.0, 0.0]</span></div><div class=\"line\"><span class=\"keyword\">var</span> threeDoubles = <span class=\"type\">Array</span>(repeating: <span class=\"number\">0.0</span>, <span class=\"built_in\">count</span>: <span class=\"number\">3</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> shoppingList: [<span class=\"type\">String</span>] = [<span class=\"string\">\"Eggs\"</span>, <span class=\"string\">\"Milk”]</span></div></pre></td></tr></table></figure>\n<h4 id=\"数组的组合\"><a href=\"#数组的组合\" class=\"headerlink\" title=\"数组的组合\"></a>数组的组合</h4><p>可以通过操作符<code>+</code>将两个形同类型元素的数组合并到一起。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> anotherThreeDoubles = <span class=\"type\">Array</span>(repeating: <span class=\"number\">2.5</span>, <span class=\"built_in\">count</span>: <span class=\"number\">3</span>)</div><div class=\"line\"><span class=\"comment\">// anotherThreeDoubles is of type [Double], and equals [2.5, 2.5, 2.5]</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">var</span> sixDoubles = threeDoubles + anotherThreeDoubles</div><div class=\"line\"><span class=\"comment\">// sixDoubles is inferred as [Double], and equals [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]</span></div></pre></td></tr></table></figure>\n<h4 id=\"数组元素的访问和修改\"><a href=\"#数组元素的访问和修改\" class=\"headerlink\" title=\"数组元素的访问和修改\"></a>数组元素的访问和修改</h4><p>可以通过调用数组的方法和属性来访问和修改数组元素，或者通过下标语法，比如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//通过数组的count属性来确定数组的元素</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The shopping list contains <span class=\"subst\">\\(shoppingList.<span class=\"built_in\">count</span>)</span> items.\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//通过数组的Bool属性isEmpty来判断数组是否为空</span></div><div class=\"line\"><span class=\"keyword\">if</span> shoppingList.isEmpty &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The shopping list is empty.\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The shopping list is not empty.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//通过调用数组的append方法来给数组添加元素</span></div><div class=\"line\">shoppingList.append(<span class=\"string\">\"Flour\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//当然也可以通过操作符+=给数组添加元素（合并数组）</span></div><div class=\"line\">shoppingList += [<span class=\"string\">\"Baking Powder\"</span>]</div><div class=\"line\">shoppingList += [<span class=\"string\">\"Chocolate Spread\"</span>, <span class=\"string\">\"Cheese\"</span>, <span class=\"string\">\"Butter\"</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//通过下标访问和修改数组元素：如果越界会导致运行时错误</span></div><div class=\"line\"><span class=\"keyword\">var</span> firstItem = shoppingList[<span class=\"number\">0</span>]</div><div class=\"line\">shoppingList[<span class=\"number\">0</span>] = <span class=\"string\">\"Six eggs\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//当然也可以通过下标来同时修改一个范围元素，长度不相同也无所谓</span></div><div class=\"line\">shoppingList[<span class=\"number\">4</span>...<span class=\"number\">6</span>] = [<span class=\"string\">\"Bananas\"</span>, <span class=\"string\">\"Apples\"</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//可以通过insert方法向数组中插入元素</span></div><div class=\"line\">shoppingList.insert(<span class=\"string\">\"Maple Syrup\"</span>, at: <span class=\"number\">0</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//可以通过remove方法向移除数组特定位置的元素</span></div><div class=\"line\"><span class=\"keyword\">let</span> mapleSyrup = shoppingList.remove(at: <span class=\"number\">0</span>)</div></pre></td></tr></table></figure>\n<h4 id=\"数组的遍历\"><a href=\"#数组的遍历\" class=\"headerlink\" title=\"数组的遍历\"></a>数组的遍历</h4><p>通过使用<code>for-in</code>循环来遍历数组，当然如果需要数组对应下标值的话，可以通过<code>enumerated()</code>方法（对于数组的<code>enumerated()</code>方法，会返回一个包含整形索引和具体值的元组）。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> shoppingList &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(item)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (index, value) <span class=\"keyword\">in</span> shoppingList.enumerated() &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Item <span class=\"subst\">\\(index + <span class=\"number\">1</span>)</span>: <span class=\"subst\">\\(value)</span>\"</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><p>Set是用来存储不重复的相同类型元素<code>无序</code>列表；Swift中的<code>Set</code>类型是Foundation框架中的<code>NSSet</code>类型的桥接。</p>\n<h4 id=\"Set类型的哈希值\"><a href=\"#Set类型的哈希值\" class=\"headerlink\" title=\"Set类型的哈希值\"></a>Set类型的哈希值</h4><p>存储在Set类型中的元素必须是<code>hashable</code>的（用来保证存储在Set中的元素唯一）。Swift中Set类型的创建语法格式为<code>Set[Element]</code>。与其他语言一样，不再赘述</p>\n<blockquote>\n<p>注：可以通过实现Swfit中的<code>Hashable</code>协议来自定义存储在Set集合中的元素</p>\n</blockquote>\n<h4 id=\"Set类型的创建\"><a href=\"#Set类型的创建\" class=\"headerlink\" title=\"Set类型的创建\"></a>Set类型的创建</h4><p>可以通过<code>Set&lt;Element&gt;(), []</code>语法创建一个Set类型对象，当然也可以通过字面值<code>[value 1, value 2, value 3]</code>的形式创建并初始化一个Set对象，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建一个空的Character类型的Set对象</span></div><div class=\"line\"><span class=\"keyword\">var</span> letters = <span class=\"type\">Set</span>&lt;<span class=\"type\">Character</span>&gt;()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//通过调用inset方法，向Set中添加元素</span></div><div class=\"line\">letters.insert(<span class=\"string\">\"a\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//Set被清空</span></div><div class=\"line\">letters = []</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//通过字面值创建并初始化Set集合</span></div><div class=\"line\"><span class=\"keyword\">var</span> favoriteGenres: <span class=\"type\">Set</span>&lt;<span class=\"type\">String</span>&gt; = [<span class=\"string\">\"Rock\"</span>, <span class=\"string\">\"Classical\"</span>, <span class=\"string\">\"Hip hop\"</span>]</div><div class=\"line\"><span class=\"comment\">//也可以这样写，Swift存在类型推断</span></div><div class=\"line\"><span class=\"keyword\">var</span> favoriteGenres: <span class=\"type\">Set</span> = [<span class=\"string\">\"Rock\"</span>, <span class=\"string\">\"Classical\"</span>, <span class=\"string\">\"Hip hop\"</span>]</div></pre></td></tr></table></figure>\n<h4 id=\"Set对象的访问和修改\"><a href=\"#Set对象的访问和修改\" class=\"headerlink\" title=\"Set对象的访问和修改\"></a>Set对象的访问和修改</h4><p>可以通过调用Set的方法和属性来访问和修改Set元素，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//通过Set的count属性来确定Set的元素</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"I have <span class=\"subst\">\\(favoriteGenres.<span class=\"built_in\">count</span>)</span> favorite music genres.\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//通过Set的Bool属性isEmpty来判断Set是否为空</span></div><div class=\"line\"><span class=\"keyword\">if</span> favoriteGenres.isEmpty &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"As far as music goes, I'm not picky.\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"I have particular music preferences.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//通过调用Set的insert方法来给Set添加元素</span></div><div class=\"line\">favoriteGenres.insert(<span class=\"string\">\"Jazz\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//可以通过remove方法向移除Set中的特定元素</span></div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> removedGenre = favoriteGenres.remove(<span class=\"string\">\"Rock\"</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(removedGenre)</span>? I'm over it.\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"I never much cared for that.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//通过调用Set的contains方法来判断Set是否包含某个元素</span></div><div class=\"line\"><span class=\"keyword\">if</span> favoriteGenres.<span class=\"built_in\">contains</span>(<span class=\"string\">\"Funk\"</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"I get up on the good foot.\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"It's too funky in here.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"It's too funky in here.\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"Set的遍历\"><a href=\"#Set的遍历\" class=\"headerlink\" title=\"Set的遍历\"></a>Set的遍历</h4><p>通过使用<code>for-in</code>循环来遍历Set，Set对象是无序列表，如果想要顺序访问具体对象值，可以调用Set的<code>sorted()</code>方法。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> genre <span class=\"keyword\">in</span> favoriteGenres &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(genre)</span>\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Jazz</span></div><div class=\"line\"><span class=\"comment\">// Hip hop</span></div><div class=\"line\"><span class=\"comment\">// Classical</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> genre <span class=\"keyword\">in</span> favoriteGenres.sorted() &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(genre)</span>\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Classical</span></div><div class=\"line\"><span class=\"comment\">// Hip hop</span></div><div class=\"line\"><span class=\"comment\">// Jazz</span></div></pre></td></tr></table></figure>\n<h4 id=\"Set常用运算\"><a href=\"#Set常用运算\" class=\"headerlink\" title=\"Set常用运算\"></a>Set常用运算</h4><p>常用操作如下：</p>\n<blockquote>\n<ul>\n<li>operator (==) 判断是非相等</li>\n<li>isSubset(of:) 判断Set是否子集</li>\n<li>isSuperset(of:) 判断是否超级</li>\n<li>isStrictSubset(of:) 或 isStrictSuperset(of:) 判断是否是子集或者超集，但不相等</li>\n<li>isDisjoint(with:) 判断两个Set是否有相同元素</li>\n</ul>\n</blockquote>\n<p>再放一张图吧<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/setVennDiagram_2x.png\" alt=\"\"></p>\n<h3 id=\"Dictionary\"><a href=\"#Dictionary\" class=\"headerlink\" title=\"Dictionary\"></a>Dictionary</h3><p>Dictionary存储<key,value>键值对，其中键key值必须唯一，Swift中的<code>Dictionary</code>类型是Foundation框架中的<code>NSDictionary</code>类型的桥接。</key,value></p>\n<h4 id=\"Dictionary的创建\"><a href=\"#Dictionary的创建\" class=\"headerlink\" title=\"Dictionary的创建\"></a>Dictionary的创建</h4><p>可以通过<code>[Key:Value](), []</code>的形式创建空Dictionary，也可以通过字面值<code>[key 1: value 1, key 2: value 2, key 3: value 3]</code>的形式创建。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建一个空字典</span></div><div class=\"line\"><span class=\"keyword\">var</span> namesOfIntegers = [<span class=\"type\">Int</span>: <span class=\"type\">String</span>]()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//字典的赋值</span></div><div class=\"line\">namesOfIntegers[<span class=\"number\">16</span>] = <span class=\"string\">\"sixteen\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//字典的清空</span></div><div class=\"line\">namesOfIntegers = [:]</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//通过字面值创建</span></div><div class=\"line\"><span class=\"keyword\">var</span> airports: [<span class=\"type\">String</span>: <span class=\"type\">String</span>] = [<span class=\"string\">\"YYZ\"</span>: <span class=\"string\">\"Toronto Pearson\"</span>, <span class=\"string\">\"DUB\"</span>: <span class=\"string\">\"Dublin\"</span>]</div><div class=\"line\"><span class=\"comment\">//类型推断</span></div><div class=\"line\"><span class=\"keyword\">var</span> airports = [<span class=\"string\">\"YYZ\"</span>: <span class=\"string\">\"Toronto Pearson\"</span>, <span class=\"string\">\"DUB\"</span>: <span class=\"string\">\"Dublin\"</span>]</div></pre></td></tr></table></figure>\n<h4 id=\"Dictionary对象的访问和修改\"><a href=\"#Dictionary对象的访问和修改\" class=\"headerlink\" title=\"Dictionary对象的访问和修改\"></a>Dictionary对象的访问和修改</h4><p>可以通过调用Dictionary的方法和属性来访问和修改Dictionary元素，或者通过下标语法，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//通过Dictionary的count属性来确定Dictionary的元素个数</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The airports dictionary contains <span class=\"subst\">\\(airports.<span class=\"built_in\">count</span>)</span> items.\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//通过Dictionary的Bool属性isEmpty来判断Dictionary是否为空</span></div><div class=\"line\"><span class=\"keyword\">if</span> airports.isEmpty &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The airports dictionary is empty.\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The airports dictionary is not empty.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//通过下标语法添加或者修改Dictionary中的元素</span></div><div class=\"line\">airports[<span class=\"string\">\"LHR\"</span>] = <span class=\"string\">\"London\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//可以通过updateValue(_:forKey:) 方法添加或者修改Dictionary中的元素。</span></div><div class=\"line\"><span class=\"comment\">//需要注意的是如果执行更新操作，该方法会返回旧的Value值</span></div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> oldValue = airports.updateValue(<span class=\"string\">\"Dublin Airport\"</span>, forKey: <span class=\"string\">\"DUB\"</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The old value for DUB was <span class=\"subst\">\\(oldValue)</span>.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//可以通过下标语法来访问某个key对应的value</span></div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> airportName = airports[<span class=\"string\">\"DUB\"</span>] &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The name of the airport is <span class=\"subst\">\\(airportName)</span>.\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"That airport is not in the airports dictionary.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//可以通过下标语法来移除某个&lt;key,value&gt;元素</span></div><div class=\"line\">airports[<span class=\"string\">\"APL\"</span>] = <span class=\"string\">\"Apple International\"</span></div><div class=\"line\">airports[<span class=\"string\">\"APL\"</span>] = <span class=\"literal\">nil</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//可以通过removeValue(forKey:) 方法移除某个&lt;key,value&gt;元素</span></div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> removedValue = airports.removeValue(forKey: <span class=\"string\">\"DUB\"</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The removed airport's name is <span class=\"subst\">\\(removedValue)</span>.\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The airports dictionary does not contain a value for DUB.\"</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"Dictionary的遍历\"><a href=\"#Dictionary的遍历\" class=\"headerlink\" title=\"Dictionary的遍历\"></a>Dictionary的遍历</h4><p>通过使用<code>for-in</code>循环来遍历Dictionary，每个Dictionary元素是以(key,value)元组的形式，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (airportCode, airportName) <span class=\"keyword\">in</span> airports &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(airportCode)</span>: <span class=\"subst\">\\(airportName)</span>\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// YYZ: Toronto Pearson</span></div><div class=\"line\"><span class=\"comment\">// LHR: London Heathrow</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> airportCode <span class=\"keyword\">in</span> airports.keys &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Airport code: <span class=\"subst\">\\(airportCode)</span>\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Airport code: YYZ</span></div><div class=\"line\"><span class=\"comment\">// Airport code: LHR</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">for</span> airportName <span class=\"keyword\">in</span> airports.values &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Airport name: <span class=\"subst\">\\(airportName)</span>\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Airport name: Toronto Pearson</span></div><div class=\"line\"><span class=\"comment\">// Airport name: London Heathrow</span></div></pre></td></tr></table></figure>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/CollectionTypes.html/\" target=\"_blank\" rel=\"external\">CollectionTypes</a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;</p>\n<blockquote>\n<p>​Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>"},{"layout":"post","title":"Swift Control Flow","date":"2016-11-16T16:20:11.000Z","author":"liangtong","catalog":true,"_content":"\n\n\n​\tSwift提供了很多流程控制语法，包括可以通过使用`while`循环来重复执行一个任务，可以通过`if`、`guard`和`switch`来进行条件判断从而执行不同代码分支，可以通过`break`和`continue`来跳转到特定代码位置。\n​\tSwift也提供了诸如可以通过`for-in`循环来遍历数组，字典，区间(range)，字符串和其他一些序列(sequences)。\n​\tSwift的`switch`语句相对比C语言的`强大`(该关键字与其他多数语言不同，至于算不算优点，意见保留)。在Swift中，该语句中的`case`语法不会自动流转到下一个`case`，这避免了像C语言中因为缺失`break`语句导致的错误。而Swift中的Case语句也相对比较强大，可以匹配多种包括整型、元组、转换的特殊类型等形式。在Case语句中匹配的值可以被绑定到一个临时的常量或者变量中，从而在`case`语句对一个的代码块(body)中使用，一些复杂的匹配可以通过使用`where`表达式进行。\n\n\n\n### for-in 循环\n可以使用`for-in`循环来遍历一个序列，比如一个区间(range)中的数字、数组中的元素、字符串的字符，例如：\n\n\n<!-- more -->\n\n```Swift\n//使用index变量来访问range中的具体值。注意操作符`...`的用法\nfor index in 1...5 {\n    print(\"\\(index) times 5 is \\(index * 5)\")\n}\n//不关心range中的具体值，可以使用下划线’_’\nlet base = 3\nlet power = 10\nvar answer = 1\nfor _ in 1...power {\n    answer *= base\n}\nprint(\"\\(base) to the power of \\(power) is \\(answer)\")\n//遍历数组\nlet names = [\"Anna\", \"Alex\", \"Brian\", \"Jack\"]\nfor name in names {\n    print(\"Hello, \\(name)!\")\n}\n//字典，是以元组的形式来匹配的，当然也可以使用下划线’_’\nlet numberOfLegs = [\"spider\": 8, \"ant\": 6, \"cat\": 4]\nfor (animalName, legCount) in numberOfLegs {\n    print(\"\\(animalName)s have \\(legCount) legs\")\n}\n\n```\n### while循环\nwhile的代码块会一直被执行，知道条件变为flase。这类循环主要用在不确定遍历次数的情况下，Swift提供了两种while循环语法：`while`和`repeat-while`\n\n#### while\nwhile循环是以一个简单的bool条件式开始，当该条件为true的时，循环体会一直被执行。知道条件变为false。语法如下：\n\n```Swift\nwhile condition {\n    statements\n}\n```\n\n#### repeat-while \n与`while`不同的是，`repeat-while`循环会首先执行以下循环体，然后判断条件是否为true。和其他语言中的`do-while`循环类似。语法如下：\n\n```Swift\nrepeat {\n    statements\n} while condition\n```\n\n### 分支判断\n根据特定的条件执行对应的处理代码是很常用的，Swift提供了两种分支判断语法：`if`和`switch`，通常情况下`if`用在简单的分支判断，`switch`用在比较复杂的场合。\n\n#### if \nif语句包含一个条件，如果条件为true，则执行紧接着的语句集合。否则执行else (if) 对应的语句集合（如果不关心else (if) 的情况，该部分可以不写）。\n\n#### switch\nswitch语句将一个值和多种匹配的模式进行比较，然后根据第`一`个合适的配结果执行对应的代码块，语法格式如下：\n\n```Swift\nswitch some value to consider {\ncase value 1:\n    respond to value 1\ncase value 2,\n     value 3:\n    respond to value 2 or 3\ndefault:\n    otherwise, do something else\n}\n```\nswitch语句包含多个情况，每个case语句都代表一个分支。switch语句必须列举出所有情况，也就是说case分支必须能够匹配所有可能的情况，如果case不能完全匹配，则需要通过关键字`default`在最后位置定义一个默认的分支，例如：\n\n```Swift\nlet someCharacter: Character = \"z\"\nswitch someCharacter {\ncase \"a\":\n    print(\"The first letter of the alphabet\")\ncase \"z\":\n    print(\"The last letter of the alphabet\")\ndefault:\n    print(\"Some other character\")\n}\n```\n\n##### 不存在隐式穿透(No Implicit Fallthrough)\n和C与ObjC语言中的Switch语法不同的是，Swift中的switch语法默认情况下在case语句执行完成后不会自动匹配下一个case语句，而是当第一个匹配case分支执行之后马上结束，你不需要像其他语言那样为每个case写上一个break关键字。（尽管break在swift中switch中是非必需的，但你可以使用它来中断一些代码的执行）。如果想自动匹配下一个，则需要使用关键字`fallthrough`。\n每一条case分支必须包含至少一个可执行语句，比如以下代码会引起编译时错误\n\n```Swift\nlet anotherCharacter: Character = \"a\"\nswitch anotherCharacter {\ncase \"a\": // Invalid, the case has an empty body\ncase \"A\":\n    print(\"The letter A\")\ndefault:\n    print(\"Not the letter A\")\n}\n// This will report a compile-time error.\n```\n一条case分支可以匹配多个值，用逗号`,`隔开，比如上述代码会引起编译时错误可以通过以下写法来解决\n\n```Swift\nlet anotherCharacter: Character = \"a\"\nswitch anotherCharacter {\ncase \"a\", \"A\":\n    print(\"The letter A\")\ndefault:\n    print(\"Not the letter A\")\n}\n// Prints \"The letter A\"\n```\n\n##### 区间匹配\nswitch中的值可以进行区间匹配，比如：\n\n```Swift\nlet approximateCount = 62\nlet countedThings = \"moons orbiting Saturn\"\nvar naturalCount: String\nswitch approximateCount {\ncase 0:\n    naturalCount = \"no\"\ncase 1..<5:\n    naturalCount = \"a few\"\ncase 5..<12:\n    naturalCount = \"several\"\ncase 12..<100:\n    naturalCount = \"dozens of\"\ncase 100..<1000:\n    naturalCount = \"hundreds of\"\ndefault:\n    naturalCount = \"many\"\n}\nprint(\"There are \\(naturalCount) \\(countedThings).\")\n// Prints \"There are dozens of moons orbiting Saturn.\"\n```\n\n##### 元组\n可以通过使用下划线`_`来匹配任意一个元素，如果存在多个匹配，默认情况下执行第一个匹配的case，其他case会被忽略。代码比较清楚：\n\n```Swift\nlet somePoint = (1, 1)\nswitch somePoint {\ncase (0, 0):\n    print(\"(0, 0) is at the origin\")\ncase (_, 0):\n    print(\"(\\(somePoint.0), 0) is on the x-axis\")\ncase (0, _):\n    print(\"(0, \\(somePoint.1)) is on the y-axis\")\ncase (-2...2, -2...2):\n    print(\"(\\(somePoint.0), \\(somePoint.1)) is inside the box\")\ndefault:\n    print(\"(\\(somePoint.0), \\(somePoint.1)) is outside of the box\")\n}\n// Prints \"(1, 1) is inside the box\"\n```\n\n##### 值绑定\n在switch的case语句中，可以将匹配的值绑定给一个临时的常量或者变量，在case的body中使用。例如：\n\n```Swift\nlet anotherPoint = (2, 0)\nswitch anotherPoint {\ncase (let x, 0):\n    print(\"on the x-axis with an x value of \\(x)\")\ncase (0, let y):\n    print(\"on the y-axis with a y value of \\(y)\")\ncase let (x, y):\n    print(\"somewhere else at (\\(x), \\(y))\")\n}\n// Prints \"on the x-axis with an x value of 2\"\n```\n\n##### where\n一个case语句中可以使用where语法进行额外的匹配检查，比如：\n\n```Swift\nlet yetAnotherPoint = (1, -1)\nswitch yetAnotherPoint {\ncase let (x, y) where x == y:\n    print(\"(\\(x), \\(y)) is on the line x == y\")\ncase let (x, y) where x == -y:\n    print(\"(\\(x), \\(y)) is on the line x == -y\")\ncase let (x, y):\n    print(\"(\\(x), \\(y)) is just some arbitrary point\")\n}\n// Prints \"(1, -1) is on the line x == -y\"\n```\n\n##### 复合匹配\n在case中通过逗号`,`隔开匹配内容。复合匹配也可以包含值绑定，在复合匹配中，无论哪个部分匹配上，case的body都会被执行。例如：\n\n```Swift\nlet stillAnotherPoint = (9, 0)\nswitch stillAnotherPoint {\ncase (let distance, 0), (0, let distance):\n    print(\"On an axis, \\(distance) from the origin\")\ndefault:\n    print(\"Not on an axis\")\n}\n// Prints \"On an axis, 9 from the origin\"\n```\n\n### 控制转移语句\nswift提供了5个流程控制转移语句：`continue`、`break`、`fallthrough`、`return`、`throw`。\n除了`fallthrough`，其他四个关键字与C等语言中的基本相同，swift中的switch语句默认情况下不存在隐式穿透，如果想要支持，则需要在case语句后添加`fallthrough`，（注：该关键字不检查即将进入的case条件）例如：\n\n```Swift\nlet integerToDescribe = 5\nvar description = \"The number \\(integerToDescribe) is\"\nswitch integerToDescribe {\ncase 2, 3, 5, 7, 11, 13, 17, 19:\n    description += \" a prime number, and also\"\n    fallthrough\ndefault:\n    description += \" an integer.\"\n}\nprint(description)\n// Prints \"The number 5 is a prime number, and also an integer.\"\n```\n\n### 标签语法\n循环或条件语句可以嵌套，可以通过break语法结束当前代码块的执行，如果有多个嵌套的循环，明确哪个循环是非常有用的，为了实现这个目标，你可以使用标签语法。标签语法是由名字和冒号`:`组成。例如一个while循环的标签如下：\n\n```Swift\nlabel name: while condition {\n    statements\n}\n```\n\n### 提前退出\n和`if`语法类似，`guard`语法语句的执行取决于一个bool表达式。可以使用`guard`语法来确保在特定条件成立的情况下执行某些代码。和`if`不同的是，`guard`语法在条件表达式为false时会执行`else`块中的内容。例如：\n\n```Swift\nguard let name = person[\"name\"] else {\n        return\n    }\n    \n    print(\"Hello \\(name)!\")\n```\n\n### API有效性检查\n可以在`if`或`guard`语句中使用`availability`条件。其中平台比如：`iOS`, `macOS`, `watchOS`, 和 `tvOS`，语法格式如下\n\n```Swift\nif #available(platform name version, ..., *) {\n    statements to execute if the APIs are available\n} else {\n    fallback statements to execute if the APIs are unavailable\n}\n```\n具体写法例如：\n\n```Swift\nif #available(iOS 10, macOS 10.12, *) {\n    // Use iOS 10 APIs on iOS, and use macOS 10.12 APIs on macOS\n} else {\n    // Fall back to earlier iOS and macOS APIs\n}\n```\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html/\">Control Flow</a> \n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","source":"_posts/iOS_Swift_language_note_Control-Flow.md","raw":"---\nlayout:     post\ntitle:      Swift Control Flow\ndate:       2016-11-17 00:20:11\nauthor:     liangtong\ncatalog: true\ncategories: iOS\ntags: Swift \n\n---\n\n\n\n​\tSwift提供了很多流程控制语法，包括可以通过使用`while`循环来重复执行一个任务，可以通过`if`、`guard`和`switch`来进行条件判断从而执行不同代码分支，可以通过`break`和`continue`来跳转到特定代码位置。\n​\tSwift也提供了诸如可以通过`for-in`循环来遍历数组，字典，区间(range)，字符串和其他一些序列(sequences)。\n​\tSwift的`switch`语句相对比C语言的`强大`(该关键字与其他多数语言不同，至于算不算优点，意见保留)。在Swift中，该语句中的`case`语法不会自动流转到下一个`case`，这避免了像C语言中因为缺失`break`语句导致的错误。而Swift中的Case语句也相对比较强大，可以匹配多种包括整型、元组、转换的特殊类型等形式。在Case语句中匹配的值可以被绑定到一个临时的常量或者变量中，从而在`case`语句对一个的代码块(body)中使用，一些复杂的匹配可以通过使用`where`表达式进行。\n\n\n\n### for-in 循环\n可以使用`for-in`循环来遍历一个序列，比如一个区间(range)中的数字、数组中的元素、字符串的字符，例如：\n\n\n<!-- more -->\n\n```Swift\n//使用index变量来访问range中的具体值。注意操作符`...`的用法\nfor index in 1...5 {\n    print(\"\\(index) times 5 is \\(index * 5)\")\n}\n//不关心range中的具体值，可以使用下划线’_’\nlet base = 3\nlet power = 10\nvar answer = 1\nfor _ in 1...power {\n    answer *= base\n}\nprint(\"\\(base) to the power of \\(power) is \\(answer)\")\n//遍历数组\nlet names = [\"Anna\", \"Alex\", \"Brian\", \"Jack\"]\nfor name in names {\n    print(\"Hello, \\(name)!\")\n}\n//字典，是以元组的形式来匹配的，当然也可以使用下划线’_’\nlet numberOfLegs = [\"spider\": 8, \"ant\": 6, \"cat\": 4]\nfor (animalName, legCount) in numberOfLegs {\n    print(\"\\(animalName)s have \\(legCount) legs\")\n}\n\n```\n### while循环\nwhile的代码块会一直被执行，知道条件变为flase。这类循环主要用在不确定遍历次数的情况下，Swift提供了两种while循环语法：`while`和`repeat-while`\n\n#### while\nwhile循环是以一个简单的bool条件式开始，当该条件为true的时，循环体会一直被执行。知道条件变为false。语法如下：\n\n```Swift\nwhile condition {\n    statements\n}\n```\n\n#### repeat-while \n与`while`不同的是，`repeat-while`循环会首先执行以下循环体，然后判断条件是否为true。和其他语言中的`do-while`循环类似。语法如下：\n\n```Swift\nrepeat {\n    statements\n} while condition\n```\n\n### 分支判断\n根据特定的条件执行对应的处理代码是很常用的，Swift提供了两种分支判断语法：`if`和`switch`，通常情况下`if`用在简单的分支判断，`switch`用在比较复杂的场合。\n\n#### if \nif语句包含一个条件，如果条件为true，则执行紧接着的语句集合。否则执行else (if) 对应的语句集合（如果不关心else (if) 的情况，该部分可以不写）。\n\n#### switch\nswitch语句将一个值和多种匹配的模式进行比较，然后根据第`一`个合适的配结果执行对应的代码块，语法格式如下：\n\n```Swift\nswitch some value to consider {\ncase value 1:\n    respond to value 1\ncase value 2,\n     value 3:\n    respond to value 2 or 3\ndefault:\n    otherwise, do something else\n}\n```\nswitch语句包含多个情况，每个case语句都代表一个分支。switch语句必须列举出所有情况，也就是说case分支必须能够匹配所有可能的情况，如果case不能完全匹配，则需要通过关键字`default`在最后位置定义一个默认的分支，例如：\n\n```Swift\nlet someCharacter: Character = \"z\"\nswitch someCharacter {\ncase \"a\":\n    print(\"The first letter of the alphabet\")\ncase \"z\":\n    print(\"The last letter of the alphabet\")\ndefault:\n    print(\"Some other character\")\n}\n```\n\n##### 不存在隐式穿透(No Implicit Fallthrough)\n和C与ObjC语言中的Switch语法不同的是，Swift中的switch语法默认情况下在case语句执行完成后不会自动匹配下一个case语句，而是当第一个匹配case分支执行之后马上结束，你不需要像其他语言那样为每个case写上一个break关键字。（尽管break在swift中switch中是非必需的，但你可以使用它来中断一些代码的执行）。如果想自动匹配下一个，则需要使用关键字`fallthrough`。\n每一条case分支必须包含至少一个可执行语句，比如以下代码会引起编译时错误\n\n```Swift\nlet anotherCharacter: Character = \"a\"\nswitch anotherCharacter {\ncase \"a\": // Invalid, the case has an empty body\ncase \"A\":\n    print(\"The letter A\")\ndefault:\n    print(\"Not the letter A\")\n}\n// This will report a compile-time error.\n```\n一条case分支可以匹配多个值，用逗号`,`隔开，比如上述代码会引起编译时错误可以通过以下写法来解决\n\n```Swift\nlet anotherCharacter: Character = \"a\"\nswitch anotherCharacter {\ncase \"a\", \"A\":\n    print(\"The letter A\")\ndefault:\n    print(\"Not the letter A\")\n}\n// Prints \"The letter A\"\n```\n\n##### 区间匹配\nswitch中的值可以进行区间匹配，比如：\n\n```Swift\nlet approximateCount = 62\nlet countedThings = \"moons orbiting Saturn\"\nvar naturalCount: String\nswitch approximateCount {\ncase 0:\n    naturalCount = \"no\"\ncase 1..<5:\n    naturalCount = \"a few\"\ncase 5..<12:\n    naturalCount = \"several\"\ncase 12..<100:\n    naturalCount = \"dozens of\"\ncase 100..<1000:\n    naturalCount = \"hundreds of\"\ndefault:\n    naturalCount = \"many\"\n}\nprint(\"There are \\(naturalCount) \\(countedThings).\")\n// Prints \"There are dozens of moons orbiting Saturn.\"\n```\n\n##### 元组\n可以通过使用下划线`_`来匹配任意一个元素，如果存在多个匹配，默认情况下执行第一个匹配的case，其他case会被忽略。代码比较清楚：\n\n```Swift\nlet somePoint = (1, 1)\nswitch somePoint {\ncase (0, 0):\n    print(\"(0, 0) is at the origin\")\ncase (_, 0):\n    print(\"(\\(somePoint.0), 0) is on the x-axis\")\ncase (0, _):\n    print(\"(0, \\(somePoint.1)) is on the y-axis\")\ncase (-2...2, -2...2):\n    print(\"(\\(somePoint.0), \\(somePoint.1)) is inside the box\")\ndefault:\n    print(\"(\\(somePoint.0), \\(somePoint.1)) is outside of the box\")\n}\n// Prints \"(1, 1) is inside the box\"\n```\n\n##### 值绑定\n在switch的case语句中，可以将匹配的值绑定给一个临时的常量或者变量，在case的body中使用。例如：\n\n```Swift\nlet anotherPoint = (2, 0)\nswitch anotherPoint {\ncase (let x, 0):\n    print(\"on the x-axis with an x value of \\(x)\")\ncase (0, let y):\n    print(\"on the y-axis with a y value of \\(y)\")\ncase let (x, y):\n    print(\"somewhere else at (\\(x), \\(y))\")\n}\n// Prints \"on the x-axis with an x value of 2\"\n```\n\n##### where\n一个case语句中可以使用where语法进行额外的匹配检查，比如：\n\n```Swift\nlet yetAnotherPoint = (1, -1)\nswitch yetAnotherPoint {\ncase let (x, y) where x == y:\n    print(\"(\\(x), \\(y)) is on the line x == y\")\ncase let (x, y) where x == -y:\n    print(\"(\\(x), \\(y)) is on the line x == -y\")\ncase let (x, y):\n    print(\"(\\(x), \\(y)) is just some arbitrary point\")\n}\n// Prints \"(1, -1) is on the line x == -y\"\n```\n\n##### 复合匹配\n在case中通过逗号`,`隔开匹配内容。复合匹配也可以包含值绑定，在复合匹配中，无论哪个部分匹配上，case的body都会被执行。例如：\n\n```Swift\nlet stillAnotherPoint = (9, 0)\nswitch stillAnotherPoint {\ncase (let distance, 0), (0, let distance):\n    print(\"On an axis, \\(distance) from the origin\")\ndefault:\n    print(\"Not on an axis\")\n}\n// Prints \"On an axis, 9 from the origin\"\n```\n\n### 控制转移语句\nswift提供了5个流程控制转移语句：`continue`、`break`、`fallthrough`、`return`、`throw`。\n除了`fallthrough`，其他四个关键字与C等语言中的基本相同，swift中的switch语句默认情况下不存在隐式穿透，如果想要支持，则需要在case语句后添加`fallthrough`，（注：该关键字不检查即将进入的case条件）例如：\n\n```Swift\nlet integerToDescribe = 5\nvar description = \"The number \\(integerToDescribe) is\"\nswitch integerToDescribe {\ncase 2, 3, 5, 7, 11, 13, 17, 19:\n    description += \" a prime number, and also\"\n    fallthrough\ndefault:\n    description += \" an integer.\"\n}\nprint(description)\n// Prints \"The number 5 is a prime number, and also an integer.\"\n```\n\n### 标签语法\n循环或条件语句可以嵌套，可以通过break语法结束当前代码块的执行，如果有多个嵌套的循环，明确哪个循环是非常有用的，为了实现这个目标，你可以使用标签语法。标签语法是由名字和冒号`:`组成。例如一个while循环的标签如下：\n\n```Swift\nlabel name: while condition {\n    statements\n}\n```\n\n### 提前退出\n和`if`语法类似，`guard`语法语句的执行取决于一个bool表达式。可以使用`guard`语法来确保在特定条件成立的情况下执行某些代码。和`if`不同的是，`guard`语法在条件表达式为false时会执行`else`块中的内容。例如：\n\n```Swift\nguard let name = person[\"name\"] else {\n        return\n    }\n    \n    print(\"Hello \\(name)!\")\n```\n\n### API有效性检查\n可以在`if`或`guard`语句中使用`availability`条件。其中平台比如：`iOS`, `macOS`, `watchOS`, 和 `tvOS`，语法格式如下\n\n```Swift\nif #available(platform name version, ..., *) {\n    statements to execute if the APIs are available\n} else {\n    fallback statements to execute if the APIs are unavailable\n}\n```\n具体写法例如：\n\n```Swift\nif #available(iOS 10, macOS 10.12, *) {\n    // Use iOS 10 APIs on iOS, and use macOS 10.12 APIs on macOS\n} else {\n    // Fall back to earlier iOS and macOS APIs\n}\n```\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html/\">Control Flow</a> \n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","slug":"iOS_Swift_language_note_Control-Flow","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4u5002joko8yrcewr03","content":"<p>​    Swift提供了很多流程控制语法，包括可以通过使用<code>while</code>循环来重复执行一个任务，可以通过<code>if</code>、<code>guard</code>和<code>switch</code>来进行条件判断从而执行不同代码分支，可以通过<code>break</code>和<code>continue</code>来跳转到特定代码位置。<br>​    Swift也提供了诸如可以通过<code>for-in</code>循环来遍历数组，字典，区间(range)，字符串和其他一些序列(sequences)。<br>​    Swift的<code>switch</code>语句相对比C语言的<code>强大</code>(该关键字与其他多数语言不同，至于算不算优点，意见保留)。在Swift中，该语句中的<code>case</code>语法不会自动流转到下一个<code>case</code>，这避免了像C语言中因为缺失<code>break</code>语句导致的错误。而Swift中的Case语句也相对比较强大，可以匹配多种包括整型、元组、转换的特殊类型等形式。在Case语句中匹配的值可以被绑定到一个临时的常量或者变量中，从而在<code>case</code>语句对一个的代码块(body)中使用，一些复杂的匹配可以通过使用<code>where</code>表达式进行。</p>\n<h3 id=\"for-in-循环\"><a href=\"#for-in-循环\" class=\"headerlink\" title=\"for-in 循环\"></a>for-in 循环</h3><p>可以使用<code>for-in</code>循环来遍历一个序列，比如一个区间(range)中的数字、数组中的元素、字符串的字符，例如：</p>\n<a id=\"more\"></a>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//使用index变量来访问range中的具体值。注意操作符`...`的用法</span></div><div class=\"line\"><span class=\"keyword\">for</span> index <span class=\"keyword\">in</span> <span class=\"number\">1</span>...<span class=\"number\">5</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(index)</span> times 5 is <span class=\"subst\">\\(index * <span class=\"number\">5</span>)</span>\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//不关心range中的具体值，可以使用下划线’_’</span></div><div class=\"line\"><span class=\"keyword\">let</span> base = <span class=\"number\">3</span></div><div class=\"line\"><span class=\"keyword\">let</span> power = <span class=\"number\">10</span></div><div class=\"line\"><span class=\"keyword\">var</span> answer = <span class=\"number\">1</span></div><div class=\"line\"><span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">1</span>...power &#123;</div><div class=\"line\">    answer *= base</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(base)</span> to the power of <span class=\"subst\">\\(power)</span> is <span class=\"subst\">\\(answer)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">//遍历数组</span></div><div class=\"line\"><span class=\"keyword\">let</span> names = [<span class=\"string\">\"Anna\"</span>, <span class=\"string\">\"Alex\"</span>, <span class=\"string\">\"Brian\"</span>, <span class=\"string\">\"Jack\"</span>]</div><div class=\"line\"><span class=\"keyword\">for</span> name <span class=\"keyword\">in</span> names &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Hello, <span class=\"subst\">\\(name)</span>!\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//字典，是以元组的形式来匹配的，当然也可以使用下划线’_’</span></div><div class=\"line\"><span class=\"keyword\">let</span> numberOfLegs = [<span class=\"string\">\"spider\"</span>: <span class=\"number\">8</span>, <span class=\"string\">\"ant\"</span>: <span class=\"number\">6</span>, <span class=\"string\">\"cat\"</span>: <span class=\"number\">4</span>]</div><div class=\"line\"><span class=\"keyword\">for</span> (animalName, legCount) <span class=\"keyword\">in</span> numberOfLegs &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(animalName)</span>s have <span class=\"subst\">\\(legCount)</span> legs\"</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"while循环\"><a href=\"#while循环\" class=\"headerlink\" title=\"while循环\"></a>while循环</h3><p>while的代码块会一直被执行，知道条件变为flase。这类循环主要用在不确定遍历次数的情况下，Swift提供了两种while循环语法：<code>while</code>和<code>repeat-while</code></p>\n<h4 id=\"while\"><a href=\"#while\" class=\"headerlink\" title=\"while\"></a>while</h4><p>while循环是以一个简单的bool条件式开始，当该条件为true的时，循环体会一直被执行。知道条件变为false。语法如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span> condition &#123;</div><div class=\"line\">    statements</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"repeat-while\"><a href=\"#repeat-while\" class=\"headerlink\" title=\"repeat-while\"></a>repeat-while</h4><p>与<code>while</code>不同的是，<code>repeat-while</code>循环会首先执行以下循环体，然后判断条件是否为true。和其他语言中的<code>do-while</code>循环类似。语法如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">repeat</span> &#123;</div><div class=\"line\">    statements</div><div class=\"line\">&#125; <span class=\"keyword\">while</span> condition</div></pre></td></tr></table></figure>\n<h3 id=\"分支判断\"><a href=\"#分支判断\" class=\"headerlink\" title=\"分支判断\"></a>分支判断</h3><p>根据特定的条件执行对应的处理代码是很常用的，Swift提供了两种分支判断语法：<code>if</code>和<code>switch</code>，通常情况下<code>if</code>用在简单的分支判断，<code>switch</code>用在比较复杂的场合。</p>\n<h4 id=\"if\"><a href=\"#if\" class=\"headerlink\" title=\"if\"></a>if</h4><p>if语句包含一个条件，如果条件为true，则执行紧接着的语句集合。否则执行else (if) 对应的语句集合（如果不关心else (if) 的情况，该部分可以不写）。</p>\n<h4 id=\"switch\"><a href=\"#switch\" class=\"headerlink\" title=\"switch\"></a>switch</h4><p>switch语句将一个值和多种匹配的模式进行比较，然后根据第<code>一</code>个合适的配结果执行对应的代码块，语法格式如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">switch</span> some value to consider &#123;</div><div class=\"line\"><span class=\"keyword\">case</span> value <span class=\"number\">1</span>:</div><div class=\"line\">    respond to value <span class=\"number\">1</span></div><div class=\"line\"><span class=\"keyword\">case</span> value <span class=\"number\">2</span>,</div><div class=\"line\">     value <span class=\"number\">3</span>:</div><div class=\"line\">    respond to value <span class=\"number\">2</span> or <span class=\"number\">3</span></div><div class=\"line\"><span class=\"keyword\">default</span>:</div><div class=\"line\">    otherwise, <span class=\"keyword\">do</span> something <span class=\"keyword\">else</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>switch语句包含多个情况，每个case语句都代表一个分支。switch语句必须列举出所有情况，也就是说case分支必须能够匹配所有可能的情况，如果case不能完全匹配，则需要通过关键字<code>default</code>在最后位置定义一个默认的分支，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> someCharacter: <span class=\"type\">Character</span> = <span class=\"string\">\"z\"</span></div><div class=\"line\"><span class=\"keyword\">switch</span> someCharacter &#123;</div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">\"a\"</span>:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The first letter of the alphabet\"</span>)</div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">\"z\"</span>:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The last letter of the alphabet\"</span>)</div><div class=\"line\"><span class=\"keyword\">default</span>:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Some other character\"</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"不存在隐式穿透-No-Implicit-Fallthrough\"><a href=\"#不存在隐式穿透-No-Implicit-Fallthrough\" class=\"headerlink\" title=\"不存在隐式穿透(No Implicit Fallthrough)\"></a>不存在隐式穿透(No Implicit Fallthrough)</h5><p>和C与ObjC语言中的Switch语法不同的是，Swift中的switch语法默认情况下在case语句执行完成后不会自动匹配下一个case语句，而是当第一个匹配case分支执行之后马上结束，你不需要像其他语言那样为每个case写上一个break关键字。（尽管break在swift中switch中是非必需的，但你可以使用它来中断一些代码的执行）。如果想自动匹配下一个，则需要使用关键字<code>fallthrough</code>。<br>每一条case分支必须包含至少一个可执行语句，比如以下代码会引起编译时错误</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> anotherCharacter: <span class=\"type\">Character</span> = <span class=\"string\">\"a\"</span></div><div class=\"line\"><span class=\"keyword\">switch</span> anotherCharacter &#123;</div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">\"a\"</span>: <span class=\"comment\">// Invalid, the case has an empty body</span></div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">\"A\"</span>:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The letter A\"</span>)</div><div class=\"line\"><span class=\"keyword\">default</span>:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Not the letter A\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// This will report a compile-time error.</span></div></pre></td></tr></table></figure>\n<p>一条case分支可以匹配多个值，用逗号<code>,</code>隔开，比如上述代码会引起编译时错误可以通过以下写法来解决</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> anotherCharacter: <span class=\"type\">Character</span> = <span class=\"string\">\"a\"</span></div><div class=\"line\"><span class=\"keyword\">switch</span> anotherCharacter &#123;</div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">\"a\"</span>, <span class=\"string\">\"A\"</span>:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The letter A\"</span>)</div><div class=\"line\"><span class=\"keyword\">default</span>:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Not the letter A\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"The letter A\"</span></div></pre></td></tr></table></figure>\n<h5 id=\"区间匹配\"><a href=\"#区间匹配\" class=\"headerlink\" title=\"区间匹配\"></a>区间匹配</h5><p>switch中的值可以进行区间匹配，比如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> approximateCount = <span class=\"number\">62</span></div><div class=\"line\"><span class=\"keyword\">let</span> countedThings = <span class=\"string\">\"moons orbiting Saturn\"</span></div><div class=\"line\"><span class=\"keyword\">var</span> naturalCount: <span class=\"type\">String</span></div><div class=\"line\"><span class=\"keyword\">switch</span> approximateCount &#123;</div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"number\">0</span>:</div><div class=\"line\">    naturalCount = <span class=\"string\">\"no\"</span></div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"number\">1</span>..&lt;<span class=\"number\">5</span>:</div><div class=\"line\">    naturalCount = <span class=\"string\">\"a few\"</span></div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"number\">5</span>..&lt;<span class=\"number\">12</span>:</div><div class=\"line\">    naturalCount = <span class=\"string\">\"several\"</span></div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"number\">12</span>..&lt;<span class=\"number\">100</span>:</div><div class=\"line\">    naturalCount = <span class=\"string\">\"dozens of\"</span></div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"number\">100</span>..&lt;<span class=\"number\">1000</span>:</div><div class=\"line\">    naturalCount = <span class=\"string\">\"hundreds of\"</span></div><div class=\"line\"><span class=\"keyword\">default</span>:</div><div class=\"line\">    naturalCount = <span class=\"string\">\"many\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"There are <span class=\"subst\">\\(naturalCount)</span> <span class=\"subst\">\\(countedThings)</span>.\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"There are dozens of moons orbiting Saturn.\"</span></div></pre></td></tr></table></figure>\n<h5 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h5><p>可以通过使用下划线<code>_</code>来匹配任意一个元素，如果存在多个匹配，默认情况下执行第一个匹配的case，其他case会被忽略。代码比较清楚：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> somePoint = (<span class=\"number\">1</span>, <span class=\"number\">1</span>)</div><div class=\"line\"><span class=\"keyword\">switch</span> somePoint &#123;</div><div class=\"line\"><span class=\"keyword\">case</span> (<span class=\"number\">0</span>, <span class=\"number\">0</span>):</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"(0, 0) is at the origin\"</span>)</div><div class=\"line\"><span class=\"keyword\">case</span> (<span class=\"number\">_</span>, <span class=\"number\">0</span>):</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"(<span class=\"subst\">\\(somePoint.<span class=\"number\">0</span>)</span>, 0) is on the x-axis\"</span>)</div><div class=\"line\"><span class=\"keyword\">case</span> (<span class=\"number\">0</span>, <span class=\"number\">_</span>):</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"(0, <span class=\"subst\">\\(somePoint.<span class=\"number\">1</span>)</span>) is on the y-axis\"</span>)</div><div class=\"line\"><span class=\"keyword\">case</span> (-<span class=\"number\">2</span>...<span class=\"number\">2</span>, -<span class=\"number\">2</span>...<span class=\"number\">2</span>):</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"(<span class=\"subst\">\\(somePoint.<span class=\"number\">0</span>)</span>, <span class=\"subst\">\\(somePoint.<span class=\"number\">1</span>)</span>) is inside the box\"</span>)</div><div class=\"line\"><span class=\"keyword\">default</span>:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"(<span class=\"subst\">\\(somePoint.<span class=\"number\">0</span>)</span>, <span class=\"subst\">\\(somePoint.<span class=\"number\">1</span>)</span>) is outside of the box\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"(1, 1) is inside the box\"</span></div></pre></td></tr></table></figure>\n<h5 id=\"值绑定\"><a href=\"#值绑定\" class=\"headerlink\" title=\"值绑定\"></a>值绑定</h5><p>在switch的case语句中，可以将匹配的值绑定给一个临时的常量或者变量，在case的body中使用。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> anotherPoint = (<span class=\"number\">2</span>, <span class=\"number\">0</span>)</div><div class=\"line\"><span class=\"keyword\">switch</span> anotherPoint &#123;</div><div class=\"line\"><span class=\"keyword\">case</span> (<span class=\"keyword\">let</span> x, <span class=\"number\">0</span>):</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"on the x-axis with an x value of <span class=\"subst\">\\(x)</span>\"</span>)</div><div class=\"line\"><span class=\"keyword\">case</span> (<span class=\"number\">0</span>, <span class=\"keyword\">let</span> y):</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"on the y-axis with a y value of <span class=\"subst\">\\(y)</span>\"</span>)</div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"keyword\">let</span> (x, y):</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"somewhere else at (<span class=\"subst\">\\(x)</span>, <span class=\"subst\">\\(y)</span>)\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"on the x-axis with an x value of 2\"</span></div></pre></td></tr></table></figure>\n<h5 id=\"where\"><a href=\"#where\" class=\"headerlink\" title=\"where\"></a>where</h5><p>一个case语句中可以使用where语法进行额外的匹配检查，比如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> yetAnotherPoint = (<span class=\"number\">1</span>, -<span class=\"number\">1</span>)</div><div class=\"line\"><span class=\"keyword\">switch</span> yetAnotherPoint &#123;</div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"keyword\">let</span> (x, y) <span class=\"keyword\">where</span> x == y:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"(<span class=\"subst\">\\(x)</span>, <span class=\"subst\">\\(y)</span>) is on the line x == y\"</span>)</div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"keyword\">let</span> (x, y) <span class=\"keyword\">where</span> x == -y:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"(<span class=\"subst\">\\(x)</span>, <span class=\"subst\">\\(y)</span>) is on the line x == -y\"</span>)</div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"keyword\">let</span> (x, y):</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"(<span class=\"subst\">\\(x)</span>, <span class=\"subst\">\\(y)</span>) is just some arbitrary point\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"(1, -1) is on the line x == -y\"</span></div></pre></td></tr></table></figure>\n<h5 id=\"复合匹配\"><a href=\"#复合匹配\" class=\"headerlink\" title=\"复合匹配\"></a>复合匹配</h5><p>在case中通过逗号<code>,</code>隔开匹配内容。复合匹配也可以包含值绑定，在复合匹配中，无论哪个部分匹配上，case的body都会被执行。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> stillAnotherPoint = (<span class=\"number\">9</span>, <span class=\"number\">0</span>)</div><div class=\"line\"><span class=\"keyword\">switch</span> stillAnotherPoint &#123;</div><div class=\"line\"><span class=\"keyword\">case</span> (<span class=\"keyword\">let</span> <span class=\"built_in\">distance</span>, <span class=\"number\">0</span>), (<span class=\"number\">0</span>, <span class=\"keyword\">let</span> <span class=\"built_in\">distance</span>):</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"On an axis, <span class=\"subst\">\\(<span class=\"built_in\">distance</span>)</span> from the origin\"</span>)</div><div class=\"line\"><span class=\"keyword\">default</span>:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Not on an axis\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"On an axis, 9 from the origin\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"控制转移语句\"><a href=\"#控制转移语句\" class=\"headerlink\" title=\"控制转移语句\"></a>控制转移语句</h3><p>swift提供了5个流程控制转移语句：<code>continue</code>、<code>break</code>、<code>fallthrough</code>、<code>return</code>、<code>throw</code>。<br>除了<code>fallthrough</code>，其他四个关键字与C等语言中的基本相同，swift中的switch语句默认情况下不存在隐式穿透，如果想要支持，则需要在case语句后添加<code>fallthrough</code>，（注：该关键字不检查即将进入的case条件）例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> integerToDescribe = <span class=\"number\">5</span></div><div class=\"line\"><span class=\"keyword\">var</span> description = <span class=\"string\">\"The number <span class=\"subst\">\\(integerToDescribe)</span> is\"</span></div><div class=\"line\"><span class=\"keyword\">switch</span> integerToDescribe &#123;</div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>, <span class=\"number\">17</span>, <span class=\"number\">19</span>:</div><div class=\"line\">    description += <span class=\"string\">\" a prime number, and also\"</span></div><div class=\"line\">    <span class=\"keyword\">fallthrough</span></div><div class=\"line\"><span class=\"keyword\">default</span>:</div><div class=\"line\">    description += <span class=\"string\">\" an integer.\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">print</span>(description)</div><div class=\"line\"><span class=\"comment\">// Prints \"The number 5 is a prime number, and also an integer.\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"标签语法\"><a href=\"#标签语法\" class=\"headerlink\" title=\"标签语法\"></a>标签语法</h3><p>循环或条件语句可以嵌套，可以通过break语法结束当前代码块的执行，如果有多个嵌套的循环，明确哪个循环是非常有用的，为了实现这个目标，你可以使用标签语法。标签语法是由名字和冒号<code>:</code>组成。例如一个while循环的标签如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">label name: <span class=\"keyword\">while</span> condition &#123;</div><div class=\"line\">    statements</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"提前退出\"><a href=\"#提前退出\" class=\"headerlink\" title=\"提前退出\"></a>提前退出</h3><p>和<code>if</code>语法类似，<code>guard</code>语法语句的执行取决于一个bool表达式。可以使用<code>guard</code>语法来确保在特定条件成立的情况下执行某些代码。和<code>if</code>不同的是，<code>guard</code>语法在条件表达式为false时会执行<code>else</code>块中的内容。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> name = person[<span class=\"string\">\"name\"</span>] <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Hello <span class=\"subst\">\\(name)</span>!\"</span>)</div></pre></td></tr></table></figure>\n<h3 id=\"API有效性检查\"><a href=\"#API有效性检查\" class=\"headerlink\" title=\"API有效性检查\"></a>API有效性检查</h3><p>可以在<code>if</code>或<code>guard</code>语句中使用<code>availability</code>条件。其中平台比如：<code>iOS</code>, <code>macOS</code>, <code>watchOS</code>, 和 <code>tvOS</code>，语法格式如下</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> #available(platform name version, ..., *) &#123;</div><div class=\"line\">    statements to execute <span class=\"keyword\">if</span> the <span class=\"type\">APIs</span> are available</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    fallback statements to execute <span class=\"keyword\">if</span> the <span class=\"type\">APIs</span> are unavailable</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>具体写法例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> #available(iOS <span class=\"number\">10</span>, macOS <span class=\"number\">10.12</span>, *) &#123;</div><div class=\"line\">    <span class=\"comment\">// Use iOS 10 APIs on iOS, and use macOS 10.12 APIs on macOS</span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// Fall back to earlier iOS and macOS APIs</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html/\" target=\"_blank\" rel=\"external\">Control Flow</a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>​    Swift提供了很多流程控制语法，包括可以通过使用<code>while</code>循环来重复执行一个任务，可以通过<code>if</code>、<code>guard</code>和<code>switch</code>来进行条件判断从而执行不同代码分支，可以通过<code>break</code>和<code>continue</code>来跳转到特定代码位置。<br>​    Swift也提供了诸如可以通过<code>for-in</code>循环来遍历数组，字典，区间(range)，字符串和其他一些序列(sequences)。<br>​    Swift的<code>switch</code>语句相对比C语言的<code>强大</code>(该关键字与其他多数语言不同，至于算不算优点，意见保留)。在Swift中，该语句中的<code>case</code>语法不会自动流转到下一个<code>case</code>，这避免了像C语言中因为缺失<code>break</code>语句导致的错误。而Swift中的Case语句也相对比较强大，可以匹配多种包括整型、元组、转换的特殊类型等形式。在Case语句中匹配的值可以被绑定到一个临时的常量或者变量中，从而在<code>case</code>语句对一个的代码块(body)中使用，一些复杂的匹配可以通过使用<code>where</code>表达式进行。</p>\n<h3 id=\"for-in-循环\"><a href=\"#for-in-循环\" class=\"headerlink\" title=\"for-in 循环\"></a>for-in 循环</h3><p>可以使用<code>for-in</code>循环来遍历一个序列，比如一个区间(range)中的数字、数组中的元素、字符串的字符，例如：</p>","more":"<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//使用index变量来访问range中的具体值。注意操作符`...`的用法</span></div><div class=\"line\"><span class=\"keyword\">for</span> index <span class=\"keyword\">in</span> <span class=\"number\">1</span>...<span class=\"number\">5</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(index)</span> times 5 is <span class=\"subst\">\\(index * <span class=\"number\">5</span>)</span>\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//不关心range中的具体值，可以使用下划线’_’</span></div><div class=\"line\"><span class=\"keyword\">let</span> base = <span class=\"number\">3</span></div><div class=\"line\"><span class=\"keyword\">let</span> power = <span class=\"number\">10</span></div><div class=\"line\"><span class=\"keyword\">var</span> answer = <span class=\"number\">1</span></div><div class=\"line\"><span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">1</span>...power &#123;</div><div class=\"line\">    answer *= base</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(base)</span> to the power of <span class=\"subst\">\\(power)</span> is <span class=\"subst\">\\(answer)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">//遍历数组</span></div><div class=\"line\"><span class=\"keyword\">let</span> names = [<span class=\"string\">\"Anna\"</span>, <span class=\"string\">\"Alex\"</span>, <span class=\"string\">\"Brian\"</span>, <span class=\"string\">\"Jack\"</span>]</div><div class=\"line\"><span class=\"keyword\">for</span> name <span class=\"keyword\">in</span> names &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Hello, <span class=\"subst\">\\(name)</span>!\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//字典，是以元组的形式来匹配的，当然也可以使用下划线’_’</span></div><div class=\"line\"><span class=\"keyword\">let</span> numberOfLegs = [<span class=\"string\">\"spider\"</span>: <span class=\"number\">8</span>, <span class=\"string\">\"ant\"</span>: <span class=\"number\">6</span>, <span class=\"string\">\"cat\"</span>: <span class=\"number\">4</span>]</div><div class=\"line\"><span class=\"keyword\">for</span> (animalName, legCount) <span class=\"keyword\">in</span> numberOfLegs &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(animalName)</span>s have <span class=\"subst\">\\(legCount)</span> legs\"</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"while循环\"><a href=\"#while循环\" class=\"headerlink\" title=\"while循环\"></a>while循环</h3><p>while的代码块会一直被执行，知道条件变为flase。这类循环主要用在不确定遍历次数的情况下，Swift提供了两种while循环语法：<code>while</code>和<code>repeat-while</code></p>\n<h4 id=\"while\"><a href=\"#while\" class=\"headerlink\" title=\"while\"></a>while</h4><p>while循环是以一个简单的bool条件式开始，当该条件为true的时，循环体会一直被执行。知道条件变为false。语法如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span> condition &#123;</div><div class=\"line\">    statements</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"repeat-while\"><a href=\"#repeat-while\" class=\"headerlink\" title=\"repeat-while\"></a>repeat-while</h4><p>与<code>while</code>不同的是，<code>repeat-while</code>循环会首先执行以下循环体，然后判断条件是否为true。和其他语言中的<code>do-while</code>循环类似。语法如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">repeat</span> &#123;</div><div class=\"line\">    statements</div><div class=\"line\">&#125; <span class=\"keyword\">while</span> condition</div></pre></td></tr></table></figure>\n<h3 id=\"分支判断\"><a href=\"#分支判断\" class=\"headerlink\" title=\"分支判断\"></a>分支判断</h3><p>根据特定的条件执行对应的处理代码是很常用的，Swift提供了两种分支判断语法：<code>if</code>和<code>switch</code>，通常情况下<code>if</code>用在简单的分支判断，<code>switch</code>用在比较复杂的场合。</p>\n<h4 id=\"if\"><a href=\"#if\" class=\"headerlink\" title=\"if\"></a>if</h4><p>if语句包含一个条件，如果条件为true，则执行紧接着的语句集合。否则执行else (if) 对应的语句集合（如果不关心else (if) 的情况，该部分可以不写）。</p>\n<h4 id=\"switch\"><a href=\"#switch\" class=\"headerlink\" title=\"switch\"></a>switch</h4><p>switch语句将一个值和多种匹配的模式进行比较，然后根据第<code>一</code>个合适的配结果执行对应的代码块，语法格式如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">switch</span> some value to consider &#123;</div><div class=\"line\"><span class=\"keyword\">case</span> value <span class=\"number\">1</span>:</div><div class=\"line\">    respond to value <span class=\"number\">1</span></div><div class=\"line\"><span class=\"keyword\">case</span> value <span class=\"number\">2</span>,</div><div class=\"line\">     value <span class=\"number\">3</span>:</div><div class=\"line\">    respond to value <span class=\"number\">2</span> or <span class=\"number\">3</span></div><div class=\"line\"><span class=\"keyword\">default</span>:</div><div class=\"line\">    otherwise, <span class=\"keyword\">do</span> something <span class=\"keyword\">else</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>switch语句包含多个情况，每个case语句都代表一个分支。switch语句必须列举出所有情况，也就是说case分支必须能够匹配所有可能的情况，如果case不能完全匹配，则需要通过关键字<code>default</code>在最后位置定义一个默认的分支，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> someCharacter: <span class=\"type\">Character</span> = <span class=\"string\">\"z\"</span></div><div class=\"line\"><span class=\"keyword\">switch</span> someCharacter &#123;</div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">\"a\"</span>:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The first letter of the alphabet\"</span>)</div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">\"z\"</span>:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The last letter of the alphabet\"</span>)</div><div class=\"line\"><span class=\"keyword\">default</span>:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Some other character\"</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"不存在隐式穿透-No-Implicit-Fallthrough\"><a href=\"#不存在隐式穿透-No-Implicit-Fallthrough\" class=\"headerlink\" title=\"不存在隐式穿透(No Implicit Fallthrough)\"></a>不存在隐式穿透(No Implicit Fallthrough)</h5><p>和C与ObjC语言中的Switch语法不同的是，Swift中的switch语法默认情况下在case语句执行完成后不会自动匹配下一个case语句，而是当第一个匹配case分支执行之后马上结束，你不需要像其他语言那样为每个case写上一个break关键字。（尽管break在swift中switch中是非必需的，但你可以使用它来中断一些代码的执行）。如果想自动匹配下一个，则需要使用关键字<code>fallthrough</code>。<br>每一条case分支必须包含至少一个可执行语句，比如以下代码会引起编译时错误</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> anotherCharacter: <span class=\"type\">Character</span> = <span class=\"string\">\"a\"</span></div><div class=\"line\"><span class=\"keyword\">switch</span> anotherCharacter &#123;</div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">\"a\"</span>: <span class=\"comment\">// Invalid, the case has an empty body</span></div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">\"A\"</span>:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The letter A\"</span>)</div><div class=\"line\"><span class=\"keyword\">default</span>:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Not the letter A\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// This will report a compile-time error.</span></div></pre></td></tr></table></figure>\n<p>一条case分支可以匹配多个值，用逗号<code>,</code>隔开，比如上述代码会引起编译时错误可以通过以下写法来解决</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> anotherCharacter: <span class=\"type\">Character</span> = <span class=\"string\">\"a\"</span></div><div class=\"line\"><span class=\"keyword\">switch</span> anotherCharacter &#123;</div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">\"a\"</span>, <span class=\"string\">\"A\"</span>:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The letter A\"</span>)</div><div class=\"line\"><span class=\"keyword\">default</span>:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Not the letter A\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"The letter A\"</span></div></pre></td></tr></table></figure>\n<h5 id=\"区间匹配\"><a href=\"#区间匹配\" class=\"headerlink\" title=\"区间匹配\"></a>区间匹配</h5><p>switch中的值可以进行区间匹配，比如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> approximateCount = <span class=\"number\">62</span></div><div class=\"line\"><span class=\"keyword\">let</span> countedThings = <span class=\"string\">\"moons orbiting Saturn\"</span></div><div class=\"line\"><span class=\"keyword\">var</span> naturalCount: <span class=\"type\">String</span></div><div class=\"line\"><span class=\"keyword\">switch</span> approximateCount &#123;</div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"number\">0</span>:</div><div class=\"line\">    naturalCount = <span class=\"string\">\"no\"</span></div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"number\">1</span>..&lt;<span class=\"number\">5</span>:</div><div class=\"line\">    naturalCount = <span class=\"string\">\"a few\"</span></div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"number\">5</span>..&lt;<span class=\"number\">12</span>:</div><div class=\"line\">    naturalCount = <span class=\"string\">\"several\"</span></div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"number\">12</span>..&lt;<span class=\"number\">100</span>:</div><div class=\"line\">    naturalCount = <span class=\"string\">\"dozens of\"</span></div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"number\">100</span>..&lt;<span class=\"number\">1000</span>:</div><div class=\"line\">    naturalCount = <span class=\"string\">\"hundreds of\"</span></div><div class=\"line\"><span class=\"keyword\">default</span>:</div><div class=\"line\">    naturalCount = <span class=\"string\">\"many\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"There are <span class=\"subst\">\\(naturalCount)</span> <span class=\"subst\">\\(countedThings)</span>.\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"There are dozens of moons orbiting Saturn.\"</span></div></pre></td></tr></table></figure>\n<h5 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h5><p>可以通过使用下划线<code>_</code>来匹配任意一个元素，如果存在多个匹配，默认情况下执行第一个匹配的case，其他case会被忽略。代码比较清楚：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> somePoint = (<span class=\"number\">1</span>, <span class=\"number\">1</span>)</div><div class=\"line\"><span class=\"keyword\">switch</span> somePoint &#123;</div><div class=\"line\"><span class=\"keyword\">case</span> (<span class=\"number\">0</span>, <span class=\"number\">0</span>):</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"(0, 0) is at the origin\"</span>)</div><div class=\"line\"><span class=\"keyword\">case</span> (<span class=\"number\">_</span>, <span class=\"number\">0</span>):</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"(<span class=\"subst\">\\(somePoint.<span class=\"number\">0</span>)</span>, 0) is on the x-axis\"</span>)</div><div class=\"line\"><span class=\"keyword\">case</span> (<span class=\"number\">0</span>, <span class=\"number\">_</span>):</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"(0, <span class=\"subst\">\\(somePoint.<span class=\"number\">1</span>)</span>) is on the y-axis\"</span>)</div><div class=\"line\"><span class=\"keyword\">case</span> (-<span class=\"number\">2</span>...<span class=\"number\">2</span>, -<span class=\"number\">2</span>...<span class=\"number\">2</span>):</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"(<span class=\"subst\">\\(somePoint.<span class=\"number\">0</span>)</span>, <span class=\"subst\">\\(somePoint.<span class=\"number\">1</span>)</span>) is inside the box\"</span>)</div><div class=\"line\"><span class=\"keyword\">default</span>:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"(<span class=\"subst\">\\(somePoint.<span class=\"number\">0</span>)</span>, <span class=\"subst\">\\(somePoint.<span class=\"number\">1</span>)</span>) is outside of the box\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"(1, 1) is inside the box\"</span></div></pre></td></tr></table></figure>\n<h5 id=\"值绑定\"><a href=\"#值绑定\" class=\"headerlink\" title=\"值绑定\"></a>值绑定</h5><p>在switch的case语句中，可以将匹配的值绑定给一个临时的常量或者变量，在case的body中使用。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> anotherPoint = (<span class=\"number\">2</span>, <span class=\"number\">0</span>)</div><div class=\"line\"><span class=\"keyword\">switch</span> anotherPoint &#123;</div><div class=\"line\"><span class=\"keyword\">case</span> (<span class=\"keyword\">let</span> x, <span class=\"number\">0</span>):</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"on the x-axis with an x value of <span class=\"subst\">\\(x)</span>\"</span>)</div><div class=\"line\"><span class=\"keyword\">case</span> (<span class=\"number\">0</span>, <span class=\"keyword\">let</span> y):</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"on the y-axis with a y value of <span class=\"subst\">\\(y)</span>\"</span>)</div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"keyword\">let</span> (x, y):</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"somewhere else at (<span class=\"subst\">\\(x)</span>, <span class=\"subst\">\\(y)</span>)\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"on the x-axis with an x value of 2\"</span></div></pre></td></tr></table></figure>\n<h5 id=\"where\"><a href=\"#where\" class=\"headerlink\" title=\"where\"></a>where</h5><p>一个case语句中可以使用where语法进行额外的匹配检查，比如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> yetAnotherPoint = (<span class=\"number\">1</span>, -<span class=\"number\">1</span>)</div><div class=\"line\"><span class=\"keyword\">switch</span> yetAnotherPoint &#123;</div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"keyword\">let</span> (x, y) <span class=\"keyword\">where</span> x == y:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"(<span class=\"subst\">\\(x)</span>, <span class=\"subst\">\\(y)</span>) is on the line x == y\"</span>)</div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"keyword\">let</span> (x, y) <span class=\"keyword\">where</span> x == -y:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"(<span class=\"subst\">\\(x)</span>, <span class=\"subst\">\\(y)</span>) is on the line x == -y\"</span>)</div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"keyword\">let</span> (x, y):</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"(<span class=\"subst\">\\(x)</span>, <span class=\"subst\">\\(y)</span>) is just some arbitrary point\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"(1, -1) is on the line x == -y\"</span></div></pre></td></tr></table></figure>\n<h5 id=\"复合匹配\"><a href=\"#复合匹配\" class=\"headerlink\" title=\"复合匹配\"></a>复合匹配</h5><p>在case中通过逗号<code>,</code>隔开匹配内容。复合匹配也可以包含值绑定，在复合匹配中，无论哪个部分匹配上，case的body都会被执行。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> stillAnotherPoint = (<span class=\"number\">9</span>, <span class=\"number\">0</span>)</div><div class=\"line\"><span class=\"keyword\">switch</span> stillAnotherPoint &#123;</div><div class=\"line\"><span class=\"keyword\">case</span> (<span class=\"keyword\">let</span> <span class=\"built_in\">distance</span>, <span class=\"number\">0</span>), (<span class=\"number\">0</span>, <span class=\"keyword\">let</span> <span class=\"built_in\">distance</span>):</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"On an axis, <span class=\"subst\">\\(<span class=\"built_in\">distance</span>)</span> from the origin\"</span>)</div><div class=\"line\"><span class=\"keyword\">default</span>:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Not on an axis\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"On an axis, 9 from the origin\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"控制转移语句\"><a href=\"#控制转移语句\" class=\"headerlink\" title=\"控制转移语句\"></a>控制转移语句</h3><p>swift提供了5个流程控制转移语句：<code>continue</code>、<code>break</code>、<code>fallthrough</code>、<code>return</code>、<code>throw</code>。<br>除了<code>fallthrough</code>，其他四个关键字与C等语言中的基本相同，swift中的switch语句默认情况下不存在隐式穿透，如果想要支持，则需要在case语句后添加<code>fallthrough</code>，（注：该关键字不检查即将进入的case条件）例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> integerToDescribe = <span class=\"number\">5</span></div><div class=\"line\"><span class=\"keyword\">var</span> description = <span class=\"string\">\"The number <span class=\"subst\">\\(integerToDescribe)</span> is\"</span></div><div class=\"line\"><span class=\"keyword\">switch</span> integerToDescribe &#123;</div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>, <span class=\"number\">17</span>, <span class=\"number\">19</span>:</div><div class=\"line\">    description += <span class=\"string\">\" a prime number, and also\"</span></div><div class=\"line\">    <span class=\"keyword\">fallthrough</span></div><div class=\"line\"><span class=\"keyword\">default</span>:</div><div class=\"line\">    description += <span class=\"string\">\" an integer.\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">print</span>(description)</div><div class=\"line\"><span class=\"comment\">// Prints \"The number 5 is a prime number, and also an integer.\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"标签语法\"><a href=\"#标签语法\" class=\"headerlink\" title=\"标签语法\"></a>标签语法</h3><p>循环或条件语句可以嵌套，可以通过break语法结束当前代码块的执行，如果有多个嵌套的循环，明确哪个循环是非常有用的，为了实现这个目标，你可以使用标签语法。标签语法是由名字和冒号<code>:</code>组成。例如一个while循环的标签如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">label name: <span class=\"keyword\">while</span> condition &#123;</div><div class=\"line\">    statements</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"提前退出\"><a href=\"#提前退出\" class=\"headerlink\" title=\"提前退出\"></a>提前退出</h3><p>和<code>if</code>语法类似，<code>guard</code>语法语句的执行取决于一个bool表达式。可以使用<code>guard</code>语法来确保在特定条件成立的情况下执行某些代码。和<code>if</code>不同的是，<code>guard</code>语法在条件表达式为false时会执行<code>else</code>块中的内容。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> name = person[<span class=\"string\">\"name\"</span>] <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Hello <span class=\"subst\">\\(name)</span>!\"</span>)</div></pre></td></tr></table></figure>\n<h3 id=\"API有效性检查\"><a href=\"#API有效性检查\" class=\"headerlink\" title=\"API有效性检查\"></a>API有效性检查</h3><p>可以在<code>if</code>或<code>guard</code>语句中使用<code>availability</code>条件。其中平台比如：<code>iOS</code>, <code>macOS</code>, <code>watchOS</code>, 和 <code>tvOS</code>，语法格式如下</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> #available(platform name version, ..., *) &#123;</div><div class=\"line\">    statements to execute <span class=\"keyword\">if</span> the <span class=\"type\">APIs</span> are available</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    fallback statements to execute <span class=\"keyword\">if</span> the <span class=\"type\">APIs</span> are unavailable</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>具体写法例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> #available(iOS <span class=\"number\">10</span>, macOS <span class=\"number\">10.12</span>, *) &#123;</div><div class=\"line\">    <span class=\"comment\">// Use iOS 10 APIs on iOS, and use macOS 10.12 APIs on macOS</span></div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// Fall back to earlier iOS and macOS APIs</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ControlFlow.html/\" target=\"_blank\" rel=\"external\">Control Flow</a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>"},{"layout":"post","title":"Swift Deinitialization","date":"2016-11-27T16:20:11.000Z","author":"liangtong","catalog":true,"_content":"\n\n\n​\t析构器只适用于类类型，当一个类的实例被释放之前，析构器会被立即调用。析构器用关键字deinit来标示。\n\n\n\n### 析构过程\nSwift 会自动释放不再需要的实例以释放资源。通过自动引用计数（ARC）处理实例的内存管理。通常当你的实例被释放时不需要手动地去清理。但是，当使用自己的资源时，你可能需要进行一些额外的清理。例如，如果创建了一个自定义的类来打开一个文件，并写入一些数据，你可能需要在类实例被释放之前手动去关闭该文件。\n\n在类的定义中，每个类最多只能有一个析构器，而且析构器不带任何参数，如下所示：\n\n```Swift\ndeinit {\n    // perform the deinitialization\n}\n```\n\n析构器是在实例释放发生前被自动调用。你不能主动调用析构器。子类继承了父类的析构器，并且在子类析构器实现的最后，父类的析构器会被自动调用。即使子类没有提供自己的析构器，父类的析构器也同样会被调用。\n\n<!-- more -->\n\n因为直到实例的析构器被调用后，实例才会被释放，所以析构器可以访问实例的所有属性，并且可以根据那些属性可以修改它的行为（比如查找一个需要被关闭的文件）。\n\n### 析构实践\n这是一个析构器实践的例子。这个例子描述了一个简单的游戏，这里定义了两种新类型，分别是Bank和Player。Bank类管理一种虚拟硬币，确保流通的硬币数量永远不可能超过 10,000。在游戏中有且只能有一个Bank存在，因此Bank用类来实现，并使用类型属性和类型方法来存储和管理其当前状态。\n\n```Swift\nclass Bank {\n    static var coinsInBank = 10_000\n    static func distribute(coins numberOfCoinsRequested: Int) -> Int {\n        let numberOfCoinsToVend = min(numberOfCoinsRequested, coinsInBank)\n        coinsInBank -= numberOfCoinsToVend\n        return numberOfCoinsToVend\n    }\n    static func receive(coins: Int) {\n        coinsInBank += coins\n    }\n}\n```\n\nBank使用coinsInBank属性来跟踪它当前拥有的硬币数量。Bank还提供了两个方法，distribute(coins:)和receive(coins:)，分别用来处理硬币的分发和收集。\n\ndistribute(coins:)方法在Bank对象分发硬币之前检查是否有足够的硬币。如果硬币不足，Bank对象会返回一个比请求时小的数字（如果Bank对象中没有硬币了就返回0）。此方法返回一个整型值，表示提供的硬币的实际数量。\n\nreceive(coins:)方法只是将Bank实例接收到的硬币数目加回硬币存储中。\n\nPlayer类描述了游戏中的一个玩家。每一个玩家在任意时间都有一定数量的硬币存储在他们的钱包中。这通过玩家的coinsInPurse属性来表示：\n\n```Swift\nclass Player {\n    var coinsInPurse: Int\n    init(coins: Int) {\n        coinsInPurse = Bank.distribute(coins: coins)\n    }\n    func win(coins: Int) {\n        coinsInPurse += Bank.distribute(coins: coins)\n    }\n    deinit {\n        Bank.receive(coins: coinsInPurse)\n    }\n}\n```\n\n每个Player实例在初始化的过程中，都从Bank对象获取指定数量的硬币。如果没有足够的硬币可用，Player实例可能会收到比指定数量少的硬币.\n\nPlayer类定义了一个win(coins:)方法，该方法从Bank对象获取一定数量的硬币，并把它们添加到玩家的钱包。Player类还实现了一个析构器，这个析构器在Player实例释放前被调用。在这里，析构器的作用只是将玩家的所有硬币都返还给Bank对象：\n\n```Swift\nvar playerOne: Player? = Player(coins: 100)\nprint(\"A new player has joined the game with \\(playerOne!.coinsInPurse) coins\")\n// Prints \"A new player has joined the game with 100 coins\"\nprint(\"There are now \\(Bank.coinsInBank) coins left in the bank\")\n// Prints \"There are now 9900 coins left in the bank\"\n```\n\n创建一个Player实例的时候，会向Bank对象请求 100 个硬币，如果有足够的硬币可用的话。这个Player实例存储在一个名为playerOne的可选类型的变量中。这里使用了一个可选类型的变量，因为玩家可以随时离开游戏，设置为可选使你可以追踪玩家当前是否在游戏中。\n因为playerOne是可选的，所以访问其coinsInPurse属性来打印钱包中的硬币数量时，使用感叹号（!）来解包：\n\n```Swift\nplayerOne!.win(coins: 2_000)\nprint(\"PlayerOne won 2000 coins & now has \\(playerOne!.coinsInPurse) coins\")\n// Prints \"PlayerOne won 2000 coins & now has 2100 coins\"\nprint(\"The bank now only has \\(Bank.coinsInBank) coins left\")\n// Prints \"The bank now only has 7900 coins left\"\n```\n\n这里，玩家已经赢得了 2,000 枚硬币，所以玩家的钱包中现在有 2,100 枚硬币，而Bank对象只剩余 7,900 枚硬币。\n\n```Swift\nplayerOne = nil\nprint(\"PlayerOne has left the game\")\n// Prints \"PlayerOne has left the game\"\nprint(\"The bank now has \\(Bank.coinsInBank) coins\")\n// Prints \"The bank now has 10000 coins\"\n```\n\n玩家现在已经离开了游戏。这通过将可选类型的playerOne变量设置为nil来表示，意味着“没有Player实例”。当这一切发生时，playerOne变量对Player实例的引用被破坏了。没有其它属性或者变量引用Player实例，因此该实例会被释放，以便回收内存。在这之前，该实例的析构器被自动调用，玩家的硬币被返还给银行。\n\n\n\n\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Deinitialization.html/\"> Deinitialization </a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","source":"_posts/iOS_Swift_language_note_Deinitialization.md","raw":"---\nlayout:     post\ntitle:      Swift Deinitialization\ndate:       2016-11-28 00:20:11\nauthor:     liangtong\ncatalog: true\ncategories: iOS\ntags: Swift \n\n---\n\n\n\n​\t析构器只适用于类类型，当一个类的实例被释放之前，析构器会被立即调用。析构器用关键字deinit来标示。\n\n\n\n### 析构过程\nSwift 会自动释放不再需要的实例以释放资源。通过自动引用计数（ARC）处理实例的内存管理。通常当你的实例被释放时不需要手动地去清理。但是，当使用自己的资源时，你可能需要进行一些额外的清理。例如，如果创建了一个自定义的类来打开一个文件，并写入一些数据，你可能需要在类实例被释放之前手动去关闭该文件。\n\n在类的定义中，每个类最多只能有一个析构器，而且析构器不带任何参数，如下所示：\n\n```Swift\ndeinit {\n    // perform the deinitialization\n}\n```\n\n析构器是在实例释放发生前被自动调用。你不能主动调用析构器。子类继承了父类的析构器，并且在子类析构器实现的最后，父类的析构器会被自动调用。即使子类没有提供自己的析构器，父类的析构器也同样会被调用。\n\n<!-- more -->\n\n因为直到实例的析构器被调用后，实例才会被释放，所以析构器可以访问实例的所有属性，并且可以根据那些属性可以修改它的行为（比如查找一个需要被关闭的文件）。\n\n### 析构实践\n这是一个析构器实践的例子。这个例子描述了一个简单的游戏，这里定义了两种新类型，分别是Bank和Player。Bank类管理一种虚拟硬币，确保流通的硬币数量永远不可能超过 10,000。在游戏中有且只能有一个Bank存在，因此Bank用类来实现，并使用类型属性和类型方法来存储和管理其当前状态。\n\n```Swift\nclass Bank {\n    static var coinsInBank = 10_000\n    static func distribute(coins numberOfCoinsRequested: Int) -> Int {\n        let numberOfCoinsToVend = min(numberOfCoinsRequested, coinsInBank)\n        coinsInBank -= numberOfCoinsToVend\n        return numberOfCoinsToVend\n    }\n    static func receive(coins: Int) {\n        coinsInBank += coins\n    }\n}\n```\n\nBank使用coinsInBank属性来跟踪它当前拥有的硬币数量。Bank还提供了两个方法，distribute(coins:)和receive(coins:)，分别用来处理硬币的分发和收集。\n\ndistribute(coins:)方法在Bank对象分发硬币之前检查是否有足够的硬币。如果硬币不足，Bank对象会返回一个比请求时小的数字（如果Bank对象中没有硬币了就返回0）。此方法返回一个整型值，表示提供的硬币的实际数量。\n\nreceive(coins:)方法只是将Bank实例接收到的硬币数目加回硬币存储中。\n\nPlayer类描述了游戏中的一个玩家。每一个玩家在任意时间都有一定数量的硬币存储在他们的钱包中。这通过玩家的coinsInPurse属性来表示：\n\n```Swift\nclass Player {\n    var coinsInPurse: Int\n    init(coins: Int) {\n        coinsInPurse = Bank.distribute(coins: coins)\n    }\n    func win(coins: Int) {\n        coinsInPurse += Bank.distribute(coins: coins)\n    }\n    deinit {\n        Bank.receive(coins: coinsInPurse)\n    }\n}\n```\n\n每个Player实例在初始化的过程中，都从Bank对象获取指定数量的硬币。如果没有足够的硬币可用，Player实例可能会收到比指定数量少的硬币.\n\nPlayer类定义了一个win(coins:)方法，该方法从Bank对象获取一定数量的硬币，并把它们添加到玩家的钱包。Player类还实现了一个析构器，这个析构器在Player实例释放前被调用。在这里，析构器的作用只是将玩家的所有硬币都返还给Bank对象：\n\n```Swift\nvar playerOne: Player? = Player(coins: 100)\nprint(\"A new player has joined the game with \\(playerOne!.coinsInPurse) coins\")\n// Prints \"A new player has joined the game with 100 coins\"\nprint(\"There are now \\(Bank.coinsInBank) coins left in the bank\")\n// Prints \"There are now 9900 coins left in the bank\"\n```\n\n创建一个Player实例的时候，会向Bank对象请求 100 个硬币，如果有足够的硬币可用的话。这个Player实例存储在一个名为playerOne的可选类型的变量中。这里使用了一个可选类型的变量，因为玩家可以随时离开游戏，设置为可选使你可以追踪玩家当前是否在游戏中。\n因为playerOne是可选的，所以访问其coinsInPurse属性来打印钱包中的硬币数量时，使用感叹号（!）来解包：\n\n```Swift\nplayerOne!.win(coins: 2_000)\nprint(\"PlayerOne won 2000 coins & now has \\(playerOne!.coinsInPurse) coins\")\n// Prints \"PlayerOne won 2000 coins & now has 2100 coins\"\nprint(\"The bank now only has \\(Bank.coinsInBank) coins left\")\n// Prints \"The bank now only has 7900 coins left\"\n```\n\n这里，玩家已经赢得了 2,000 枚硬币，所以玩家的钱包中现在有 2,100 枚硬币，而Bank对象只剩余 7,900 枚硬币。\n\n```Swift\nplayerOne = nil\nprint(\"PlayerOne has left the game\")\n// Prints \"PlayerOne has left the game\"\nprint(\"The bank now has \\(Bank.coinsInBank) coins\")\n// Prints \"The bank now has 10000 coins\"\n```\n\n玩家现在已经离开了游戏。这通过将可选类型的playerOne变量设置为nil来表示，意味着“没有Player实例”。当这一切发生时，playerOne变量对Player实例的引用被破坏了。没有其它属性或者变量引用Player实例，因此该实例会被释放，以便回收内存。在这之前，该实例的析构器被自动调用，玩家的硬币被返还给银行。\n\n\n\n\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Deinitialization.html/\"> Deinitialization </a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","slug":"iOS_Swift_language_note_Deinitialization","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4u6002noko8zd3trl5k","content":"<p>​    析构器只适用于类类型，当一个类的实例被释放之前，析构器会被立即调用。析构器用关键字deinit来标示。</p>\n<h3 id=\"析构过程\"><a href=\"#析构过程\" class=\"headerlink\" title=\"析构过程\"></a>析构过程</h3><p>Swift 会自动释放不再需要的实例以释放资源。通过自动引用计数（ARC）处理实例的内存管理。通常当你的实例被释放时不需要手动地去清理。但是，当使用自己的资源时，你可能需要进行一些额外的清理。例如，如果创建了一个自定义的类来打开一个文件，并写入一些数据，你可能需要在类实例被释放之前手动去关闭该文件。</p>\n<p>在类的定义中，每个类最多只能有一个析构器，而且析构器不带任何参数，如下所示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">deinit</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// perform the deinitialization</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>析构器是在实例释放发生前被自动调用。你不能主动调用析构器。子类继承了父类的析构器，并且在子类析构器实现的最后，父类的析构器会被自动调用。即使子类没有提供自己的析构器，父类的析构器也同样会被调用。</p>\n<a id=\"more\"></a>\n<p>因为直到实例的析构器被调用后，实例才会被释放，所以析构器可以访问实例的所有属性，并且可以根据那些属性可以修改它的行为（比如查找一个需要被关闭的文件）。</p>\n<h3 id=\"析构实践\"><a href=\"#析构实践\" class=\"headerlink\" title=\"析构实践\"></a>析构实践</h3><p>这是一个析构器实践的例子。这个例子描述了一个简单的游戏，这里定义了两种新类型，分别是Bank和Player。Bank类管理一种虚拟硬币，确保流通的硬币数量永远不可能超过 10,000。在游戏中有且只能有一个Bank存在，因此Bank用类来实现，并使用类型属性和类型方法来存储和管理其当前状态。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bank</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> coinsInBank = <span class=\"number\">10_000</span></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">distribute</span><span class=\"params\">(coins numberOfCoinsRequested: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> numberOfCoinsToVend = <span class=\"built_in\">min</span>(numberOfCoinsRequested, coinsInBank)</div><div class=\"line\">        coinsInBank -= numberOfCoinsToVend</div><div class=\"line\">        <span class=\"keyword\">return</span> numberOfCoinsToVend</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">receive</span><span class=\"params\">(coins: Int)</span></span> &#123;</div><div class=\"line\">        coinsInBank += coins</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Bank使用coinsInBank属性来跟踪它当前拥有的硬币数量。Bank还提供了两个方法，distribute(coins:)和receive(coins:)，分别用来处理硬币的分发和收集。</p>\n<p>distribute(coins:)方法在Bank对象分发硬币之前检查是否有足够的硬币。如果硬币不足，Bank对象会返回一个比请求时小的数字（如果Bank对象中没有硬币了就返回0）。此方法返回一个整型值，表示提供的硬币的实际数量。</p>\n<p>receive(coins:)方法只是将Bank实例接收到的硬币数目加回硬币存储中。</p>\n<p>Player类描述了游戏中的一个玩家。每一个玩家在任意时间都有一定数量的硬币存储在他们的钱包中。这通过玩家的coinsInPurse属性来表示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Player</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> coinsInPurse: <span class=\"type\">Int</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(coins: <span class=\"type\">Int</span>) &#123;</div><div class=\"line\">        coinsInPurse = <span class=\"type\">Bank</span>.distribute(coins: coins)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">win</span><span class=\"params\">(coins: Int)</span></span> &#123;</div><div class=\"line\">        coinsInPurse += <span class=\"type\">Bank</span>.distribute(coins: coins)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">deinit</span> &#123;</div><div class=\"line\">        <span class=\"type\">Bank</span>.receive(coins: coinsInPurse)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>每个Player实例在初始化的过程中，都从Bank对象获取指定数量的硬币。如果没有足够的硬币可用，Player实例可能会收到比指定数量少的硬币.</p>\n<p>Player类定义了一个win(coins:)方法，该方法从Bank对象获取一定数量的硬币，并把它们添加到玩家的钱包。Player类还实现了一个析构器，这个析构器在Player实例释放前被调用。在这里，析构器的作用只是将玩家的所有硬币都返还给Bank对象：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> playerOne: <span class=\"type\">Player</span>? = <span class=\"type\">Player</span>(coins: <span class=\"number\">100</span>)</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"A new player has joined the game with <span class=\"subst\">\\(playerOne!.coinsInPurse)</span> coins\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"A new player has joined the game with 100 coins\"</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"There are now <span class=\"subst\">\\(Bank.coinsInBank)</span> coins left in the bank\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"There are now 9900 coins left in the bank\"</span></div></pre></td></tr></table></figure>\n<p>创建一个Player实例的时候，会向Bank对象请求 100 个硬币，如果有足够的硬币可用的话。这个Player实例存储在一个名为playerOne的可选类型的变量中。这里使用了一个可选类型的变量，因为玩家可以随时离开游戏，设置为可选使你可以追踪玩家当前是否在游戏中。<br>因为playerOne是可选的，所以访问其coinsInPurse属性来打印钱包中的硬币数量时，使用感叹号（!）来解包：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">playerOne!.win(coins: <span class=\"number\">2_000</span>)</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"PlayerOne won 2000 coins &amp; now has <span class=\"subst\">\\(playerOne!.coinsInPurse)</span> coins\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"PlayerOne won 2000 coins &amp; now has 2100 coins\"</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The bank now only has <span class=\"subst\">\\(Bank.coinsInBank)</span> coins left\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"The bank now only has 7900 coins left\"</span></div></pre></td></tr></table></figure>\n<p>这里，玩家已经赢得了 2,000 枚硬币，所以玩家的钱包中现在有 2,100 枚硬币，而Bank对象只剩余 7,900 枚硬币。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">playerOne = <span class=\"literal\">nil</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"PlayerOne has left the game\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"PlayerOne has left the game\"</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The bank now has <span class=\"subst\">\\(Bank.coinsInBank)</span> coins\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"The bank now has 10000 coins\"</span></div></pre></td></tr></table></figure>\n<p>玩家现在已经离开了游戏。这通过将可选类型的playerOne变量设置为nil来表示，意味着“没有Player实例”。当这一切发生时，playerOne变量对Player实例的引用被破坏了。没有其它属性或者变量引用Player实例，因此该实例会被释放，以便回收内存。在这之前，该实例的析构器被自动调用，玩家的硬币被返还给银行。</p>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Deinitialization.html/\" target=\"_blank\" rel=\"external\"> Deinitialization </a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>​    析构器只适用于类类型，当一个类的实例被释放之前，析构器会被立即调用。析构器用关键字deinit来标示。</p>\n<h3 id=\"析构过程\"><a href=\"#析构过程\" class=\"headerlink\" title=\"析构过程\"></a>析构过程</h3><p>Swift 会自动释放不再需要的实例以释放资源。通过自动引用计数（ARC）处理实例的内存管理。通常当你的实例被释放时不需要手动地去清理。但是，当使用自己的资源时，你可能需要进行一些额外的清理。例如，如果创建了一个自定义的类来打开一个文件，并写入一些数据，你可能需要在类实例被释放之前手动去关闭该文件。</p>\n<p>在类的定义中，每个类最多只能有一个析构器，而且析构器不带任何参数，如下所示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">deinit</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// perform the deinitialization</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>析构器是在实例释放发生前被自动调用。你不能主动调用析构器。子类继承了父类的析构器，并且在子类析构器实现的最后，父类的析构器会被自动调用。即使子类没有提供自己的析构器，父类的析构器也同样会被调用。</p>","more":"<p>因为直到实例的析构器被调用后，实例才会被释放，所以析构器可以访问实例的所有属性，并且可以根据那些属性可以修改它的行为（比如查找一个需要被关闭的文件）。</p>\n<h3 id=\"析构实践\"><a href=\"#析构实践\" class=\"headerlink\" title=\"析构实践\"></a>析构实践</h3><p>这是一个析构器实践的例子。这个例子描述了一个简单的游戏，这里定义了两种新类型，分别是Bank和Player。Bank类管理一种虚拟硬币，确保流通的硬币数量永远不可能超过 10,000。在游戏中有且只能有一个Bank存在，因此Bank用类来实现，并使用类型属性和类型方法来存储和管理其当前状态。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bank</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> coinsInBank = <span class=\"number\">10_000</span></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">distribute</span><span class=\"params\">(coins numberOfCoinsRequested: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> numberOfCoinsToVend = <span class=\"built_in\">min</span>(numberOfCoinsRequested, coinsInBank)</div><div class=\"line\">        coinsInBank -= numberOfCoinsToVend</div><div class=\"line\">        <span class=\"keyword\">return</span> numberOfCoinsToVend</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">receive</span><span class=\"params\">(coins: Int)</span></span> &#123;</div><div class=\"line\">        coinsInBank += coins</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Bank使用coinsInBank属性来跟踪它当前拥有的硬币数量。Bank还提供了两个方法，distribute(coins:)和receive(coins:)，分别用来处理硬币的分发和收集。</p>\n<p>distribute(coins:)方法在Bank对象分发硬币之前检查是否有足够的硬币。如果硬币不足，Bank对象会返回一个比请求时小的数字（如果Bank对象中没有硬币了就返回0）。此方法返回一个整型值，表示提供的硬币的实际数量。</p>\n<p>receive(coins:)方法只是将Bank实例接收到的硬币数目加回硬币存储中。</p>\n<p>Player类描述了游戏中的一个玩家。每一个玩家在任意时间都有一定数量的硬币存储在他们的钱包中。这通过玩家的coinsInPurse属性来表示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Player</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> coinsInPurse: <span class=\"type\">Int</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(coins: <span class=\"type\">Int</span>) &#123;</div><div class=\"line\">        coinsInPurse = <span class=\"type\">Bank</span>.distribute(coins: coins)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">win</span><span class=\"params\">(coins: Int)</span></span> &#123;</div><div class=\"line\">        coinsInPurse += <span class=\"type\">Bank</span>.distribute(coins: coins)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">deinit</span> &#123;</div><div class=\"line\">        <span class=\"type\">Bank</span>.receive(coins: coinsInPurse)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>每个Player实例在初始化的过程中，都从Bank对象获取指定数量的硬币。如果没有足够的硬币可用，Player实例可能会收到比指定数量少的硬币.</p>\n<p>Player类定义了一个win(coins:)方法，该方法从Bank对象获取一定数量的硬币，并把它们添加到玩家的钱包。Player类还实现了一个析构器，这个析构器在Player实例释放前被调用。在这里，析构器的作用只是将玩家的所有硬币都返还给Bank对象：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> playerOne: <span class=\"type\">Player</span>? = <span class=\"type\">Player</span>(coins: <span class=\"number\">100</span>)</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"A new player has joined the game with <span class=\"subst\">\\(playerOne!.coinsInPurse)</span> coins\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"A new player has joined the game with 100 coins\"</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"There are now <span class=\"subst\">\\(Bank.coinsInBank)</span> coins left in the bank\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"There are now 9900 coins left in the bank\"</span></div></pre></td></tr></table></figure>\n<p>创建一个Player实例的时候，会向Bank对象请求 100 个硬币，如果有足够的硬币可用的话。这个Player实例存储在一个名为playerOne的可选类型的变量中。这里使用了一个可选类型的变量，因为玩家可以随时离开游戏，设置为可选使你可以追踪玩家当前是否在游戏中。<br>因为playerOne是可选的，所以访问其coinsInPurse属性来打印钱包中的硬币数量时，使用感叹号（!）来解包：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">playerOne!.win(coins: <span class=\"number\">2_000</span>)</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"PlayerOne won 2000 coins &amp; now has <span class=\"subst\">\\(playerOne!.coinsInPurse)</span> coins\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"PlayerOne won 2000 coins &amp; now has 2100 coins\"</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The bank now only has <span class=\"subst\">\\(Bank.coinsInBank)</span> coins left\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"The bank now only has 7900 coins left\"</span></div></pre></td></tr></table></figure>\n<p>这里，玩家已经赢得了 2,000 枚硬币，所以玩家的钱包中现在有 2,100 枚硬币，而Bank对象只剩余 7,900 枚硬币。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">playerOne = <span class=\"literal\">nil</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"PlayerOne has left the game\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"PlayerOne has left the game\"</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The bank now has <span class=\"subst\">\\(Bank.coinsInBank)</span> coins\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"The bank now has 10000 coins\"</span></div></pre></td></tr></table></figure>\n<p>玩家现在已经离开了游戏。这通过将可选类型的playerOne变量设置为nil来表示，意味着“没有Player实例”。当这一切发生时，playerOne变量对Player实例的引用被破坏了。没有其它属性或者变量引用Player实例，因此该实例会被释放，以便回收内存。在这之前，该实例的析构器被自动调用，玩家的硬币被返还给银行。</p>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Deinitialization.html/\" target=\"_blank\" rel=\"external\"> Deinitialization </a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>"},{"layout":"post","title":"Swift Enumerations","date":"2016-11-22T16:20:11.000Z","author":"liangtong","catalog":true,"_content":"\n\n\n​\t枚举为一系相关联的值定义了一个公共的组类型来保证你在类型安全的情况下去使用这些值。 C语言里边的枚举是一系列整型值；Swift中的枚举更佳灵活，而且你不需要为枚举的每个成员赋值，枚举中的原始值（raw）可以是字符串、字符、数字等。\n​\t就像其他语言中的联合体和变体，枚举中的成员可以被指定为不同于其他成员的可以存储的类型，你可以在一个枚举中定义一组相关的枚举成员，每一个枚举成员都可以有适当类型的关联值。\n​\t在Swift中，枚举是一等（`first-class`）类型，它们支持了很多在传统上只被类（class）所支持的特性，比如计算属性（computed properties），用于提供枚举值的附加信息，实例方法（instance methods），用于提供和枚举值相关联的功能。枚举也可以定义构造函数（initializers）来提供一个初始值；可以在原始实现的基础上扩展它们的功能；还可以遵循协议（protocols）来提供标准的功能。\n\n\n\n### 枚举语法\n使用enum关键词来创建枚举并且把它们的整个定义放在一对大括号内：\n\n```Swift\nenum SomeEnumeration {\n    // enumeration definition goes here\n}\n```\n\n例如一个指南针方向的例子：\n\n```Swift\nenum CompassPoint {\n    case north\n    case south\n    case east\n    case west\n}\n```\n枚举中定义的值（如 north，south，east和west）是这个枚举的成员值（或成员）。你可以使用case关键字来定义一个新的枚举成员值。\n\t与 C 和 Objective-C 不同，Swift 的枚举成员在被创建时不会被赋予一个默认的整型值。在上面的CompassPoint例子中，north，south，east和west不会被隐式地赋值为0，1，2和3。相反，这些枚举成员本身就是完备的值，这些值的类型是已经明确定义好的CompassPoint类型。\n\n<!-- more -->\n\n多个成员变量可以出现在一行上，用逗号隔开：\n\n```Swift\nenum Planet {\n    case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune\n}\n```\n\n每个枚举定义了一个全新的类型。像 Swift 中其他类型一样，它们的名字（例如CompassPoint和Planet）应该以一个大写字母开头。给枚举类型起一个单数名字而不是复数名字，以便于读起来更加容易理解：\n\n```Swift\nvar directionToHead = CompassPoint.west\n```\n\ndirectionToHead的类型可以在它被CompassPoint的某个值初始化时推断出来。一旦directionToHead被声明为CompassPoint类型，你可以使用更简短的点语法将其设置为另一个CompassPoint的值：\n\n```Swift\ndirectionToHead = .east\n```\n\n### 使用 Switch 语句匹配枚举值\n可以使用`switch`语句来匹配枚举值，例如：\n\n```Swift\ndirectionToHead = .south\nswitch directionToHead {\ncase .north:\n    print(\"Lots of planets have a north\")\ncase .south:\n    print(\"Watch out for penguins\")\ncase .east:\n    print(\"Where the sun rises\")\ncase .west:\n    print(\"Where the skies are blue\")\n}\n// Prints \"Watch out for penguins\"\n```\n\n在判断一个枚举类型的值时，switch语句必须穷举所有情况。当不需要匹配每个枚举成员的时候，你可以提供一个default分支来涵盖所有未明确处理的枚举成员：\n\n```Swift\nlet somePlanet = Planet.earth\nswitch somePlanet {\ncase .earth:\n    print(\"Mostly harmless\")\ndefault:\n    print(\"Not a safe place for humans\")\n}\n// Prints \"Mostly harmless\"\n```\n\n### 关联值\n你可以定义 Swift 枚举来存储任意类型的关联值，如果需要的话，每个枚举成员的关联值类型可以各不相同。枚举的这种特性跟其他语言中的可识别联合（discriminated unions），标签联合（tagged unions），或者变体（variants）相似。\n例如，假设一个库存跟踪系统需要利用两种不同类型的条形码来跟踪商品。有些商品上标有使用0到9的数字的 UPC 格式的一维条形码。每一个条形码都有一个代表“数字系统”的数字，该数字后接五位代表“厂商代码”的数字，接下来是五位代表“产品代码”的数字。最后一个数字是“检查”位，用来验证代码是否被正确扫描：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/barcode_UPC_2x.png)\n其他商品上标有 QR 码格式的二维码，它可以使用任何 ISO 8859-1 字符，并且可以编码一个最多拥有 2,953 个字符的字符串：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/barcode_QR_2x.png)\n这便于库存跟踪系统用包含四个整型值的元组存储 UPC 码，以及用任意长度的字符串储存 QR 码。\n\n在 Swift 中，使用如下方式定义表示两种商品条形码的枚举：\n\n```Swift\nenum Barcode {\n    case upc(Int, Int, Int, Int)\n    case qrCode(String)\n}\n```\n\n可以使用任意一种条形码类型创建新的条形码，例如，创建了一个名为productBarcode的变量，并将Barcode.upc赋值给它，关联的元组值为(8, 85909, 51226, 3)：\n\n```Swift\nvar productBarcode = Barcode.upc(8, 85909, 51226, 3)\n```\n\n同一个商品可以被分配一个不同类型的条形码，例如，原始的Barcode.upc和其整数关联值被新的Barcode.qrCode和其字符串关联值所替代。Barcode类型的常量和变量可以存储一个.upc或者一个.qrCode（连同它们的关联值），但是在同一时间只能存储这两个值中的一个。：\n\n```Swift\nproductBarcode = .qrCode(\"ABCDEFGHIJKLMNOP\")\n```\n\n可以使用switch语句来匹配不同类型的枚举值，例如：\n\n```Swift\nswitch productBarcode {\ncase .upc(let numberSystem, let manufacturer, let product, let check):\n    print(\"UPC: \\(numberSystem), \\(manufacturer), \\(product), \\(check).\")\ncase .qrCode(let productCode):\n    print(\"QR code: \\(productCode).\")\n}\n// Prints \"QR code: ABCDEFGHIJKLMNOP.\"\n```\n\n如果一个枚举成员的所有关联值都被提取为常量，或者都被提取为变量，为了简洁，你可以只在成员名称前标注一个let或者var：\n\n```Swift\nswitch productBarcode {\ncase let .upc(numberSystem, manufacturer, product, check):\n    print(\"UPC : \\(numberSystem), \\(manufacturer), \\(product), \\(check).\")\ncase let .qrCode(productCode):\n    print(\"QR code: \\(productCode).\")\n}\n// Prints \"QR code: ABCDEFGHIJKLMNOP.\"\n```\n\n### 原始值raw\n作为关联值的替代选择，枚举成员可以被默认值（称为原始值）预填充，这些原始值的类型必须相同。例如，以下是一个使用 ASCII 码作为原始值的枚举：\n\n```Swift\nenum ASCIIControlCharacter: Character {\n    case tab = \"\\t\"\n    case lineFeed = \"\\n\"\n    case carriageReturn = \"\\r\"\n}\n```\n\n原始值可以是字符串，字符，或者任意整型值或浮点型值。每个原始值在枚举声明中必须是唯一的。\n\t原始值和关联值是不同的。原始值是在定义枚举时被预先填充的值，像上述三个 ASCII 码。对于一个特定的枚举成员，它的原始值始终不变。关联值是创建一个基于枚举成员的常量或变量时才设置的值，枚举成员的关联值可以变化。\n\n### 原始值的隐式赋值\n在使用原始值为整数或者字符串类型的枚举时，不需要显式地为每一个枚举成员设置原始值，Swift 将会自动为你赋值。\n例如，当使用整数作为原始值时，隐式赋值的值依次递增1。如果第一个枚举成员没有设置原始值，其原始值将为0。\n下面的枚举是对之前Planet这个枚举的一个细化，利用整型的原始值来表示每个行星在太阳系中的顺序：\n\n```Swift\nenum Planet: Int {\n    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune\n}\n```\n\n在上面的例子中，Plant.mercury的显式原始值为1，Planet.venus的隐式原始值为2，依次类推。\n\n当使用字符串作为枚举类型的原始值时，每个枚举成员的隐式原始值为该枚举成员的名称。\n下面的例子是CompassPoint枚举的细化，使用字符串类型的原始值来表示各个方向的名称：\n\n```Swift\nenum CompassPoint: String {\n    case north, south, east, west\n}\n```\n\n使用枚举成员的rawValue属性可以访问该枚举成员的原始值：\n\n```Swift\nlet earthsOrder = Planet.earth.rawValue\n// earthsOrder is 3\n \nlet sunsetDirection = CompassPoint.west.rawValue\n// sunsetDirection is \"west\"\n```\n\n### 使用原始值初始化枚举实例\n如果在定义枚举类型的时候使用了原始值，那么将会自动获得一个初始化方法，这个方法接收一个叫做rawValue的参数，参数类型即为原始值类型，返回值则是枚举成员或nil。你可以使用这个初始化方法来创建一个新的枚举实例。例如\n\n```Swift\nlet possiblePlanet = Planet(rawValue: 7)\n// possiblePlanet is of type Planet? and equals Planet.uranus\n```\n\n\t原始值构造器是一个可失败构造器，因为并不是每一个原始值都有与之对应的枚举成员。\n\n原始值构造器总是返回一个可选的枚举成员。例如：如果你试图寻找一个位置为11的行星，通过原始值构造器返回的可选Planet值将是nil：\n\n```Swift\nlet positionToFind = 11\nif let somePlanet = Planet(rawValue: positionToFind) {\n    switch somePlanet {\n    case .earth:\n        print(\"Mostly harmless\")\n    default:\n        print(\"Not a safe place for humans\")\n    }\n} else {\n    print(\"There isn't a planet at position \\(positionToFind)\")\n}\n// Prints \"There isn't a planet at position 11\"\n```\n\n### 递归枚举\n递归枚举是一种枚举类型，它有一个或多个枚举成员使用该枚举类型的实例作为关联值。使用递归枚举时，编译器会插入一个间接层。你可以在枚举成员前加上indirect来表示该成员可递归。\n例如，下面的例子中，枚举类型存储了简单的算术表达式：\n\n```Swift\nenum ArithmeticExpression {\n    case number(Int)\n    indirect case addition(ArithmeticExpression, ArithmeticExpression)\n    indirect case multiplication(ArithmeticExpression, ArithmeticExpression)\n}\n```\n\n你也可以在枚举类型开头加上indirect关键字来表明它的所有成员都是可递归的：\n\n```Swift\nenum ArithmeticExpression {\nindirect enum ArithmeticExpression {\n    case number(Int)\n    case addition(ArithmeticExpression, ArithmeticExpression)\n    case multiplication(ArithmeticExpression, ArithmeticExpression)\n}\n```\n\n上面定义的枚举类型可以存储三种算术表达式：纯数字、两个表达式相加、两个表达式相乘。枚举成员addition和multiplication的关联值也是算术表达式——这些关联值使得嵌套表达式成为可能。例如，表达式(5 + 4) * 2，乘号右边是一个数字，左边则是另一个表达式。因为数据是嵌套的，因而用来存储数据的枚举类型也需要支持这种嵌套——这意味着枚举类型需要支持递归。下面的代码展示了使用ArithmeticExpression这个递归枚举创建表达式(5 + 4) * 2\n\n```Swift\nlet five = ArithmeticExpression.number(5)\nlet four = ArithmeticExpression.number(4)\nlet sum = ArithmeticExpression.addition(five, four)\nlet product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(2))\n```\n\n要操作具有递归性质的数据结构，使用递归函数是一种直截了当的方式。例如，下面是一个对算术表达式求值的函数：\n\n```Swift\nfunc evaluate(_ expression: ArithmeticExpression) -> Int {\n    switch expression {\n    case let .number(value):\n        return value\n    case let .addition(left, right):\n        return evaluate(left) + evaluate(right)\n    case let .multiplication(left, right):\n        return evaluate(left) * evaluate(right)\n    }\n}\n \nprint(evaluate(product))\n// Prints \"18\"\n```\n\n该函数如果遇到纯数字，就直接返回该数字的值。如果遇到的是加法或乘法运算，则分别计算左边表达式和右边表达式的值，然后相加或相乘。\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html/\">Enumerations</a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","source":"_posts/iOS_Swift_language_note_Enumerations.md","raw":"---\nlayout:     post\ntitle:      Swift Enumerations\ndate:       2016-11-23 00:20:11\nauthor:     liangtong\ncatalog: true\ncategories: iOS\ntags: Swift \n\n---\n\n\n\n​\t枚举为一系相关联的值定义了一个公共的组类型来保证你在类型安全的情况下去使用这些值。 C语言里边的枚举是一系列整型值；Swift中的枚举更佳灵活，而且你不需要为枚举的每个成员赋值，枚举中的原始值（raw）可以是字符串、字符、数字等。\n​\t就像其他语言中的联合体和变体，枚举中的成员可以被指定为不同于其他成员的可以存储的类型，你可以在一个枚举中定义一组相关的枚举成员，每一个枚举成员都可以有适当类型的关联值。\n​\t在Swift中，枚举是一等（`first-class`）类型，它们支持了很多在传统上只被类（class）所支持的特性，比如计算属性（computed properties），用于提供枚举值的附加信息，实例方法（instance methods），用于提供和枚举值相关联的功能。枚举也可以定义构造函数（initializers）来提供一个初始值；可以在原始实现的基础上扩展它们的功能；还可以遵循协议（protocols）来提供标准的功能。\n\n\n\n### 枚举语法\n使用enum关键词来创建枚举并且把它们的整个定义放在一对大括号内：\n\n```Swift\nenum SomeEnumeration {\n    // enumeration definition goes here\n}\n```\n\n例如一个指南针方向的例子：\n\n```Swift\nenum CompassPoint {\n    case north\n    case south\n    case east\n    case west\n}\n```\n枚举中定义的值（如 north，south，east和west）是这个枚举的成员值（或成员）。你可以使用case关键字来定义一个新的枚举成员值。\n\t与 C 和 Objective-C 不同，Swift 的枚举成员在被创建时不会被赋予一个默认的整型值。在上面的CompassPoint例子中，north，south，east和west不会被隐式地赋值为0，1，2和3。相反，这些枚举成员本身就是完备的值，这些值的类型是已经明确定义好的CompassPoint类型。\n\n<!-- more -->\n\n多个成员变量可以出现在一行上，用逗号隔开：\n\n```Swift\nenum Planet {\n    case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune\n}\n```\n\n每个枚举定义了一个全新的类型。像 Swift 中其他类型一样，它们的名字（例如CompassPoint和Planet）应该以一个大写字母开头。给枚举类型起一个单数名字而不是复数名字，以便于读起来更加容易理解：\n\n```Swift\nvar directionToHead = CompassPoint.west\n```\n\ndirectionToHead的类型可以在它被CompassPoint的某个值初始化时推断出来。一旦directionToHead被声明为CompassPoint类型，你可以使用更简短的点语法将其设置为另一个CompassPoint的值：\n\n```Swift\ndirectionToHead = .east\n```\n\n### 使用 Switch 语句匹配枚举值\n可以使用`switch`语句来匹配枚举值，例如：\n\n```Swift\ndirectionToHead = .south\nswitch directionToHead {\ncase .north:\n    print(\"Lots of planets have a north\")\ncase .south:\n    print(\"Watch out for penguins\")\ncase .east:\n    print(\"Where the sun rises\")\ncase .west:\n    print(\"Where the skies are blue\")\n}\n// Prints \"Watch out for penguins\"\n```\n\n在判断一个枚举类型的值时，switch语句必须穷举所有情况。当不需要匹配每个枚举成员的时候，你可以提供一个default分支来涵盖所有未明确处理的枚举成员：\n\n```Swift\nlet somePlanet = Planet.earth\nswitch somePlanet {\ncase .earth:\n    print(\"Mostly harmless\")\ndefault:\n    print(\"Not a safe place for humans\")\n}\n// Prints \"Mostly harmless\"\n```\n\n### 关联值\n你可以定义 Swift 枚举来存储任意类型的关联值，如果需要的话，每个枚举成员的关联值类型可以各不相同。枚举的这种特性跟其他语言中的可识别联合（discriminated unions），标签联合（tagged unions），或者变体（variants）相似。\n例如，假设一个库存跟踪系统需要利用两种不同类型的条形码来跟踪商品。有些商品上标有使用0到9的数字的 UPC 格式的一维条形码。每一个条形码都有一个代表“数字系统”的数字，该数字后接五位代表“厂商代码”的数字，接下来是五位代表“产品代码”的数字。最后一个数字是“检查”位，用来验证代码是否被正确扫描：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/barcode_UPC_2x.png)\n其他商品上标有 QR 码格式的二维码，它可以使用任何 ISO 8859-1 字符，并且可以编码一个最多拥有 2,953 个字符的字符串：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/barcode_QR_2x.png)\n这便于库存跟踪系统用包含四个整型值的元组存储 UPC 码，以及用任意长度的字符串储存 QR 码。\n\n在 Swift 中，使用如下方式定义表示两种商品条形码的枚举：\n\n```Swift\nenum Barcode {\n    case upc(Int, Int, Int, Int)\n    case qrCode(String)\n}\n```\n\n可以使用任意一种条形码类型创建新的条形码，例如，创建了一个名为productBarcode的变量，并将Barcode.upc赋值给它，关联的元组值为(8, 85909, 51226, 3)：\n\n```Swift\nvar productBarcode = Barcode.upc(8, 85909, 51226, 3)\n```\n\n同一个商品可以被分配一个不同类型的条形码，例如，原始的Barcode.upc和其整数关联值被新的Barcode.qrCode和其字符串关联值所替代。Barcode类型的常量和变量可以存储一个.upc或者一个.qrCode（连同它们的关联值），但是在同一时间只能存储这两个值中的一个。：\n\n```Swift\nproductBarcode = .qrCode(\"ABCDEFGHIJKLMNOP\")\n```\n\n可以使用switch语句来匹配不同类型的枚举值，例如：\n\n```Swift\nswitch productBarcode {\ncase .upc(let numberSystem, let manufacturer, let product, let check):\n    print(\"UPC: \\(numberSystem), \\(manufacturer), \\(product), \\(check).\")\ncase .qrCode(let productCode):\n    print(\"QR code: \\(productCode).\")\n}\n// Prints \"QR code: ABCDEFGHIJKLMNOP.\"\n```\n\n如果一个枚举成员的所有关联值都被提取为常量，或者都被提取为变量，为了简洁，你可以只在成员名称前标注一个let或者var：\n\n```Swift\nswitch productBarcode {\ncase let .upc(numberSystem, manufacturer, product, check):\n    print(\"UPC : \\(numberSystem), \\(manufacturer), \\(product), \\(check).\")\ncase let .qrCode(productCode):\n    print(\"QR code: \\(productCode).\")\n}\n// Prints \"QR code: ABCDEFGHIJKLMNOP.\"\n```\n\n### 原始值raw\n作为关联值的替代选择，枚举成员可以被默认值（称为原始值）预填充，这些原始值的类型必须相同。例如，以下是一个使用 ASCII 码作为原始值的枚举：\n\n```Swift\nenum ASCIIControlCharacter: Character {\n    case tab = \"\\t\"\n    case lineFeed = \"\\n\"\n    case carriageReturn = \"\\r\"\n}\n```\n\n原始值可以是字符串，字符，或者任意整型值或浮点型值。每个原始值在枚举声明中必须是唯一的。\n\t原始值和关联值是不同的。原始值是在定义枚举时被预先填充的值，像上述三个 ASCII 码。对于一个特定的枚举成员，它的原始值始终不变。关联值是创建一个基于枚举成员的常量或变量时才设置的值，枚举成员的关联值可以变化。\n\n### 原始值的隐式赋值\n在使用原始值为整数或者字符串类型的枚举时，不需要显式地为每一个枚举成员设置原始值，Swift 将会自动为你赋值。\n例如，当使用整数作为原始值时，隐式赋值的值依次递增1。如果第一个枚举成员没有设置原始值，其原始值将为0。\n下面的枚举是对之前Planet这个枚举的一个细化，利用整型的原始值来表示每个行星在太阳系中的顺序：\n\n```Swift\nenum Planet: Int {\n    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune\n}\n```\n\n在上面的例子中，Plant.mercury的显式原始值为1，Planet.venus的隐式原始值为2，依次类推。\n\n当使用字符串作为枚举类型的原始值时，每个枚举成员的隐式原始值为该枚举成员的名称。\n下面的例子是CompassPoint枚举的细化，使用字符串类型的原始值来表示各个方向的名称：\n\n```Swift\nenum CompassPoint: String {\n    case north, south, east, west\n}\n```\n\n使用枚举成员的rawValue属性可以访问该枚举成员的原始值：\n\n```Swift\nlet earthsOrder = Planet.earth.rawValue\n// earthsOrder is 3\n \nlet sunsetDirection = CompassPoint.west.rawValue\n// sunsetDirection is \"west\"\n```\n\n### 使用原始值初始化枚举实例\n如果在定义枚举类型的时候使用了原始值，那么将会自动获得一个初始化方法，这个方法接收一个叫做rawValue的参数，参数类型即为原始值类型，返回值则是枚举成员或nil。你可以使用这个初始化方法来创建一个新的枚举实例。例如\n\n```Swift\nlet possiblePlanet = Planet(rawValue: 7)\n// possiblePlanet is of type Planet? and equals Planet.uranus\n```\n\n\t原始值构造器是一个可失败构造器，因为并不是每一个原始值都有与之对应的枚举成员。\n\n原始值构造器总是返回一个可选的枚举成员。例如：如果你试图寻找一个位置为11的行星，通过原始值构造器返回的可选Planet值将是nil：\n\n```Swift\nlet positionToFind = 11\nif let somePlanet = Planet(rawValue: positionToFind) {\n    switch somePlanet {\n    case .earth:\n        print(\"Mostly harmless\")\n    default:\n        print(\"Not a safe place for humans\")\n    }\n} else {\n    print(\"There isn't a planet at position \\(positionToFind)\")\n}\n// Prints \"There isn't a planet at position 11\"\n```\n\n### 递归枚举\n递归枚举是一种枚举类型，它有一个或多个枚举成员使用该枚举类型的实例作为关联值。使用递归枚举时，编译器会插入一个间接层。你可以在枚举成员前加上indirect来表示该成员可递归。\n例如，下面的例子中，枚举类型存储了简单的算术表达式：\n\n```Swift\nenum ArithmeticExpression {\n    case number(Int)\n    indirect case addition(ArithmeticExpression, ArithmeticExpression)\n    indirect case multiplication(ArithmeticExpression, ArithmeticExpression)\n}\n```\n\n你也可以在枚举类型开头加上indirect关键字来表明它的所有成员都是可递归的：\n\n```Swift\nenum ArithmeticExpression {\nindirect enum ArithmeticExpression {\n    case number(Int)\n    case addition(ArithmeticExpression, ArithmeticExpression)\n    case multiplication(ArithmeticExpression, ArithmeticExpression)\n}\n```\n\n上面定义的枚举类型可以存储三种算术表达式：纯数字、两个表达式相加、两个表达式相乘。枚举成员addition和multiplication的关联值也是算术表达式——这些关联值使得嵌套表达式成为可能。例如，表达式(5 + 4) * 2，乘号右边是一个数字，左边则是另一个表达式。因为数据是嵌套的，因而用来存储数据的枚举类型也需要支持这种嵌套——这意味着枚举类型需要支持递归。下面的代码展示了使用ArithmeticExpression这个递归枚举创建表达式(5 + 4) * 2\n\n```Swift\nlet five = ArithmeticExpression.number(5)\nlet four = ArithmeticExpression.number(4)\nlet sum = ArithmeticExpression.addition(five, four)\nlet product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(2))\n```\n\n要操作具有递归性质的数据结构，使用递归函数是一种直截了当的方式。例如，下面是一个对算术表达式求值的函数：\n\n```Swift\nfunc evaluate(_ expression: ArithmeticExpression) -> Int {\n    switch expression {\n    case let .number(value):\n        return value\n    case let .addition(left, right):\n        return evaluate(left) + evaluate(right)\n    case let .multiplication(left, right):\n        return evaluate(left) * evaluate(right)\n    }\n}\n \nprint(evaluate(product))\n// Prints \"18\"\n```\n\n该函数如果遇到纯数字，就直接返回该数字的值。如果遇到的是加法或乘法运算，则分别计算左边表达式和右边表达式的值，然后相加或相乘。\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html/\">Enumerations</a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","slug":"iOS_Swift_language_note_Enumerations","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4u7002qoko82f2dhdb5","content":"<p>​    枚举为一系相关联的值定义了一个公共的组类型来保证你在类型安全的情况下去使用这些值。 C语言里边的枚举是一系列整型值；Swift中的枚举更佳灵活，而且你不需要为枚举的每个成员赋值，枚举中的原始值（raw）可以是字符串、字符、数字等。<br>​    就像其他语言中的联合体和变体，枚举中的成员可以被指定为不同于其他成员的可以存储的类型，你可以在一个枚举中定义一组相关的枚举成员，每一个枚举成员都可以有适当类型的关联值。<br>​    在Swift中，枚举是一等（<code>first-class</code>）类型，它们支持了很多在传统上只被类（class）所支持的特性，比如计算属性（computed properties），用于提供枚举值的附加信息，实例方法（instance methods），用于提供和枚举值相关联的功能。枚举也可以定义构造函数（initializers）来提供一个初始值；可以在原始实现的基础上扩展它们的功能；还可以遵循协议（protocols）来提供标准的功能。</p>\n<h3 id=\"枚举语法\"><a href=\"#枚举语法\" class=\"headerlink\" title=\"枚举语法\"></a>枚举语法</h3><p>使用enum关键词来创建枚举并且把它们的整个定义放在一对大括号内：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">SomeEnumeration</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// enumeration definition goes here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>例如一个指南针方向的例子：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">CompassPoint</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> north</div><div class=\"line\">    <span class=\"keyword\">case</span> south</div><div class=\"line\">    <span class=\"keyword\">case</span> east</div><div class=\"line\">    <span class=\"keyword\">case</span> west</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>枚举中定义的值（如 north，south，east和west）是这个枚举的成员值（或成员）。你可以使用case关键字来定义一个新的枚举成员值。<br>    与 C 和 Objective-C 不同，Swift 的枚举成员在被创建时不会被赋予一个默认的整型值。在上面的CompassPoint例子中，north，south，east和west不会被隐式地赋值为0，1，2和3。相反，这些枚举成员本身就是完备的值，这些值的类型是已经明确定义好的CompassPoint类型。</p>\n<a id=\"more\"></a>\n<p>多个成员变量可以出现在一行上，用逗号隔开：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Planet</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> mercury, venus, earth, mars, jupiter, saturn, uranus, neptune</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>每个枚举定义了一个全新的类型。像 Swift 中其他类型一样，它们的名字（例如CompassPoint和Planet）应该以一个大写字母开头。给枚举类型起一个单数名字而不是复数名字，以便于读起来更加容易理解：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> directionToHead = <span class=\"type\">CompassPoint</span>.west</div></pre></td></tr></table></figure>\n<p>directionToHead的类型可以在它被CompassPoint的某个值初始化时推断出来。一旦directionToHead被声明为CompassPoint类型，你可以使用更简短的点语法将其设置为另一个CompassPoint的值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">directionToHead = .east</div></pre></td></tr></table></figure>\n<h3 id=\"使用-Switch-语句匹配枚举值\"><a href=\"#使用-Switch-语句匹配枚举值\" class=\"headerlink\" title=\"使用 Switch 语句匹配枚举值\"></a>使用 Switch 语句匹配枚举值</h3><p>可以使用<code>switch</code>语句来匹配枚举值，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">directionToHead = .south</div><div class=\"line\"><span class=\"keyword\">switch</span> directionToHead &#123;</div><div class=\"line\"><span class=\"keyword\">case</span> .north:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Lots of planets have a north\"</span>)</div><div class=\"line\"><span class=\"keyword\">case</span> .south:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Watch out for penguins\"</span>)</div><div class=\"line\"><span class=\"keyword\">case</span> .east:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Where the sun rises\"</span>)</div><div class=\"line\"><span class=\"keyword\">case</span> .west:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Where the skies are blue\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"Watch out for penguins\"</span></div></pre></td></tr></table></figure>\n<p>在判断一个枚举类型的值时，switch语句必须穷举所有情况。当不需要匹配每个枚举成员的时候，你可以提供一个default分支来涵盖所有未明确处理的枚举成员：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> somePlanet = <span class=\"type\">Planet</span>.earth</div><div class=\"line\"><span class=\"keyword\">switch</span> somePlanet &#123;</div><div class=\"line\"><span class=\"keyword\">case</span> .earth:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Mostly harmless\"</span>)</div><div class=\"line\"><span class=\"keyword\">default</span>:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Not a safe place for humans\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"Mostly harmless\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"关联值\"><a href=\"#关联值\" class=\"headerlink\" title=\"关联值\"></a>关联值</h3><p>你可以定义 Swift 枚举来存储任意类型的关联值，如果需要的话，每个枚举成员的关联值类型可以各不相同。枚举的这种特性跟其他语言中的可识别联合（discriminated unions），标签联合（tagged unions），或者变体（variants）相似。<br>例如，假设一个库存跟踪系统需要利用两种不同类型的条形码来跟踪商品。有些商品上标有使用0到9的数字的 UPC 格式的一维条形码。每一个条形码都有一个代表“数字系统”的数字，该数字后接五位代表“厂商代码”的数字，接下来是五位代表“产品代码”的数字。最后一个数字是“检查”位，用来验证代码是否被正确扫描：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/barcode_UPC_2x.png\" alt=\"\"><br>其他商品上标有 QR 码格式的二维码，它可以使用任何 ISO 8859-1 字符，并且可以编码一个最多拥有 2,953 个字符的字符串：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/barcode_QR_2x.png\" alt=\"\"><br>这便于库存跟踪系统用包含四个整型值的元组存储 UPC 码，以及用任意长度的字符串储存 QR 码。</p>\n<p>在 Swift 中，使用如下方式定义表示两种商品条形码的枚举：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Barcode</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> upc(<span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>)</div><div class=\"line\">    <span class=\"keyword\">case</span> qrCode(<span class=\"type\">String</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以使用任意一种条形码类型创建新的条形码，例如，创建了一个名为productBarcode的变量，并将Barcode.upc赋值给它，关联的元组值为(8, 85909, 51226, 3)：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> productBarcode = <span class=\"type\">Barcode</span>.upc(<span class=\"number\">8</span>, <span class=\"number\">85909</span>, <span class=\"number\">51226</span>, <span class=\"number\">3</span>)</div></pre></td></tr></table></figure>\n<p>同一个商品可以被分配一个不同类型的条形码，例如，原始的Barcode.upc和其整数关联值被新的Barcode.qrCode和其字符串关联值所替代。Barcode类型的常量和变量可以存储一个.upc或者一个.qrCode（连同它们的关联值），但是在同一时间只能存储这两个值中的一个。：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">productBarcode = .qrCode(<span class=\"string\">\"ABCDEFGHIJKLMNOP\"</span>)</div></pre></td></tr></table></figure>\n<p>可以使用switch语句来匹配不同类型的枚举值，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">switch</span> productBarcode &#123;</div><div class=\"line\"><span class=\"keyword\">case</span> .upc(<span class=\"keyword\">let</span> numberSystem, <span class=\"keyword\">let</span> manufacturer, <span class=\"keyword\">let</span> product, <span class=\"keyword\">let</span> check):</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"UPC: <span class=\"subst\">\\(numberSystem)</span>, <span class=\"subst\">\\(manufacturer)</span>, <span class=\"subst\">\\(product)</span>, <span class=\"subst\">\\(check)</span>.\"</span>)</div><div class=\"line\"><span class=\"keyword\">case</span> .qrCode(<span class=\"keyword\">let</span> productCode):</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"QR code: <span class=\"subst\">\\(productCode)</span>.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"QR code: ABCDEFGHIJKLMNOP.\"</span></div></pre></td></tr></table></figure>\n<p>如果一个枚举成员的所有关联值都被提取为常量，或者都被提取为变量，为了简洁，你可以只在成员名称前标注一个let或者var：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">switch</span> productBarcode &#123;</div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"keyword\">let</span> .upc(numberSystem, manufacturer, product, check):</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"UPC : <span class=\"subst\">\\(numberSystem)</span>, <span class=\"subst\">\\(manufacturer)</span>, <span class=\"subst\">\\(product)</span>, <span class=\"subst\">\\(check)</span>.\"</span>)</div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"keyword\">let</span> .qrCode(productCode):</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"QR code: <span class=\"subst\">\\(productCode)</span>.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"QR code: ABCDEFGHIJKLMNOP.\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"原始值raw\"><a href=\"#原始值raw\" class=\"headerlink\" title=\"原始值raw\"></a>原始值raw</h3><p>作为关联值的替代选择，枚举成员可以被默认值（称为原始值）预填充，这些原始值的类型必须相同。例如，以下是一个使用 ASCII 码作为原始值的枚举：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">ASCIIControlCharacter</span>: <span class=\"title\">Character</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> tab = <span class=\"string\">\"\\t\"</span></div><div class=\"line\">    <span class=\"keyword\">case</span> lineFeed = <span class=\"string\">\"\\n\"</span></div><div class=\"line\">    <span class=\"keyword\">case</span> carriageReturn = <span class=\"string\">\"\\r\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>原始值可以是字符串，字符，或者任意整型值或浮点型值。每个原始值在枚举声明中必须是唯一的。<br>    原始值和关联值是不同的。原始值是在定义枚举时被预先填充的值，像上述三个 ASCII 码。对于一个特定的枚举成员，它的原始值始终不变。关联值是创建一个基于枚举成员的常量或变量时才设置的值，枚举成员的关联值可以变化。</p>\n<h3 id=\"原始值的隐式赋值\"><a href=\"#原始值的隐式赋值\" class=\"headerlink\" title=\"原始值的隐式赋值\"></a>原始值的隐式赋值</h3><p>在使用原始值为整数或者字符串类型的枚举时，不需要显式地为每一个枚举成员设置原始值，Swift 将会自动为你赋值。<br>例如，当使用整数作为原始值时，隐式赋值的值依次递增1。如果第一个枚举成员没有设置原始值，其原始值将为0。<br>下面的枚举是对之前Planet这个枚举的一个细化，利用整型的原始值来表示每个行星在太阳系中的顺序：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Planet</span>: <span class=\"title\">Int</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> mercury = <span class=\"number\">1</span>, venus, earth, mars, jupiter, saturn, uranus, neptune</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在上面的例子中，Plant.mercury的显式原始值为1，Planet.venus的隐式原始值为2，依次类推。</p>\n<p>当使用字符串作为枚举类型的原始值时，每个枚举成员的隐式原始值为该枚举成员的名称。<br>下面的例子是CompassPoint枚举的细化，使用字符串类型的原始值来表示各个方向的名称：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">CompassPoint</span>: <span class=\"title\">String</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> north, south, east, west</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用枚举成员的rawValue属性可以访问该枚举成员的原始值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> earthsOrder = <span class=\"type\">Planet</span>.earth.rawValue</div><div class=\"line\"><span class=\"comment\">// earthsOrder is 3</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">let</span> sunsetDirection = <span class=\"type\">CompassPoint</span>.west.rawValue</div><div class=\"line\"><span class=\"comment\">// sunsetDirection is \"west\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"使用原始值初始化枚举实例\"><a href=\"#使用原始值初始化枚举实例\" class=\"headerlink\" title=\"使用原始值初始化枚举实例\"></a>使用原始值初始化枚举实例</h3><p>如果在定义枚举类型的时候使用了原始值，那么将会自动获得一个初始化方法，这个方法接收一个叫做rawValue的参数，参数类型即为原始值类型，返回值则是枚举成员或nil。你可以使用这个初始化方法来创建一个新的枚举实例。例如</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> possiblePlanet = <span class=\"type\">Planet</span>(rawValue: <span class=\"number\">7</span>)</div><div class=\"line\"><span class=\"comment\">// possiblePlanet is of type Planet? and equals Planet.uranus</span></div></pre></td></tr></table></figure>\n<pre><code>原始值构造器是一个可失败构造器，因为并不是每一个原始值都有与之对应的枚举成员。\n</code></pre><p>原始值构造器总是返回一个可选的枚举成员。例如：如果你试图寻找一个位置为11的行星，通过原始值构造器返回的可选Planet值将是nil：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> positionToFind = <span class=\"number\">11</span></div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> somePlanet = <span class=\"type\">Planet</span>(rawValue: positionToFind) &#123;</div><div class=\"line\">    <span class=\"keyword\">switch</span> somePlanet &#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> .earth:</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Mostly harmless\"</span>)</div><div class=\"line\">    <span class=\"keyword\">default</span>:</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Not a safe place for humans\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"There isn't a planet at position <span class=\"subst\">\\(positionToFind)</span>\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"There isn't a planet at position 11\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"递归枚举\"><a href=\"#递归枚举\" class=\"headerlink\" title=\"递归枚举\"></a>递归枚举</h3><p>递归枚举是一种枚举类型，它有一个或多个枚举成员使用该枚举类型的实例作为关联值。使用递归枚举时，编译器会插入一个间接层。你可以在枚举成员前加上indirect来表示该成员可递归。<br>例如，下面的例子中，枚举类型存储了简单的算术表达式：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">ArithmeticExpression</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> number(<span class=\"type\">Int</span>)</div><div class=\"line\">    <span class=\"keyword\">indirect</span> <span class=\"keyword\">case</span> addition(<span class=\"type\">ArithmeticExpression</span>, <span class=\"type\">ArithmeticExpression</span>)</div><div class=\"line\">    <span class=\"keyword\">indirect</span> <span class=\"keyword\">case</span> multiplication(<span class=\"type\">ArithmeticExpression</span>, <span class=\"type\">ArithmeticExpression</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你也可以在枚举类型开头加上indirect关键字来表明它的所有成员都是可递归的：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">ArithmeticExpression</span> </span>&#123;</div><div class=\"line\"><span class=\"keyword\">indirect</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">ArithmeticExpression</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> number(<span class=\"type\">Int</span>)</div><div class=\"line\">    <span class=\"keyword\">case</span> addition(<span class=\"type\">ArithmeticExpression</span>, <span class=\"type\">ArithmeticExpression</span>)</div><div class=\"line\">    <span class=\"keyword\">case</span> multiplication(<span class=\"type\">ArithmeticExpression</span>, <span class=\"type\">ArithmeticExpression</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面定义的枚举类型可以存储三种算术表达式：纯数字、两个表达式相加、两个表达式相乘。枚举成员addition和multiplication的关联值也是算术表达式——这些关联值使得嵌套表达式成为可能。例如，表达式(5 + 4) <em> 2，乘号右边是一个数字，左边则是另一个表达式。因为数据是嵌套的，因而用来存储数据的枚举类型也需要支持这种嵌套——这意味着枚举类型需要支持递归。下面的代码展示了使用ArithmeticExpression这个递归枚举创建表达式(5 + 4) </em> 2</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> five = <span class=\"type\">ArithmeticExpression</span>.number(<span class=\"number\">5</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> four = <span class=\"type\">ArithmeticExpression</span>.number(<span class=\"number\">4</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> sum = <span class=\"type\">ArithmeticExpression</span>.addition(five, four)</div><div class=\"line\"><span class=\"keyword\">let</span> product = <span class=\"type\">ArithmeticExpression</span>.multiplication(sum, <span class=\"type\">ArithmeticExpression</span>.number(<span class=\"number\">2</span>))</div></pre></td></tr></table></figure>\n<p>要操作具有递归性质的数据结构，使用递归函数是一种直截了当的方式。例如，下面是一个对算术表达式求值的函数：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">evaluate</span><span class=\"params\">(<span class=\"number\">_</span> expression: ArithmeticExpression)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">switch</span> expression &#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> .number(value):</div><div class=\"line\">        <span class=\"keyword\">return</span> value</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> .addition(<span class=\"keyword\">left</span>, <span class=\"keyword\">right</span>):</div><div class=\"line\">        <span class=\"keyword\">return</span> evaluate(<span class=\"keyword\">left</span>) + evaluate(<span class=\"keyword\">right</span>)</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> .multiplication(<span class=\"keyword\">left</span>, <span class=\"keyword\">right</span>):</div><div class=\"line\">        <span class=\"keyword\">return</span> evaluate(<span class=\"keyword\">left</span>) * evaluate(<span class=\"keyword\">right</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"built_in\">print</span>(evaluate(product))</div><div class=\"line\"><span class=\"comment\">// Prints \"18\"</span></div></pre></td></tr></table></figure>\n<p>该函数如果遇到纯数字，就直接返回该数字的值。如果遇到的是加法或乘法运算，则分别计算左边表达式和右边表达式的值，然后相加或相乘。</p>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html/\" target=\"_blank\" rel=\"external\">Enumerations</a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>​    枚举为一系相关联的值定义了一个公共的组类型来保证你在类型安全的情况下去使用这些值。 C语言里边的枚举是一系列整型值；Swift中的枚举更佳灵活，而且你不需要为枚举的每个成员赋值，枚举中的原始值（raw）可以是字符串、字符、数字等。<br>​    就像其他语言中的联合体和变体，枚举中的成员可以被指定为不同于其他成员的可以存储的类型，你可以在一个枚举中定义一组相关的枚举成员，每一个枚举成员都可以有适当类型的关联值。<br>​    在Swift中，枚举是一等（<code>first-class</code>）类型，它们支持了很多在传统上只被类（class）所支持的特性，比如计算属性（computed properties），用于提供枚举值的附加信息，实例方法（instance methods），用于提供和枚举值相关联的功能。枚举也可以定义构造函数（initializers）来提供一个初始值；可以在原始实现的基础上扩展它们的功能；还可以遵循协议（protocols）来提供标准的功能。</p>\n<h3 id=\"枚举语法\"><a href=\"#枚举语法\" class=\"headerlink\" title=\"枚举语法\"></a>枚举语法</h3><p>使用enum关键词来创建枚举并且把它们的整个定义放在一对大括号内：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">SomeEnumeration</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// enumeration definition goes here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>例如一个指南针方向的例子：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">CompassPoint</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> north</div><div class=\"line\">    <span class=\"keyword\">case</span> south</div><div class=\"line\">    <span class=\"keyword\">case</span> east</div><div class=\"line\">    <span class=\"keyword\">case</span> west</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>枚举中定义的值（如 north，south，east和west）是这个枚举的成员值（或成员）。你可以使用case关键字来定义一个新的枚举成员值。<br>    与 C 和 Objective-C 不同，Swift 的枚举成员在被创建时不会被赋予一个默认的整型值。在上面的CompassPoint例子中，north，south，east和west不会被隐式地赋值为0，1，2和3。相反，这些枚举成员本身就是完备的值，这些值的类型是已经明确定义好的CompassPoint类型。</p>","more":"<p>多个成员变量可以出现在一行上，用逗号隔开：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Planet</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> mercury, venus, earth, mars, jupiter, saturn, uranus, neptune</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>每个枚举定义了一个全新的类型。像 Swift 中其他类型一样，它们的名字（例如CompassPoint和Planet）应该以一个大写字母开头。给枚举类型起一个单数名字而不是复数名字，以便于读起来更加容易理解：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> directionToHead = <span class=\"type\">CompassPoint</span>.west</div></pre></td></tr></table></figure>\n<p>directionToHead的类型可以在它被CompassPoint的某个值初始化时推断出来。一旦directionToHead被声明为CompassPoint类型，你可以使用更简短的点语法将其设置为另一个CompassPoint的值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">directionToHead = .east</div></pre></td></tr></table></figure>\n<h3 id=\"使用-Switch-语句匹配枚举值\"><a href=\"#使用-Switch-语句匹配枚举值\" class=\"headerlink\" title=\"使用 Switch 语句匹配枚举值\"></a>使用 Switch 语句匹配枚举值</h3><p>可以使用<code>switch</code>语句来匹配枚举值，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">directionToHead = .south</div><div class=\"line\"><span class=\"keyword\">switch</span> directionToHead &#123;</div><div class=\"line\"><span class=\"keyword\">case</span> .north:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Lots of planets have a north\"</span>)</div><div class=\"line\"><span class=\"keyword\">case</span> .south:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Watch out for penguins\"</span>)</div><div class=\"line\"><span class=\"keyword\">case</span> .east:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Where the sun rises\"</span>)</div><div class=\"line\"><span class=\"keyword\">case</span> .west:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Where the skies are blue\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"Watch out for penguins\"</span></div></pre></td></tr></table></figure>\n<p>在判断一个枚举类型的值时，switch语句必须穷举所有情况。当不需要匹配每个枚举成员的时候，你可以提供一个default分支来涵盖所有未明确处理的枚举成员：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> somePlanet = <span class=\"type\">Planet</span>.earth</div><div class=\"line\"><span class=\"keyword\">switch</span> somePlanet &#123;</div><div class=\"line\"><span class=\"keyword\">case</span> .earth:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Mostly harmless\"</span>)</div><div class=\"line\"><span class=\"keyword\">default</span>:</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Not a safe place for humans\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"Mostly harmless\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"关联值\"><a href=\"#关联值\" class=\"headerlink\" title=\"关联值\"></a>关联值</h3><p>你可以定义 Swift 枚举来存储任意类型的关联值，如果需要的话，每个枚举成员的关联值类型可以各不相同。枚举的这种特性跟其他语言中的可识别联合（discriminated unions），标签联合（tagged unions），或者变体（variants）相似。<br>例如，假设一个库存跟踪系统需要利用两种不同类型的条形码来跟踪商品。有些商品上标有使用0到9的数字的 UPC 格式的一维条形码。每一个条形码都有一个代表“数字系统”的数字，该数字后接五位代表“厂商代码”的数字，接下来是五位代表“产品代码”的数字。最后一个数字是“检查”位，用来验证代码是否被正确扫描：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/barcode_UPC_2x.png\" alt=\"\"><br>其他商品上标有 QR 码格式的二维码，它可以使用任何 ISO 8859-1 字符，并且可以编码一个最多拥有 2,953 个字符的字符串：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/barcode_QR_2x.png\" alt=\"\"><br>这便于库存跟踪系统用包含四个整型值的元组存储 UPC 码，以及用任意长度的字符串储存 QR 码。</p>\n<p>在 Swift 中，使用如下方式定义表示两种商品条形码的枚举：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Barcode</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> upc(<span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>, <span class=\"type\">Int</span>)</div><div class=\"line\">    <span class=\"keyword\">case</span> qrCode(<span class=\"type\">String</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以使用任意一种条形码类型创建新的条形码，例如，创建了一个名为productBarcode的变量，并将Barcode.upc赋值给它，关联的元组值为(8, 85909, 51226, 3)：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> productBarcode = <span class=\"type\">Barcode</span>.upc(<span class=\"number\">8</span>, <span class=\"number\">85909</span>, <span class=\"number\">51226</span>, <span class=\"number\">3</span>)</div></pre></td></tr></table></figure>\n<p>同一个商品可以被分配一个不同类型的条形码，例如，原始的Barcode.upc和其整数关联值被新的Barcode.qrCode和其字符串关联值所替代。Barcode类型的常量和变量可以存储一个.upc或者一个.qrCode（连同它们的关联值），但是在同一时间只能存储这两个值中的一个。：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">productBarcode = .qrCode(<span class=\"string\">\"ABCDEFGHIJKLMNOP\"</span>)</div></pre></td></tr></table></figure>\n<p>可以使用switch语句来匹配不同类型的枚举值，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">switch</span> productBarcode &#123;</div><div class=\"line\"><span class=\"keyword\">case</span> .upc(<span class=\"keyword\">let</span> numberSystem, <span class=\"keyword\">let</span> manufacturer, <span class=\"keyword\">let</span> product, <span class=\"keyword\">let</span> check):</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"UPC: <span class=\"subst\">\\(numberSystem)</span>, <span class=\"subst\">\\(manufacturer)</span>, <span class=\"subst\">\\(product)</span>, <span class=\"subst\">\\(check)</span>.\"</span>)</div><div class=\"line\"><span class=\"keyword\">case</span> .qrCode(<span class=\"keyword\">let</span> productCode):</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"QR code: <span class=\"subst\">\\(productCode)</span>.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"QR code: ABCDEFGHIJKLMNOP.\"</span></div></pre></td></tr></table></figure>\n<p>如果一个枚举成员的所有关联值都被提取为常量，或者都被提取为变量，为了简洁，你可以只在成员名称前标注一个let或者var：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">switch</span> productBarcode &#123;</div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"keyword\">let</span> .upc(numberSystem, manufacturer, product, check):</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"UPC : <span class=\"subst\">\\(numberSystem)</span>, <span class=\"subst\">\\(manufacturer)</span>, <span class=\"subst\">\\(product)</span>, <span class=\"subst\">\\(check)</span>.\"</span>)</div><div class=\"line\"><span class=\"keyword\">case</span> <span class=\"keyword\">let</span> .qrCode(productCode):</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"QR code: <span class=\"subst\">\\(productCode)</span>.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"QR code: ABCDEFGHIJKLMNOP.\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"原始值raw\"><a href=\"#原始值raw\" class=\"headerlink\" title=\"原始值raw\"></a>原始值raw</h3><p>作为关联值的替代选择，枚举成员可以被默认值（称为原始值）预填充，这些原始值的类型必须相同。例如，以下是一个使用 ASCII 码作为原始值的枚举：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">ASCIIControlCharacter</span>: <span class=\"title\">Character</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> tab = <span class=\"string\">\"\\t\"</span></div><div class=\"line\">    <span class=\"keyword\">case</span> lineFeed = <span class=\"string\">\"\\n\"</span></div><div class=\"line\">    <span class=\"keyword\">case</span> carriageReturn = <span class=\"string\">\"\\r\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>原始值可以是字符串，字符，或者任意整型值或浮点型值。每个原始值在枚举声明中必须是唯一的。<br>    原始值和关联值是不同的。原始值是在定义枚举时被预先填充的值，像上述三个 ASCII 码。对于一个特定的枚举成员，它的原始值始终不变。关联值是创建一个基于枚举成员的常量或变量时才设置的值，枚举成员的关联值可以变化。</p>\n<h3 id=\"原始值的隐式赋值\"><a href=\"#原始值的隐式赋值\" class=\"headerlink\" title=\"原始值的隐式赋值\"></a>原始值的隐式赋值</h3><p>在使用原始值为整数或者字符串类型的枚举时，不需要显式地为每一个枚举成员设置原始值，Swift 将会自动为你赋值。<br>例如，当使用整数作为原始值时，隐式赋值的值依次递增1。如果第一个枚举成员没有设置原始值，其原始值将为0。<br>下面的枚举是对之前Planet这个枚举的一个细化，利用整型的原始值来表示每个行星在太阳系中的顺序：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Planet</span>: <span class=\"title\">Int</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> mercury = <span class=\"number\">1</span>, venus, earth, mars, jupiter, saturn, uranus, neptune</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在上面的例子中，Plant.mercury的显式原始值为1，Planet.venus的隐式原始值为2，依次类推。</p>\n<p>当使用字符串作为枚举类型的原始值时，每个枚举成员的隐式原始值为该枚举成员的名称。<br>下面的例子是CompassPoint枚举的细化，使用字符串类型的原始值来表示各个方向的名称：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">CompassPoint</span>: <span class=\"title\">String</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> north, south, east, west</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用枚举成员的rawValue属性可以访问该枚举成员的原始值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> earthsOrder = <span class=\"type\">Planet</span>.earth.rawValue</div><div class=\"line\"><span class=\"comment\">// earthsOrder is 3</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">let</span> sunsetDirection = <span class=\"type\">CompassPoint</span>.west.rawValue</div><div class=\"line\"><span class=\"comment\">// sunsetDirection is \"west\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"使用原始值初始化枚举实例\"><a href=\"#使用原始值初始化枚举实例\" class=\"headerlink\" title=\"使用原始值初始化枚举实例\"></a>使用原始值初始化枚举实例</h3><p>如果在定义枚举类型的时候使用了原始值，那么将会自动获得一个初始化方法，这个方法接收一个叫做rawValue的参数，参数类型即为原始值类型，返回值则是枚举成员或nil。你可以使用这个初始化方法来创建一个新的枚举实例。例如</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> possiblePlanet = <span class=\"type\">Planet</span>(rawValue: <span class=\"number\">7</span>)</div><div class=\"line\"><span class=\"comment\">// possiblePlanet is of type Planet? and equals Planet.uranus</span></div></pre></td></tr></table></figure>\n<pre><code>原始值构造器是一个可失败构造器，因为并不是每一个原始值都有与之对应的枚举成员。\n</code></pre><p>原始值构造器总是返回一个可选的枚举成员。例如：如果你试图寻找一个位置为11的行星，通过原始值构造器返回的可选Planet值将是nil：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> positionToFind = <span class=\"number\">11</span></div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> somePlanet = <span class=\"type\">Planet</span>(rawValue: positionToFind) &#123;</div><div class=\"line\">    <span class=\"keyword\">switch</span> somePlanet &#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> .earth:</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Mostly harmless\"</span>)</div><div class=\"line\">    <span class=\"keyword\">default</span>:</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Not a safe place for humans\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"There isn't a planet at position <span class=\"subst\">\\(positionToFind)</span>\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"There isn't a planet at position 11\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"递归枚举\"><a href=\"#递归枚举\" class=\"headerlink\" title=\"递归枚举\"></a>递归枚举</h3><p>递归枚举是一种枚举类型，它有一个或多个枚举成员使用该枚举类型的实例作为关联值。使用递归枚举时，编译器会插入一个间接层。你可以在枚举成员前加上indirect来表示该成员可递归。<br>例如，下面的例子中，枚举类型存储了简单的算术表达式：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">ArithmeticExpression</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> number(<span class=\"type\">Int</span>)</div><div class=\"line\">    <span class=\"keyword\">indirect</span> <span class=\"keyword\">case</span> addition(<span class=\"type\">ArithmeticExpression</span>, <span class=\"type\">ArithmeticExpression</span>)</div><div class=\"line\">    <span class=\"keyword\">indirect</span> <span class=\"keyword\">case</span> multiplication(<span class=\"type\">ArithmeticExpression</span>, <span class=\"type\">ArithmeticExpression</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你也可以在枚举类型开头加上indirect关键字来表明它的所有成员都是可递归的：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">ArithmeticExpression</span> </span>&#123;</div><div class=\"line\"><span class=\"keyword\">indirect</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">ArithmeticExpression</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> number(<span class=\"type\">Int</span>)</div><div class=\"line\">    <span class=\"keyword\">case</span> addition(<span class=\"type\">ArithmeticExpression</span>, <span class=\"type\">ArithmeticExpression</span>)</div><div class=\"line\">    <span class=\"keyword\">case</span> multiplication(<span class=\"type\">ArithmeticExpression</span>, <span class=\"type\">ArithmeticExpression</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面定义的枚举类型可以存储三种算术表达式：纯数字、两个表达式相加、两个表达式相乘。枚举成员addition和multiplication的关联值也是算术表达式——这些关联值使得嵌套表达式成为可能。例如，表达式(5 + 4) <em> 2，乘号右边是一个数字，左边则是另一个表达式。因为数据是嵌套的，因而用来存储数据的枚举类型也需要支持这种嵌套——这意味着枚举类型需要支持递归。下面的代码展示了使用ArithmeticExpression这个递归枚举创建表达式(5 + 4) </em> 2</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> five = <span class=\"type\">ArithmeticExpression</span>.number(<span class=\"number\">5</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> four = <span class=\"type\">ArithmeticExpression</span>.number(<span class=\"number\">4</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> sum = <span class=\"type\">ArithmeticExpression</span>.addition(five, four)</div><div class=\"line\"><span class=\"keyword\">let</span> product = <span class=\"type\">ArithmeticExpression</span>.multiplication(sum, <span class=\"type\">ArithmeticExpression</span>.number(<span class=\"number\">2</span>))</div></pre></td></tr></table></figure>\n<p>要操作具有递归性质的数据结构，使用递归函数是一种直截了当的方式。例如，下面是一个对算术表达式求值的函数：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">evaluate</span><span class=\"params\">(<span class=\"number\">_</span> expression: ArithmeticExpression)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">switch</span> expression &#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> .number(value):</div><div class=\"line\">        <span class=\"keyword\">return</span> value</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> .addition(<span class=\"keyword\">left</span>, <span class=\"keyword\">right</span>):</div><div class=\"line\">        <span class=\"keyword\">return</span> evaluate(<span class=\"keyword\">left</span>) + evaluate(<span class=\"keyword\">right</span>)</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> .multiplication(<span class=\"keyword\">left</span>, <span class=\"keyword\">right</span>):</div><div class=\"line\">        <span class=\"keyword\">return</span> evaluate(<span class=\"keyword\">left</span>) * evaluate(<span class=\"keyword\">right</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"built_in\">print</span>(evaluate(product))</div><div class=\"line\"><span class=\"comment\">// Prints \"18\"</span></div></pre></td></tr></table></figure>\n<p>该函数如果遇到纯数字，就直接返回该数字的值。如果遇到的是加法或乘法运算，则分别计算左边表达式和右边表达式的值，然后相加或相乘。</p>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html/\" target=\"_blank\" rel=\"external\">Enumerations</a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>"},{"layout":"post","title":"Swift Error Handling","date":"2016-11-30T15:20:11.000Z","author":"liangtong","catalog":true,"_content":"\n\n\n​\t错误处理（Error handling）是响应错误以及从错误中恢复的过程。Swift 提供了在运行时对可恢复错误的抛出、捕获、传递和操作的一等公民支持。\n某些操作无法保证总是执行完所有代码或总是生成有用的结果。可选类型可用来表示值缺失，但是当某个操作失败时，最好能得知失败的原因，从而可以作出相应的应对。\n举个例子，假如有个从磁盘上的某个文件读取数据并进行处理的任务，该任务会有多种可能失败的情况，包括指定路径下文件并不存在，文件不具有可读权限，或者文件编码格式不兼容。区分这些不同的失败情况可以让程序解决并处理某些错误，然后把它解决不了的错误报告给用户。\n\tSwift 中的错误处理涉及到错误处理模式，这会用到 Cocoa 和 Objective-C 中的NSError。\n\n\n\n### 表示并抛出错误\n在 Swift 中，错误用符合Error协议的类型的值来表示。这个空协议表明该类型可以用于错误处理。\nSwift 的枚举类型尤为适合构建一组相关的错误状态，枚举的关联值还可以提供错误状态的额外信息。例如，你可以这样表示在一个游戏中操作自动贩卖机时可能会出现的错误状态：\n\n```Swift\nenum VendingMachineError: Error {\n    case invalidSelection\n    case insufficientFunds(coinsNeeded: Int)\n    case outOfStock\n}\n```\n\n抛出一个错误可以让你表明有意外情况发生，导致正常的执行流程无法继续执行。抛出错误使用throw关键字。例如，下面的代码抛出一个错误，提示贩卖机还需要5个硬币：\n\n```Swift\nthrow VendingMachineError.insufficientFunds(coinsNeeded: 5)\n```\n\n\n<!-- more -->\n\n### 处理错误\n某个错误被抛出时，附近的某部分代码必须负责处理这个错误，例如纠正这个问题、尝试另外一种方式、或是向用户报告错误。\nSwift 中有4种处理错误的方式。你可以把函数抛出的错误传递给调用此函数的代码、用do-catch语句处理错误、将错误作为可选类型处理、或者断言此错误根本不会发生。\n\n当一个函数抛出一个错误时，你的程序流程会发生改变，所以重要的是你能迅速识别代码中会抛出错误的地方。为了标识出这些地方，在调用一个能抛出错误的函数、方法或者构造器之前，加上 `try` 关键字，或者 `try?` 或 `try!` 这种变体。\n\tSwift 中的错误处理和其他语言中用try，catch和throw进行异常处理很像。和其他语言中（包括 Objective-C ）的异常处理不同的是，Swift 中的错误处理并不涉及解除调用栈，这是一个计算代价高昂的过程。就此而言，throw语句的性能特性是可以和return语句相媲美的。\n\n#### 用 throwing 函数传递错误\n为了表示一个函数、方法或构造器可以抛出错误，在函数声明的参数列表之后加上throws关键字。一个标有 `throws` 关键字的函数被称作throwing 函数。如果这个函数指明了返回值类型，throws关键词需要写在箭头（->）的前面。\n\n```Swift\nfunc canThrowErrors() throws -> String\n \nfunc cannotThrowErrors() -> String\n```\n\n一个 throwing 函数可以在其内部抛出错误，并将错误传递到函数被调用时的作用域。\n\t只有 throwing 函数可以传递错误。任何在某个非 throwing 函数内部抛出的错误只能在函数内部处理。\n\n下面的例子中，VendingMechine类有一个vend(itemNamed:)方法，如果请求的物品不存在、缺货或者投入金额小于物品价格，该方法就会抛出一个相应的VendingMachineError：\n\n```Swift\nstruct Item {\n    var price: Int\n    var count: Int\n}\n \nclass VendingMachine {\n    var inventory = [\n        \"Candy Bar\": Item(price: 12, count: 7),\n        \"Chips\": Item(price: 10, count: 4),\n        \"Pretzels\": Item(price: 7, count: 11)\n    ]\n    var coinsDeposited = 0\n    \n    func vend(itemNamed name: String) throws {\n        guard let item = inventory[name] else {\n            throw VendingMachineError.invalidSelection\n        }\n        \n        guard item.count > 0 else {\n            throw VendingMachineError.outOfStock\n        }\n        \n        guard item.price < coinsDeposited else {\n            throw VendingMachineError.insufficientFunds(coinsNeeded: item.price - coinsDeposited)\n        }\n        \n        coinsDeposited -= item.price\n        \n        var newItem = item\n        newItem.count -= 1\n        inventory[name] = newItem\n        \n        print(\"Dispensing \\(name)\")\n    }\n}\n```\n\n在vend(itemNamed:)方法的实现中使用了guard语句来提前退出方法，确保在购买某个物品所需的条件中，有任一条件不满足时，能提前退出方法并抛出相应的错误。由于throw语句会立即退出方法，所以物品只有在所有条件都满足时才会被售出。\n\n因为vend(itemNamed:)方法会传递出它抛出的任何错误，在你的代码中调用此方法的地方，必须要么直接处理这些错误——使用do-catch语句，try?或try!；要么继续将这些错误传递下去。例如下面例子中，buyFavoriteSnack(_:vendingMachine:)同样是一个 throwing 函数，任何由vend(itemNamed:)方法抛出的错误会一直被传递到buyFavoriteSnack(person:vendingMachine:)函数被调用的地方。\n\n```Swift\nlet favoriteSnacks = [\n    \"Alice\": \"Chips\",\n    \"Bob\": \"Licorice\",\n    \"Eve\": \"Pretzels\",\n]\nfunc buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws {\n    let snackName = favoriteSnacks[person] ?? \"Candy Bar\"\n    try vendingMachine.vend(itemNamed: snackName)\n}\n```\n\n上例中，buyFavoriteSnack(person:vendingMachine:)函数会查找某人最喜欢的零食，并通过调用vend(itemNamed:)方法来尝试为他们购买。因为vend(itemNamed:)方法能抛出错误，所以在调用的它时候在它前面加了try关键字。\nthrowing构造器能像throwing函数一样传递错误.例如下面代码中的PurchasedSnack构造器在构造过程中调用了throwing函数,并且通过传递到它的调用者来处理这些错误。\n\n```Swift\nstruct PurchasedSnack {\n    let name: String\n    init(name: String, vendingMachine: VendingMachine) throws {\n        try vendingMachine.vend(itemNamed: name)\n        self.name = name\n    }\n}\n```\n\n#### 用 do-Catch 处理错误\n可以使用一个do-catch语句运行一段闭包代码来处理错误。如果在do子句中的代码抛出了一个错误，这个错误会与catch子句做匹配，从而决定哪条子句能处理它。\n\n下面是do-catch语句的一般形式：\n\n```Swift\ndo {\n    try expression\n    statements\n} catch pattern 1 {\n    statements\n} catch pattern 2 where condition {\n    statements\n}\n```\n\n在catch后面写一个匹配模式来表明这个子句能处理什么样的错误。如果一条catch子句没有指定匹配模式，那么这条子句可以匹配任何错误，并且把错误绑定到一个名字为error的局部常量\n\ncatch子句不必将do子句中的代码所抛出的每一个可能的错误都作处理。如果所有catch子句都未处理错误，错误就会传递到周围的作用域。然而，错误还是必须要被某个周围的作用域处理的——要么是一个外围的do-catch错误处理语句，要么是一个 throwing 函数的内部。举例来说，下面的代码处理了VendingMachineError枚举类型的全部枚举值，但是所有其它的错误就必须由它周围的作用域处理：\n\n```Swift\nvar vendingMachine = VendingMachine()\nvendingMachine.coinsDeposited = 8\ndo {\n    try buyFavoriteSnack(person: \"Alice\", vendingMachine: vendingMachine)\n} catch VendingMachineError.invalidSelection {\n    print(\"Invalid Selection.\")\n} catch VendingMachineError.outOfStock {\n    print(\"Out of Stock.\")\n} catch VendingMachineError.insufficientFunds(let coinsNeeded) {\n    print(\"Insufficient funds. Please insert an additional \\(coinsNeeded) coins.\")\n}\n// Prints \"Insufficient funds. Please insert an additional 2 coins.\"\n```\n\n上面的例子中，buyFavoriteSnack(person:vendingMachine:)函数在一个try表达式中调用，因为它能抛出错误。如果错误被抛出，相应的执行会马上转移到catch子句中，并判断这个错误是否要被继续传递下去。如果没有错误抛出，do子句中余下的语句就会被执行。\n\n#### 将错误转换成可选值\n可以使用try?通过将错误转换成一个可选值来处理错误。如果在评估try?表达式时一个错误被抛出，那么表达式的值就是nil。例如,在下面的代码中,x和y有着相同的数值和等价的含义：\n\n```Swift\nfunc someThrowingFunction() throws -> Int {\n    // ...\n}\n \nlet x = try? someThrowingFunction()\n \nlet y: Int?\ndo {\n    y = try someThrowingFunction()\n} catch {\n    y = nil\n}\n```\n\n如果someThrowingFunction()抛出一个错误，x和y的值是nil。否则x和y的值就是该函数的返回值。注意，无论someThrowingFunction()的返回值类型是什么类型，x和y都是这个类型的可选类型。例子中此函数返回一个整型，所以x和y是可选整型。\n如果你想对所有的错误都采用同样的方式来处理，用try?就可以让你写出简洁的错误处理代码。例如，下面的代码用几种方式来获取数据，如果所有方式都失败了则返回nil：\n\n```Swift\nfunc fetchData() -> Data? {\n    if let data = try? fetchDataFromDisk() { return data }\n    if let data = try? fetchDataFromServer() { return data }\n    return nil\n}\n```\n\n#### 禁用错误传递\n例如，下面的代码使用了loadImage(atPath:)函数，该函数从给定的路径加载图片资源，如果图片无法载入则抛出一个错误。在这种情况下，因为图片是和应用绑定的，运行时不会有错误抛出，所以适合禁用错误传递：\n\n```Swift\nlet photo = try! loadImage(atPath: \"./Resources/John Appleseed.jpg\")\n```\n\n### 指定清理操作\n可以使用defer语句在即将离开当前代码块时执行一系列语句。该语句让你能执行一些必要的清理工作，不管是以何种方式离开当前代码块的——无论是由于抛出错误而离开，还是由于诸如return或者break的语句。例如，你可以用defer语句来确保文件描述符得以关闭，以及手动分配的内存得以释放。\n\ndefer语句将代码的执行延迟到当前的作用域退出之前。该语句由defer关键字和要被延迟执行的语句组成。延迟执行的语句不能包含任何控制转移语句，例如break或是return语句，或是抛出一个错误。延迟执行的操作会按照它们被指定时的顺序的相反顺序执行——也就是说，第一条defer语句中的代码会在第二条defer语句中的代码被执行之后才执行，以此类推。\n\n```Swift\nfunc processFile(filename: String) throws {\n    if exists(filename) {\n        let file = open(filename)\n        defer {\n            close(file)\n        }\n        while let line = try file.readline() {\n            // Work with the file.\n        }\n        // close(file) is called here, at the end of the scope.\n    }\n}\n```\n\n上面的代码使用一条defer语句来确保open(_:)函数有一个相应的对close(_:)函数的调用。\n\t即使没有涉及到错误处理，你也可以使用defer语句。\n\n\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html/\"> ErrorHandling </a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","source":"_posts/iOS_Swift_language_note_Error-Handling.md","raw":"---\nlayout:     post\ntitle:      Swift Error Handling\ndate:       2016-11-30 23:20:11\nauthor:     liangtong\ncatalog: true\ncategories: iOS\ntags: Swift \n\n---\n\n\n\n​\t错误处理（Error handling）是响应错误以及从错误中恢复的过程。Swift 提供了在运行时对可恢复错误的抛出、捕获、传递和操作的一等公民支持。\n某些操作无法保证总是执行完所有代码或总是生成有用的结果。可选类型可用来表示值缺失，但是当某个操作失败时，最好能得知失败的原因，从而可以作出相应的应对。\n举个例子，假如有个从磁盘上的某个文件读取数据并进行处理的任务，该任务会有多种可能失败的情况，包括指定路径下文件并不存在，文件不具有可读权限，或者文件编码格式不兼容。区分这些不同的失败情况可以让程序解决并处理某些错误，然后把它解决不了的错误报告给用户。\n\tSwift 中的错误处理涉及到错误处理模式，这会用到 Cocoa 和 Objective-C 中的NSError。\n\n\n\n### 表示并抛出错误\n在 Swift 中，错误用符合Error协议的类型的值来表示。这个空协议表明该类型可以用于错误处理。\nSwift 的枚举类型尤为适合构建一组相关的错误状态，枚举的关联值还可以提供错误状态的额外信息。例如，你可以这样表示在一个游戏中操作自动贩卖机时可能会出现的错误状态：\n\n```Swift\nenum VendingMachineError: Error {\n    case invalidSelection\n    case insufficientFunds(coinsNeeded: Int)\n    case outOfStock\n}\n```\n\n抛出一个错误可以让你表明有意外情况发生，导致正常的执行流程无法继续执行。抛出错误使用throw关键字。例如，下面的代码抛出一个错误，提示贩卖机还需要5个硬币：\n\n```Swift\nthrow VendingMachineError.insufficientFunds(coinsNeeded: 5)\n```\n\n\n<!-- more -->\n\n### 处理错误\n某个错误被抛出时，附近的某部分代码必须负责处理这个错误，例如纠正这个问题、尝试另外一种方式、或是向用户报告错误。\nSwift 中有4种处理错误的方式。你可以把函数抛出的错误传递给调用此函数的代码、用do-catch语句处理错误、将错误作为可选类型处理、或者断言此错误根本不会发生。\n\n当一个函数抛出一个错误时，你的程序流程会发生改变，所以重要的是你能迅速识别代码中会抛出错误的地方。为了标识出这些地方，在调用一个能抛出错误的函数、方法或者构造器之前，加上 `try` 关键字，或者 `try?` 或 `try!` 这种变体。\n\tSwift 中的错误处理和其他语言中用try，catch和throw进行异常处理很像。和其他语言中（包括 Objective-C ）的异常处理不同的是，Swift 中的错误处理并不涉及解除调用栈，这是一个计算代价高昂的过程。就此而言，throw语句的性能特性是可以和return语句相媲美的。\n\n#### 用 throwing 函数传递错误\n为了表示一个函数、方法或构造器可以抛出错误，在函数声明的参数列表之后加上throws关键字。一个标有 `throws` 关键字的函数被称作throwing 函数。如果这个函数指明了返回值类型，throws关键词需要写在箭头（->）的前面。\n\n```Swift\nfunc canThrowErrors() throws -> String\n \nfunc cannotThrowErrors() -> String\n```\n\n一个 throwing 函数可以在其内部抛出错误，并将错误传递到函数被调用时的作用域。\n\t只有 throwing 函数可以传递错误。任何在某个非 throwing 函数内部抛出的错误只能在函数内部处理。\n\n下面的例子中，VendingMechine类有一个vend(itemNamed:)方法，如果请求的物品不存在、缺货或者投入金额小于物品价格，该方法就会抛出一个相应的VendingMachineError：\n\n```Swift\nstruct Item {\n    var price: Int\n    var count: Int\n}\n \nclass VendingMachine {\n    var inventory = [\n        \"Candy Bar\": Item(price: 12, count: 7),\n        \"Chips\": Item(price: 10, count: 4),\n        \"Pretzels\": Item(price: 7, count: 11)\n    ]\n    var coinsDeposited = 0\n    \n    func vend(itemNamed name: String) throws {\n        guard let item = inventory[name] else {\n            throw VendingMachineError.invalidSelection\n        }\n        \n        guard item.count > 0 else {\n            throw VendingMachineError.outOfStock\n        }\n        \n        guard item.price < coinsDeposited else {\n            throw VendingMachineError.insufficientFunds(coinsNeeded: item.price - coinsDeposited)\n        }\n        \n        coinsDeposited -= item.price\n        \n        var newItem = item\n        newItem.count -= 1\n        inventory[name] = newItem\n        \n        print(\"Dispensing \\(name)\")\n    }\n}\n```\n\n在vend(itemNamed:)方法的实现中使用了guard语句来提前退出方法，确保在购买某个物品所需的条件中，有任一条件不满足时，能提前退出方法并抛出相应的错误。由于throw语句会立即退出方法，所以物品只有在所有条件都满足时才会被售出。\n\n因为vend(itemNamed:)方法会传递出它抛出的任何错误，在你的代码中调用此方法的地方，必须要么直接处理这些错误——使用do-catch语句，try?或try!；要么继续将这些错误传递下去。例如下面例子中，buyFavoriteSnack(_:vendingMachine:)同样是一个 throwing 函数，任何由vend(itemNamed:)方法抛出的错误会一直被传递到buyFavoriteSnack(person:vendingMachine:)函数被调用的地方。\n\n```Swift\nlet favoriteSnacks = [\n    \"Alice\": \"Chips\",\n    \"Bob\": \"Licorice\",\n    \"Eve\": \"Pretzels\",\n]\nfunc buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws {\n    let snackName = favoriteSnacks[person] ?? \"Candy Bar\"\n    try vendingMachine.vend(itemNamed: snackName)\n}\n```\n\n上例中，buyFavoriteSnack(person:vendingMachine:)函数会查找某人最喜欢的零食，并通过调用vend(itemNamed:)方法来尝试为他们购买。因为vend(itemNamed:)方法能抛出错误，所以在调用的它时候在它前面加了try关键字。\nthrowing构造器能像throwing函数一样传递错误.例如下面代码中的PurchasedSnack构造器在构造过程中调用了throwing函数,并且通过传递到它的调用者来处理这些错误。\n\n```Swift\nstruct PurchasedSnack {\n    let name: String\n    init(name: String, vendingMachine: VendingMachine) throws {\n        try vendingMachine.vend(itemNamed: name)\n        self.name = name\n    }\n}\n```\n\n#### 用 do-Catch 处理错误\n可以使用一个do-catch语句运行一段闭包代码来处理错误。如果在do子句中的代码抛出了一个错误，这个错误会与catch子句做匹配，从而决定哪条子句能处理它。\n\n下面是do-catch语句的一般形式：\n\n```Swift\ndo {\n    try expression\n    statements\n} catch pattern 1 {\n    statements\n} catch pattern 2 where condition {\n    statements\n}\n```\n\n在catch后面写一个匹配模式来表明这个子句能处理什么样的错误。如果一条catch子句没有指定匹配模式，那么这条子句可以匹配任何错误，并且把错误绑定到一个名字为error的局部常量\n\ncatch子句不必将do子句中的代码所抛出的每一个可能的错误都作处理。如果所有catch子句都未处理错误，错误就会传递到周围的作用域。然而，错误还是必须要被某个周围的作用域处理的——要么是一个外围的do-catch错误处理语句，要么是一个 throwing 函数的内部。举例来说，下面的代码处理了VendingMachineError枚举类型的全部枚举值，但是所有其它的错误就必须由它周围的作用域处理：\n\n```Swift\nvar vendingMachine = VendingMachine()\nvendingMachine.coinsDeposited = 8\ndo {\n    try buyFavoriteSnack(person: \"Alice\", vendingMachine: vendingMachine)\n} catch VendingMachineError.invalidSelection {\n    print(\"Invalid Selection.\")\n} catch VendingMachineError.outOfStock {\n    print(\"Out of Stock.\")\n} catch VendingMachineError.insufficientFunds(let coinsNeeded) {\n    print(\"Insufficient funds. Please insert an additional \\(coinsNeeded) coins.\")\n}\n// Prints \"Insufficient funds. Please insert an additional 2 coins.\"\n```\n\n上面的例子中，buyFavoriteSnack(person:vendingMachine:)函数在一个try表达式中调用，因为它能抛出错误。如果错误被抛出，相应的执行会马上转移到catch子句中，并判断这个错误是否要被继续传递下去。如果没有错误抛出，do子句中余下的语句就会被执行。\n\n#### 将错误转换成可选值\n可以使用try?通过将错误转换成一个可选值来处理错误。如果在评估try?表达式时一个错误被抛出，那么表达式的值就是nil。例如,在下面的代码中,x和y有着相同的数值和等价的含义：\n\n```Swift\nfunc someThrowingFunction() throws -> Int {\n    // ...\n}\n \nlet x = try? someThrowingFunction()\n \nlet y: Int?\ndo {\n    y = try someThrowingFunction()\n} catch {\n    y = nil\n}\n```\n\n如果someThrowingFunction()抛出一个错误，x和y的值是nil。否则x和y的值就是该函数的返回值。注意，无论someThrowingFunction()的返回值类型是什么类型，x和y都是这个类型的可选类型。例子中此函数返回一个整型，所以x和y是可选整型。\n如果你想对所有的错误都采用同样的方式来处理，用try?就可以让你写出简洁的错误处理代码。例如，下面的代码用几种方式来获取数据，如果所有方式都失败了则返回nil：\n\n```Swift\nfunc fetchData() -> Data? {\n    if let data = try? fetchDataFromDisk() { return data }\n    if let data = try? fetchDataFromServer() { return data }\n    return nil\n}\n```\n\n#### 禁用错误传递\n例如，下面的代码使用了loadImage(atPath:)函数，该函数从给定的路径加载图片资源，如果图片无法载入则抛出一个错误。在这种情况下，因为图片是和应用绑定的，运行时不会有错误抛出，所以适合禁用错误传递：\n\n```Swift\nlet photo = try! loadImage(atPath: \"./Resources/John Appleseed.jpg\")\n```\n\n### 指定清理操作\n可以使用defer语句在即将离开当前代码块时执行一系列语句。该语句让你能执行一些必要的清理工作，不管是以何种方式离开当前代码块的——无论是由于抛出错误而离开，还是由于诸如return或者break的语句。例如，你可以用defer语句来确保文件描述符得以关闭，以及手动分配的内存得以释放。\n\ndefer语句将代码的执行延迟到当前的作用域退出之前。该语句由defer关键字和要被延迟执行的语句组成。延迟执行的语句不能包含任何控制转移语句，例如break或是return语句，或是抛出一个错误。延迟执行的操作会按照它们被指定时的顺序的相反顺序执行——也就是说，第一条defer语句中的代码会在第二条defer语句中的代码被执行之后才执行，以此类推。\n\n```Swift\nfunc processFile(filename: String) throws {\n    if exists(filename) {\n        let file = open(filename)\n        defer {\n            close(file)\n        }\n        while let line = try file.readline() {\n            // Work with the file.\n        }\n        // close(file) is called here, at the end of the scope.\n    }\n}\n```\n\n上面的代码使用一条defer语句来确保open(_:)函数有一个相应的对close(_:)函数的调用。\n\t即使没有涉及到错误处理，你也可以使用defer语句。\n\n\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html/\"> ErrorHandling </a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","slug":"iOS_Swift_language_note_Error-Handling","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4u8002uoko8m8c13clg","content":"<p>​    错误处理（Error handling）是响应错误以及从错误中恢复的过程。Swift 提供了在运行时对可恢复错误的抛出、捕获、传递和操作的一等公民支持。<br>某些操作无法保证总是执行完所有代码或总是生成有用的结果。可选类型可用来表示值缺失，但是当某个操作失败时，最好能得知失败的原因，从而可以作出相应的应对。<br>举个例子，假如有个从磁盘上的某个文件读取数据并进行处理的任务，该任务会有多种可能失败的情况，包括指定路径下文件并不存在，文件不具有可读权限，或者文件编码格式不兼容。区分这些不同的失败情况可以让程序解决并处理某些错误，然后把它解决不了的错误报告给用户。<br>    Swift 中的错误处理涉及到错误处理模式，这会用到 Cocoa 和 Objective-C 中的NSError。</p>\n<h3 id=\"表示并抛出错误\"><a href=\"#表示并抛出错误\" class=\"headerlink\" title=\"表示并抛出错误\"></a>表示并抛出错误</h3><p>在 Swift 中，错误用符合Error协议的类型的值来表示。这个空协议表明该类型可以用于错误处理。<br>Swift 的枚举类型尤为适合构建一组相关的错误状态，枚举的关联值还可以提供错误状态的额外信息。例如，你可以这样表示在一个游戏中操作自动贩卖机时可能会出现的错误状态：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">VendingMachineError</span>: <span class=\"title\">Error</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> invalidSelection</div><div class=\"line\">    <span class=\"keyword\">case</span> insufficientFunds(coinsNeeded: <span class=\"type\">Int</span>)</div><div class=\"line\">    <span class=\"keyword\">case</span> outOfStock</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>抛出一个错误可以让你表明有意外情况发生，导致正常的执行流程无法继续执行。抛出错误使用throw关键字。例如，下面的代码抛出一个错误，提示贩卖机还需要5个硬币：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">throw</span> <span class=\"type\">VendingMachineError</span>.insufficientFunds(coinsNeeded: <span class=\"number\">5</span>)</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"处理错误\"><a href=\"#处理错误\" class=\"headerlink\" title=\"处理错误\"></a>处理错误</h3><p>某个错误被抛出时，附近的某部分代码必须负责处理这个错误，例如纠正这个问题、尝试另外一种方式、或是向用户报告错误。<br>Swift 中有4种处理错误的方式。你可以把函数抛出的错误传递给调用此函数的代码、用do-catch语句处理错误、将错误作为可选类型处理、或者断言此错误根本不会发生。</p>\n<p>当一个函数抛出一个错误时，你的程序流程会发生改变，所以重要的是你能迅速识别代码中会抛出错误的地方。为了标识出这些地方，在调用一个能抛出错误的函数、方法或者构造器之前，加上 <code>try</code> 关键字，或者 <code>try?</code> 或 <code>try!</code> 这种变体。<br>    Swift 中的错误处理和其他语言中用try，catch和throw进行异常处理很像。和其他语言中（包括 Objective-C ）的异常处理不同的是，Swift 中的错误处理并不涉及解除调用栈，这是一个计算代价高昂的过程。就此而言，throw语句的性能特性是可以和return语句相媲美的。</p>\n<h4 id=\"用-throwing-函数传递错误\"><a href=\"#用-throwing-函数传递错误\" class=\"headerlink\" title=\"用 throwing 函数传递错误\"></a>用 throwing 函数传递错误</h4><p>为了表示一个函数、方法或构造器可以抛出错误，在函数声明的参数列表之后加上throws关键字。一个标有 <code>throws</code> 关键字的函数被称作throwing 函数。如果这个函数指明了返回值类型，throws关键词需要写在箭头（-&gt;）的前面。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">canThrowErrors</span><span class=\"params\">()</span></span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">String</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cannotThrowErrors</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">String</span></div></pre></td></tr></table></figure>\n<p>一个 throwing 函数可以在其内部抛出错误，并将错误传递到函数被调用时的作用域。<br>    只有 throwing 函数可以传递错误。任何在某个非 throwing 函数内部抛出的错误只能在函数内部处理。</p>\n<p>下面的例子中，VendingMechine类有一个vend(itemNamed:)方法，如果请求的物品不存在、缺货或者投入金额小于物品价格，该方法就会抛出一个相应的VendingMachineError：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Item</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> price: <span class=\"type\">Int</span></div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">count</span>: <span class=\"type\">Int</span></div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VendingMachine</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> inventory = [</div><div class=\"line\">        <span class=\"string\">\"Candy Bar\"</span>: <span class=\"type\">Item</span>(price: <span class=\"number\">12</span>, <span class=\"built_in\">count</span>: <span class=\"number\">7</span>),</div><div class=\"line\">        <span class=\"string\">\"Chips\"</span>: <span class=\"type\">Item</span>(price: <span class=\"number\">10</span>, <span class=\"built_in\">count</span>: <span class=\"number\">4</span>),</div><div class=\"line\">        <span class=\"string\">\"Pretzels\"</span>: <span class=\"type\">Item</span>(price: <span class=\"number\">7</span>, <span class=\"built_in\">count</span>: <span class=\"number\">11</span>)</div><div class=\"line\">    ]</div><div class=\"line\">    <span class=\"keyword\">var</span> coinsDeposited = <span class=\"number\">0</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">vend</span><span class=\"params\">(itemNamed name: String)</span></span> <span class=\"keyword\">throws</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> item = inventory[name] <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"type\">VendingMachineError</span>.invalidSelection</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">guard</span> item.<span class=\"built_in\">count</span> &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"type\">VendingMachineError</span>.outOfStock</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">guard</span> item.price &lt; coinsDeposited <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"type\">VendingMachineError</span>.insufficientFunds(coinsNeeded: item.price - coinsDeposited)</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        coinsDeposited -= item.price</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">var</span> newItem = item</div><div class=\"line\">        newItem.<span class=\"built_in\">count</span> -= <span class=\"number\">1</span></div><div class=\"line\">        inventory[name] = newItem</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Dispensing <span class=\"subst\">\\(name)</span>\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在vend(itemNamed:)方法的实现中使用了guard语句来提前退出方法，确保在购买某个物品所需的条件中，有任一条件不满足时，能提前退出方法并抛出相应的错误。由于throw语句会立即退出方法，所以物品只有在所有条件都满足时才会被售出。</p>\n<p>因为vend(itemNamed:)方法会传递出它抛出的任何错误，在你的代码中调用此方法的地方，必须要么直接处理这些错误——使用do-catch语句，try?或try!；要么继续将这些错误传递下去。例如下面例子中，buyFavoriteSnack(_:vendingMachine:)同样是一个 throwing 函数，任何由vend(itemNamed:)方法抛出的错误会一直被传递到buyFavoriteSnack(person:vendingMachine:)函数被调用的地方。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> favoriteSnacks = [</div><div class=\"line\">    <span class=\"string\">\"Alice\"</span>: <span class=\"string\">\"Chips\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Bob\"</span>: <span class=\"string\">\"Licorice\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Eve\"</span>: <span class=\"string\">\"Pretzels\"</span>,</div><div class=\"line\">]</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buyFavoriteSnack</span><span class=\"params\">(person: String, vendingMachine: VendingMachine)</span></span> <span class=\"keyword\">throws</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> snackName = favoriteSnacks[person] ?? <span class=\"string\">\"Candy Bar\"</span></div><div class=\"line\">    <span class=\"keyword\">try</span> vendingMachine.vend(itemNamed: snackName)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上例中，buyFavoriteSnack(person:vendingMachine:)函数会查找某人最喜欢的零食，并通过调用vend(itemNamed:)方法来尝试为他们购买。因为vend(itemNamed:)方法能抛出错误，所以在调用的它时候在它前面加了try关键字。<br>throwing构造器能像throwing函数一样传递错误.例如下面代码中的PurchasedSnack构造器在构造过程中调用了throwing函数,并且通过传递到它的调用者来处理这些错误。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PurchasedSnack</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> name: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>, vendingMachine: <span class=\"type\">VendingMachine</span>) <span class=\"keyword\">throws</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> vendingMachine.vend(itemNamed: name)</div><div class=\"line\">        <span class=\"keyword\">self</span>.name = name</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"用-do-Catch-处理错误\"><a href=\"#用-do-Catch-处理错误\" class=\"headerlink\" title=\"用 do-Catch 处理错误\"></a>用 do-Catch 处理错误</h4><p>可以使用一个do-catch语句运行一段闭包代码来处理错误。如果在do子句中的代码抛出了一个错误，这个错误会与catch子句做匹配，从而决定哪条子句能处理它。</p>\n<p>下面是do-catch语句的一般形式：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">do</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">try</span> expression</div><div class=\"line\">    statements</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> pattern <span class=\"number\">1</span> &#123;</div><div class=\"line\">    statements</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> pattern <span class=\"number\">2</span> <span class=\"keyword\">where</span> condition &#123;</div><div class=\"line\">    statements</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在catch后面写一个匹配模式来表明这个子句能处理什么样的错误。如果一条catch子句没有指定匹配模式，那么这条子句可以匹配任何错误，并且把错误绑定到一个名字为error的局部常量</p>\n<p>catch子句不必将do子句中的代码所抛出的每一个可能的错误都作处理。如果所有catch子句都未处理错误，错误就会传递到周围的作用域。然而，错误还是必须要被某个周围的作用域处理的——要么是一个外围的do-catch错误处理语句，要么是一个 throwing 函数的内部。举例来说，下面的代码处理了VendingMachineError枚举类型的全部枚举值，但是所有其它的错误就必须由它周围的作用域处理：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vendingMachine = <span class=\"type\">VendingMachine</span>()</div><div class=\"line\">vendingMachine.coinsDeposited = <span class=\"number\">8</span></div><div class=\"line\"><span class=\"keyword\">do</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">try</span> buyFavoriteSnack(person: <span class=\"string\">\"Alice\"</span>, vendingMachine: vendingMachine)</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> <span class=\"type\">VendingMachineError</span>.invalidSelection &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Invalid Selection.\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> <span class=\"type\">VendingMachineError</span>.outOfStock &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Out of Stock.\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> <span class=\"type\">VendingMachineError</span>.insufficientFunds(<span class=\"keyword\">let</span> coinsNeeded) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Insufficient funds. Please insert an additional <span class=\"subst\">\\(coinsNeeded)</span> coins.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"Insufficient funds. Please insert an additional 2 coins.\"</span></div></pre></td></tr></table></figure>\n<p>上面的例子中，buyFavoriteSnack(person:vendingMachine:)函数在一个try表达式中调用，因为它能抛出错误。如果错误被抛出，相应的执行会马上转移到catch子句中，并判断这个错误是否要被继续传递下去。如果没有错误抛出，do子句中余下的语句就会被执行。</p>\n<h4 id=\"将错误转换成可选值\"><a href=\"#将错误转换成可选值\" class=\"headerlink\" title=\"将错误转换成可选值\"></a>将错误转换成可选值</h4><p>可以使用try?通过将错误转换成一个可选值来处理错误。如果在评估try?表达式时一个错误被抛出，那么表达式的值就是nil。例如,在下面的代码中,x和y有着相同的数值和等价的含义：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someThrowingFunction</span><span class=\"params\">()</span></span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"keyword\">try</span>? someThrowingFunction()</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">let</span> y: <span class=\"type\">Int</span>?</div><div class=\"line\"><span class=\"keyword\">do</span> &#123;</div><div class=\"line\">    y = <span class=\"keyword\">try</span> someThrowingFunction()</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> &#123;</div><div class=\"line\">    y = <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果someThrowingFunction()抛出一个错误，x和y的值是nil。否则x和y的值就是该函数的返回值。注意，无论someThrowingFunction()的返回值类型是什么类型，x和y都是这个类型的可选类型。例子中此函数返回一个整型，所以x和y是可选整型。<br>如果你想对所有的错误都采用同样的方式来处理，用try?就可以让你写出简洁的错误处理代码。例如，下面的代码用几种方式来获取数据，如果所有方式都失败了则返回nil：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fetchData</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Data</span>? &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> data = <span class=\"keyword\">try</span>? fetchDataFromDisk() &#123; <span class=\"keyword\">return</span> data &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> data = <span class=\"keyword\">try</span>? fetchDataFromServer() &#123; <span class=\"keyword\">return</span> data &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"禁用错误传递\"><a href=\"#禁用错误传递\" class=\"headerlink\" title=\"禁用错误传递\"></a>禁用错误传递</h4><p>例如，下面的代码使用了loadImage(atPath:)函数，该函数从给定的路径加载图片资源，如果图片无法载入则抛出一个错误。在这种情况下，因为图片是和应用绑定的，运行时不会有错误抛出，所以适合禁用错误传递：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> photo = <span class=\"keyword\">try</span>! loadImage(atPath: <span class=\"string\">\"./Resources/John Appleseed.jpg\"</span>)</div></pre></td></tr></table></figure>\n<h3 id=\"指定清理操作\"><a href=\"#指定清理操作\" class=\"headerlink\" title=\"指定清理操作\"></a>指定清理操作</h3><p>可以使用defer语句在即将离开当前代码块时执行一系列语句。该语句让你能执行一些必要的清理工作，不管是以何种方式离开当前代码块的——无论是由于抛出错误而离开，还是由于诸如return或者break的语句。例如，你可以用defer语句来确保文件描述符得以关闭，以及手动分配的内存得以释放。</p>\n<p>defer语句将代码的执行延迟到当前的作用域退出之前。该语句由defer关键字和要被延迟执行的语句组成。延迟执行的语句不能包含任何控制转移语句，例如break或是return语句，或是抛出一个错误。延迟执行的操作会按照它们被指定时的顺序的相反顺序执行——也就是说，第一条defer语句中的代码会在第二条defer语句中的代码被执行之后才执行，以此类推。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">processFile</span><span class=\"params\">(filename: String)</span></span> <span class=\"keyword\">throws</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> exists(filename) &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> file = <span class=\"keyword\">open</span>(filename)</div><div class=\"line\">        <span class=\"keyword\">defer</span> &#123;</div><div class=\"line\">            close(file)</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">while</span> <span class=\"keyword\">let</span> line = <span class=\"keyword\">try</span> file.readline() &#123;</div><div class=\"line\">            <span class=\"comment\">// Work with the file.</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// close(file) is called here, at the end of the scope.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码使用一条defer语句来确保open(<em>:)函数有一个相应的对close(</em>:)函数的调用。<br>    即使没有涉及到错误处理，你也可以使用defer语句。</p>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html/\" target=\"_blank\" rel=\"external\"> ErrorHandling </a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>​    错误处理（Error handling）是响应错误以及从错误中恢复的过程。Swift 提供了在运行时对可恢复错误的抛出、捕获、传递和操作的一等公民支持。<br>某些操作无法保证总是执行完所有代码或总是生成有用的结果。可选类型可用来表示值缺失，但是当某个操作失败时，最好能得知失败的原因，从而可以作出相应的应对。<br>举个例子，假如有个从磁盘上的某个文件读取数据并进行处理的任务，该任务会有多种可能失败的情况，包括指定路径下文件并不存在，文件不具有可读权限，或者文件编码格式不兼容。区分这些不同的失败情况可以让程序解决并处理某些错误，然后把它解决不了的错误报告给用户。<br>    Swift 中的错误处理涉及到错误处理模式，这会用到 Cocoa 和 Objective-C 中的NSError。</p>\n<h3 id=\"表示并抛出错误\"><a href=\"#表示并抛出错误\" class=\"headerlink\" title=\"表示并抛出错误\"></a>表示并抛出错误</h3><p>在 Swift 中，错误用符合Error协议的类型的值来表示。这个空协议表明该类型可以用于错误处理。<br>Swift 的枚举类型尤为适合构建一组相关的错误状态，枚举的关联值还可以提供错误状态的额外信息。例如，你可以这样表示在一个游戏中操作自动贩卖机时可能会出现的错误状态：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">VendingMachineError</span>: <span class=\"title\">Error</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> invalidSelection</div><div class=\"line\">    <span class=\"keyword\">case</span> insufficientFunds(coinsNeeded: <span class=\"type\">Int</span>)</div><div class=\"line\">    <span class=\"keyword\">case</span> outOfStock</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>抛出一个错误可以让你表明有意外情况发生，导致正常的执行流程无法继续执行。抛出错误使用throw关键字。例如，下面的代码抛出一个错误，提示贩卖机还需要5个硬币：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">throw</span> <span class=\"type\">VendingMachineError</span>.insufficientFunds(coinsNeeded: <span class=\"number\">5</span>)</div></pre></td></tr></table></figure>","more":"<h3 id=\"处理错误\"><a href=\"#处理错误\" class=\"headerlink\" title=\"处理错误\"></a>处理错误</h3><p>某个错误被抛出时，附近的某部分代码必须负责处理这个错误，例如纠正这个问题、尝试另外一种方式、或是向用户报告错误。<br>Swift 中有4种处理错误的方式。你可以把函数抛出的错误传递给调用此函数的代码、用do-catch语句处理错误、将错误作为可选类型处理、或者断言此错误根本不会发生。</p>\n<p>当一个函数抛出一个错误时，你的程序流程会发生改变，所以重要的是你能迅速识别代码中会抛出错误的地方。为了标识出这些地方，在调用一个能抛出错误的函数、方法或者构造器之前，加上 <code>try</code> 关键字，或者 <code>try?</code> 或 <code>try!</code> 这种变体。<br>    Swift 中的错误处理和其他语言中用try，catch和throw进行异常处理很像。和其他语言中（包括 Objective-C ）的异常处理不同的是，Swift 中的错误处理并不涉及解除调用栈，这是一个计算代价高昂的过程。就此而言，throw语句的性能特性是可以和return语句相媲美的。</p>\n<h4 id=\"用-throwing-函数传递错误\"><a href=\"#用-throwing-函数传递错误\" class=\"headerlink\" title=\"用 throwing 函数传递错误\"></a>用 throwing 函数传递错误</h4><p>为了表示一个函数、方法或构造器可以抛出错误，在函数声明的参数列表之后加上throws关键字。一个标有 <code>throws</code> 关键字的函数被称作throwing 函数。如果这个函数指明了返回值类型，throws关键词需要写在箭头（-&gt;）的前面。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">canThrowErrors</span><span class=\"params\">()</span></span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">String</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cannotThrowErrors</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">String</span></div></pre></td></tr></table></figure>\n<p>一个 throwing 函数可以在其内部抛出错误，并将错误传递到函数被调用时的作用域。<br>    只有 throwing 函数可以传递错误。任何在某个非 throwing 函数内部抛出的错误只能在函数内部处理。</p>\n<p>下面的例子中，VendingMechine类有一个vend(itemNamed:)方法，如果请求的物品不存在、缺货或者投入金额小于物品价格，该方法就会抛出一个相应的VendingMachineError：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Item</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> price: <span class=\"type\">Int</span></div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">count</span>: <span class=\"type\">Int</span></div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VendingMachine</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> inventory = [</div><div class=\"line\">        <span class=\"string\">\"Candy Bar\"</span>: <span class=\"type\">Item</span>(price: <span class=\"number\">12</span>, <span class=\"built_in\">count</span>: <span class=\"number\">7</span>),</div><div class=\"line\">        <span class=\"string\">\"Chips\"</span>: <span class=\"type\">Item</span>(price: <span class=\"number\">10</span>, <span class=\"built_in\">count</span>: <span class=\"number\">4</span>),</div><div class=\"line\">        <span class=\"string\">\"Pretzels\"</span>: <span class=\"type\">Item</span>(price: <span class=\"number\">7</span>, <span class=\"built_in\">count</span>: <span class=\"number\">11</span>)</div><div class=\"line\">    ]</div><div class=\"line\">    <span class=\"keyword\">var</span> coinsDeposited = <span class=\"number\">0</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">vend</span><span class=\"params\">(itemNamed name: String)</span></span> <span class=\"keyword\">throws</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> item = inventory[name] <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"type\">VendingMachineError</span>.invalidSelection</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">guard</span> item.<span class=\"built_in\">count</span> &gt; <span class=\"number\">0</span> <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"type\">VendingMachineError</span>.outOfStock</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">guard</span> item.price &lt; coinsDeposited <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"type\">VendingMachineError</span>.insufficientFunds(coinsNeeded: item.price - coinsDeposited)</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        coinsDeposited -= item.price</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">var</span> newItem = item</div><div class=\"line\">        newItem.<span class=\"built_in\">count</span> -= <span class=\"number\">1</span></div><div class=\"line\">        inventory[name] = newItem</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Dispensing <span class=\"subst\">\\(name)</span>\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在vend(itemNamed:)方法的实现中使用了guard语句来提前退出方法，确保在购买某个物品所需的条件中，有任一条件不满足时，能提前退出方法并抛出相应的错误。由于throw语句会立即退出方法，所以物品只有在所有条件都满足时才会被售出。</p>\n<p>因为vend(itemNamed:)方法会传递出它抛出的任何错误，在你的代码中调用此方法的地方，必须要么直接处理这些错误——使用do-catch语句，try?或try!；要么继续将这些错误传递下去。例如下面例子中，buyFavoriteSnack(_:vendingMachine:)同样是一个 throwing 函数，任何由vend(itemNamed:)方法抛出的错误会一直被传递到buyFavoriteSnack(person:vendingMachine:)函数被调用的地方。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> favoriteSnacks = [</div><div class=\"line\">    <span class=\"string\">\"Alice\"</span>: <span class=\"string\">\"Chips\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Bob\"</span>: <span class=\"string\">\"Licorice\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Eve\"</span>: <span class=\"string\">\"Pretzels\"</span>,</div><div class=\"line\">]</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buyFavoriteSnack</span><span class=\"params\">(person: String, vendingMachine: VendingMachine)</span></span> <span class=\"keyword\">throws</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> snackName = favoriteSnacks[person] ?? <span class=\"string\">\"Candy Bar\"</span></div><div class=\"line\">    <span class=\"keyword\">try</span> vendingMachine.vend(itemNamed: snackName)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上例中，buyFavoriteSnack(person:vendingMachine:)函数会查找某人最喜欢的零食，并通过调用vend(itemNamed:)方法来尝试为他们购买。因为vend(itemNamed:)方法能抛出错误，所以在调用的它时候在它前面加了try关键字。<br>throwing构造器能像throwing函数一样传递错误.例如下面代码中的PurchasedSnack构造器在构造过程中调用了throwing函数,并且通过传递到它的调用者来处理这些错误。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PurchasedSnack</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> name: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>, vendingMachine: <span class=\"type\">VendingMachine</span>) <span class=\"keyword\">throws</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> vendingMachine.vend(itemNamed: name)</div><div class=\"line\">        <span class=\"keyword\">self</span>.name = name</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"用-do-Catch-处理错误\"><a href=\"#用-do-Catch-处理错误\" class=\"headerlink\" title=\"用 do-Catch 处理错误\"></a>用 do-Catch 处理错误</h4><p>可以使用一个do-catch语句运行一段闭包代码来处理错误。如果在do子句中的代码抛出了一个错误，这个错误会与catch子句做匹配，从而决定哪条子句能处理它。</p>\n<p>下面是do-catch语句的一般形式：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">do</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">try</span> expression</div><div class=\"line\">    statements</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> pattern <span class=\"number\">1</span> &#123;</div><div class=\"line\">    statements</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> pattern <span class=\"number\">2</span> <span class=\"keyword\">where</span> condition &#123;</div><div class=\"line\">    statements</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在catch后面写一个匹配模式来表明这个子句能处理什么样的错误。如果一条catch子句没有指定匹配模式，那么这条子句可以匹配任何错误，并且把错误绑定到一个名字为error的局部常量</p>\n<p>catch子句不必将do子句中的代码所抛出的每一个可能的错误都作处理。如果所有catch子句都未处理错误，错误就会传递到周围的作用域。然而，错误还是必须要被某个周围的作用域处理的——要么是一个外围的do-catch错误处理语句，要么是一个 throwing 函数的内部。举例来说，下面的代码处理了VendingMachineError枚举类型的全部枚举值，但是所有其它的错误就必须由它周围的作用域处理：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> vendingMachine = <span class=\"type\">VendingMachine</span>()</div><div class=\"line\">vendingMachine.coinsDeposited = <span class=\"number\">8</span></div><div class=\"line\"><span class=\"keyword\">do</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">try</span> buyFavoriteSnack(person: <span class=\"string\">\"Alice\"</span>, vendingMachine: vendingMachine)</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> <span class=\"type\">VendingMachineError</span>.invalidSelection &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Invalid Selection.\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> <span class=\"type\">VendingMachineError</span>.outOfStock &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Out of Stock.\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> <span class=\"type\">VendingMachineError</span>.insufficientFunds(<span class=\"keyword\">let</span> coinsNeeded) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Insufficient funds. Please insert an additional <span class=\"subst\">\\(coinsNeeded)</span> coins.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"Insufficient funds. Please insert an additional 2 coins.\"</span></div></pre></td></tr></table></figure>\n<p>上面的例子中，buyFavoriteSnack(person:vendingMachine:)函数在一个try表达式中调用，因为它能抛出错误。如果错误被抛出，相应的执行会马上转移到catch子句中，并判断这个错误是否要被继续传递下去。如果没有错误抛出，do子句中余下的语句就会被执行。</p>\n<h4 id=\"将错误转换成可选值\"><a href=\"#将错误转换成可选值\" class=\"headerlink\" title=\"将错误转换成可选值\"></a>将错误转换成可选值</h4><p>可以使用try?通过将错误转换成一个可选值来处理错误。如果在评估try?表达式时一个错误被抛出，那么表达式的值就是nil。例如,在下面的代码中,x和y有着相同的数值和等价的含义：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someThrowingFunction</span><span class=\"params\">()</span></span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// ...</span></div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"keyword\">try</span>? someThrowingFunction()</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">let</span> y: <span class=\"type\">Int</span>?</div><div class=\"line\"><span class=\"keyword\">do</span> &#123;</div><div class=\"line\">    y = <span class=\"keyword\">try</span> someThrowingFunction()</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> &#123;</div><div class=\"line\">    y = <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果someThrowingFunction()抛出一个错误，x和y的值是nil。否则x和y的值就是该函数的返回值。注意，无论someThrowingFunction()的返回值类型是什么类型，x和y都是这个类型的可选类型。例子中此函数返回一个整型，所以x和y是可选整型。<br>如果你想对所有的错误都采用同样的方式来处理，用try?就可以让你写出简洁的错误处理代码。例如，下面的代码用几种方式来获取数据，如果所有方式都失败了则返回nil：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fetchData</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Data</span>? &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> data = <span class=\"keyword\">try</span>? fetchDataFromDisk() &#123; <span class=\"keyword\">return</span> data &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> data = <span class=\"keyword\">try</span>? fetchDataFromServer() &#123; <span class=\"keyword\">return</span> data &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"禁用错误传递\"><a href=\"#禁用错误传递\" class=\"headerlink\" title=\"禁用错误传递\"></a>禁用错误传递</h4><p>例如，下面的代码使用了loadImage(atPath:)函数，该函数从给定的路径加载图片资源，如果图片无法载入则抛出一个错误。在这种情况下，因为图片是和应用绑定的，运行时不会有错误抛出，所以适合禁用错误传递：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> photo = <span class=\"keyword\">try</span>! loadImage(atPath: <span class=\"string\">\"./Resources/John Appleseed.jpg\"</span>)</div></pre></td></tr></table></figure>\n<h3 id=\"指定清理操作\"><a href=\"#指定清理操作\" class=\"headerlink\" title=\"指定清理操作\"></a>指定清理操作</h3><p>可以使用defer语句在即将离开当前代码块时执行一系列语句。该语句让你能执行一些必要的清理工作，不管是以何种方式离开当前代码块的——无论是由于抛出错误而离开，还是由于诸如return或者break的语句。例如，你可以用defer语句来确保文件描述符得以关闭，以及手动分配的内存得以释放。</p>\n<p>defer语句将代码的执行延迟到当前的作用域退出之前。该语句由defer关键字和要被延迟执行的语句组成。延迟执行的语句不能包含任何控制转移语句，例如break或是return语句，或是抛出一个错误。延迟执行的操作会按照它们被指定时的顺序的相反顺序执行——也就是说，第一条defer语句中的代码会在第二条defer语句中的代码被执行之后才执行，以此类推。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">processFile</span><span class=\"params\">(filename: String)</span></span> <span class=\"keyword\">throws</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> exists(filename) &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> file = <span class=\"keyword\">open</span>(filename)</div><div class=\"line\">        <span class=\"keyword\">defer</span> &#123;</div><div class=\"line\">            close(file)</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">while</span> <span class=\"keyword\">let</span> line = <span class=\"keyword\">try</span> file.readline() &#123;</div><div class=\"line\">            <span class=\"comment\">// Work with the file.</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// close(file) is called here, at the end of the scope.</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码使用一条defer语句来确保open(<em>:)函数有一个相应的对close(</em>:)函数的调用。<br>    即使没有涉及到错误处理，你也可以使用defer语句。</p>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ErrorHandling.html/\" target=\"_blank\" rel=\"external\"> ErrorHandling </a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>"},{"layout":"post","title":"Swift Extensions","date":"2016-12-01T11:20:11.000Z","author":"liangtong","catalog":true,"_content":"\n\t\n\n​\t扩展为一个已有的类、结构体、枚举类型或者协议类型添加新功能。这包括在没有权限获取原始源代码的情况下扩展类型的能力（即 逆向建模 ）。扩展和 Objective-C 中的分类类似。（与 Objective-C 不同的是，Swift 的扩展没有名字。）\n在Swift中，扩展可以：\n\n * 添加计算型属性和计算型类型属性\n * 定义实例方法和类型方法\n * 提供新的构造器\n * 定义下标\n * 定义和使用新的嵌套类型\n * 使一个已有类型符合某个协议\n\n在 Swift 中，你甚至可以对协议进行扩展，提供协议要求的实现，或者添加额外的功能，从而可以让符合协议的类型拥有这些功能。\n\t扩展可以为一个类型添加新的功能，但是不能重写已有的功能。\n\n\n\n<!-- more -->\n\n### 扩展语法\n使用关键字 extension 来声明扩展：\n\n```Swift\nextension SomeType {\n    // new functionality to add to SomeType goes here\n}\n```\n\n可以通过扩展来扩展一个已有类型，使其采纳一个或多个协议。在这种情况下，无论是类还是结构体，协议名字的书写方式完全一样：\n\n```Swift\nextension SomeType: SomeProtocol, AnotherProtocol {\n    // implementation of protocol requirements goes here\n}\n```\n\n\t如果你通过扩展为一个已有类型添加新功能，那么新功能对该类型的所有已有实例都是可用的，即使它们是在这个扩展定义之前创建的。\n\n\n### 计算型属性\n扩展可以为已有类型添加计算型实例属性和计算型类型属性。下面的例子为 Swift 的内建 Double 类型添加了五个计算型实例属性，从而提供与距离单位协作的基本支持：\n\n```Swift\nextension Double {\n    var km: Double { return self * 1_000.0 }\n    var m: Double { return self }\n    var cm: Double { return self / 100.0 }\n    var mm: Double { return self / 1_000.0 }\n    var ft: Double { return self / 3.28084 }\n}\nlet oneInch = 25.4.mm\nprint(\"One inch is \\(oneInch) meters\")\n// Prints \"One inch is 0.0254 meters\"\nlet threeFeet = 3.ft\nprint(\"Three feet is \\(threeFeet) meters\")\n// Prints \"Three feet is 0.914399970739201 meters\"\n```\n\n这些计算型属性表达的含义是把一个 Double 值看作是某单位下的长度值。即使它们被实现为计算型属性，但这些属性的名字仍可紧接一个浮点型字面值，从而通过点语法来使用，并以此实现距离转换。\n在上述例子中，Double 值 1.0 用来表示“1米”。这就是为什么计算型属性 m 返回 self，即表达式 1.m 被认为是计算 Double 值 1.0。\n其它单位则需要一些单位换算。一千米等于 1,000 米，所以计算型属性 km 要把值乘以 1_000.00 来实现千米到米的单位换算。类似地，一米有 3.28024 英尺，所以计算型属性 ft 要把对应的 Double 值除以 3.28024 来实现英尺到米的单位换算。\n\n这些属性是只读的计算型属性，为了更简洁，省略了 get 关键字。它们的返回值是 Double，而且可以用于所有接受 Double 值的数学计算中：\n\n```Swift\nlet aMarathon = 42.km + 195.m\nprint(\"A marathon is \\(aMarathon) meters long\")\n// Prints \"A marathon is 42195.0 meters long\"\n```\n\n\t扩展可以添加新的计算型属性，但是不可以添加存储型属性，也不可以为已有属性添加属性观察器。\n\n\n### 构造器\n扩展可以为已有类型添加新的构造器。这可以让你扩展其它类型，将你自己的定制类型作为其构造器参数，或者提供该类型的原始实现中未提供的额外初始化选项。\n\n扩展能为类添加新的便利构造器，但是它们不能为类添加新的指定构造器或析构器。指定构造器和析构器必须总是由原始的类实现来提供。\n\t如果你使用扩展为一个值类型添加构造器，同时该值类型的原始实现中未定义任何定制的构造器且所有存储属性提供了默认值，那么我们就可以在扩展中的构造器里调用默认构造器和逐一成员构造器。如果你把定制的构造器写在值类型的原始实现中，规则将不再适用。\n\n下面的例子定义了一个用于描述几何矩形的结构体 Rect。这个例子同时定义了两个辅助结构体 Size 和 Point，它们都把 0.0 作为所有属性的默认值：\n\n```Swift\nstruct Size {\n    var width = 0.0, height = 0.0\n}\nstruct Point {\n    var x = 0.0, y = 0.0\n}\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n}\n```\n\n因为结构体 Rect 未提供定制的构造器，因此它会获得一个逐一成员构造器。又因为它为所有存储型属性提供了默认值，它又会获得一个默认构造器。\n\n```Swift\nlet defaultRect = Rect()\nlet memberwiseRect = Rect(origin: Point(x: 2.0, y: 2.0),\n                          size: Size(width: 5.0, height: 5.0))\n```\n\n你可以提供一个额外的接受指定中心点和大小的构造器来扩展 Rect 结构体：\n\n```Swift\nextension Rect {\n    init(center: Point, size: Size) {\n        let originX = center.x - (size.width / 2)\n        let originY = center.y - (size.height / 2)\n        self.init(origin: Point(x: originX, y: originY), size: size)\n    }\n}\n```\n\n这个新的构造器首先根据提供的 center 和 size 的值计算一个合适的原点。然后调用该结构体的逐一成员构造器 init(origin:size:)，该构造器将新的原点和大小的值保存到了相应的属性中：\n\n```Swift\nlet centerRect = Rect(center: Point(x: 4.0, y: 4.0),\n                      size: Size(width: 3.0, height: 3.0))\n// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)\n```\n\n\t如果你使用扩展提供了一个新的构造器，你依旧有责任确保构造过程能够让实例完全初始化。\n\n\n### 方法\n扩展可以为已有类型添加新的实例方法和类型方法。\n下面的例子为 Int 类型添加了一个名为 repetitions 的实例方法：\n\n```Swift\nextension Int {\n    func repetitions(task: () -> Void) {\n        for _ in 0..<self {\n            task()\n        }\n    }\n}\n```\n\n这个 repetitions(task:) 方法接受一个 () -> Void 类型的单参数，表示没有参数且没有返回值的函数。\n定义该扩展之后，你就可以对任意整数调用 repetitions(task:) 方法，将闭包中的任务执行整数对应的次数：\n\n```Swift\n3.repetitions {\n    print(\"Hello!\")\n}\n// Hello!\n// Hello!\n// Hello!\n```\n\n#### 可变实例方法\n通过扩展添加的实例方法也可以修改该实例本身。结构体和枚举类型中修改 self 或其属性的方法必须将该实例方法标注为 `mutating`，正如来自原始实现的可变方法一样。\n下面的例子为 Swift 的 Int 类型添加了一个名为 square 的可变方法，用于计算原始值的平方值：\n\n```Swift\nextension Int {\n    mutating func square() {\n        self = self * self\n    }\n}\nvar someInt = 3\nsomeInt.square()\n// someInt is now 9\n```\n\n### 下标\n扩展可以为已有类型添加新下标。\n这个例子为 Swift 内建类型 Int 添加了一个整型下标。该下标 [n] 返回十进制数字从右向左数的第 n 个数字：\n\n```Swift\nextension Int {\n    subscript(digitIndex: Int) -> Int {\n        var decimalBase = 1\n        for _ in 0..<digitIndex {\n            decimalBase *= 10\n        }\n        return (self / decimalBase) % 10\n    }\n}\n746381295[0]\n// returns 5\n746381295[1]\n// returns 9\n746381295[2]\n// returns 2\n746381295[8]\n// returns 7\n```\n\n如果该 Int 值没有足够的位数，即下标越界，那么上述下标实现会返回 0，犹如在数字左边自动补 0：\n\n```Swift\n746381295[9]\n// returns 0, as if you had requested:\n0746381295[9]\n```\n\n### 嵌套类型\n扩展可以为已有的类、结构体和枚举添加新的嵌套类型：\n\n```Swift\nextension Int {\n    enum Kind {\n        case negative, zero, positive\n    }\n    var kind: Kind {\n        switch self {\n        case 0:\n            return .zero\n        case let x where x > 0:\n            return .positive\n        default:\n            return .negative\n        }\n    }\n}\n```\n\n该例子为 Int 添加了嵌套枚举。这个名为 Kind 的枚举表示特定整数的类型。具体来说，就是表示整数是正数、零或者负数。\n这个例子还为 Int 添加了一个计算型实例属性，即 kind，用来根据整数返回适当的 Kind 枚举成员。\n现在，这个嵌套枚举可以和任意 Int 值一起使用了：\n\n```Swift\nfunc printIntegerKinds(_ numbers: [Int]) {\n    for number in numbers {\n        switch number.kind {\n        case .negative:\n            print(\"- \", terminator: \"\")\n        case .zero:\n            print(\"0 \", terminator: \"\")\n        case .positive:\n            print(\"+ \", terminator: \"\")\n        }\n    }\n    print(\"\")\n}\nprintIntegerKinds([3, 19, -27, 0, -6, 0, 7])\n// Prints \"+ + - 0 - 0 + \"\n```\n\n函数 printIntegerKinds(_:) 接受一个 Int 数组，然后对该数组进行迭代。在每次迭代过程中，对当前整数的计算型属性 kind 的值进行评估，并打印出适当的描述。\n\t由于已知 number.kind 是 Int.Kind 类型，因此在 switch 语句中，Int.Kind 中的所有成员值都可以使用简写形式，例如使用 . Negative 而不是 Int.Kind.Negative。\n\n\n\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/NestedTypes.html/\"> NestedTypes </a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","source":"_posts/iOS_Swift_language_note_Extensions.md","raw":"---\nlayout:     post\ntitle:      Swift Extensions\ndate:       2016-12-01 19:20:11\nauthor:     liangtong\ncatalog: true\ncategories: iOS\ntags: Swift \n\n---\n\n\t\n\n​\t扩展为一个已有的类、结构体、枚举类型或者协议类型添加新功能。这包括在没有权限获取原始源代码的情况下扩展类型的能力（即 逆向建模 ）。扩展和 Objective-C 中的分类类似。（与 Objective-C 不同的是，Swift 的扩展没有名字。）\n在Swift中，扩展可以：\n\n * 添加计算型属性和计算型类型属性\n * 定义实例方法和类型方法\n * 提供新的构造器\n * 定义下标\n * 定义和使用新的嵌套类型\n * 使一个已有类型符合某个协议\n\n在 Swift 中，你甚至可以对协议进行扩展，提供协议要求的实现，或者添加额外的功能，从而可以让符合协议的类型拥有这些功能。\n\t扩展可以为一个类型添加新的功能，但是不能重写已有的功能。\n\n\n\n<!-- more -->\n\n### 扩展语法\n使用关键字 extension 来声明扩展：\n\n```Swift\nextension SomeType {\n    // new functionality to add to SomeType goes here\n}\n```\n\n可以通过扩展来扩展一个已有类型，使其采纳一个或多个协议。在这种情况下，无论是类还是结构体，协议名字的书写方式完全一样：\n\n```Swift\nextension SomeType: SomeProtocol, AnotherProtocol {\n    // implementation of protocol requirements goes here\n}\n```\n\n\t如果你通过扩展为一个已有类型添加新功能，那么新功能对该类型的所有已有实例都是可用的，即使它们是在这个扩展定义之前创建的。\n\n\n### 计算型属性\n扩展可以为已有类型添加计算型实例属性和计算型类型属性。下面的例子为 Swift 的内建 Double 类型添加了五个计算型实例属性，从而提供与距离单位协作的基本支持：\n\n```Swift\nextension Double {\n    var km: Double { return self * 1_000.0 }\n    var m: Double { return self }\n    var cm: Double { return self / 100.0 }\n    var mm: Double { return self / 1_000.0 }\n    var ft: Double { return self / 3.28084 }\n}\nlet oneInch = 25.4.mm\nprint(\"One inch is \\(oneInch) meters\")\n// Prints \"One inch is 0.0254 meters\"\nlet threeFeet = 3.ft\nprint(\"Three feet is \\(threeFeet) meters\")\n// Prints \"Three feet is 0.914399970739201 meters\"\n```\n\n这些计算型属性表达的含义是把一个 Double 值看作是某单位下的长度值。即使它们被实现为计算型属性，但这些属性的名字仍可紧接一个浮点型字面值，从而通过点语法来使用，并以此实现距离转换。\n在上述例子中，Double 值 1.0 用来表示“1米”。这就是为什么计算型属性 m 返回 self，即表达式 1.m 被认为是计算 Double 值 1.0。\n其它单位则需要一些单位换算。一千米等于 1,000 米，所以计算型属性 km 要把值乘以 1_000.00 来实现千米到米的单位换算。类似地，一米有 3.28024 英尺，所以计算型属性 ft 要把对应的 Double 值除以 3.28024 来实现英尺到米的单位换算。\n\n这些属性是只读的计算型属性，为了更简洁，省略了 get 关键字。它们的返回值是 Double，而且可以用于所有接受 Double 值的数学计算中：\n\n```Swift\nlet aMarathon = 42.km + 195.m\nprint(\"A marathon is \\(aMarathon) meters long\")\n// Prints \"A marathon is 42195.0 meters long\"\n```\n\n\t扩展可以添加新的计算型属性，但是不可以添加存储型属性，也不可以为已有属性添加属性观察器。\n\n\n### 构造器\n扩展可以为已有类型添加新的构造器。这可以让你扩展其它类型，将你自己的定制类型作为其构造器参数，或者提供该类型的原始实现中未提供的额外初始化选项。\n\n扩展能为类添加新的便利构造器，但是它们不能为类添加新的指定构造器或析构器。指定构造器和析构器必须总是由原始的类实现来提供。\n\t如果你使用扩展为一个值类型添加构造器，同时该值类型的原始实现中未定义任何定制的构造器且所有存储属性提供了默认值，那么我们就可以在扩展中的构造器里调用默认构造器和逐一成员构造器。如果你把定制的构造器写在值类型的原始实现中，规则将不再适用。\n\n下面的例子定义了一个用于描述几何矩形的结构体 Rect。这个例子同时定义了两个辅助结构体 Size 和 Point，它们都把 0.0 作为所有属性的默认值：\n\n```Swift\nstruct Size {\n    var width = 0.0, height = 0.0\n}\nstruct Point {\n    var x = 0.0, y = 0.0\n}\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n}\n```\n\n因为结构体 Rect 未提供定制的构造器，因此它会获得一个逐一成员构造器。又因为它为所有存储型属性提供了默认值，它又会获得一个默认构造器。\n\n```Swift\nlet defaultRect = Rect()\nlet memberwiseRect = Rect(origin: Point(x: 2.0, y: 2.0),\n                          size: Size(width: 5.0, height: 5.0))\n```\n\n你可以提供一个额外的接受指定中心点和大小的构造器来扩展 Rect 结构体：\n\n```Swift\nextension Rect {\n    init(center: Point, size: Size) {\n        let originX = center.x - (size.width / 2)\n        let originY = center.y - (size.height / 2)\n        self.init(origin: Point(x: originX, y: originY), size: size)\n    }\n}\n```\n\n这个新的构造器首先根据提供的 center 和 size 的值计算一个合适的原点。然后调用该结构体的逐一成员构造器 init(origin:size:)，该构造器将新的原点和大小的值保存到了相应的属性中：\n\n```Swift\nlet centerRect = Rect(center: Point(x: 4.0, y: 4.0),\n                      size: Size(width: 3.0, height: 3.0))\n// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)\n```\n\n\t如果你使用扩展提供了一个新的构造器，你依旧有责任确保构造过程能够让实例完全初始化。\n\n\n### 方法\n扩展可以为已有类型添加新的实例方法和类型方法。\n下面的例子为 Int 类型添加了一个名为 repetitions 的实例方法：\n\n```Swift\nextension Int {\n    func repetitions(task: () -> Void) {\n        for _ in 0..<self {\n            task()\n        }\n    }\n}\n```\n\n这个 repetitions(task:) 方法接受一个 () -> Void 类型的单参数，表示没有参数且没有返回值的函数。\n定义该扩展之后，你就可以对任意整数调用 repetitions(task:) 方法，将闭包中的任务执行整数对应的次数：\n\n```Swift\n3.repetitions {\n    print(\"Hello!\")\n}\n// Hello!\n// Hello!\n// Hello!\n```\n\n#### 可变实例方法\n通过扩展添加的实例方法也可以修改该实例本身。结构体和枚举类型中修改 self 或其属性的方法必须将该实例方法标注为 `mutating`，正如来自原始实现的可变方法一样。\n下面的例子为 Swift 的 Int 类型添加了一个名为 square 的可变方法，用于计算原始值的平方值：\n\n```Swift\nextension Int {\n    mutating func square() {\n        self = self * self\n    }\n}\nvar someInt = 3\nsomeInt.square()\n// someInt is now 9\n```\n\n### 下标\n扩展可以为已有类型添加新下标。\n这个例子为 Swift 内建类型 Int 添加了一个整型下标。该下标 [n] 返回十进制数字从右向左数的第 n 个数字：\n\n```Swift\nextension Int {\n    subscript(digitIndex: Int) -> Int {\n        var decimalBase = 1\n        for _ in 0..<digitIndex {\n            decimalBase *= 10\n        }\n        return (self / decimalBase) % 10\n    }\n}\n746381295[0]\n// returns 5\n746381295[1]\n// returns 9\n746381295[2]\n// returns 2\n746381295[8]\n// returns 7\n```\n\n如果该 Int 值没有足够的位数，即下标越界，那么上述下标实现会返回 0，犹如在数字左边自动补 0：\n\n```Swift\n746381295[9]\n// returns 0, as if you had requested:\n0746381295[9]\n```\n\n### 嵌套类型\n扩展可以为已有的类、结构体和枚举添加新的嵌套类型：\n\n```Swift\nextension Int {\n    enum Kind {\n        case negative, zero, positive\n    }\n    var kind: Kind {\n        switch self {\n        case 0:\n            return .zero\n        case let x where x > 0:\n            return .positive\n        default:\n            return .negative\n        }\n    }\n}\n```\n\n该例子为 Int 添加了嵌套枚举。这个名为 Kind 的枚举表示特定整数的类型。具体来说，就是表示整数是正数、零或者负数。\n这个例子还为 Int 添加了一个计算型实例属性，即 kind，用来根据整数返回适当的 Kind 枚举成员。\n现在，这个嵌套枚举可以和任意 Int 值一起使用了：\n\n```Swift\nfunc printIntegerKinds(_ numbers: [Int]) {\n    for number in numbers {\n        switch number.kind {\n        case .negative:\n            print(\"- \", terminator: \"\")\n        case .zero:\n            print(\"0 \", terminator: \"\")\n        case .positive:\n            print(\"+ \", terminator: \"\")\n        }\n    }\n    print(\"\")\n}\nprintIntegerKinds([3, 19, -27, 0, -6, 0, 7])\n// Prints \"+ + - 0 - 0 + \"\n```\n\n函数 printIntegerKinds(_:) 接受一个 Int 数组，然后对该数组进行迭代。在每次迭代过程中，对当前整数的计算型属性 kind 的值进行评估，并打印出适当的描述。\n\t由于已知 number.kind 是 Int.Kind 类型，因此在 switch 语句中，Int.Kind 中的所有成员值都可以使用简写形式，例如使用 . Negative 而不是 Int.Kind.Negative。\n\n\n\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/NestedTypes.html/\"> NestedTypes </a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","slug":"iOS_Swift_language_note_Extensions","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4ub002xoko8y3wmj0r4","content":"<p>​    扩展为一个已有的类、结构体、枚举类型或者协议类型添加新功能。这包括在没有权限获取原始源代码的情况下扩展类型的能力（即 逆向建模 ）。扩展和 Objective-C 中的分类类似。（与 Objective-C 不同的是，Swift 的扩展没有名字。）<br>在Swift中，扩展可以：</p>\n<ul>\n<li>添加计算型属性和计算型类型属性</li>\n<li>定义实例方法和类型方法</li>\n<li>提供新的构造器</li>\n<li>定义下标</li>\n<li>定义和使用新的嵌套类型</li>\n<li>使一个已有类型符合某个协议</li>\n</ul>\n<p>在 Swift 中，你甚至可以对协议进行扩展，提供协议要求的实现，或者添加额外的功能，从而可以让符合协议的类型拥有这些功能。<br>    扩展可以为一个类型添加新的功能，但是不能重写已有的功能。</p>\n<a id=\"more\"></a>\n<h3 id=\"扩展语法\"><a href=\"#扩展语法\" class=\"headerlink\" title=\"扩展语法\"></a>扩展语法</h3><p>使用关键字 extension 来声明扩展：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">SomeType</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// new functionality to add to SomeType goes here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以通过扩展来扩展一个已有类型，使其采纳一个或多个协议。在这种情况下，无论是类还是结构体，协议名字的书写方式完全一样：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">SomeType</span>: <span class=\"title\">SomeProtocol</span>, <span class=\"title\">AnotherProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// implementation of protocol requirements goes here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<pre><code>如果你通过扩展为一个已有类型添加新功能，那么新功能对该类型的所有已有实例都是可用的，即使它们是在这个扩展定义之前创建的。\n</code></pre><h3 id=\"计算型属性\"><a href=\"#计算型属性\" class=\"headerlink\" title=\"计算型属性\"></a>计算型属性</h3><p>扩展可以为已有类型添加计算型实例属性和计算型类型属性。下面的例子为 Swift 的内建 Double 类型添加了五个计算型实例属性，从而提供与距离单位协作的基本支持：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Double</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> km: <span class=\"type\">Double</span> &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">self</span> * <span class=\"number\">1_000.0</span> &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> m: <span class=\"type\">Double</span> &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">self</span> &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> cm: <span class=\"type\">Double</span> &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">self</span> / <span class=\"number\">100.0</span> &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> mm: <span class=\"type\">Double</span> &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">self</span> / <span class=\"number\">1_000.0</span> &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> ft: <span class=\"type\">Double</span> &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">self</span> / <span class=\"number\">3.28084</span> &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> oneInch = <span class=\"number\">25.4</span>.mm</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"One inch is <span class=\"subst\">\\(oneInch)</span> meters\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"One inch is 0.0254 meters\"</span></div><div class=\"line\"><span class=\"keyword\">let</span> threeFeet = <span class=\"number\">3</span>.ft</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Three feet is <span class=\"subst\">\\(threeFeet)</span> meters\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"Three feet is 0.914399970739201 meters\"</span></div></pre></td></tr></table></figure>\n<p>这些计算型属性表达的含义是把一个 Double 值看作是某单位下的长度值。即使它们被实现为计算型属性，但这些属性的名字仍可紧接一个浮点型字面值，从而通过点语法来使用，并以此实现距离转换。<br>在上述例子中，Double 值 1.0 用来表示“1米”。这就是为什么计算型属性 m 返回 self，即表达式 1.m 被认为是计算 Double 值 1.0。<br>其它单位则需要一些单位换算。一千米等于 1,000 米，所以计算型属性 km 要把值乘以 1_000.00 来实现千米到米的单位换算。类似地，一米有 3.28024 英尺，所以计算型属性 ft 要把对应的 Double 值除以 3.28024 来实现英尺到米的单位换算。</p>\n<p>这些属性是只读的计算型属性，为了更简洁，省略了 get 关键字。它们的返回值是 Double，而且可以用于所有接受 Double 值的数学计算中：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> aMarathon = <span class=\"number\">42</span>.km + <span class=\"number\">195</span>.m</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"A marathon is <span class=\"subst\">\\(aMarathon)</span> meters long\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"A marathon is 42195.0 meters long\"</span></div></pre></td></tr></table></figure>\n<pre><code>扩展可以添加新的计算型属性，但是不可以添加存储型属性，也不可以为已有属性添加属性观察器。\n</code></pre><h3 id=\"构造器\"><a href=\"#构造器\" class=\"headerlink\" title=\"构造器\"></a>构造器</h3><p>扩展可以为已有类型添加新的构造器。这可以让你扩展其它类型，将你自己的定制类型作为其构造器参数，或者提供该类型的原始实现中未提供的额外初始化选项。</p>\n<p>扩展能为类添加新的便利构造器，但是它们不能为类添加新的指定构造器或析构器。指定构造器和析构器必须总是由原始的类实现来提供。<br>    如果你使用扩展为一个值类型添加构造器，同时该值类型的原始实现中未定义任何定制的构造器且所有存储属性提供了默认值，那么我们就可以在扩展中的构造器里调用默认构造器和逐一成员构造器。如果你把定制的构造器写在值类型的原始实现中，规则将不再适用。</p>\n<p>下面的例子定义了一个用于描述几何矩形的结构体 Rect。这个例子同时定义了两个辅助结构体 Size 和 Point，它们都把 0.0 作为所有属性的默认值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Size</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> width = <span class=\"number\">0.0</span>, height = <span class=\"number\">0.0</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">0.0</span>, y = <span class=\"number\">0.0</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Rect</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> origin = <span class=\"type\">Point</span>()</div><div class=\"line\">    <span class=\"keyword\">var</span> size = <span class=\"type\">Size</span>()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>因为结构体 Rect 未提供定制的构造器，因此它会获得一个逐一成员构造器。又因为它为所有存储型属性提供了默认值，它又会获得一个默认构造器。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> defaultRect = <span class=\"type\">Rect</span>()</div><div class=\"line\"><span class=\"keyword\">let</span> memberwiseRect = <span class=\"type\">Rect</span>(origin: <span class=\"type\">Point</span>(x: <span class=\"number\">2.0</span>, y: <span class=\"number\">2.0</span>),</div><div class=\"line\">                          size: <span class=\"type\">Size</span>(width: <span class=\"number\">5.0</span>, height: <span class=\"number\">5.0</span>))</div></pre></td></tr></table></figure>\n<p>你可以提供一个额外的接受指定中心点和大小的构造器来扩展 Rect 结构体：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Rect</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">init</span>(center: <span class=\"type\">Point</span>, size: <span class=\"type\">Size</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> originX = center.x - (size.width / <span class=\"number\">2</span>)</div><div class=\"line\">        <span class=\"keyword\">let</span> originY = center.y - (size.height / <span class=\"number\">2</span>)</div><div class=\"line\">        <span class=\"keyword\">self</span>.<span class=\"keyword\">init</span>(origin: <span class=\"type\">Point</span>(x: originX, y: originY), size: size)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个新的构造器首先根据提供的 center 和 size 的值计算一个合适的原点。然后调用该结构体的逐一成员构造器 init(origin:size:)，该构造器将新的原点和大小的值保存到了相应的属性中：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> centerRect = <span class=\"type\">Rect</span>(center: <span class=\"type\">Point</span>(x: <span class=\"number\">4.0</span>, y: <span class=\"number\">4.0</span>),</div><div class=\"line\">                      size: <span class=\"type\">Size</span>(width: <span class=\"number\">3.0</span>, height: <span class=\"number\">3.0</span>))</div><div class=\"line\"><span class=\"comment\">// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)</span></div></pre></td></tr></table></figure>\n<pre><code>如果你使用扩展提供了一个新的构造器，你依旧有责任确保构造过程能够让实例完全初始化。\n</code></pre><h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><p>扩展可以为已有类型添加新的实例方法和类型方法。<br>下面的例子为 Int 类型添加了一个名为 repetitions 的实例方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Int</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">repetitions</span><span class=\"params\">(task: <span class=\"params\">()</span></span></span> -&gt; <span class=\"type\">Void</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;<span class=\"keyword\">self</span> &#123;</div><div class=\"line\">            task()</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个 repetitions(task:) 方法接受一个 () -&gt; Void 类型的单参数，表示没有参数且没有返回值的函数。<br>定义该扩展之后，你就可以对任意整数调用 repetitions(task:) 方法，将闭包中的任务执行整数对应的次数：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">3</span>.repetitions &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Hello!\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Hello!</span></div><div class=\"line\"><span class=\"comment\">// Hello!</span></div><div class=\"line\"><span class=\"comment\">// Hello!</span></div></pre></td></tr></table></figure>\n<h4 id=\"可变实例方法\"><a href=\"#可变实例方法\" class=\"headerlink\" title=\"可变实例方法\"></a>可变实例方法</h4><p>通过扩展添加的实例方法也可以修改该实例本身。结构体和枚举类型中修改 self 或其属性的方法必须将该实例方法标注为 <code>mutating</code>，正如来自原始实现的可变方法一样。<br>下面的例子为 Swift 的 Int 类型添加了一个名为 square 的可变方法，用于计算原始值的平方值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Int</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">square</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span> = <span class=\"keyword\">self</span> * <span class=\"keyword\">self</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> someInt = <span class=\"number\">3</span></div><div class=\"line\">someInt.square()</div><div class=\"line\"><span class=\"comment\">// someInt is now 9</span></div></pre></td></tr></table></figure>\n<h3 id=\"下标\"><a href=\"#下标\" class=\"headerlink\" title=\"下标\"></a>下标</h3><p>扩展可以为已有类型添加新下标。<br>这个例子为 Swift 内建类型 Int 添加了一个整型下标。该下标 [n] 返回十进制数字从右向左数的第 n 个数字：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Int</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">subscript</span>(digitIndex: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> decimalBase = <span class=\"number\">1</span></div><div class=\"line\">        <span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;digitIndex &#123;</div><div class=\"line\">            decimalBase *= <span class=\"number\">10</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">self</span> / decimalBase) % <span class=\"number\">10</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"number\">746381295</span>[<span class=\"number\">0</span>]</div><div class=\"line\"><span class=\"comment\">// returns 5</span></div><div class=\"line\"><span class=\"number\">746381295</span>[<span class=\"number\">1</span>]</div><div class=\"line\"><span class=\"comment\">// returns 9</span></div><div class=\"line\"><span class=\"number\">746381295</span>[<span class=\"number\">2</span>]</div><div class=\"line\"><span class=\"comment\">// returns 2</span></div><div class=\"line\"><span class=\"number\">746381295</span>[<span class=\"number\">8</span>]</div><div class=\"line\"><span class=\"comment\">// returns 7</span></div></pre></td></tr></table></figure>\n<p>如果该 Int 值没有足够的位数，即下标越界，那么上述下标实现会返回 0，犹如在数字左边自动补 0：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">746381295</span>[<span class=\"number\">9</span>]</div><div class=\"line\"><span class=\"comment\">// returns 0, as if you had requested:</span></div><div class=\"line\"><span class=\"number\">0746381295</span>[<span class=\"number\">9</span>]</div></pre></td></tr></table></figure>\n<h3 id=\"嵌套类型\"><a href=\"#嵌套类型\" class=\"headerlink\" title=\"嵌套类型\"></a>嵌套类型</h3><p>扩展可以为已有的类、结构体和枚举添加新的嵌套类型：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Int</span> </span>&#123;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Kind</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> negative, zero, positive</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> kind: <span class=\"type\">Kind</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> <span class=\"keyword\">self</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</div><div class=\"line\">            <span class=\"keyword\">return</span> .zero</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> x <span class=\"keyword\">where</span> x &gt; <span class=\"number\">0</span>:</div><div class=\"line\">            <span class=\"keyword\">return</span> .positive</div><div class=\"line\">        <span class=\"keyword\">default</span>:</div><div class=\"line\">            <span class=\"keyword\">return</span> .negative</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>该例子为 Int 添加了嵌套枚举。这个名为 Kind 的枚举表示特定整数的类型。具体来说，就是表示整数是正数、零或者负数。<br>这个例子还为 Int 添加了一个计算型实例属性，即 kind，用来根据整数返回适当的 Kind 枚举成员。<br>现在，这个嵌套枚举可以和任意 Int 值一起使用了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printIntegerKinds</span><span class=\"params\">(<span class=\"number\">_</span> numbers: [Int])</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> number <span class=\"keyword\">in</span> numbers &#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> number.kind &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> .negative:</div><div class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">\"- \"</span>, terminator: <span class=\"string\">\"\"</span>)</div><div class=\"line\">        <span class=\"keyword\">case</span> .zero:</div><div class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">\"0 \"</span>, terminator: <span class=\"string\">\"\"</span>)</div><div class=\"line\">        <span class=\"keyword\">case</span> .positive:</div><div class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">\"+ \"</span>, terminator: <span class=\"string\">\"\"</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\">printIntegerKinds([<span class=\"number\">3</span>, <span class=\"number\">19</span>, -<span class=\"number\">27</span>, <span class=\"number\">0</span>, -<span class=\"number\">6</span>, <span class=\"number\">0</span>, <span class=\"number\">7</span>])</div><div class=\"line\"><span class=\"comment\">// Prints \"+ + - 0 - 0 + \"</span></div></pre></td></tr></table></figure>\n<p>函数 printIntegerKinds(_:) 接受一个 Int 数组，然后对该数组进行迭代。在每次迭代过程中，对当前整数的计算型属性 kind 的值进行评估，并打印出适当的描述。<br>    由于已知 number.kind 是 Int.Kind 类型，因此在 switch 语句中，Int.Kind 中的所有成员值都可以使用简写形式，例如使用 . Negative 而不是 Int.Kind.Negative。</p>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/NestedTypes.html/\" target=\"_blank\" rel=\"external\"> NestedTypes </a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>​    扩展为一个已有的类、结构体、枚举类型或者协议类型添加新功能。这包括在没有权限获取原始源代码的情况下扩展类型的能力（即 逆向建模 ）。扩展和 Objective-C 中的分类类似。（与 Objective-C 不同的是，Swift 的扩展没有名字。）<br>在Swift中，扩展可以：</p>\n<ul>\n<li>添加计算型属性和计算型类型属性</li>\n<li>定义实例方法和类型方法</li>\n<li>提供新的构造器</li>\n<li>定义下标</li>\n<li>定义和使用新的嵌套类型</li>\n<li>使一个已有类型符合某个协议</li>\n</ul>\n<p>在 Swift 中，你甚至可以对协议进行扩展，提供协议要求的实现，或者添加额外的功能，从而可以让符合协议的类型拥有这些功能。<br>    扩展可以为一个类型添加新的功能，但是不能重写已有的功能。</p>","more":"<h3 id=\"扩展语法\"><a href=\"#扩展语法\" class=\"headerlink\" title=\"扩展语法\"></a>扩展语法</h3><p>使用关键字 extension 来声明扩展：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">SomeType</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// new functionality to add to SomeType goes here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以通过扩展来扩展一个已有类型，使其采纳一个或多个协议。在这种情况下，无论是类还是结构体，协议名字的书写方式完全一样：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">SomeType</span>: <span class=\"title\">SomeProtocol</span>, <span class=\"title\">AnotherProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// implementation of protocol requirements goes here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<pre><code>如果你通过扩展为一个已有类型添加新功能，那么新功能对该类型的所有已有实例都是可用的，即使它们是在这个扩展定义之前创建的。\n</code></pre><h3 id=\"计算型属性\"><a href=\"#计算型属性\" class=\"headerlink\" title=\"计算型属性\"></a>计算型属性</h3><p>扩展可以为已有类型添加计算型实例属性和计算型类型属性。下面的例子为 Swift 的内建 Double 类型添加了五个计算型实例属性，从而提供与距离单位协作的基本支持：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Double</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> km: <span class=\"type\">Double</span> &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">self</span> * <span class=\"number\">1_000.0</span> &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> m: <span class=\"type\">Double</span> &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">self</span> &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> cm: <span class=\"type\">Double</span> &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">self</span> / <span class=\"number\">100.0</span> &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> mm: <span class=\"type\">Double</span> &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">self</span> / <span class=\"number\">1_000.0</span> &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> ft: <span class=\"type\">Double</span> &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">self</span> / <span class=\"number\">3.28084</span> &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> oneInch = <span class=\"number\">25.4</span>.mm</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"One inch is <span class=\"subst\">\\(oneInch)</span> meters\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"One inch is 0.0254 meters\"</span></div><div class=\"line\"><span class=\"keyword\">let</span> threeFeet = <span class=\"number\">3</span>.ft</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Three feet is <span class=\"subst\">\\(threeFeet)</span> meters\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"Three feet is 0.914399970739201 meters\"</span></div></pre></td></tr></table></figure>\n<p>这些计算型属性表达的含义是把一个 Double 值看作是某单位下的长度值。即使它们被实现为计算型属性，但这些属性的名字仍可紧接一个浮点型字面值，从而通过点语法来使用，并以此实现距离转换。<br>在上述例子中，Double 值 1.0 用来表示“1米”。这就是为什么计算型属性 m 返回 self，即表达式 1.m 被认为是计算 Double 值 1.0。<br>其它单位则需要一些单位换算。一千米等于 1,000 米，所以计算型属性 km 要把值乘以 1_000.00 来实现千米到米的单位换算。类似地，一米有 3.28024 英尺，所以计算型属性 ft 要把对应的 Double 值除以 3.28024 来实现英尺到米的单位换算。</p>\n<p>这些属性是只读的计算型属性，为了更简洁，省略了 get 关键字。它们的返回值是 Double，而且可以用于所有接受 Double 值的数学计算中：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> aMarathon = <span class=\"number\">42</span>.km + <span class=\"number\">195</span>.m</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"A marathon is <span class=\"subst\">\\(aMarathon)</span> meters long\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"A marathon is 42195.0 meters long\"</span></div></pre></td></tr></table></figure>\n<pre><code>扩展可以添加新的计算型属性，但是不可以添加存储型属性，也不可以为已有属性添加属性观察器。\n</code></pre><h3 id=\"构造器\"><a href=\"#构造器\" class=\"headerlink\" title=\"构造器\"></a>构造器</h3><p>扩展可以为已有类型添加新的构造器。这可以让你扩展其它类型，将你自己的定制类型作为其构造器参数，或者提供该类型的原始实现中未提供的额外初始化选项。</p>\n<p>扩展能为类添加新的便利构造器，但是它们不能为类添加新的指定构造器或析构器。指定构造器和析构器必须总是由原始的类实现来提供。<br>    如果你使用扩展为一个值类型添加构造器，同时该值类型的原始实现中未定义任何定制的构造器且所有存储属性提供了默认值，那么我们就可以在扩展中的构造器里调用默认构造器和逐一成员构造器。如果你把定制的构造器写在值类型的原始实现中，规则将不再适用。</p>\n<p>下面的例子定义了一个用于描述几何矩形的结构体 Rect。这个例子同时定义了两个辅助结构体 Size 和 Point，它们都把 0.0 作为所有属性的默认值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Size</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> width = <span class=\"number\">0.0</span>, height = <span class=\"number\">0.0</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">0.0</span>, y = <span class=\"number\">0.0</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Rect</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> origin = <span class=\"type\">Point</span>()</div><div class=\"line\">    <span class=\"keyword\">var</span> size = <span class=\"type\">Size</span>()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>因为结构体 Rect 未提供定制的构造器，因此它会获得一个逐一成员构造器。又因为它为所有存储型属性提供了默认值，它又会获得一个默认构造器。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> defaultRect = <span class=\"type\">Rect</span>()</div><div class=\"line\"><span class=\"keyword\">let</span> memberwiseRect = <span class=\"type\">Rect</span>(origin: <span class=\"type\">Point</span>(x: <span class=\"number\">2.0</span>, y: <span class=\"number\">2.0</span>),</div><div class=\"line\">                          size: <span class=\"type\">Size</span>(width: <span class=\"number\">5.0</span>, height: <span class=\"number\">5.0</span>))</div></pre></td></tr></table></figure>\n<p>你可以提供一个额外的接受指定中心点和大小的构造器来扩展 Rect 结构体：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Rect</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">init</span>(center: <span class=\"type\">Point</span>, size: <span class=\"type\">Size</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> originX = center.x - (size.width / <span class=\"number\">2</span>)</div><div class=\"line\">        <span class=\"keyword\">let</span> originY = center.y - (size.height / <span class=\"number\">2</span>)</div><div class=\"line\">        <span class=\"keyword\">self</span>.<span class=\"keyword\">init</span>(origin: <span class=\"type\">Point</span>(x: originX, y: originY), size: size)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个新的构造器首先根据提供的 center 和 size 的值计算一个合适的原点。然后调用该结构体的逐一成员构造器 init(origin:size:)，该构造器将新的原点和大小的值保存到了相应的属性中：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> centerRect = <span class=\"type\">Rect</span>(center: <span class=\"type\">Point</span>(x: <span class=\"number\">4.0</span>, y: <span class=\"number\">4.0</span>),</div><div class=\"line\">                      size: <span class=\"type\">Size</span>(width: <span class=\"number\">3.0</span>, height: <span class=\"number\">3.0</span>))</div><div class=\"line\"><span class=\"comment\">// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)</span></div></pre></td></tr></table></figure>\n<pre><code>如果你使用扩展提供了一个新的构造器，你依旧有责任确保构造过程能够让实例完全初始化。\n</code></pre><h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><p>扩展可以为已有类型添加新的实例方法和类型方法。<br>下面的例子为 Int 类型添加了一个名为 repetitions 的实例方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Int</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">repetitions</span><span class=\"params\">(task: <span class=\"params\">()</span></span></span> -&gt; <span class=\"type\">Void</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;<span class=\"keyword\">self</span> &#123;</div><div class=\"line\">            task()</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个 repetitions(task:) 方法接受一个 () -&gt; Void 类型的单参数，表示没有参数且没有返回值的函数。<br>定义该扩展之后，你就可以对任意整数调用 repetitions(task:) 方法，将闭包中的任务执行整数对应的次数：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">3</span>.repetitions &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Hello!\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Hello!</span></div><div class=\"line\"><span class=\"comment\">// Hello!</span></div><div class=\"line\"><span class=\"comment\">// Hello!</span></div></pre></td></tr></table></figure>\n<h4 id=\"可变实例方法\"><a href=\"#可变实例方法\" class=\"headerlink\" title=\"可变实例方法\"></a>可变实例方法</h4><p>通过扩展添加的实例方法也可以修改该实例本身。结构体和枚举类型中修改 self 或其属性的方法必须将该实例方法标注为 <code>mutating</code>，正如来自原始实现的可变方法一样。<br>下面的例子为 Swift 的 Int 类型添加了一个名为 square 的可变方法，用于计算原始值的平方值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Int</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">square</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span> = <span class=\"keyword\">self</span> * <span class=\"keyword\">self</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> someInt = <span class=\"number\">3</span></div><div class=\"line\">someInt.square()</div><div class=\"line\"><span class=\"comment\">// someInt is now 9</span></div></pre></td></tr></table></figure>\n<h3 id=\"下标\"><a href=\"#下标\" class=\"headerlink\" title=\"下标\"></a>下标</h3><p>扩展可以为已有类型添加新下标。<br>这个例子为 Swift 内建类型 Int 添加了一个整型下标。该下标 [n] 返回十进制数字从右向左数的第 n 个数字：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Int</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">subscript</span>(digitIndex: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> decimalBase = <span class=\"number\">1</span></div><div class=\"line\">        <span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;digitIndex &#123;</div><div class=\"line\">            decimalBase *= <span class=\"number\">10</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">self</span> / decimalBase) % <span class=\"number\">10</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"number\">746381295</span>[<span class=\"number\">0</span>]</div><div class=\"line\"><span class=\"comment\">// returns 5</span></div><div class=\"line\"><span class=\"number\">746381295</span>[<span class=\"number\">1</span>]</div><div class=\"line\"><span class=\"comment\">// returns 9</span></div><div class=\"line\"><span class=\"number\">746381295</span>[<span class=\"number\">2</span>]</div><div class=\"line\"><span class=\"comment\">// returns 2</span></div><div class=\"line\"><span class=\"number\">746381295</span>[<span class=\"number\">8</span>]</div><div class=\"line\"><span class=\"comment\">// returns 7</span></div></pre></td></tr></table></figure>\n<p>如果该 Int 值没有足够的位数，即下标越界，那么上述下标实现会返回 0，犹如在数字左边自动补 0：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"number\">746381295</span>[<span class=\"number\">9</span>]</div><div class=\"line\"><span class=\"comment\">// returns 0, as if you had requested:</span></div><div class=\"line\"><span class=\"number\">0746381295</span>[<span class=\"number\">9</span>]</div></pre></td></tr></table></figure>\n<h3 id=\"嵌套类型\"><a href=\"#嵌套类型\" class=\"headerlink\" title=\"嵌套类型\"></a>嵌套类型</h3><p>扩展可以为已有的类、结构体和枚举添加新的嵌套类型：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Int</span> </span>&#123;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Kind</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> negative, zero, positive</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> kind: <span class=\"type\">Kind</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> <span class=\"keyword\">self</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</div><div class=\"line\">            <span class=\"keyword\">return</span> .zero</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> x <span class=\"keyword\">where</span> x &gt; <span class=\"number\">0</span>:</div><div class=\"line\">            <span class=\"keyword\">return</span> .positive</div><div class=\"line\">        <span class=\"keyword\">default</span>:</div><div class=\"line\">            <span class=\"keyword\">return</span> .negative</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>该例子为 Int 添加了嵌套枚举。这个名为 Kind 的枚举表示特定整数的类型。具体来说，就是表示整数是正数、零或者负数。<br>这个例子还为 Int 添加了一个计算型实例属性，即 kind，用来根据整数返回适当的 Kind 枚举成员。<br>现在，这个嵌套枚举可以和任意 Int 值一起使用了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printIntegerKinds</span><span class=\"params\">(<span class=\"number\">_</span> numbers: [Int])</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> number <span class=\"keyword\">in</span> numbers &#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> number.kind &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> .negative:</div><div class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">\"- \"</span>, terminator: <span class=\"string\">\"\"</span>)</div><div class=\"line\">        <span class=\"keyword\">case</span> .zero:</div><div class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">\"0 \"</span>, terminator: <span class=\"string\">\"\"</span>)</div><div class=\"line\">        <span class=\"keyword\">case</span> .positive:</div><div class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">\"+ \"</span>, terminator: <span class=\"string\">\"\"</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\">printIntegerKinds([<span class=\"number\">3</span>, <span class=\"number\">19</span>, -<span class=\"number\">27</span>, <span class=\"number\">0</span>, -<span class=\"number\">6</span>, <span class=\"number\">0</span>, <span class=\"number\">7</span>])</div><div class=\"line\"><span class=\"comment\">// Prints \"+ + - 0 - 0 + \"</span></div></pre></td></tr></table></figure>\n<p>函数 printIntegerKinds(_:) 接受一个 Int 数组，然后对该数组进行迭代。在每次迭代过程中，对当前整数的计算型属性 kind 的值进行评估，并打印出适当的描述。<br>    由于已知 number.kind 是 Int.Kind 类型，因此在 switch 语句中，Int.Kind 中的所有成员值都可以使用简写形式，例如使用 . Negative 而不是 Int.Kind.Negative。</p>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/NestedTypes.html/\" target=\"_blank\" rel=\"external\"> NestedTypes </a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>"},{"layout":"post","title":"Swift Functions","date":"2016-11-19T16:20:11.000Z","author":"liangtong","catalog":true,"_content":"\n\n\n​\t函数是执行特定功能的独立代码块，可以通过函数名字调用函数执行其功能。Swift的函数统一语法可以很灵活地表达任何东西，无论是没有参数的C风格函数还是拥有多个名字和参数的ObjC风格函数。参数可以提供默认值以简化函数调用、当参数变量需要改变的时候，参数也可以作为输入输出(`in-out`)参数.\n在Swift中，每个函数都有一个类型，包括参数类型和返回值类型。你可以像Swift中其他任何一个类型一样使用函数，这使得将函数作为函数参数、作为函数返回值变得非常简单。函数也可以写在其他函数内部以限制其作用域（内部函数）。\n\n\n\n### 函数的声明和调用\n当定义函数的时候，可以选择性的定义一个或多个名字，定义一些输入类型值作为参数，也可以选择性的定义一类值作为输出类型。每一个函数都有一个名字，用来表明函数的功能，可以通过调用该函数的名字来使用函数，并且通过传递输入值（参数）来匹配函数的参数，调用函数时，输入参数类型必须和函数声明时类型的参数类型顺序一致。\n\n函数以关键字`func`开头，返回值类型紧跟符号`->`。说了这么多，还是直接看例子，函数名字为：`greet(person:)`参数和返回值是String类型，定义及调用如下：\n\n\n<!-- more -->\n\n\n```Swift\nfunc greet(person: String) -> String {\n    let greeting = \"Hello, \" + person + \"!\"\n    return greeting\n}\n\nprint(greet(person: \"Anna\"))\n// Prints \"Hello, Anna!\"\nprint(greet(person: \"Brian\"))\n// Prints \"Hello, Brian!\"\n```\n\n### 函数的参数和返回值\nSwift中函数的参数和返回值比较灵活，无论是一个只有一个未命名参数的简单函数，还是包含不同类型参数的复杂函数，你可以随意定义。\n\n#### 无参函数\n函数参数是非必需的，例如：\n\n```Swift\nfunc sayHelloWorld() -> String {\n    return \"hello, world\"\n}\nprint(sayHelloWorld())\n// Prints \"hello, world\"\n```\n\n#### 多参函数\n函数可以有多个输入参数，这些参数写在函数的括号内，用逗号隔开。例如：\n\n```Swift\nfunc greet(person: String, alreadyGreeted: Bool) -> String {\n    if alreadyGreeted {\n        return greetAgain(person: person)\n    } else {\n        return greet(person: person)\n    }\n}\nprint(greet(person: \"Tim\", alreadyGreeted: true))\n// Prints \"Hello again, Tim!\"\n```\n\n#### 无返回值函数\n函数也不需要定义返回值类型，当没有返回值的时候，返回箭头（ - >）和返回类型可以省略。例如：\n\n```Swift\nfunc greet(person: String) {\n    print(\"Hello, \\(person)!\")\n}\ngreet(person: \"Dave\")\n// Prints \"Hello, Dave!\"\n```\n\n > * 严格的说，即使没有定义返回值，函数仍然会返回一个void类型的特殊值，他是一个简单的空的元组，可以写为()。\n\n再调用函数时，其返回值可以被忽略，例如：\n\n```Swift\nfunc printAndCount(string: String) -> Int {\n    print(string)\n    return string.characters.count\n}\nfunc printWithoutCounting(string: String) {\n    let _ = printAndCount(string: string)\n}\nprintAndCount(string: \"hello, world\")\n// prints \"hello, world\" and returns a value of 12\nprintWithoutCounting(string: \"hello, world\")\n// prints \"hello, world\" but does not return a value\n```\n\n#### 多返回值函数\n可以使用元组作为函数的返回值来一次返回多个值。例如：\n\n```Swift\nfunc minMax(array: [Int]) -> (min: Int, max: Int) {\n    var currentMin = array[0]\n    var currentMax = array[0]\n    for value in array[1..<array.count] {\n        if value < currentMin {\n            currentMin = value\n        } else if value > currentMax {\n            currentMax = value\n        }\n    }\n    return (currentMin, currentMax)\n}\n```\n\n由于元组成员的类型是函数的返回值，可以通过如下方式使用，例如：\n\n```Swift\nlet bounds = minMax(array: [8, -6, 2, 109, 3, 71])\nprint(\"min is \\(bounds.min) and max is \\(bounds.max)\")\n// Prints \"min is -6 and max is 109\"\n```\n\n### 可选的元组返回类型\n如果一个函数的返回的元组是可选的，就可以使用一个可选的元组返回类型，例如：`(Int, Int)? `。\n\n```Swift\nfunc minMax(array: [Int]) -> (min: Int, max: Int)? {\n    if array.isEmpty { return nil }\n    var currentMin = array[0]\n    var currentMax = array[0]\n    for value in array[1..<array.count] {\n        if value < currentMin {\n            currentMin = value\n        } else if value > currentMax {\n            currentMax = value\n        }\n    }\n    return (currentMin, currentMax)\n}\n\nif let bounds = minMax(array: [8, -6, 2, 109, 3, 71]) {\n    print(\"min is \\(bounds.min) and max is \\(bounds.max)\")\n}\n// Prints \"min is -6 and max is 109\"\n```\n\n>* 注：可选元组类型(Int, Int)? 和包含可选值的元组(Int?, Int?)不同，对于可选的元组类型，这个元组是可选的，而不是元组中的某个组成元素可选。\n\n### 函数的参数标签和参数名\n每个函数参数都包含一个标签名和一个参数名称，标签名在函数被调用的时候使用；函数中的每一个参数前都有一个标签名，参数名在函数体内使用，默认情况下，函数参数使用它们的参数名作为标签名。所有的参数名必须唯一，尽管参数的标签名可以不唯一，但唯一的标签名可以提高代码的易读性。\n\n```Swift\nfunc someFunction(firstParameterName: Int, secondParameterName: Int) {\n    // In the function body, firstParameterName and secondParameterName\n    // refer to the argument values for the first and second parameters.\n}\nsomeFunction(firstParameterName: 1, secondParameterName: 2)\n```\n\n#### 明确的参数标签\n在参数名前写一个参数标签，用空格隔开，来明确参数标签，格式如下：\n\n```Swift\nfunc someFunction(argumentLabel parameterName: Int) {\n    // In the function body, parameterName refers to the argument value\n    // for that parameter.\n}\n\n```\n\n以下是一个使用明确标签名的例子：\n\n```Swift\nfunc greet(person: String, from hometown: String) -> String {\n    return \"Hello \\(person)!  Glad you could visit from \\(hometown).\"\n}\nprint(greet(person: \"Bill\", from: \"Cupertino\"))\n// Prints \"Hello Bill!  Glad you could visit from Cupertino.\"\n```\n\n#### 省略的参数标签\n如果不需要参数标签，可以使用下划线(_)来代替参数标签。如果参数前有标签的话，函数调用的时候就必须使用标签。\n\n```Swift\nfunc someFunction(parameterWithoutDefault: Int, parameterWithDefault: Int = 12) {\n    // If you omit the second argument when calling this function, then\n    // the value of parameterWithDefault is 12 inside the function body.\n}\nsomeFunction(parameterWithoutDefault: 3, parameterWithDefault: 6) // parameterWithDefault is 6\nsomeFunction(parameterWithoutDefault: 4) // parameterWithDefault is 12\n```\n\n#### 默认的参数值\n可以为任何参数设定默认值来作为函数的定义的一部分。如果默认值已经定义，调用函数时就可以省略该参数的传值。将使用默认值的参数放在函数列表的末尾，在函数中，没有默认值的参数通常有重要的意义。例如\n\n```Swift\nfunc someFunction(_ firstParameterName: Int, secondParameterName: Int) {\n    // In the function body, firstParameterName and secondParameterName\n    // refer to the argument values for the first and second parameters.\n}\nsomeFunction(1, secondParameterName: 2)\n```\n\n#### 可变参数\n一个可变参数的参数接受零个或多个指定类型的值。当函数被调用时，您可以使用一个可变参数的参数来指定该参数可以传递不同数量的输入值。写可变参数的参数时，需要参数的类型名称后加上点字符（...）。传递一个可变参数的参数的值时，函数体中是以提供适当类型的数组的形式存在。例如\n\n```Swift\nfunc arithmeticMean(_ numbers: Double...) -> Double {\n    var total: Double = 0\n    for number in numbers {\n        total += number\n    }\n    return total / Double(numbers.count)\n}\narithmeticMean(1, 2, 3, 4, 5)\n// returns 3.0, which is the arithmetic mean of these five numbers\narithmeticMean(3, 8.25, 18.75)\n// returns 10.0, which is the arithmetic mean of these three numbers\n```\n\n > * 一个函数最多只有一个可变参数。\n\n#### 输入-输出参数\n默认情况下，函数的参数是常量（只读）形式，在函数方法体内修改参数会导致编译错误。如果想在函数体内修改参数，则需要将参数类型设置为`in-out`来代替。通过在参数类型前添加关键字`inout`来表明输入-输出参数。一个在输入-输出参数都有一个传递给函数的值，由函数修改后，并从函数返回来替换原来的值。\n\n > * 输入输出参数类型必须是变量，不能有默认值。不能说常量，不能是可变参数。当你把一个变量传给输入输出参数时，在变量前添加一个连接符&，表明它在函数体内可以修改\n\n例如：\n\n```Swift\nfunc swapTwoInts(_ a: inout Int, _ b: inout Int) {\n    let temporaryA = a\n    a = b\n    b = temporaryA\n}\n```\n\n调用的时候，注意添加前缀符号&，例如：\n\n```Swift\nvar someInt = 3\nvar anotherInt = 107\nswapTwoInts(&someInt, &anotherInt)\nprint(\"someInt is now \\(someInt), and anotherInt is now \\(anotherInt)\")\n// Prints \"someInt is now 107, and anotherInt is now 3\"\n```\n\n### 函数类型\n每一个函数都有一个特定的函数类型，由参数类型和返回值类型。例如，以下例子中的函数类型是：(Int, Int)->Int\n\n```Swift\nfunc addTwoInts(_ a: Int, _ b: Int) -> Int {\n    return a + b\n}\nfunc multiplyTwoInts(_ a: Int, _ b: Int) -> Int {\n    return a * b\n}\n```\n\n#### 使用函数类型\n在Swift中可以像其他类型一样使用函数类型，例如可以定义一个函数类型的常量或者变量和调用该变量：\n\n```Swift\nvar mathFunction: (Int, Int) -> Int = addTwoInts\n\nprint(\"Result: \\(mathFunction(2, 3))\")\n// Prints \"Result: 5\"\n}\n```\n\n#### 函数类型的参数\n可以使用函数类型（例如：(Int, Int)->Int）作为另一个函数的参数类型，例如：\n\n```Swift\nfunc printMathResult(_ mathFunction: (Int, Int) -> Int, _ a: Int, _ b: Int) {\n    print(\"Result: \\(mathFunction(a, b))\")\n}\nprintMathResult(addTwoInts, 3, 5)\n// Prints \"Result: 8\"\n```\n\n#### 函数类型的返回值\n可以使用函数类型作为一个函数的返回值。例如：\n\n```Swift\nfunc stepForward(_ input: Int) -> Int {\n    return input + 1\n}\nfunc stepBackward(_ input: Int) -> Int {\n    return input - 1\n}\n```\n\n函数类型的返回值\n\n```Swift\nfunc chooseStepFunction(backward: Bool) -> (Int) -> Int {\n    return backward ? stepBackward : stepForward\n}\n```\n\n使用\n\n```Swift\nvar currentValue = 3\nlet moveNearerToZero = chooseStepFunction(backward: currentValue > 0)\n// moveNearerToZero now refers to the stepBackward() function\n```\n\n### 嵌套函数\n\n嵌套函数是定义在函数内的函数，对外是隐藏的，但是可以调用和使用其内部的函数。例如\n\n```Swift\nfunc chooseStepFunction(backward: Bool) -> (Int) -> Int {\n    func stepForward(input: Int) -> Int { return input + 1 }\n    func stepBackward(input: Int) -> Int { return input - 1 }\n    return backward ? stepBackward : stepForward\n}\nvar currentValue = -4\nlet moveNearerToZero = chooseStepFunction(backward: currentValue > 0)\n// moveNearerToZero now refers to the nested stepForward() function\nwhile currentValue != 0 {\n    print(\"\\(currentValue)... \")\n    currentValue = moveNearerToZero(currentValue)\n}\nprint(\"zero!\")\n// -4...\n// -3...\n// -2...\n// -1...\n// zero!\n```\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html/\">Functions</a> \n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","source":"_posts/iOS_Swift_language_note_Functions.md","raw":"---\nlayout:     post\ntitle:      Swift Functions\ndate:       2016-11-20 00:20:11\nauthor:     liangtong\ncatalog: true\ncategories: iOS\ntags: Swift \n\n---\n\n\n\n​\t函数是执行特定功能的独立代码块，可以通过函数名字调用函数执行其功能。Swift的函数统一语法可以很灵活地表达任何东西，无论是没有参数的C风格函数还是拥有多个名字和参数的ObjC风格函数。参数可以提供默认值以简化函数调用、当参数变量需要改变的时候，参数也可以作为输入输出(`in-out`)参数.\n在Swift中，每个函数都有一个类型，包括参数类型和返回值类型。你可以像Swift中其他任何一个类型一样使用函数，这使得将函数作为函数参数、作为函数返回值变得非常简单。函数也可以写在其他函数内部以限制其作用域（内部函数）。\n\n\n\n### 函数的声明和调用\n当定义函数的时候，可以选择性的定义一个或多个名字，定义一些输入类型值作为参数，也可以选择性的定义一类值作为输出类型。每一个函数都有一个名字，用来表明函数的功能，可以通过调用该函数的名字来使用函数，并且通过传递输入值（参数）来匹配函数的参数，调用函数时，输入参数类型必须和函数声明时类型的参数类型顺序一致。\n\n函数以关键字`func`开头，返回值类型紧跟符号`->`。说了这么多，还是直接看例子，函数名字为：`greet(person:)`参数和返回值是String类型，定义及调用如下：\n\n\n<!-- more -->\n\n\n```Swift\nfunc greet(person: String) -> String {\n    let greeting = \"Hello, \" + person + \"!\"\n    return greeting\n}\n\nprint(greet(person: \"Anna\"))\n// Prints \"Hello, Anna!\"\nprint(greet(person: \"Brian\"))\n// Prints \"Hello, Brian!\"\n```\n\n### 函数的参数和返回值\nSwift中函数的参数和返回值比较灵活，无论是一个只有一个未命名参数的简单函数，还是包含不同类型参数的复杂函数，你可以随意定义。\n\n#### 无参函数\n函数参数是非必需的，例如：\n\n```Swift\nfunc sayHelloWorld() -> String {\n    return \"hello, world\"\n}\nprint(sayHelloWorld())\n// Prints \"hello, world\"\n```\n\n#### 多参函数\n函数可以有多个输入参数，这些参数写在函数的括号内，用逗号隔开。例如：\n\n```Swift\nfunc greet(person: String, alreadyGreeted: Bool) -> String {\n    if alreadyGreeted {\n        return greetAgain(person: person)\n    } else {\n        return greet(person: person)\n    }\n}\nprint(greet(person: \"Tim\", alreadyGreeted: true))\n// Prints \"Hello again, Tim!\"\n```\n\n#### 无返回值函数\n函数也不需要定义返回值类型，当没有返回值的时候，返回箭头（ - >）和返回类型可以省略。例如：\n\n```Swift\nfunc greet(person: String) {\n    print(\"Hello, \\(person)!\")\n}\ngreet(person: \"Dave\")\n// Prints \"Hello, Dave!\"\n```\n\n > * 严格的说，即使没有定义返回值，函数仍然会返回一个void类型的特殊值，他是一个简单的空的元组，可以写为()。\n\n再调用函数时，其返回值可以被忽略，例如：\n\n```Swift\nfunc printAndCount(string: String) -> Int {\n    print(string)\n    return string.characters.count\n}\nfunc printWithoutCounting(string: String) {\n    let _ = printAndCount(string: string)\n}\nprintAndCount(string: \"hello, world\")\n// prints \"hello, world\" and returns a value of 12\nprintWithoutCounting(string: \"hello, world\")\n// prints \"hello, world\" but does not return a value\n```\n\n#### 多返回值函数\n可以使用元组作为函数的返回值来一次返回多个值。例如：\n\n```Swift\nfunc minMax(array: [Int]) -> (min: Int, max: Int) {\n    var currentMin = array[0]\n    var currentMax = array[0]\n    for value in array[1..<array.count] {\n        if value < currentMin {\n            currentMin = value\n        } else if value > currentMax {\n            currentMax = value\n        }\n    }\n    return (currentMin, currentMax)\n}\n```\n\n由于元组成员的类型是函数的返回值，可以通过如下方式使用，例如：\n\n```Swift\nlet bounds = minMax(array: [8, -6, 2, 109, 3, 71])\nprint(\"min is \\(bounds.min) and max is \\(bounds.max)\")\n// Prints \"min is -6 and max is 109\"\n```\n\n### 可选的元组返回类型\n如果一个函数的返回的元组是可选的，就可以使用一个可选的元组返回类型，例如：`(Int, Int)? `。\n\n```Swift\nfunc minMax(array: [Int]) -> (min: Int, max: Int)? {\n    if array.isEmpty { return nil }\n    var currentMin = array[0]\n    var currentMax = array[0]\n    for value in array[1..<array.count] {\n        if value < currentMin {\n            currentMin = value\n        } else if value > currentMax {\n            currentMax = value\n        }\n    }\n    return (currentMin, currentMax)\n}\n\nif let bounds = minMax(array: [8, -6, 2, 109, 3, 71]) {\n    print(\"min is \\(bounds.min) and max is \\(bounds.max)\")\n}\n// Prints \"min is -6 and max is 109\"\n```\n\n>* 注：可选元组类型(Int, Int)? 和包含可选值的元组(Int?, Int?)不同，对于可选的元组类型，这个元组是可选的，而不是元组中的某个组成元素可选。\n\n### 函数的参数标签和参数名\n每个函数参数都包含一个标签名和一个参数名称，标签名在函数被调用的时候使用；函数中的每一个参数前都有一个标签名，参数名在函数体内使用，默认情况下，函数参数使用它们的参数名作为标签名。所有的参数名必须唯一，尽管参数的标签名可以不唯一，但唯一的标签名可以提高代码的易读性。\n\n```Swift\nfunc someFunction(firstParameterName: Int, secondParameterName: Int) {\n    // In the function body, firstParameterName and secondParameterName\n    // refer to the argument values for the first and second parameters.\n}\nsomeFunction(firstParameterName: 1, secondParameterName: 2)\n```\n\n#### 明确的参数标签\n在参数名前写一个参数标签，用空格隔开，来明确参数标签，格式如下：\n\n```Swift\nfunc someFunction(argumentLabel parameterName: Int) {\n    // In the function body, parameterName refers to the argument value\n    // for that parameter.\n}\n\n```\n\n以下是一个使用明确标签名的例子：\n\n```Swift\nfunc greet(person: String, from hometown: String) -> String {\n    return \"Hello \\(person)!  Glad you could visit from \\(hometown).\"\n}\nprint(greet(person: \"Bill\", from: \"Cupertino\"))\n// Prints \"Hello Bill!  Glad you could visit from Cupertino.\"\n```\n\n#### 省略的参数标签\n如果不需要参数标签，可以使用下划线(_)来代替参数标签。如果参数前有标签的话，函数调用的时候就必须使用标签。\n\n```Swift\nfunc someFunction(parameterWithoutDefault: Int, parameterWithDefault: Int = 12) {\n    // If you omit the second argument when calling this function, then\n    // the value of parameterWithDefault is 12 inside the function body.\n}\nsomeFunction(parameterWithoutDefault: 3, parameterWithDefault: 6) // parameterWithDefault is 6\nsomeFunction(parameterWithoutDefault: 4) // parameterWithDefault is 12\n```\n\n#### 默认的参数值\n可以为任何参数设定默认值来作为函数的定义的一部分。如果默认值已经定义，调用函数时就可以省略该参数的传值。将使用默认值的参数放在函数列表的末尾，在函数中，没有默认值的参数通常有重要的意义。例如\n\n```Swift\nfunc someFunction(_ firstParameterName: Int, secondParameterName: Int) {\n    // In the function body, firstParameterName and secondParameterName\n    // refer to the argument values for the first and second parameters.\n}\nsomeFunction(1, secondParameterName: 2)\n```\n\n#### 可变参数\n一个可变参数的参数接受零个或多个指定类型的值。当函数被调用时，您可以使用一个可变参数的参数来指定该参数可以传递不同数量的输入值。写可变参数的参数时，需要参数的类型名称后加上点字符（...）。传递一个可变参数的参数的值时，函数体中是以提供适当类型的数组的形式存在。例如\n\n```Swift\nfunc arithmeticMean(_ numbers: Double...) -> Double {\n    var total: Double = 0\n    for number in numbers {\n        total += number\n    }\n    return total / Double(numbers.count)\n}\narithmeticMean(1, 2, 3, 4, 5)\n// returns 3.0, which is the arithmetic mean of these five numbers\narithmeticMean(3, 8.25, 18.75)\n// returns 10.0, which is the arithmetic mean of these three numbers\n```\n\n > * 一个函数最多只有一个可变参数。\n\n#### 输入-输出参数\n默认情况下，函数的参数是常量（只读）形式，在函数方法体内修改参数会导致编译错误。如果想在函数体内修改参数，则需要将参数类型设置为`in-out`来代替。通过在参数类型前添加关键字`inout`来表明输入-输出参数。一个在输入-输出参数都有一个传递给函数的值，由函数修改后，并从函数返回来替换原来的值。\n\n > * 输入输出参数类型必须是变量，不能有默认值。不能说常量，不能是可变参数。当你把一个变量传给输入输出参数时，在变量前添加一个连接符&，表明它在函数体内可以修改\n\n例如：\n\n```Swift\nfunc swapTwoInts(_ a: inout Int, _ b: inout Int) {\n    let temporaryA = a\n    a = b\n    b = temporaryA\n}\n```\n\n调用的时候，注意添加前缀符号&，例如：\n\n```Swift\nvar someInt = 3\nvar anotherInt = 107\nswapTwoInts(&someInt, &anotherInt)\nprint(\"someInt is now \\(someInt), and anotherInt is now \\(anotherInt)\")\n// Prints \"someInt is now 107, and anotherInt is now 3\"\n```\n\n### 函数类型\n每一个函数都有一个特定的函数类型，由参数类型和返回值类型。例如，以下例子中的函数类型是：(Int, Int)->Int\n\n```Swift\nfunc addTwoInts(_ a: Int, _ b: Int) -> Int {\n    return a + b\n}\nfunc multiplyTwoInts(_ a: Int, _ b: Int) -> Int {\n    return a * b\n}\n```\n\n#### 使用函数类型\n在Swift中可以像其他类型一样使用函数类型，例如可以定义一个函数类型的常量或者变量和调用该变量：\n\n```Swift\nvar mathFunction: (Int, Int) -> Int = addTwoInts\n\nprint(\"Result: \\(mathFunction(2, 3))\")\n// Prints \"Result: 5\"\n}\n```\n\n#### 函数类型的参数\n可以使用函数类型（例如：(Int, Int)->Int）作为另一个函数的参数类型，例如：\n\n```Swift\nfunc printMathResult(_ mathFunction: (Int, Int) -> Int, _ a: Int, _ b: Int) {\n    print(\"Result: \\(mathFunction(a, b))\")\n}\nprintMathResult(addTwoInts, 3, 5)\n// Prints \"Result: 8\"\n```\n\n#### 函数类型的返回值\n可以使用函数类型作为一个函数的返回值。例如：\n\n```Swift\nfunc stepForward(_ input: Int) -> Int {\n    return input + 1\n}\nfunc stepBackward(_ input: Int) -> Int {\n    return input - 1\n}\n```\n\n函数类型的返回值\n\n```Swift\nfunc chooseStepFunction(backward: Bool) -> (Int) -> Int {\n    return backward ? stepBackward : stepForward\n}\n```\n\n使用\n\n```Swift\nvar currentValue = 3\nlet moveNearerToZero = chooseStepFunction(backward: currentValue > 0)\n// moveNearerToZero now refers to the stepBackward() function\n```\n\n### 嵌套函数\n\n嵌套函数是定义在函数内的函数，对外是隐藏的，但是可以调用和使用其内部的函数。例如\n\n```Swift\nfunc chooseStepFunction(backward: Bool) -> (Int) -> Int {\n    func stepForward(input: Int) -> Int { return input + 1 }\n    func stepBackward(input: Int) -> Int { return input - 1 }\n    return backward ? stepBackward : stepForward\n}\nvar currentValue = -4\nlet moveNearerToZero = chooseStepFunction(backward: currentValue > 0)\n// moveNearerToZero now refers to the nested stepForward() function\nwhile currentValue != 0 {\n    print(\"\\(currentValue)... \")\n    currentValue = moveNearerToZero(currentValue)\n}\nprint(\"zero!\")\n// -4...\n// -3...\n// -2...\n// -1...\n// zero!\n```\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html/\">Functions</a> \n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","slug":"iOS_Swift_language_note_Functions","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4uc0031oko8hhs79kg9","content":"<p>​    函数是执行特定功能的独立代码块，可以通过函数名字调用函数执行其功能。Swift的函数统一语法可以很灵活地表达任何东西，无论是没有参数的C风格函数还是拥有多个名字和参数的ObjC风格函数。参数可以提供默认值以简化函数调用、当参数变量需要改变的时候，参数也可以作为输入输出(<code>in-out</code>)参数.<br>在Swift中，每个函数都有一个类型，包括参数类型和返回值类型。你可以像Swift中其他任何一个类型一样使用函数，这使得将函数作为函数参数、作为函数返回值变得非常简单。函数也可以写在其他函数内部以限制其作用域（内部函数）。</p>\n<h3 id=\"函数的声明和调用\"><a href=\"#函数的声明和调用\" class=\"headerlink\" title=\"函数的声明和调用\"></a>函数的声明和调用</h3><p>当定义函数的时候，可以选择性的定义一个或多个名字，定义一些输入类型值作为参数，也可以选择性的定义一类值作为输出类型。每一个函数都有一个名字，用来表明函数的功能，可以通过调用该函数的名字来使用函数，并且通过传递输入值（参数）来匹配函数的参数，调用函数时，输入参数类型必须和函数声明时类型的参数类型顺序一致。</p>\n<p>函数以关键字<code>func</code>开头，返回值类型紧跟符号<code>-&gt;</code>。说了这么多，还是直接看例子，函数名字为：<code>greet(person:)</code>参数和返回值是String类型，定义及调用如下：</p>\n<a id=\"more\"></a>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">greet</span><span class=\"params\">(person: String)</span></span> -&gt; <span class=\"type\">String</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> greeting = <span class=\"string\">\"Hello, \"</span> + person + <span class=\"string\">\"!\"</span></div><div class=\"line\">    <span class=\"keyword\">return</span> greeting</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">print</span>(greet(person: <span class=\"string\">\"Anna\"</span>))</div><div class=\"line\"><span class=\"comment\">// Prints \"Hello, Anna!\"</span></div><div class=\"line\"><span class=\"built_in\">print</span>(greet(person: <span class=\"string\">\"Brian\"</span>))</div><div class=\"line\"><span class=\"comment\">// Prints \"Hello, Brian!\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"函数的参数和返回值\"><a href=\"#函数的参数和返回值\" class=\"headerlink\" title=\"函数的参数和返回值\"></a>函数的参数和返回值</h3><p>Swift中函数的参数和返回值比较灵活，无论是一个只有一个未命名参数的简单函数，还是包含不同类型参数的复杂函数，你可以随意定义。</p>\n<h4 id=\"无参函数\"><a href=\"#无参函数\" class=\"headerlink\" title=\"无参函数\"></a>无参函数</h4><p>函数参数是非必需的，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sayHelloWorld</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">String</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"hello, world\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">print</span>(sayHelloWorld())</div><div class=\"line\"><span class=\"comment\">// Prints \"hello, world\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"多参函数\"><a href=\"#多参函数\" class=\"headerlink\" title=\"多参函数\"></a>多参函数</h4><p>函数可以有多个输入参数，这些参数写在函数的括号内，用逗号隔开。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">greet</span><span class=\"params\">(person: String, alreadyGreeted: Bool)</span></span> -&gt; <span class=\"type\">String</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> alreadyGreeted &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> greetAgain(person: person)</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> greet(person: person)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">print</span>(greet(person: <span class=\"string\">\"Tim\"</span>, alreadyGreeted: <span class=\"literal\">true</span>))</div><div class=\"line\"><span class=\"comment\">// Prints \"Hello again, Tim!\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"无返回值函数\"><a href=\"#无返回值函数\" class=\"headerlink\" title=\"无返回值函数\"></a>无返回值函数</h4><p>函数也不需要定义返回值类型，当没有返回值的时候，返回箭头（ - &gt;）和返回类型可以省略。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">greet</span><span class=\"params\">(person: String)</span></span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Hello, <span class=\"subst\">\\(person)</span>!\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\">greet(person: <span class=\"string\">\"Dave\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"Hello, Dave!\"</span></div></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>严格的说，即使没有定义返回值，函数仍然会返回一个void类型的特殊值，他是一个简单的空的元组，可以写为()。</li>\n</ul>\n</blockquote>\n<p>再调用函数时，其返回值可以被忽略，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printAndCount</span><span class=\"params\">(string: String)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(string)</div><div class=\"line\">    <span class=\"keyword\">return</span> string.characters.<span class=\"built_in\">count</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printWithoutCounting</span><span class=\"params\">(string: String)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> <span class=\"number\">_</span> = printAndCount(string: string)</div><div class=\"line\">&#125;</div><div class=\"line\">printAndCount(string: <span class=\"string\">\"hello, world\"</span>)</div><div class=\"line\"><span class=\"comment\">// prints \"hello, world\" and returns a value of 12</span></div><div class=\"line\">printWithoutCounting(string: <span class=\"string\">\"hello, world\"</span>)</div><div class=\"line\"><span class=\"comment\">// prints \"hello, world\" but does not return a value</span></div></pre></td></tr></table></figure>\n<h4 id=\"多返回值函数\"><a href=\"#多返回值函数\" class=\"headerlink\" title=\"多返回值函数\"></a>多返回值函数</h4><p>可以使用元组作为函数的返回值来一次返回多个值。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">minMax</span><span class=\"params\">(array: [Int])</span></span> -&gt; (<span class=\"built_in\">min</span>: <span class=\"type\">Int</span>, <span class=\"built_in\">max</span>: <span class=\"type\">Int</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> currentMin = array[<span class=\"number\">0</span>]</div><div class=\"line\">    <span class=\"keyword\">var</span> currentMax = array[<span class=\"number\">0</span>]</div><div class=\"line\">    <span class=\"keyword\">for</span> value <span class=\"keyword\">in</span> array[<span class=\"number\">1</span>..&lt;array.<span class=\"built_in\">count</span>] &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> value &lt; currentMin &#123;</div><div class=\"line\">            currentMin = value</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> value &gt; currentMax &#123;</div><div class=\"line\">            currentMax = value</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> (currentMin, currentMax)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于元组成员的类型是函数的返回值，可以通过如下方式使用，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> bounds = minMax(array: [<span class=\"number\">8</span>, -<span class=\"number\">6</span>, <span class=\"number\">2</span>, <span class=\"number\">109</span>, <span class=\"number\">3</span>, <span class=\"number\">71</span>])</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"min is <span class=\"subst\">\\(bounds.<span class=\"built_in\">min</span>)</span> and max is <span class=\"subst\">\\(bounds.<span class=\"built_in\">max</span>)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"min is -6 and max is 109\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"可选的元组返回类型\"><a href=\"#可选的元组返回类型\" class=\"headerlink\" title=\"可选的元组返回类型\"></a>可选的元组返回类型</h3><p>如果一个函数的返回的元组是可选的，就可以使用一个可选的元组返回类型，例如：<code>(Int, Int)?</code>。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">minMax</span><span class=\"params\">(array: [Int])</span></span> -&gt; (<span class=\"built_in\">min</span>: <span class=\"type\">Int</span>, <span class=\"built_in\">max</span>: <span class=\"type\">Int</span>)? &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> array.isEmpty &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> currentMin = array[<span class=\"number\">0</span>]</div><div class=\"line\">    <span class=\"keyword\">var</span> currentMax = array[<span class=\"number\">0</span>]</div><div class=\"line\">    <span class=\"keyword\">for</span> value <span class=\"keyword\">in</span> array[<span class=\"number\">1</span>..&lt;array.<span class=\"built_in\">count</span>] &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> value &lt; currentMin &#123;</div><div class=\"line\">            currentMin = value</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> value &gt; currentMax &#123;</div><div class=\"line\">            currentMax = value</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> (currentMin, currentMax)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> bounds = minMax(array: [<span class=\"number\">8</span>, -<span class=\"number\">6</span>, <span class=\"number\">2</span>, <span class=\"number\">109</span>, <span class=\"number\">3</span>, <span class=\"number\">71</span>]) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"min is <span class=\"subst\">\\(bounds.<span class=\"built_in\">min</span>)</span> and max is <span class=\"subst\">\\(bounds.<span class=\"built_in\">max</span>)</span>\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"min is -6 and max is 109\"</span></div></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>注：可选元组类型(Int, Int)? 和包含可选值的元组(Int?, Int?)不同，对于可选的元组类型，这个元组是可选的，而不是元组中的某个组成元素可选。</li>\n</ul>\n</blockquote>\n<h3 id=\"函数的参数标签和参数名\"><a href=\"#函数的参数标签和参数名\" class=\"headerlink\" title=\"函数的参数标签和参数名\"></a>函数的参数标签和参数名</h3><p>每个函数参数都包含一个标签名和一个参数名称，标签名在函数被调用的时候使用；函数中的每一个参数前都有一个标签名，参数名在函数体内使用，默认情况下，函数参数使用它们的参数名作为标签名。所有的参数名必须唯一，尽管参数的标签名可以不唯一，但唯一的标签名可以提高代码的易读性。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someFunction</span><span class=\"params\">(firstParameterName: Int, secondParameterName: Int)</span></span> &#123;</div><div class=\"line\">    <span class=\"comment\">// In the function body, firstParameterName and secondParameterName</span></div><div class=\"line\">    <span class=\"comment\">// refer to the argument values for the first and second parameters.</span></div><div class=\"line\">&#125;</div><div class=\"line\">someFunction(firstParameterName: <span class=\"number\">1</span>, secondParameterName: <span class=\"number\">2</span>)</div></pre></td></tr></table></figure>\n<h4 id=\"明确的参数标签\"><a href=\"#明确的参数标签\" class=\"headerlink\" title=\"明确的参数标签\"></a>明确的参数标签</h4><p>在参数名前写一个参数标签，用空格隔开，来明确参数标签，格式如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someFunction</span><span class=\"params\">(argumentLabel parameterName: Int)</span></span> &#123;</div><div class=\"line\">    <span class=\"comment\">// In the function body, parameterName refers to the argument value</span></div><div class=\"line\">    <span class=\"comment\">// for that parameter.</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以下是一个使用明确标签名的例子：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">greet</span><span class=\"params\">(person: String, from hometown: String)</span></span> -&gt; <span class=\"type\">String</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Hello <span class=\"subst\">\\(person)</span>!  Glad you could visit from <span class=\"subst\">\\(hometown)</span>.\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">print</span>(greet(person: <span class=\"string\">\"Bill\"</span>, from: <span class=\"string\">\"Cupertino\"</span>))</div><div class=\"line\"><span class=\"comment\">// Prints \"Hello Bill!  Glad you could visit from Cupertino.\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"省略的参数标签\"><a href=\"#省略的参数标签\" class=\"headerlink\" title=\"省略的参数标签\"></a>省略的参数标签</h4><p>如果不需要参数标签，可以使用下划线(_)来代替参数标签。如果参数前有标签的话，函数调用的时候就必须使用标签。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someFunction</span><span class=\"params\">(parameterWithoutDefault: Int, parameterWithDefault: Int = <span class=\"number\">12</span>)</span></span> &#123;</div><div class=\"line\">    <span class=\"comment\">// If you omit the second argument when calling this function, then</span></div><div class=\"line\">    <span class=\"comment\">// the value of parameterWithDefault is 12 inside the function body.</span></div><div class=\"line\">&#125;</div><div class=\"line\">someFunction(parameterWithoutDefault: <span class=\"number\">3</span>, parameterWithDefault: <span class=\"number\">6</span>) <span class=\"comment\">// parameterWithDefault is 6</span></div><div class=\"line\">someFunction(parameterWithoutDefault: <span class=\"number\">4</span>) <span class=\"comment\">// parameterWithDefault is 12</span></div></pre></td></tr></table></figure>\n<h4 id=\"默认的参数值\"><a href=\"#默认的参数值\" class=\"headerlink\" title=\"默认的参数值\"></a>默认的参数值</h4><p>可以为任何参数设定默认值来作为函数的定义的一部分。如果默认值已经定义，调用函数时就可以省略该参数的传值。将使用默认值的参数放在函数列表的末尾，在函数中，没有默认值的参数通常有重要的意义。例如</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someFunction</span><span class=\"params\">(<span class=\"number\">_</span> firstParameterName: Int, secondParameterName: Int)</span></span> &#123;</div><div class=\"line\">    <span class=\"comment\">// In the function body, firstParameterName and secondParameterName</span></div><div class=\"line\">    <span class=\"comment\">// refer to the argument values for the first and second parameters.</span></div><div class=\"line\">&#125;</div><div class=\"line\">someFunction(<span class=\"number\">1</span>, secondParameterName: <span class=\"number\">2</span>)</div></pre></td></tr></table></figure>\n<h4 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"可变参数\"></a>可变参数</h4><p>一个可变参数的参数接受零个或多个指定类型的值。当函数被调用时，您可以使用一个可变参数的参数来指定该参数可以传递不同数量的输入值。写可变参数的参数时，需要参数的类型名称后加上点字符（…）。传递一个可变参数的参数的值时，函数体中是以提供适当类型的数组的形式存在。例如</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">arithmeticMean</span><span class=\"params\">(<span class=\"number\">_</span> numbers: Double...)</span></span> -&gt; <span class=\"type\">Double</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> total: <span class=\"type\">Double</span> = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">for</span> number <span class=\"keyword\">in</span> numbers &#123;</div><div class=\"line\">        total += number</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> total / <span class=\"type\">Double</span>(numbers.<span class=\"built_in\">count</span>)</div><div class=\"line\">&#125;</div><div class=\"line\">arithmeticMean(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</div><div class=\"line\"><span class=\"comment\">// returns 3.0, which is the arithmetic mean of these five numbers</span></div><div class=\"line\">arithmeticMean(<span class=\"number\">3</span>, <span class=\"number\">8.25</span>, <span class=\"number\">18.75</span>)</div><div class=\"line\"><span class=\"comment\">// returns 10.0, which is the arithmetic mean of these three numbers</span></div></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>一个函数最多只有一个可变参数。</li>\n</ul>\n</blockquote>\n<h4 id=\"输入-输出参数\"><a href=\"#输入-输出参数\" class=\"headerlink\" title=\"输入-输出参数\"></a>输入-输出参数</h4><p>默认情况下，函数的参数是常量（只读）形式，在函数方法体内修改参数会导致编译错误。如果想在函数体内修改参数，则需要将参数类型设置为<code>in-out</code>来代替。通过在参数类型前添加关键字<code>inout</code>来表明输入-输出参数。一个在输入-输出参数都有一个传递给函数的值，由函数修改后，并从函数返回来替换原来的值。</p>\n<blockquote>\n<ul>\n<li>输入输出参数类型必须是变量，不能有默认值。不能说常量，不能是可变参数。当你把一个变量传给输入输出参数时，在变量前添加一个连接符&amp;，表明它在函数体内可以修改</li>\n</ul>\n</blockquote>\n<p>例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">swapTwoInts</span><span class=\"params\">(<span class=\"number\">_</span> a: <span class=\"keyword\">inout</span> Int, <span class=\"number\">_</span> b: <span class=\"keyword\">inout</span> Int)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> temporaryA = a</div><div class=\"line\">    a = b</div><div class=\"line\">    b = temporaryA</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用的时候，注意添加前缀符号&amp;，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> someInt = <span class=\"number\">3</span></div><div class=\"line\"><span class=\"keyword\">var</span> anotherInt = <span class=\"number\">107</span></div><div class=\"line\">swapTwoInts(&amp;someInt, &amp;anotherInt)</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"someInt is now <span class=\"subst\">\\(someInt)</span>, and anotherInt is now <span class=\"subst\">\\(anotherInt)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"someInt is now 107, and anotherInt is now 3\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"函数类型\"><a href=\"#函数类型\" class=\"headerlink\" title=\"函数类型\"></a>函数类型</h3><p>每一个函数都有一个特定的函数类型，由参数类型和返回值类型。例如，以下例子中的函数类型是：(Int, Int)-&gt;Int</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addTwoInts</span><span class=\"params\">(<span class=\"number\">_</span> a: Int, <span class=\"number\">_</span> b: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a + b</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">multiplyTwoInts</span><span class=\"params\">(<span class=\"number\">_</span> a: Int, <span class=\"number\">_</span> b: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a * b</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"使用函数类型\"><a href=\"#使用函数类型\" class=\"headerlink\" title=\"使用函数类型\"></a>使用函数类型</h4><p>在Swift中可以像其他类型一样使用函数类型，例如可以定义一个函数类型的常量或者变量和调用该变量：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mathFunction: (<span class=\"type\">Int</span>, <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> = addTwoInts</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Result: <span class=\"subst\">\\(mathFunction(<span class=\"number\">2</span>, <span class=\"number\">3</span>)</span>)\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"Result: 5\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"函数类型的参数\"><a href=\"#函数类型的参数\" class=\"headerlink\" title=\"函数类型的参数\"></a>函数类型的参数</h4><p>可以使用函数类型（例如：(Int, Int)-&gt;Int）作为另一个函数的参数类型，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printMathResult</span><span class=\"params\">(<span class=\"number\">_</span> mathFunction: <span class=\"params\">(Int, Int)</span></span></span> -&gt; <span class=\"type\">Int</span>, <span class=\"number\">_</span> a: <span class=\"type\">Int</span>, <span class=\"number\">_</span> b: <span class=\"type\">Int</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Result: <span class=\"subst\">\\(mathFunction(a, b)</span>)\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\">printMathResult(addTwoInts, <span class=\"number\">3</span>, <span class=\"number\">5</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"Result: 8\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"函数类型的返回值\"><a href=\"#函数类型的返回值\" class=\"headerlink\" title=\"函数类型的返回值\"></a>函数类型的返回值</h4><p>可以使用函数类型作为一个函数的返回值。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">stepForward</span><span class=\"params\">(<span class=\"number\">_</span> input: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> input + <span class=\"number\">1</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">stepBackward</span><span class=\"params\">(<span class=\"number\">_</span> input: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> input - <span class=\"number\">1</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>函数类型的返回值</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">chooseStepFunction</span><span class=\"params\">(backward: Bool)</span></span> -&gt; (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> backward ? stepBackward : stepForward</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> currentValue = <span class=\"number\">3</span></div><div class=\"line\"><span class=\"keyword\">let</span> moveNearerToZero = chooseStepFunction(backward: currentValue &gt; <span class=\"number\">0</span>)</div><div class=\"line\"><span class=\"comment\">// moveNearerToZero now refers to the stepBackward() function</span></div></pre></td></tr></table></figure>\n<h3 id=\"嵌套函数\"><a href=\"#嵌套函数\" class=\"headerlink\" title=\"嵌套函数\"></a>嵌套函数</h3><p>嵌套函数是定义在函数内的函数，对外是隐藏的，但是可以调用和使用其内部的函数。例如</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">chooseStepFunction</span><span class=\"params\">(backward: Bool)</span></span> -&gt; (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">stepForward</span><span class=\"params\">(input: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123; <span class=\"keyword\">return</span> input + <span class=\"number\">1</span> &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">stepBackward</span><span class=\"params\">(input: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123; <span class=\"keyword\">return</span> input - <span class=\"number\">1</span> &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> backward ? stepBackward : stepForward</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> currentValue = -<span class=\"number\">4</span></div><div class=\"line\"><span class=\"keyword\">let</span> moveNearerToZero = chooseStepFunction(backward: currentValue &gt; <span class=\"number\">0</span>)</div><div class=\"line\"><span class=\"comment\">// moveNearerToZero now refers to the nested stepForward() function</span></div><div class=\"line\"><span class=\"keyword\">while</span> currentValue != <span class=\"number\">0</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(currentValue)</span>... \"</span>)</div><div class=\"line\">    currentValue = moveNearerToZero(currentValue)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"zero!\"</span>)</div><div class=\"line\"><span class=\"comment\">// -4...</span></div><div class=\"line\"><span class=\"comment\">// -3...</span></div><div class=\"line\"><span class=\"comment\">// -2...</span></div><div class=\"line\"><span class=\"comment\">// -1...</span></div><div class=\"line\"><span class=\"comment\">// zero!</span></div></pre></td></tr></table></figure>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html/\" target=\"_blank\" rel=\"external\">Functions</a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>​    函数是执行特定功能的独立代码块，可以通过函数名字调用函数执行其功能。Swift的函数统一语法可以很灵活地表达任何东西，无论是没有参数的C风格函数还是拥有多个名字和参数的ObjC风格函数。参数可以提供默认值以简化函数调用、当参数变量需要改变的时候，参数也可以作为输入输出(<code>in-out</code>)参数.<br>在Swift中，每个函数都有一个类型，包括参数类型和返回值类型。你可以像Swift中其他任何一个类型一样使用函数，这使得将函数作为函数参数、作为函数返回值变得非常简单。函数也可以写在其他函数内部以限制其作用域（内部函数）。</p>\n<h3 id=\"函数的声明和调用\"><a href=\"#函数的声明和调用\" class=\"headerlink\" title=\"函数的声明和调用\"></a>函数的声明和调用</h3><p>当定义函数的时候，可以选择性的定义一个或多个名字，定义一些输入类型值作为参数，也可以选择性的定义一类值作为输出类型。每一个函数都有一个名字，用来表明函数的功能，可以通过调用该函数的名字来使用函数，并且通过传递输入值（参数）来匹配函数的参数，调用函数时，输入参数类型必须和函数声明时类型的参数类型顺序一致。</p>\n<p>函数以关键字<code>func</code>开头，返回值类型紧跟符号<code>-&gt;</code>。说了这么多，还是直接看例子，函数名字为：<code>greet(person:)</code>参数和返回值是String类型，定义及调用如下：</p>","more":"<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">greet</span><span class=\"params\">(person: String)</span></span> -&gt; <span class=\"type\">String</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> greeting = <span class=\"string\">\"Hello, \"</span> + person + <span class=\"string\">\"!\"</span></div><div class=\"line\">    <span class=\"keyword\">return</span> greeting</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">print</span>(greet(person: <span class=\"string\">\"Anna\"</span>))</div><div class=\"line\"><span class=\"comment\">// Prints \"Hello, Anna!\"</span></div><div class=\"line\"><span class=\"built_in\">print</span>(greet(person: <span class=\"string\">\"Brian\"</span>))</div><div class=\"line\"><span class=\"comment\">// Prints \"Hello, Brian!\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"函数的参数和返回值\"><a href=\"#函数的参数和返回值\" class=\"headerlink\" title=\"函数的参数和返回值\"></a>函数的参数和返回值</h3><p>Swift中函数的参数和返回值比较灵活，无论是一个只有一个未命名参数的简单函数，还是包含不同类型参数的复杂函数，你可以随意定义。</p>\n<h4 id=\"无参函数\"><a href=\"#无参函数\" class=\"headerlink\" title=\"无参函数\"></a>无参函数</h4><p>函数参数是非必需的，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sayHelloWorld</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">String</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"hello, world\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">print</span>(sayHelloWorld())</div><div class=\"line\"><span class=\"comment\">// Prints \"hello, world\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"多参函数\"><a href=\"#多参函数\" class=\"headerlink\" title=\"多参函数\"></a>多参函数</h4><p>函数可以有多个输入参数，这些参数写在函数的括号内，用逗号隔开。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">greet</span><span class=\"params\">(person: String, alreadyGreeted: Bool)</span></span> -&gt; <span class=\"type\">String</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> alreadyGreeted &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> greetAgain(person: person)</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> greet(person: person)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">print</span>(greet(person: <span class=\"string\">\"Tim\"</span>, alreadyGreeted: <span class=\"literal\">true</span>))</div><div class=\"line\"><span class=\"comment\">// Prints \"Hello again, Tim!\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"无返回值函数\"><a href=\"#无返回值函数\" class=\"headerlink\" title=\"无返回值函数\"></a>无返回值函数</h4><p>函数也不需要定义返回值类型，当没有返回值的时候，返回箭头（ - &gt;）和返回类型可以省略。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">greet</span><span class=\"params\">(person: String)</span></span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Hello, <span class=\"subst\">\\(person)</span>!\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\">greet(person: <span class=\"string\">\"Dave\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"Hello, Dave!\"</span></div></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>严格的说，即使没有定义返回值，函数仍然会返回一个void类型的特殊值，他是一个简单的空的元组，可以写为()。</li>\n</ul>\n</blockquote>\n<p>再调用函数时，其返回值可以被忽略，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printAndCount</span><span class=\"params\">(string: String)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(string)</div><div class=\"line\">    <span class=\"keyword\">return</span> string.characters.<span class=\"built_in\">count</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printWithoutCounting</span><span class=\"params\">(string: String)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> <span class=\"number\">_</span> = printAndCount(string: string)</div><div class=\"line\">&#125;</div><div class=\"line\">printAndCount(string: <span class=\"string\">\"hello, world\"</span>)</div><div class=\"line\"><span class=\"comment\">// prints \"hello, world\" and returns a value of 12</span></div><div class=\"line\">printWithoutCounting(string: <span class=\"string\">\"hello, world\"</span>)</div><div class=\"line\"><span class=\"comment\">// prints \"hello, world\" but does not return a value</span></div></pre></td></tr></table></figure>\n<h4 id=\"多返回值函数\"><a href=\"#多返回值函数\" class=\"headerlink\" title=\"多返回值函数\"></a>多返回值函数</h4><p>可以使用元组作为函数的返回值来一次返回多个值。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">minMax</span><span class=\"params\">(array: [Int])</span></span> -&gt; (<span class=\"built_in\">min</span>: <span class=\"type\">Int</span>, <span class=\"built_in\">max</span>: <span class=\"type\">Int</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> currentMin = array[<span class=\"number\">0</span>]</div><div class=\"line\">    <span class=\"keyword\">var</span> currentMax = array[<span class=\"number\">0</span>]</div><div class=\"line\">    <span class=\"keyword\">for</span> value <span class=\"keyword\">in</span> array[<span class=\"number\">1</span>..&lt;array.<span class=\"built_in\">count</span>] &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> value &lt; currentMin &#123;</div><div class=\"line\">            currentMin = value</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> value &gt; currentMax &#123;</div><div class=\"line\">            currentMax = value</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> (currentMin, currentMax)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于元组成员的类型是函数的返回值，可以通过如下方式使用，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> bounds = minMax(array: [<span class=\"number\">8</span>, -<span class=\"number\">6</span>, <span class=\"number\">2</span>, <span class=\"number\">109</span>, <span class=\"number\">3</span>, <span class=\"number\">71</span>])</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"min is <span class=\"subst\">\\(bounds.<span class=\"built_in\">min</span>)</span> and max is <span class=\"subst\">\\(bounds.<span class=\"built_in\">max</span>)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"min is -6 and max is 109\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"可选的元组返回类型\"><a href=\"#可选的元组返回类型\" class=\"headerlink\" title=\"可选的元组返回类型\"></a>可选的元组返回类型</h3><p>如果一个函数的返回的元组是可选的，就可以使用一个可选的元组返回类型，例如：<code>(Int, Int)?</code>。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">minMax</span><span class=\"params\">(array: [Int])</span></span> -&gt; (<span class=\"built_in\">min</span>: <span class=\"type\">Int</span>, <span class=\"built_in\">max</span>: <span class=\"type\">Int</span>)? &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> array.isEmpty &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> currentMin = array[<span class=\"number\">0</span>]</div><div class=\"line\">    <span class=\"keyword\">var</span> currentMax = array[<span class=\"number\">0</span>]</div><div class=\"line\">    <span class=\"keyword\">for</span> value <span class=\"keyword\">in</span> array[<span class=\"number\">1</span>..&lt;array.<span class=\"built_in\">count</span>] &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> value &lt; currentMin &#123;</div><div class=\"line\">            currentMin = value</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> value &gt; currentMax &#123;</div><div class=\"line\">            currentMax = value</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> (currentMin, currentMax)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> bounds = minMax(array: [<span class=\"number\">8</span>, -<span class=\"number\">6</span>, <span class=\"number\">2</span>, <span class=\"number\">109</span>, <span class=\"number\">3</span>, <span class=\"number\">71</span>]) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"min is <span class=\"subst\">\\(bounds.<span class=\"built_in\">min</span>)</span> and max is <span class=\"subst\">\\(bounds.<span class=\"built_in\">max</span>)</span>\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"min is -6 and max is 109\"</span></div></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>注：可选元组类型(Int, Int)? 和包含可选值的元组(Int?, Int?)不同，对于可选的元组类型，这个元组是可选的，而不是元组中的某个组成元素可选。</li>\n</ul>\n</blockquote>\n<h3 id=\"函数的参数标签和参数名\"><a href=\"#函数的参数标签和参数名\" class=\"headerlink\" title=\"函数的参数标签和参数名\"></a>函数的参数标签和参数名</h3><p>每个函数参数都包含一个标签名和一个参数名称，标签名在函数被调用的时候使用；函数中的每一个参数前都有一个标签名，参数名在函数体内使用，默认情况下，函数参数使用它们的参数名作为标签名。所有的参数名必须唯一，尽管参数的标签名可以不唯一，但唯一的标签名可以提高代码的易读性。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someFunction</span><span class=\"params\">(firstParameterName: Int, secondParameterName: Int)</span></span> &#123;</div><div class=\"line\">    <span class=\"comment\">// In the function body, firstParameterName and secondParameterName</span></div><div class=\"line\">    <span class=\"comment\">// refer to the argument values for the first and second parameters.</span></div><div class=\"line\">&#125;</div><div class=\"line\">someFunction(firstParameterName: <span class=\"number\">1</span>, secondParameterName: <span class=\"number\">2</span>)</div></pre></td></tr></table></figure>\n<h4 id=\"明确的参数标签\"><a href=\"#明确的参数标签\" class=\"headerlink\" title=\"明确的参数标签\"></a>明确的参数标签</h4><p>在参数名前写一个参数标签，用空格隔开，来明确参数标签，格式如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someFunction</span><span class=\"params\">(argumentLabel parameterName: Int)</span></span> &#123;</div><div class=\"line\">    <span class=\"comment\">// In the function body, parameterName refers to the argument value</span></div><div class=\"line\">    <span class=\"comment\">// for that parameter.</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以下是一个使用明确标签名的例子：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">greet</span><span class=\"params\">(person: String, from hometown: String)</span></span> -&gt; <span class=\"type\">String</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Hello <span class=\"subst\">\\(person)</span>!  Glad you could visit from <span class=\"subst\">\\(hometown)</span>.\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">print</span>(greet(person: <span class=\"string\">\"Bill\"</span>, from: <span class=\"string\">\"Cupertino\"</span>))</div><div class=\"line\"><span class=\"comment\">// Prints \"Hello Bill!  Glad you could visit from Cupertino.\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"省略的参数标签\"><a href=\"#省略的参数标签\" class=\"headerlink\" title=\"省略的参数标签\"></a>省略的参数标签</h4><p>如果不需要参数标签，可以使用下划线(_)来代替参数标签。如果参数前有标签的话，函数调用的时候就必须使用标签。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someFunction</span><span class=\"params\">(parameterWithoutDefault: Int, parameterWithDefault: Int = <span class=\"number\">12</span>)</span></span> &#123;</div><div class=\"line\">    <span class=\"comment\">// If you omit the second argument when calling this function, then</span></div><div class=\"line\">    <span class=\"comment\">// the value of parameterWithDefault is 12 inside the function body.</span></div><div class=\"line\">&#125;</div><div class=\"line\">someFunction(parameterWithoutDefault: <span class=\"number\">3</span>, parameterWithDefault: <span class=\"number\">6</span>) <span class=\"comment\">// parameterWithDefault is 6</span></div><div class=\"line\">someFunction(parameterWithoutDefault: <span class=\"number\">4</span>) <span class=\"comment\">// parameterWithDefault is 12</span></div></pre></td></tr></table></figure>\n<h4 id=\"默认的参数值\"><a href=\"#默认的参数值\" class=\"headerlink\" title=\"默认的参数值\"></a>默认的参数值</h4><p>可以为任何参数设定默认值来作为函数的定义的一部分。如果默认值已经定义，调用函数时就可以省略该参数的传值。将使用默认值的参数放在函数列表的末尾，在函数中，没有默认值的参数通常有重要的意义。例如</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someFunction</span><span class=\"params\">(<span class=\"number\">_</span> firstParameterName: Int, secondParameterName: Int)</span></span> &#123;</div><div class=\"line\">    <span class=\"comment\">// In the function body, firstParameterName and secondParameterName</span></div><div class=\"line\">    <span class=\"comment\">// refer to the argument values for the first and second parameters.</span></div><div class=\"line\">&#125;</div><div class=\"line\">someFunction(<span class=\"number\">1</span>, secondParameterName: <span class=\"number\">2</span>)</div></pre></td></tr></table></figure>\n<h4 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"可变参数\"></a>可变参数</h4><p>一个可变参数的参数接受零个或多个指定类型的值。当函数被调用时，您可以使用一个可变参数的参数来指定该参数可以传递不同数量的输入值。写可变参数的参数时，需要参数的类型名称后加上点字符（…）。传递一个可变参数的参数的值时，函数体中是以提供适当类型的数组的形式存在。例如</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">arithmeticMean</span><span class=\"params\">(<span class=\"number\">_</span> numbers: Double...)</span></span> -&gt; <span class=\"type\">Double</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> total: <span class=\"type\">Double</span> = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">for</span> number <span class=\"keyword\">in</span> numbers &#123;</div><div class=\"line\">        total += number</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> total / <span class=\"type\">Double</span>(numbers.<span class=\"built_in\">count</span>)</div><div class=\"line\">&#125;</div><div class=\"line\">arithmeticMean(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</div><div class=\"line\"><span class=\"comment\">// returns 3.0, which is the arithmetic mean of these five numbers</span></div><div class=\"line\">arithmeticMean(<span class=\"number\">3</span>, <span class=\"number\">8.25</span>, <span class=\"number\">18.75</span>)</div><div class=\"line\"><span class=\"comment\">// returns 10.0, which is the arithmetic mean of these three numbers</span></div></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>一个函数最多只有一个可变参数。</li>\n</ul>\n</blockquote>\n<h4 id=\"输入-输出参数\"><a href=\"#输入-输出参数\" class=\"headerlink\" title=\"输入-输出参数\"></a>输入-输出参数</h4><p>默认情况下，函数的参数是常量（只读）形式，在函数方法体内修改参数会导致编译错误。如果想在函数体内修改参数，则需要将参数类型设置为<code>in-out</code>来代替。通过在参数类型前添加关键字<code>inout</code>来表明输入-输出参数。一个在输入-输出参数都有一个传递给函数的值，由函数修改后，并从函数返回来替换原来的值。</p>\n<blockquote>\n<ul>\n<li>输入输出参数类型必须是变量，不能有默认值。不能说常量，不能是可变参数。当你把一个变量传给输入输出参数时，在变量前添加一个连接符&amp;，表明它在函数体内可以修改</li>\n</ul>\n</blockquote>\n<p>例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">swapTwoInts</span><span class=\"params\">(<span class=\"number\">_</span> a: <span class=\"keyword\">inout</span> Int, <span class=\"number\">_</span> b: <span class=\"keyword\">inout</span> Int)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> temporaryA = a</div><div class=\"line\">    a = b</div><div class=\"line\">    b = temporaryA</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>调用的时候，注意添加前缀符号&amp;，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> someInt = <span class=\"number\">3</span></div><div class=\"line\"><span class=\"keyword\">var</span> anotherInt = <span class=\"number\">107</span></div><div class=\"line\">swapTwoInts(&amp;someInt, &amp;anotherInt)</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"someInt is now <span class=\"subst\">\\(someInt)</span>, and anotherInt is now <span class=\"subst\">\\(anotherInt)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"someInt is now 107, and anotherInt is now 3\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"函数类型\"><a href=\"#函数类型\" class=\"headerlink\" title=\"函数类型\"></a>函数类型</h3><p>每一个函数都有一个特定的函数类型，由参数类型和返回值类型。例如，以下例子中的函数类型是：(Int, Int)-&gt;Int</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addTwoInts</span><span class=\"params\">(<span class=\"number\">_</span> a: Int, <span class=\"number\">_</span> b: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a + b</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">multiplyTwoInts</span><span class=\"params\">(<span class=\"number\">_</span> a: Int, <span class=\"number\">_</span> b: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a * b</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"使用函数类型\"><a href=\"#使用函数类型\" class=\"headerlink\" title=\"使用函数类型\"></a>使用函数类型</h4><p>在Swift中可以像其他类型一样使用函数类型，例如可以定义一个函数类型的常量或者变量和调用该变量：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> mathFunction: (<span class=\"type\">Int</span>, <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> = addTwoInts</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Result: <span class=\"subst\">\\(mathFunction(<span class=\"number\">2</span>, <span class=\"number\">3</span>)</span>)\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"Result: 5\"</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"函数类型的参数\"><a href=\"#函数类型的参数\" class=\"headerlink\" title=\"函数类型的参数\"></a>函数类型的参数</h4><p>可以使用函数类型（例如：(Int, Int)-&gt;Int）作为另一个函数的参数类型，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printMathResult</span><span class=\"params\">(<span class=\"number\">_</span> mathFunction: <span class=\"params\">(Int, Int)</span></span></span> -&gt; <span class=\"type\">Int</span>, <span class=\"number\">_</span> a: <span class=\"type\">Int</span>, <span class=\"number\">_</span> b: <span class=\"type\">Int</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Result: <span class=\"subst\">\\(mathFunction(a, b)</span>)\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\">printMathResult(addTwoInts, <span class=\"number\">3</span>, <span class=\"number\">5</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"Result: 8\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"函数类型的返回值\"><a href=\"#函数类型的返回值\" class=\"headerlink\" title=\"函数类型的返回值\"></a>函数类型的返回值</h4><p>可以使用函数类型作为一个函数的返回值。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">stepForward</span><span class=\"params\">(<span class=\"number\">_</span> input: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> input + <span class=\"number\">1</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">stepBackward</span><span class=\"params\">(<span class=\"number\">_</span> input: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> input - <span class=\"number\">1</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>函数类型的返回值</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">chooseStepFunction</span><span class=\"params\">(backward: Bool)</span></span> -&gt; (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> backward ? stepBackward : stepForward</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> currentValue = <span class=\"number\">3</span></div><div class=\"line\"><span class=\"keyword\">let</span> moveNearerToZero = chooseStepFunction(backward: currentValue &gt; <span class=\"number\">0</span>)</div><div class=\"line\"><span class=\"comment\">// moveNearerToZero now refers to the stepBackward() function</span></div></pre></td></tr></table></figure>\n<h3 id=\"嵌套函数\"><a href=\"#嵌套函数\" class=\"headerlink\" title=\"嵌套函数\"></a>嵌套函数</h3><p>嵌套函数是定义在函数内的函数，对外是隐藏的，但是可以调用和使用其内部的函数。例如</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">chooseStepFunction</span><span class=\"params\">(backward: Bool)</span></span> -&gt; (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">stepForward</span><span class=\"params\">(input: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123; <span class=\"keyword\">return</span> input + <span class=\"number\">1</span> &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">stepBackward</span><span class=\"params\">(input: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123; <span class=\"keyword\">return</span> input - <span class=\"number\">1</span> &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> backward ? stepBackward : stepForward</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> currentValue = -<span class=\"number\">4</span></div><div class=\"line\"><span class=\"keyword\">let</span> moveNearerToZero = chooseStepFunction(backward: currentValue &gt; <span class=\"number\">0</span>)</div><div class=\"line\"><span class=\"comment\">// moveNearerToZero now refers to the nested stepForward() function</span></div><div class=\"line\"><span class=\"keyword\">while</span> currentValue != <span class=\"number\">0</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(currentValue)</span>... \"</span>)</div><div class=\"line\">    currentValue = moveNearerToZero(currentValue)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"zero!\"</span>)</div><div class=\"line\"><span class=\"comment\">// -4...</span></div><div class=\"line\"><span class=\"comment\">// -3...</span></div><div class=\"line\"><span class=\"comment\">// -2...</span></div><div class=\"line\"><span class=\"comment\">// -1...</span></div><div class=\"line\"><span class=\"comment\">// zero!</span></div></pre></td></tr></table></figure>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html/\" target=\"_blank\" rel=\"external\">Functions</a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>"},{"layout":"post","title":"Swift Generics","date":"2016-12-02T11:20:11.000Z","author":"liangtong","catalog":true,"_content":"\n\n​\t\n​\t泛型代码让你编写出适用于任意类型、灵活可重用的函数及类型。它能让你避免代码的重复，用一种清晰和抽象的方式来表达代码的意图。 \n\n\n\n### 泛型所解决的问题\n下面是一个标准的非泛型函数 swapTwoInts(_:_:)，用来交换两个 Int 值：\n\n```Swift\nfunc swapTwoInts(_ a: inout Int, _ b: inout Int) {\n    let temporaryA = a\n    a = b\n    b = temporaryA\n}\n```\n\n<!-- more -->\n\nswapTwoInts(_:_:) 函数交换 b 的原始值到 a，并交换 a 的原始值到 b。你可以调用这个函数交换两个 Int 变量的值：\n\n```Swift\nvar someInt = 3\nvar anotherInt = 107\nswapTwoInts(&someInt, &anotherInt)\nprint(\"someInt is now \\(someInt), and anotherInt is now \\(anotherInt)\")\n// Prints \"someInt is now 107, and anotherInt is now 3\"\n```\n\nswapTwoInts(_:_:) 函数挺有用，但是它只能交换 Int 值，如果你想要交换两个 String 值或者 Double值，就不得不写更多的函数，例如 swapTwoStrings(_:_:) 和 swapTwoDoubles(_:_:)，如下所示：\n\n```Swift\nfunc swapTwoStrings(_ a: inout String, _ b: inout String) {\n    let temporaryA = a\n    a = b\n    b = temporaryA\n}\n \nfunc swapTwoDoubles(_ a: inout Double, _ b: inout Double) {\n    let temporaryA = a\n    a = b\n    b = temporaryA\n}\n```\n\nswapTwoInts(_:_:)、swapTwoStrings(_:_:) 和 swapTwoDoubles(_:_:) 的函数功能都是相同的，唯一不同之处就在于传入的变量类型不同，分别是 Int、String 和 Double。\n\n### 泛型函数\n泛型函数可以适用于任何类型，下面的 swapTwoValues(_:_:) 函数是上面三个函数的泛型版本：\n\n```Swift\nfunc swapTwoValues<T>(_ a: inout T, _ b: inout T) {\n    let temporaryA = a\n    a = b\n    b = temporaryA\n}\n```\n\nswapTwoValues(_:_:) 的函数主体和 swapTwoInts(_:_:) 函数是一样的，它们只在第一行有点不同：\n这个函数的泛型版本使用了占位类型名（在这里用字母 T 来表示）来代替实际类型名（例如 Int、String 或 Double）。占位类型名没有指明 T 必须是什么类型，但是它指明了 a 和 b 必须是同一类型 T，无论 T 代表什么类型。只有 swapTwoValues(_:_:) 函数在调用时，才能根据所传入的实际类型决定 T 所代表的类型。\n另外一个不同之处在于这个泛型函数名（swapTwoValues(_:_:)）后面跟着占位类型名（T），并用尖括号括起来（<T>）。这个尖括号告诉 Swift 那个 T 是 swapTwoValues(_:_:) 函数定义内的一个占位类型名，因此 Swift 不会去查找名为 T 的实际类型。\n\n```Swift\nvar someInt = 3\nvar anotherInt = 107\nswapTwoValues(&someInt, &anotherInt)\n// someInt is now 107, and anotherInt is now 3\n \nvar someString = \"hello\"\nvar anotherString = \"world\"\nswapTwoValues(&someString, &anotherString)\n// someString is now \"world\", and anotherString is now \"hello\"\n```\n\n### 类型参数\n类型参数指定并命名一个占位类型，并且紧随在函数名后面，使用一对尖括号括起来（例如 <T>）。\n一旦一个类型参数被指定，你可以用它来定义一个函数的参数类型（例如 swapTwoValues(_:_:) 函数中的参数 a 和 b），或者作为函数的返回类型，还可以用作函数主体中的注释类型。在这些情况下，类型参数会在函数调用时被实际类型所替换。（在上面的 swapTwoValues(_:_:) 例子中，当函数第一次被调用时，T 被 Int 替换，第二次调用时，被 String 替换。）\n你可提供多个类型参数，将它们都写在尖括号中，用逗号分开。\n\n\n### 命名类型参数\n在大多数情况下，类型参数具有一个描述性名字，例如 Dictionary<Key, Value> 中的 Key 和 Value，以及 Array<Element> 中的 Element，这可以告诉阅读代码的人这些类型参数和泛型函数之间的关系。然而，当它们之间没有有意义的关系时，通常使用单个字母来命名，例如 T、U、V，正如上面演示的 swapTwoValues(_:_:) 函数中的 T 一样。\n\t请始终使用大写字母开头的驼峰命名法（例如 T 和 MyTypeParameter）来为类型参数命名，以表明它们是占位类型，而不是一个值。\n\n\n### 泛型类型\n除了泛型函数，Swift 还允许你定义泛型类型。这些自定义类、结构体和枚举可以适用于任何类型，类似于 Array 和 Dictionary。\n\n这部分内容将向你展示如何编写一个名为 Stack （栈）的泛型集合类型。栈是一系列值的有序集合，和 Array 类似，但它相比 Swift 的 Array 类型有更多的操作限制。数组允许在数组的任意位置插入新元素或是删除其中任意位置的元素。而栈只允许在集合的末端添加新的元素（称之为入栈）。类似的，栈也只能从末端移除元素（称之为出栈）。\n\n下图展示了一个栈的入栈（push）和出栈（pop）的行为：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPushPop_2x.png)\n\n下面展示了如何编写一个非泛型版本的栈，以 Int 型的栈为例：\n\n```Swift\nstruct IntStack {\n    var items = [Int]()\n    mutating func push(_ item: Int) {\n        items.append(item)\n    }\n    mutating func pop() -> Int {\n        return items.removeLast()\n    }\n}\n```\n\n这个结构体在栈中使用一个名为 items 的 Array 属性来存储值。Stack 提供了两个方法：push(_:) 和 pop()，用来向栈中压入值以及从栈中移除值。这些方法被标记为 mutating，因为它们需要修改结构体的 items 数组。\n上面的 IntStack 结构体只能用于 Int 类型。不过，可以定义一个泛型 Stack 结构体，从而能够处理任意类型的值。\n\n下面是相同代码的泛型版本：\n\n```Swift\nstruct Stack<Element> {\n    var items = [Element]()\n    mutating func push(_ item: Element) {\n        items.append(item)\n    }\n    mutating func pop() -> Element {\n        return items.removeLast()\n    }\n}\n```\n\nElement 为待提供的类型定义了一个占位名。这种待提供的类型可以在结构体的定义中通过 Element 来引用。在这个例子中，Element 在如下三个地方被用作占位符：\n\n * 创建 items 属性，使用 Element 类型的空数组对其进行初始化。\n * 指定 push(_:) 方法的唯一参数 item 的类型必须是 Element 类型。\n * 指定 pop() 方法的返回值类型必须是 Element 类型。\n\n由于 Stack 是泛型类型，因此可以用来创建 Swift 中任意有效类型的栈，就像 Array 和 Dictionary 那样。\n\n```Swift\nvar stackOfStrings = Stack<String>()\nstackOfStrings.push(\"uno\")\nstackOfStrings.push(\"dos\")\nstackOfStrings.push(\"tres\")\nstackOfStrings.push(\"cuatro\")\n// the stack now contains 4 strings\n```\n\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPushedFourStrings_2x.png)\n移除并返回栈顶部的值 \"cuatro\"，即将其出栈：\n\n```Swift\nlet fromTheTop = stackOfStrings.pop()\n// fromTheTop is equal to \"cuatro\", and the stack now contains 3 strings\n```\n\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPoppedOneString_2x.png)\n\n\n### 扩展一个泛型类型\n当你扩展一个泛型类型的时候，你并不需要在扩展的定义中提供类型参数列表。原始类型定义中声明的类型参数列表在扩展中可以直接使用，并且这些来自原始类型中的参数名称会被用作原始定义中类型参数的引用。\n\n下面的例子扩展了泛型类型 Stack，为其添加了一个名为 topItem 的只读计算型属性，它将会返回当前栈顶端的元素而不会将其从栈中移除：\n\n```Swift\nextension Stack {\n    var topItem: Element? {\n        return items.isEmpty ? nil : items[items.count - 1]\n    }\n}\n```\n\n注意，这个扩展并没有定义一个类型参数列表。相反的，Stack 类型已有的类型参数名称 Element，被用在扩展中来表示计算型属性 topItem 的可选类型。\n计算型属性 topItem 现在可以用来访问任意 Stack 实例的顶端元素且不移除它：\n\n```Swift\nif let topItem = stackOfStrings.topItem {\n    print(\"The top item on the stack is \\(topItem).\")\n}\n// Prints \"The top item on the stack is tres.\"\n```\n\n### 类型约束\nswapTwoValues(_:_:) 函数和 Stack 类型可以作用于任何类型。不过，有的时候如果能将使用在泛型函数和泛型类型中的类型添加一个特定的类型约束，将会是非常有用的。类型约束可以指定一个类型参数必须继承自指定类，或者符合一个特定的协议或协议组合。\n例如，Swift 的 Dictionary 类型对字典的键的类型做了些限制。在字典的描述中，字典的键的类型必须是可哈希（hashable）的。也就是说，必须有一种方法能够唯一地表示它。Dictionary 的键之所以要是可哈希的，是为了便于检查字典是否已经包含某个特定键的值。若没有这个要求，Dictionary 将无法判断是否可以插入或者替换某个指定键的值，也不能查找到已经存储在字典中的指定键的值。\n为了实现这个要求，一个类型约束被强制加到 Dictionary 的键类型上，要求其键类型必须符合 Hashable 协议，这是 Swift 标准库中定义的一个特定协议。所有的 Swift 基本类型（例如 String、Int、Double 和 Bool）默认都是可哈希的。\n当你创建自定义泛型类型时，你可以定义你自己的类型约束，这些约束将提供更为强大的泛型编程能力。抽象概念，例如可哈希的，描述的是类型在概念上的特征，而不是它们的显式类型。\n\n#### 类型约束语法\n你可以在一个类型参数名后面放置一个类名或者协议名，并用冒号进行分隔，来定义类型约束，它们将成为类型参数列表的一部分。对泛型函数添加类型约束的基本语法如下所示（作用于泛型类型时的语法与之相同）：\n\n```Swift\nfunc someFunction<T: SomeClass, U: SomeProtocol>(someT: T, someU: U) {\n    // function body goes here\n}\n```\n\n上面这个函数有两个类型参数。第一个类型参数 T，有一个要求 T 必须是 SomeClass 子类的类型约束；第二个类型参数 U，有一个要求 U 必须符合 SomeProtocol 协议的类型约束。\n\n\n#### 类型约束实践\n这里有个名为 findIndex(ofString:in:) 的非泛型函数，该函数的功能是在一个 String 数组中查找给定 String 值的索引。若查找到匹配的字符串，findIndex(ofString:in:) 函数返回该字符串在数组中的索引值，否则返回 nil：\n\n```Swift\nfunc findIndex(ofString valueToFind: String, in array: [String]) -> Int? {\n    for (index, value) in array.enumerated() {\n        if value == valueToFind {\n            return index\n        }\n    }\n    return nil\n}\n```\n\nfindIndex(ofString:in:) 函数可以用于查找字符串数组中的某个字符串：\n\n```Swift\nlet strings = [\"cat\", \"dog\", \"llama\", \"parakeet\", \"terrapin\"]\nif let foundIndex = findIndex(ofString: \"llama\", in: strings) {\n    print(\"The index of llama is \\(foundIndex)\")\n}\n// Prints \"The index of llama is 2\"\n```\n\n下面展示了 findIndex(ofString:in:) 函数的泛型版本 findIndex(ofString:in:)。请注意这个函数返回值的类型仍然是 Int?，这是因为函数返回的是一个可选的索引数，而不是从数组中得到的一个可选值。需要提醒的是，这个函数无法通过编译，原因会在例子后面说明：\n\n```Swift\nfunc findIndex<T>(of valueToFind: T, in array:[T]) -> Int? {\n    for (index, value) in array.enumerated() {\n        if value == valueToFind {\n            return index\n        }\n    }\n    return nil\n}\n```\n\n上面所写的函数无法通过编译。问题出在相等性检查上，即 \"if value == valueToFind\"。不是所有的 Swift 类型都可以用等式符（==）进行比较。比如说，如果你创建一个自定义的类或结构体来表示一个复杂的数据模型，那么 Swift 无法猜到对于这个类或结构体而言“相等”意味着什么。正因如此，这部分代码无法保证适用于每个可能的类型 T，当你试图编译这部分代码时会出现相应的错误。\n不过，所有的这些并不会让我们无从下手。Swift 标准库中定义了一个 Equatable 协议，该协议要求任何遵循该协议的类型必须实现等式符（==）及不等符(!=)，从而能对该类型的任意两个值进行比较。所有的 Swift 标准类型自动支持 Equatable 协议。\n\n任何 Equatable 类型都可以安全地使用在 findIndex(of:in:) 函数中，因为其保证支持等式操作符。为了说明这个事实，当你定义一个函数时，你可以定义一个 Equatable 类型约束作为类型参数定义的一部分：\n\n```Swift\nfunc findIndex<T: Equatable>(of valueToFind: T, in array:[T]) -> Int? {\n    for (index, value) in array.enumerated() {\n        if value == valueToFind {\n            return index\n        }\n    }\n    return nil\n}\n```\n\nfindIndex(of:in:) 唯一的类型参数写做 T: Equatable，也就意味着“任何符合 Equatable 协议的类型 T ”。\n\n```Swift\nlet doubleIndex = findIndex(of: 9.3, in: [3.14159, 0.1, 0.25])\n// doubleIndex is an optional Int with no value, because 9.3 is not in the array\nlet stringIndex = findIndex(of: \"Andrea\", in: [\"Mike\", \"Malcolm\", \"Andrea\"])\n// stringIndex is an optional Int containing a value of 2\n```\n\n### 关联类型\n定义一个协议时，有的时候声明一个或多个关联类型作为协议定义的一部分将会非常有用。关联类型为协议中的某个类型提供了一个占位名（或者说别名），其代表的实际类型在协议被采纳时才会被指定。你可以通过 associatedtype 关键字来指定关联类型。\n\n#### 关联类型实践\n下面例子定义了一个 Container 协议，该协议定义了一个关联类型 ItemType：\n\n```Swift\nprotocol Container {\n    associatedtype ItemType\n    mutating func append(_ item: ItemType)\n    var count: Int { get }\n    subscript(i: Int) -> ItemType { get }\n}\n```\n\nContainer 协议定义了三个任何采纳了该协议的类型（即容器）必须提供的功能：\n\n * 必须可以通过 append(_:) 方法添加一个新元素到容器里。\n * 必须可以通过 count 属性获取容器中元素的数量，并返回一个 Int 值。\n * 必须可以通过索引值类型为 Int 的下标检索到容器中的每一个元素。\n\n这个协议没有指定容器中元素该如何存储，以及元素必须是何种类型。这个协议只指定了三个任何遵从 Container 协议的类型必须提供的功能。遵从协议的类型在满足这三个条件的情况下也可以提供其他额外的功能。\n\n为了定义这三个条件，Container 协议需要在不知道容器中元素的具体类型的情况下引用这种类型。Container 协议需要指定任何通过 append(_:) 方法添加到容器中的元素和容器中的元素是相同类型，并且通过容器下标返回的元素的类型也是这种类型。\n\n为了达到这个目的，Container 协议声明了一个关联类型 ItemType，写作 associatedtype ItemType。这个协议无法定义 ItemType 是什么类型的别名，这个信息将留给遵从协议的类型来提供。尽管如此，ItemType 别名提供了一种方式来引用 Container 中元素的类型，并将之用于 append(_:) 方法和下标，从而保证任何 Container 的行为都能够正如预期地被执行。\n\n下面是先前的非泛型的 IntStack 类型，这一版本采纳并符合了 Container 协议：\n\n```Swift\nstruct IntStack: Container {\n    // original IntStack implementation\n    var items = [Int]()\n    mutating func push(_ item: Int) {\n        items.append(item)\n    }\n    mutating func pop() -> Int {\n        return items.removeLast()\n    }\n    // conformance to the Container protocol\n    typealias ItemType = Int\n    mutating func append(_ item: Int) {\n        self.push(item)\n    }\n    var count: Int {\n        return items.count\n    }\n    subscript(i: Int) -> Int {\n        return items[i]\n    }\n}\n```\n\nIntStack 结构体实现了 Container 协议的三个要求，其原有功能也不会和这些要求相冲突。\n此外，IntStack 在实现 Container 的要求时，指定 ItemType 为 Int 类型，即 typealias ItemType = Int，从而将 Container 协议中抽象的 ItemType 类型转换为具体的 Int 类型。\n\n由于 Swift 的类型推断，你实际上不用在 IntStack 的定义中声明 ItemType 为 Int。因为 IntStack 符合 Container 协议的所有要求，Swift 只需通过 append(_:) 方法的 item 参数类型和下标返回值的类型，就可以推断出 ItemType 的具体类型。事实上，如果你在上面的代码中删除了 typealias ItemType = Int 这一行，一切仍旧可以正常工作，因为 Swift 清楚地知道 ItemType 应该是哪种类型。\n\n你也可以让泛型 Stack 结构体遵从 Container 协议：\n\n```Swift\nstruct Stack<Element>: Container {\n    // original Stack<Element> implementation\n    var items = [Element]()\n    mutating func push(_ item: Element) {\n        items.append(item)\n    }\n    mutating func pop() -> Element {\n        return items.removeLast()\n    }\n    // conformance to the Container protocol\n    mutating func append(_ item: Element) {\n        self.push(item)\n    }\n    var count: Int {\n        return items.count\n    }\n    subscript(i: Int) -> Element {\n        return items[i]\n    }\n}\n```\n\n这一次，占位类型参数 Element 被用作 append(_:) 方法的 item 参数和下标的返回类型。Swift 可以据此推断出 Element 的类型即是 ItemType 的类型。\n\n#### 通过扩展一个存在的类型来指定关联类型\nSwift 的 Array 类型已经提供 append(_:) 方法，一个 count 属性，以及一个接受 Int 类型索引值的下标用以检索其元素。这三个功能都符合 Container 协议的要求，也就意味着你只需简单地声明 Array 采纳该协议就可以扩展 Array，使其遵从 Container 协议。你可以通过一个空扩展来实现这点，正如通过扩展采纳协议中的描述：\n\n```Swift\nextension Array: Container {}\n```\n\n### 泛型 Where 语句\n类型约束让你能够为泛型函数或泛型类型的类型参数定义一些强制要求。\n\n为关联类型定义约束也是非常有用的。你可以在参数列表中通过 where 子句为关联类型定义约束。你能通过 where 子句要求一个关联类型遵从某个特定的协议，以及某个特定的类型参数和关联类型必须类型相同。你可以通过将 where 关键字紧跟在类型参数列表后面来定义 where 子句，where 子句后跟一个或者多个针对关联类型的约束，以及一个或多个类型参数和关联类型间的相等关系。你可以在函数体或者类型的大括号之前添加 where 子句。\n\n下面的例子定义了一个名为 allItemsMatch 的泛型函数，用来检查两个 Container 实例是否包含相同顺序的相同元素。如果所有的元素能够匹配，那么返回 true，否则返回 false。\n被检查的两个 Container 可以不是相同类型的容器（虽然它们可以相同），但它们必须拥有相同类型的元素。这个要求通过一个类型约束以及一个 where 子句来表示：\n\n```Swift\nfunc allItemsMatch<C1: Container, C2: Container>\n    (_ someContainer: C1, _ anotherContainer: C2) -> Bool\n    where C1.ItemType == C2.ItemType, C1.ItemType: Equatable {\n        \n        // Check that both containers contain the same number of items.\n        if someContainer.count != anotherContainer.count {\n            return false\n        }\n        \n        // Check each pair of items to see if they are equivalent.\n        for i in 0..<someContainer.count {\n            if someContainer[i] != anotherContainer[i] {\n                return false\n            }\n        }\n        \n        // All items match, so return true.\n        return true\n}\n```\n\n下面演示了 allItemsMatch(_:_:) 函数的使用：\n\n```Swift\nvar stackOfStrings = Stack<String>()\nstackOfStrings.push(\"uno\")\nstackOfStrings.push(\"dos\")\nstackOfStrings.push(\"tres\")\n \nvar arrayOfStrings = [\"uno\", \"dos\", \"tres\"]\n \nif allItemsMatch(stackOfStrings, arrayOfStrings) {\n    print(\"All items match.\")\n} else {\n    print(\"Not all items match.\")\n}\n// Prints \"All items match.\"\n```\n\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html/\"> Protocols </a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","source":"_posts/iOS_Swift_language_note_Generics.md","raw":"---\nlayout:     post\ntitle:      Swift Generics\ndate:       2016-12-02 19:20:11\nauthor:     liangtong\ncatalog: true\ncategories: iOS\ntags: Swift \n\n---\n\n\n​\t\n​\t泛型代码让你编写出适用于任意类型、灵活可重用的函数及类型。它能让你避免代码的重复，用一种清晰和抽象的方式来表达代码的意图。 \n\n\n\n### 泛型所解决的问题\n下面是一个标准的非泛型函数 swapTwoInts(_:_:)，用来交换两个 Int 值：\n\n```Swift\nfunc swapTwoInts(_ a: inout Int, _ b: inout Int) {\n    let temporaryA = a\n    a = b\n    b = temporaryA\n}\n```\n\n<!-- more -->\n\nswapTwoInts(_:_:) 函数交换 b 的原始值到 a，并交换 a 的原始值到 b。你可以调用这个函数交换两个 Int 变量的值：\n\n```Swift\nvar someInt = 3\nvar anotherInt = 107\nswapTwoInts(&someInt, &anotherInt)\nprint(\"someInt is now \\(someInt), and anotherInt is now \\(anotherInt)\")\n// Prints \"someInt is now 107, and anotherInt is now 3\"\n```\n\nswapTwoInts(_:_:) 函数挺有用，但是它只能交换 Int 值，如果你想要交换两个 String 值或者 Double值，就不得不写更多的函数，例如 swapTwoStrings(_:_:) 和 swapTwoDoubles(_:_:)，如下所示：\n\n```Swift\nfunc swapTwoStrings(_ a: inout String, _ b: inout String) {\n    let temporaryA = a\n    a = b\n    b = temporaryA\n}\n \nfunc swapTwoDoubles(_ a: inout Double, _ b: inout Double) {\n    let temporaryA = a\n    a = b\n    b = temporaryA\n}\n```\n\nswapTwoInts(_:_:)、swapTwoStrings(_:_:) 和 swapTwoDoubles(_:_:) 的函数功能都是相同的，唯一不同之处就在于传入的变量类型不同，分别是 Int、String 和 Double。\n\n### 泛型函数\n泛型函数可以适用于任何类型，下面的 swapTwoValues(_:_:) 函数是上面三个函数的泛型版本：\n\n```Swift\nfunc swapTwoValues<T>(_ a: inout T, _ b: inout T) {\n    let temporaryA = a\n    a = b\n    b = temporaryA\n}\n```\n\nswapTwoValues(_:_:) 的函数主体和 swapTwoInts(_:_:) 函数是一样的，它们只在第一行有点不同：\n这个函数的泛型版本使用了占位类型名（在这里用字母 T 来表示）来代替实际类型名（例如 Int、String 或 Double）。占位类型名没有指明 T 必须是什么类型，但是它指明了 a 和 b 必须是同一类型 T，无论 T 代表什么类型。只有 swapTwoValues(_:_:) 函数在调用时，才能根据所传入的实际类型决定 T 所代表的类型。\n另外一个不同之处在于这个泛型函数名（swapTwoValues(_:_:)）后面跟着占位类型名（T），并用尖括号括起来（<T>）。这个尖括号告诉 Swift 那个 T 是 swapTwoValues(_:_:) 函数定义内的一个占位类型名，因此 Swift 不会去查找名为 T 的实际类型。\n\n```Swift\nvar someInt = 3\nvar anotherInt = 107\nswapTwoValues(&someInt, &anotherInt)\n// someInt is now 107, and anotherInt is now 3\n \nvar someString = \"hello\"\nvar anotherString = \"world\"\nswapTwoValues(&someString, &anotherString)\n// someString is now \"world\", and anotherString is now \"hello\"\n```\n\n### 类型参数\n类型参数指定并命名一个占位类型，并且紧随在函数名后面，使用一对尖括号括起来（例如 <T>）。\n一旦一个类型参数被指定，你可以用它来定义一个函数的参数类型（例如 swapTwoValues(_:_:) 函数中的参数 a 和 b），或者作为函数的返回类型，还可以用作函数主体中的注释类型。在这些情况下，类型参数会在函数调用时被实际类型所替换。（在上面的 swapTwoValues(_:_:) 例子中，当函数第一次被调用时，T 被 Int 替换，第二次调用时，被 String 替换。）\n你可提供多个类型参数，将它们都写在尖括号中，用逗号分开。\n\n\n### 命名类型参数\n在大多数情况下，类型参数具有一个描述性名字，例如 Dictionary<Key, Value> 中的 Key 和 Value，以及 Array<Element> 中的 Element，这可以告诉阅读代码的人这些类型参数和泛型函数之间的关系。然而，当它们之间没有有意义的关系时，通常使用单个字母来命名，例如 T、U、V，正如上面演示的 swapTwoValues(_:_:) 函数中的 T 一样。\n\t请始终使用大写字母开头的驼峰命名法（例如 T 和 MyTypeParameter）来为类型参数命名，以表明它们是占位类型，而不是一个值。\n\n\n### 泛型类型\n除了泛型函数，Swift 还允许你定义泛型类型。这些自定义类、结构体和枚举可以适用于任何类型，类似于 Array 和 Dictionary。\n\n这部分内容将向你展示如何编写一个名为 Stack （栈）的泛型集合类型。栈是一系列值的有序集合，和 Array 类似，但它相比 Swift 的 Array 类型有更多的操作限制。数组允许在数组的任意位置插入新元素或是删除其中任意位置的元素。而栈只允许在集合的末端添加新的元素（称之为入栈）。类似的，栈也只能从末端移除元素（称之为出栈）。\n\n下图展示了一个栈的入栈（push）和出栈（pop）的行为：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPushPop_2x.png)\n\n下面展示了如何编写一个非泛型版本的栈，以 Int 型的栈为例：\n\n```Swift\nstruct IntStack {\n    var items = [Int]()\n    mutating func push(_ item: Int) {\n        items.append(item)\n    }\n    mutating func pop() -> Int {\n        return items.removeLast()\n    }\n}\n```\n\n这个结构体在栈中使用一个名为 items 的 Array 属性来存储值。Stack 提供了两个方法：push(_:) 和 pop()，用来向栈中压入值以及从栈中移除值。这些方法被标记为 mutating，因为它们需要修改结构体的 items 数组。\n上面的 IntStack 结构体只能用于 Int 类型。不过，可以定义一个泛型 Stack 结构体，从而能够处理任意类型的值。\n\n下面是相同代码的泛型版本：\n\n```Swift\nstruct Stack<Element> {\n    var items = [Element]()\n    mutating func push(_ item: Element) {\n        items.append(item)\n    }\n    mutating func pop() -> Element {\n        return items.removeLast()\n    }\n}\n```\n\nElement 为待提供的类型定义了一个占位名。这种待提供的类型可以在结构体的定义中通过 Element 来引用。在这个例子中，Element 在如下三个地方被用作占位符：\n\n * 创建 items 属性，使用 Element 类型的空数组对其进行初始化。\n * 指定 push(_:) 方法的唯一参数 item 的类型必须是 Element 类型。\n * 指定 pop() 方法的返回值类型必须是 Element 类型。\n\n由于 Stack 是泛型类型，因此可以用来创建 Swift 中任意有效类型的栈，就像 Array 和 Dictionary 那样。\n\n```Swift\nvar stackOfStrings = Stack<String>()\nstackOfStrings.push(\"uno\")\nstackOfStrings.push(\"dos\")\nstackOfStrings.push(\"tres\")\nstackOfStrings.push(\"cuatro\")\n// the stack now contains 4 strings\n```\n\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPushedFourStrings_2x.png)\n移除并返回栈顶部的值 \"cuatro\"，即将其出栈：\n\n```Swift\nlet fromTheTop = stackOfStrings.pop()\n// fromTheTop is equal to \"cuatro\", and the stack now contains 3 strings\n```\n\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPoppedOneString_2x.png)\n\n\n### 扩展一个泛型类型\n当你扩展一个泛型类型的时候，你并不需要在扩展的定义中提供类型参数列表。原始类型定义中声明的类型参数列表在扩展中可以直接使用，并且这些来自原始类型中的参数名称会被用作原始定义中类型参数的引用。\n\n下面的例子扩展了泛型类型 Stack，为其添加了一个名为 topItem 的只读计算型属性，它将会返回当前栈顶端的元素而不会将其从栈中移除：\n\n```Swift\nextension Stack {\n    var topItem: Element? {\n        return items.isEmpty ? nil : items[items.count - 1]\n    }\n}\n```\n\n注意，这个扩展并没有定义一个类型参数列表。相反的，Stack 类型已有的类型参数名称 Element，被用在扩展中来表示计算型属性 topItem 的可选类型。\n计算型属性 topItem 现在可以用来访问任意 Stack 实例的顶端元素且不移除它：\n\n```Swift\nif let topItem = stackOfStrings.topItem {\n    print(\"The top item on the stack is \\(topItem).\")\n}\n// Prints \"The top item on the stack is tres.\"\n```\n\n### 类型约束\nswapTwoValues(_:_:) 函数和 Stack 类型可以作用于任何类型。不过，有的时候如果能将使用在泛型函数和泛型类型中的类型添加一个特定的类型约束，将会是非常有用的。类型约束可以指定一个类型参数必须继承自指定类，或者符合一个特定的协议或协议组合。\n例如，Swift 的 Dictionary 类型对字典的键的类型做了些限制。在字典的描述中，字典的键的类型必须是可哈希（hashable）的。也就是说，必须有一种方法能够唯一地表示它。Dictionary 的键之所以要是可哈希的，是为了便于检查字典是否已经包含某个特定键的值。若没有这个要求，Dictionary 将无法判断是否可以插入或者替换某个指定键的值，也不能查找到已经存储在字典中的指定键的值。\n为了实现这个要求，一个类型约束被强制加到 Dictionary 的键类型上，要求其键类型必须符合 Hashable 协议，这是 Swift 标准库中定义的一个特定协议。所有的 Swift 基本类型（例如 String、Int、Double 和 Bool）默认都是可哈希的。\n当你创建自定义泛型类型时，你可以定义你自己的类型约束，这些约束将提供更为强大的泛型编程能力。抽象概念，例如可哈希的，描述的是类型在概念上的特征，而不是它们的显式类型。\n\n#### 类型约束语法\n你可以在一个类型参数名后面放置一个类名或者协议名，并用冒号进行分隔，来定义类型约束，它们将成为类型参数列表的一部分。对泛型函数添加类型约束的基本语法如下所示（作用于泛型类型时的语法与之相同）：\n\n```Swift\nfunc someFunction<T: SomeClass, U: SomeProtocol>(someT: T, someU: U) {\n    // function body goes here\n}\n```\n\n上面这个函数有两个类型参数。第一个类型参数 T，有一个要求 T 必须是 SomeClass 子类的类型约束；第二个类型参数 U，有一个要求 U 必须符合 SomeProtocol 协议的类型约束。\n\n\n#### 类型约束实践\n这里有个名为 findIndex(ofString:in:) 的非泛型函数，该函数的功能是在一个 String 数组中查找给定 String 值的索引。若查找到匹配的字符串，findIndex(ofString:in:) 函数返回该字符串在数组中的索引值，否则返回 nil：\n\n```Swift\nfunc findIndex(ofString valueToFind: String, in array: [String]) -> Int? {\n    for (index, value) in array.enumerated() {\n        if value == valueToFind {\n            return index\n        }\n    }\n    return nil\n}\n```\n\nfindIndex(ofString:in:) 函数可以用于查找字符串数组中的某个字符串：\n\n```Swift\nlet strings = [\"cat\", \"dog\", \"llama\", \"parakeet\", \"terrapin\"]\nif let foundIndex = findIndex(ofString: \"llama\", in: strings) {\n    print(\"The index of llama is \\(foundIndex)\")\n}\n// Prints \"The index of llama is 2\"\n```\n\n下面展示了 findIndex(ofString:in:) 函数的泛型版本 findIndex(ofString:in:)。请注意这个函数返回值的类型仍然是 Int?，这是因为函数返回的是一个可选的索引数，而不是从数组中得到的一个可选值。需要提醒的是，这个函数无法通过编译，原因会在例子后面说明：\n\n```Swift\nfunc findIndex<T>(of valueToFind: T, in array:[T]) -> Int? {\n    for (index, value) in array.enumerated() {\n        if value == valueToFind {\n            return index\n        }\n    }\n    return nil\n}\n```\n\n上面所写的函数无法通过编译。问题出在相等性检查上，即 \"if value == valueToFind\"。不是所有的 Swift 类型都可以用等式符（==）进行比较。比如说，如果你创建一个自定义的类或结构体来表示一个复杂的数据模型，那么 Swift 无法猜到对于这个类或结构体而言“相等”意味着什么。正因如此，这部分代码无法保证适用于每个可能的类型 T，当你试图编译这部分代码时会出现相应的错误。\n不过，所有的这些并不会让我们无从下手。Swift 标准库中定义了一个 Equatable 协议，该协议要求任何遵循该协议的类型必须实现等式符（==）及不等符(!=)，从而能对该类型的任意两个值进行比较。所有的 Swift 标准类型自动支持 Equatable 协议。\n\n任何 Equatable 类型都可以安全地使用在 findIndex(of:in:) 函数中，因为其保证支持等式操作符。为了说明这个事实，当你定义一个函数时，你可以定义一个 Equatable 类型约束作为类型参数定义的一部分：\n\n```Swift\nfunc findIndex<T: Equatable>(of valueToFind: T, in array:[T]) -> Int? {\n    for (index, value) in array.enumerated() {\n        if value == valueToFind {\n            return index\n        }\n    }\n    return nil\n}\n```\n\nfindIndex(of:in:) 唯一的类型参数写做 T: Equatable，也就意味着“任何符合 Equatable 协议的类型 T ”。\n\n```Swift\nlet doubleIndex = findIndex(of: 9.3, in: [3.14159, 0.1, 0.25])\n// doubleIndex is an optional Int with no value, because 9.3 is not in the array\nlet stringIndex = findIndex(of: \"Andrea\", in: [\"Mike\", \"Malcolm\", \"Andrea\"])\n// stringIndex is an optional Int containing a value of 2\n```\n\n### 关联类型\n定义一个协议时，有的时候声明一个或多个关联类型作为协议定义的一部分将会非常有用。关联类型为协议中的某个类型提供了一个占位名（或者说别名），其代表的实际类型在协议被采纳时才会被指定。你可以通过 associatedtype 关键字来指定关联类型。\n\n#### 关联类型实践\n下面例子定义了一个 Container 协议，该协议定义了一个关联类型 ItemType：\n\n```Swift\nprotocol Container {\n    associatedtype ItemType\n    mutating func append(_ item: ItemType)\n    var count: Int { get }\n    subscript(i: Int) -> ItemType { get }\n}\n```\n\nContainer 协议定义了三个任何采纳了该协议的类型（即容器）必须提供的功能：\n\n * 必须可以通过 append(_:) 方法添加一个新元素到容器里。\n * 必须可以通过 count 属性获取容器中元素的数量，并返回一个 Int 值。\n * 必须可以通过索引值类型为 Int 的下标检索到容器中的每一个元素。\n\n这个协议没有指定容器中元素该如何存储，以及元素必须是何种类型。这个协议只指定了三个任何遵从 Container 协议的类型必须提供的功能。遵从协议的类型在满足这三个条件的情况下也可以提供其他额外的功能。\n\n为了定义这三个条件，Container 协议需要在不知道容器中元素的具体类型的情况下引用这种类型。Container 协议需要指定任何通过 append(_:) 方法添加到容器中的元素和容器中的元素是相同类型，并且通过容器下标返回的元素的类型也是这种类型。\n\n为了达到这个目的，Container 协议声明了一个关联类型 ItemType，写作 associatedtype ItemType。这个协议无法定义 ItemType 是什么类型的别名，这个信息将留给遵从协议的类型来提供。尽管如此，ItemType 别名提供了一种方式来引用 Container 中元素的类型，并将之用于 append(_:) 方法和下标，从而保证任何 Container 的行为都能够正如预期地被执行。\n\n下面是先前的非泛型的 IntStack 类型，这一版本采纳并符合了 Container 协议：\n\n```Swift\nstruct IntStack: Container {\n    // original IntStack implementation\n    var items = [Int]()\n    mutating func push(_ item: Int) {\n        items.append(item)\n    }\n    mutating func pop() -> Int {\n        return items.removeLast()\n    }\n    // conformance to the Container protocol\n    typealias ItemType = Int\n    mutating func append(_ item: Int) {\n        self.push(item)\n    }\n    var count: Int {\n        return items.count\n    }\n    subscript(i: Int) -> Int {\n        return items[i]\n    }\n}\n```\n\nIntStack 结构体实现了 Container 协议的三个要求，其原有功能也不会和这些要求相冲突。\n此外，IntStack 在实现 Container 的要求时，指定 ItemType 为 Int 类型，即 typealias ItemType = Int，从而将 Container 协议中抽象的 ItemType 类型转换为具体的 Int 类型。\n\n由于 Swift 的类型推断，你实际上不用在 IntStack 的定义中声明 ItemType 为 Int。因为 IntStack 符合 Container 协议的所有要求，Swift 只需通过 append(_:) 方法的 item 参数类型和下标返回值的类型，就可以推断出 ItemType 的具体类型。事实上，如果你在上面的代码中删除了 typealias ItemType = Int 这一行，一切仍旧可以正常工作，因为 Swift 清楚地知道 ItemType 应该是哪种类型。\n\n你也可以让泛型 Stack 结构体遵从 Container 协议：\n\n```Swift\nstruct Stack<Element>: Container {\n    // original Stack<Element> implementation\n    var items = [Element]()\n    mutating func push(_ item: Element) {\n        items.append(item)\n    }\n    mutating func pop() -> Element {\n        return items.removeLast()\n    }\n    // conformance to the Container protocol\n    mutating func append(_ item: Element) {\n        self.push(item)\n    }\n    var count: Int {\n        return items.count\n    }\n    subscript(i: Int) -> Element {\n        return items[i]\n    }\n}\n```\n\n这一次，占位类型参数 Element 被用作 append(_:) 方法的 item 参数和下标的返回类型。Swift 可以据此推断出 Element 的类型即是 ItemType 的类型。\n\n#### 通过扩展一个存在的类型来指定关联类型\nSwift 的 Array 类型已经提供 append(_:) 方法，一个 count 属性，以及一个接受 Int 类型索引值的下标用以检索其元素。这三个功能都符合 Container 协议的要求，也就意味着你只需简单地声明 Array 采纳该协议就可以扩展 Array，使其遵从 Container 协议。你可以通过一个空扩展来实现这点，正如通过扩展采纳协议中的描述：\n\n```Swift\nextension Array: Container {}\n```\n\n### 泛型 Where 语句\n类型约束让你能够为泛型函数或泛型类型的类型参数定义一些强制要求。\n\n为关联类型定义约束也是非常有用的。你可以在参数列表中通过 where 子句为关联类型定义约束。你能通过 where 子句要求一个关联类型遵从某个特定的协议，以及某个特定的类型参数和关联类型必须类型相同。你可以通过将 where 关键字紧跟在类型参数列表后面来定义 where 子句，where 子句后跟一个或者多个针对关联类型的约束，以及一个或多个类型参数和关联类型间的相等关系。你可以在函数体或者类型的大括号之前添加 where 子句。\n\n下面的例子定义了一个名为 allItemsMatch 的泛型函数，用来检查两个 Container 实例是否包含相同顺序的相同元素。如果所有的元素能够匹配，那么返回 true，否则返回 false。\n被检查的两个 Container 可以不是相同类型的容器（虽然它们可以相同），但它们必须拥有相同类型的元素。这个要求通过一个类型约束以及一个 where 子句来表示：\n\n```Swift\nfunc allItemsMatch<C1: Container, C2: Container>\n    (_ someContainer: C1, _ anotherContainer: C2) -> Bool\n    where C1.ItemType == C2.ItemType, C1.ItemType: Equatable {\n        \n        // Check that both containers contain the same number of items.\n        if someContainer.count != anotherContainer.count {\n            return false\n        }\n        \n        // Check each pair of items to see if they are equivalent.\n        for i in 0..<someContainer.count {\n            if someContainer[i] != anotherContainer[i] {\n                return false\n            }\n        }\n        \n        // All items match, so return true.\n        return true\n}\n```\n\n下面演示了 allItemsMatch(_:_:) 函数的使用：\n\n```Swift\nvar stackOfStrings = Stack<String>()\nstackOfStrings.push(\"uno\")\nstackOfStrings.push(\"dos\")\nstackOfStrings.push(\"tres\")\n \nvar arrayOfStrings = [\"uno\", \"dos\", \"tres\"]\n \nif allItemsMatch(stackOfStrings, arrayOfStrings) {\n    print(\"All items match.\")\n} else {\n    print(\"Not all items match.\")\n}\n// Prints \"All items match.\"\n```\n\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html/\"> Protocols </a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","slug":"iOS_Swift_language_note_Generics","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4ud0034oko8tyjz6bsq","content":"<p>​<br>​    泛型代码让你编写出适用于任意类型、灵活可重用的函数及类型。它能让你避免代码的重复，用一种清晰和抽象的方式来表达代码的意图。 </p>\n<h3 id=\"泛型所解决的问题\"><a href=\"#泛型所解决的问题\" class=\"headerlink\" title=\"泛型所解决的问题\"></a>泛型所解决的问题</h3><p>下面是一个标准的非泛型函数 swapTwoInts(<em>:</em>:)，用来交换两个 Int 值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">swapTwoInts</span><span class=\"params\">(<span class=\"number\">_</span> a: <span class=\"keyword\">inout</span> Int, <span class=\"number\">_</span> b: <span class=\"keyword\">inout</span> Int)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> temporaryA = a</div><div class=\"line\">    a = b</div><div class=\"line\">    b = temporaryA</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>swapTwoInts(<em>:</em>:) 函数交换 b 的原始值到 a，并交换 a 的原始值到 b。你可以调用这个函数交换两个 Int 变量的值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> someInt = <span class=\"number\">3</span></div><div class=\"line\"><span class=\"keyword\">var</span> anotherInt = <span class=\"number\">107</span></div><div class=\"line\">swapTwoInts(&amp;someInt, &amp;anotherInt)</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"someInt is now <span class=\"subst\">\\(someInt)</span>, and anotherInt is now <span class=\"subst\">\\(anotherInt)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"someInt is now 107, and anotherInt is now 3\"</span></div></pre></td></tr></table></figure>\n<p>swapTwoInts(<em>:</em>:) 函数挺有用，但是它只能交换 Int 值，如果你想要交换两个 String 值或者 Double值，就不得不写更多的函数，例如 swapTwoStrings(<em>:</em>:) 和 swapTwoDoubles(<em>:</em>:)，如下所示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">swapTwoStrings</span><span class=\"params\">(<span class=\"number\">_</span> a: <span class=\"keyword\">inout</span> String, <span class=\"number\">_</span> b: <span class=\"keyword\">inout</span> String)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> temporaryA = a</div><div class=\"line\">    a = b</div><div class=\"line\">    b = temporaryA</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">swapTwoDoubles</span><span class=\"params\">(<span class=\"number\">_</span> a: <span class=\"keyword\">inout</span> Double, <span class=\"number\">_</span> b: <span class=\"keyword\">inout</span> Double)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> temporaryA = a</div><div class=\"line\">    a = b</div><div class=\"line\">    b = temporaryA</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>swapTwoInts(<em>:</em>:)、swapTwoStrings(<em>:</em>:) 和 swapTwoDoubles(<em>:</em>:) 的函数功能都是相同的，唯一不同之处就在于传入的变量类型不同，分别是 Int、String 和 Double。</p>\n<h3 id=\"泛型函数\"><a href=\"#泛型函数\" class=\"headerlink\" title=\"泛型函数\"></a>泛型函数</h3><p>泛型函数可以适用于任何类型，下面的 swapTwoValues(<em>:</em>:) 函数是上面三个函数的泛型版本：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">swapTwoValues</span>&lt;T&gt;<span class=\"params\">(<span class=\"number\">_</span> a: <span class=\"keyword\">inout</span> T, <span class=\"number\">_</span> b: <span class=\"keyword\">inout</span> T)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> temporaryA = a</div><div class=\"line\">    a = b</div><div class=\"line\">    b = temporaryA</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>swapTwoValues(<em>:</em>:) 的函数主体和 swapTwoInts(<em>:</em>:) 函数是一样的，它们只在第一行有点不同：<br>这个函数的泛型版本使用了占位类型名（在这里用字母 T 来表示）来代替实际类型名（例如 Int、String 或 Double）。占位类型名没有指明 T 必须是什么类型，但是它指明了 a 和 b 必须是同一类型 T，无论 T 代表什么类型。只有 swapTwoValues(<em>:</em>:) 函数在调用时，才能根据所传入的实际类型决定 T 所代表的类型。<br>另外一个不同之处在于这个泛型函数名（swapTwoValues(<em>:</em>:)）后面跟着占位类型名（T），并用尖括号括起来（<t>）。这个尖括号告诉 Swift 那个 T 是 swapTwoValues(<em>:</em>:) 函数定义内的一个占位类型名，因此 Swift 不会去查找名为 T 的实际类型。</t></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> someInt = <span class=\"number\">3</span></div><div class=\"line\"><span class=\"keyword\">var</span> anotherInt = <span class=\"number\">107</span></div><div class=\"line\">swapTwoValues(&amp;someInt, &amp;anotherInt)</div><div class=\"line\"><span class=\"comment\">// someInt is now 107, and anotherInt is now 3</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">var</span> someString = <span class=\"string\">\"hello\"</span></div><div class=\"line\"><span class=\"keyword\">var</span> anotherString = <span class=\"string\">\"world\"</span></div><div class=\"line\">swapTwoValues(&amp;someString, &amp;anotherString)</div><div class=\"line\"><span class=\"comment\">// someString is now \"world\", and anotherString is now \"hello\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"类型参数\"><a href=\"#类型参数\" class=\"headerlink\" title=\"类型参数\"></a>类型参数</h3><p>类型参数指定并命名一个占位类型，并且紧随在函数名后面，使用一对尖括号括起来（例如 <t>）。<br>一旦一个类型参数被指定，你可以用它来定义一个函数的参数类型（例如 swapTwoValues(<em>:</em>:) 函数中的参数 a 和 b），或者作为函数的返回类型，还可以用作函数主体中的注释类型。在这些情况下，类型参数会在函数调用时被实际类型所替换。（在上面的 swapTwoValues(<em>:</em>:) 例子中，当函数第一次被调用时，T 被 Int 替换，第二次调用时，被 String 替换。）<br>你可提供多个类型参数，将它们都写在尖括号中，用逗号分开。</t></p>\n<h3 id=\"命名类型参数\"><a href=\"#命名类型参数\" class=\"headerlink\" title=\"命名类型参数\"></a>命名类型参数</h3><p>在大多数情况下，类型参数具有一个描述性名字，例如 Dictionary<key, value=\"\"> 中的 Key 和 Value，以及 Array<element> 中的 Element，这可以告诉阅读代码的人这些类型参数和泛型函数之间的关系。然而，当它们之间没有有意义的关系时，通常使用单个字母来命名，例如 T、U、V，正如上面演示的 swapTwoValues(<em>:</em>:) 函数中的 T 一样。<br>    请始终使用大写字母开头的驼峰命名法（例如 T 和 MyTypeParameter）来为类型参数命名，以表明它们是占位类型，而不是一个值。</element></key,></p>\n<h3 id=\"泛型类型\"><a href=\"#泛型类型\" class=\"headerlink\" title=\"泛型类型\"></a>泛型类型</h3><p>除了泛型函数，Swift 还允许你定义泛型类型。这些自定义类、结构体和枚举可以适用于任何类型，类似于 Array 和 Dictionary。</p>\n<p>这部分内容将向你展示如何编写一个名为 Stack （栈）的泛型集合类型。栈是一系列值的有序集合，和 Array 类似，但它相比 Swift 的 Array 类型有更多的操作限制。数组允许在数组的任意位置插入新元素或是删除其中任意位置的元素。而栈只允许在集合的末端添加新的元素（称之为入栈）。类似的，栈也只能从末端移除元素（称之为出栈）。</p>\n<p>下图展示了一个栈的入栈（push）和出栈（pop）的行为：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPushPop_2x.png\" alt=\"\"></p>\n<p>下面展示了如何编写一个非泛型版本的栈，以 Int 型的栈为例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">IntStack</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> items = [<span class=\"type\">Int</span>]()</div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"number\">_</span> item: Int)</span></span> &#123;</div><div class=\"line\">        items.append(item)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">pop</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> items.removeLast()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个结构体在栈中使用一个名为 items 的 Array 属性来存储值。Stack 提供了两个方法：push(_:) 和 pop()，用来向栈中压入值以及从栈中移除值。这些方法被标记为 mutating，因为它们需要修改结构体的 items 数组。<br>上面的 IntStack 结构体只能用于 Int 类型。不过，可以定义一个泛型 Stack 结构体，从而能够处理任意类型的值。</p>\n<p>下面是相同代码的泛型版本：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Stack</span>&lt;<span class=\"title\">Element</span>&gt; </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> items = [<span class=\"type\">Element</span>]()</div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"number\">_</span> item: Element)</span></span> &#123;</div><div class=\"line\">        items.append(item)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">pop</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Element</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> items.removeLast()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Element 为待提供的类型定义了一个占位名。这种待提供的类型可以在结构体的定义中通过 Element 来引用。在这个例子中，Element 在如下三个地方被用作占位符：</p>\n<ul>\n<li>创建 items 属性，使用 Element 类型的空数组对其进行初始化。</li>\n<li>指定 push(_:) 方法的唯一参数 item 的类型必须是 Element 类型。</li>\n<li>指定 pop() 方法的返回值类型必须是 Element 类型。</li>\n</ul>\n<p>由于 Stack 是泛型类型，因此可以用来创建 Swift 中任意有效类型的栈，就像 Array 和 Dictionary 那样。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> stackOfStrings = <span class=\"type\">Stack</span>&lt;<span class=\"type\">String</span>&gt;()</div><div class=\"line\">stackOfStrings.push(<span class=\"string\">\"uno\"</span>)</div><div class=\"line\">stackOfStrings.push(<span class=\"string\">\"dos\"</span>)</div><div class=\"line\">stackOfStrings.push(<span class=\"string\">\"tres\"</span>)</div><div class=\"line\">stackOfStrings.push(<span class=\"string\">\"cuatro\"</span>)</div><div class=\"line\"><span class=\"comment\">// the stack now contains 4 strings</span></div></pre></td></tr></table></figure>\n<p><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPushedFourStrings_2x.png\" alt=\"\"><br>移除并返回栈顶部的值 “cuatro”，即将其出栈：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> fromTheTop = stackOfStrings.pop()</div><div class=\"line\"><span class=\"comment\">// fromTheTop is equal to \"cuatro\", and the stack now contains 3 strings</span></div></pre></td></tr></table></figure>\n<p><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPoppedOneString_2x.png\" alt=\"\"></p>\n<h3 id=\"扩展一个泛型类型\"><a href=\"#扩展一个泛型类型\" class=\"headerlink\" title=\"扩展一个泛型类型\"></a>扩展一个泛型类型</h3><p>当你扩展一个泛型类型的时候，你并不需要在扩展的定义中提供类型参数列表。原始类型定义中声明的类型参数列表在扩展中可以直接使用，并且这些来自原始类型中的参数名称会被用作原始定义中类型参数的引用。</p>\n<p>下面的例子扩展了泛型类型 Stack，为其添加了一个名为 topItem 的只读计算型属性，它将会返回当前栈顶端的元素而不会将其从栈中移除：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Stack</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> topItem: <span class=\"type\">Element</span>? &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> items.isEmpty ? <span class=\"literal\">nil</span> : items[items.<span class=\"built_in\">count</span> - <span class=\"number\">1</span>]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意，这个扩展并没有定义一个类型参数列表。相反的，Stack 类型已有的类型参数名称 Element，被用在扩展中来表示计算型属性 topItem 的可选类型。<br>计算型属性 topItem 现在可以用来访问任意 Stack 实例的顶端元素且不移除它：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> topItem = stackOfStrings.topItem &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The top item on the stack is <span class=\"subst\">\\(topItem)</span>.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"The top item on the stack is tres.\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"类型约束\"><a href=\"#类型约束\" class=\"headerlink\" title=\"类型约束\"></a>类型约束</h3><p>swapTwoValues(<em>:</em>:) 函数和 Stack 类型可以作用于任何类型。不过，有的时候如果能将使用在泛型函数和泛型类型中的类型添加一个特定的类型约束，将会是非常有用的。类型约束可以指定一个类型参数必须继承自指定类，或者符合一个特定的协议或协议组合。<br>例如，Swift 的 Dictionary 类型对字典的键的类型做了些限制。在字典的描述中，字典的键的类型必须是可哈希（hashable）的。也就是说，必须有一种方法能够唯一地表示它。Dictionary 的键之所以要是可哈希的，是为了便于检查字典是否已经包含某个特定键的值。若没有这个要求，Dictionary 将无法判断是否可以插入或者替换某个指定键的值，也不能查找到已经存储在字典中的指定键的值。<br>为了实现这个要求，一个类型约束被强制加到 Dictionary 的键类型上，要求其键类型必须符合 Hashable 协议，这是 Swift 标准库中定义的一个特定协议。所有的 Swift 基本类型（例如 String、Int、Double 和 Bool）默认都是可哈希的。<br>当你创建自定义泛型类型时，你可以定义你自己的类型约束，这些约束将提供更为强大的泛型编程能力。抽象概念，例如可哈希的，描述的是类型在概念上的特征，而不是它们的显式类型。</p>\n<h4 id=\"类型约束语法\"><a href=\"#类型约束语法\" class=\"headerlink\" title=\"类型约束语法\"></a>类型约束语法</h4><p>你可以在一个类型参数名后面放置一个类名或者协议名，并用冒号进行分隔，来定义类型约束，它们将成为类型参数列表的一部分。对泛型函数添加类型约束的基本语法如下所示（作用于泛型类型时的语法与之相同）：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someFunction</span>&lt;T: SomeClass, U: SomeProtocol&gt;<span class=\"params\">(someT: T, someU: U)</span></span> &#123;</div><div class=\"line\">    <span class=\"comment\">// function body goes here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面这个函数有两个类型参数。第一个类型参数 T，有一个要求 T 必须是 SomeClass 子类的类型约束；第二个类型参数 U，有一个要求 U 必须符合 SomeProtocol 协议的类型约束。</p>\n<h4 id=\"类型约束实践\"><a href=\"#类型约束实践\" class=\"headerlink\" title=\"类型约束实践\"></a>类型约束实践</h4><p>这里有个名为 findIndex(ofString:in:) 的非泛型函数，该函数的功能是在一个 String 数组中查找给定 String 值的索引。若查找到匹配的字符串，findIndex(ofString:in:) 函数返回该字符串在数组中的索引值，否则返回 nil：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findIndex</span><span class=\"params\">(ofString valueToFind: String, <span class=\"keyword\">in</span> array: [String])</span></span> -&gt; <span class=\"type\">Int</span>? &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (index, value) <span class=\"keyword\">in</span> array.enumerated() &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> value == valueToFind &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> index</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>findIndex(ofString:in:) 函数可以用于查找字符串数组中的某个字符串：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> strings = [<span class=\"string\">\"cat\"</span>, <span class=\"string\">\"dog\"</span>, <span class=\"string\">\"llama\"</span>, <span class=\"string\">\"parakeet\"</span>, <span class=\"string\">\"terrapin\"</span>]</div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> foundIndex = findIndex(ofString: <span class=\"string\">\"llama\"</span>, <span class=\"keyword\">in</span>: strings) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The index of llama is <span class=\"subst\">\\(foundIndex)</span>\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"The index of llama is 2\"</span></div></pre></td></tr></table></figure>\n<p>下面展示了 findIndex(ofString:in:) 函数的泛型版本 findIndex(ofString:in:)。请注意这个函数返回值的类型仍然是 Int?，这是因为函数返回的是一个可选的索引数，而不是从数组中得到的一个可选值。需要提醒的是，这个函数无法通过编译，原因会在例子后面说明：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findIndex</span>&lt;T&gt;<span class=\"params\">(of valueToFind: T, <span class=\"keyword\">in</span> array:[T])</span></span> -&gt; <span class=\"type\">Int</span>? &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (index, value) <span class=\"keyword\">in</span> array.enumerated() &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> value == valueToFind &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> index</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面所写的函数无法通过编译。问题出在相等性检查上，即 “if value == valueToFind”。不是所有的 Swift 类型都可以用等式符（==）进行比较。比如说，如果你创建一个自定义的类或结构体来表示一个复杂的数据模型，那么 Swift 无法猜到对于这个类或结构体而言“相等”意味着什么。正因如此，这部分代码无法保证适用于每个可能的类型 T，当你试图编译这部分代码时会出现相应的错误。<br>不过，所有的这些并不会让我们无从下手。Swift 标准库中定义了一个 Equatable 协议，该协议要求任何遵循该协议的类型必须实现等式符（==）及不等符(!=)，从而能对该类型的任意两个值进行比较。所有的 Swift 标准类型自动支持 Equatable 协议。</p>\n<p>任何 Equatable 类型都可以安全地使用在 findIndex(of:in:) 函数中，因为其保证支持等式操作符。为了说明这个事实，当你定义一个函数时，你可以定义一个 Equatable 类型约束作为类型参数定义的一部分：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findIndex</span>&lt;T: Equatable&gt;<span class=\"params\">(of valueToFind: T, <span class=\"keyword\">in</span> array:[T])</span></span> -&gt; <span class=\"type\">Int</span>? &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (index, value) <span class=\"keyword\">in</span> array.enumerated() &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> value == valueToFind &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> index</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>findIndex(of:in:) 唯一的类型参数写做 T: Equatable，也就意味着“任何符合 Equatable 协议的类型 T ”。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> doubleIndex = findIndex(of: <span class=\"number\">9.3</span>, <span class=\"keyword\">in</span>: [<span class=\"number\">3.14159</span>, <span class=\"number\">0.1</span>, <span class=\"number\">0.25</span>])</div><div class=\"line\"><span class=\"comment\">// doubleIndex is an optional Int with no value, because 9.3 is not in the array</span></div><div class=\"line\"><span class=\"keyword\">let</span> stringIndex = findIndex(of: <span class=\"string\">\"Andrea\"</span>, <span class=\"keyword\">in</span>: [<span class=\"string\">\"Mike\"</span>, <span class=\"string\">\"Malcolm\"</span>, <span class=\"string\">\"Andrea\"</span>])</div><div class=\"line\"><span class=\"comment\">// stringIndex is an optional Int containing a value of 2</span></div></pre></td></tr></table></figure>\n<h3 id=\"关联类型\"><a href=\"#关联类型\" class=\"headerlink\" title=\"关联类型\"></a>关联类型</h3><p>定义一个协议时，有的时候声明一个或多个关联类型作为协议定义的一部分将会非常有用。关联类型为协议中的某个类型提供了一个占位名（或者说别名），其代表的实际类型在协议被采纳时才会被指定。你可以通过 associatedtype 关键字来指定关联类型。</p>\n<h4 id=\"关联类型实践\"><a href=\"#关联类型实践\" class=\"headerlink\" title=\"关联类型实践\"></a>关联类型实践</h4><p>下面例子定义了一个 Container 协议，该协议定义了一个关联类型 ItemType：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">Container</span> </span>&#123;</div><div class=\"line\">    associatedtype <span class=\"type\">ItemType</span></div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">append</span><span class=\"params\">(<span class=\"number\">_</span> item: ItemType)</span></span></div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">count</span>: <span class=\"type\">Int</span> &#123; <span class=\"keyword\">get</span> &#125;</div><div class=\"line\">    <span class=\"keyword\">subscript</span>(i: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">ItemType</span> &#123; <span class=\"keyword\">get</span> &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Container 协议定义了三个任何采纳了该协议的类型（即容器）必须提供的功能：</p>\n<ul>\n<li>必须可以通过 append(_:) 方法添加一个新元素到容器里。</li>\n<li>必须可以通过 count 属性获取容器中元素的数量，并返回一个 Int 值。</li>\n<li>必须可以通过索引值类型为 Int 的下标检索到容器中的每一个元素。</li>\n</ul>\n<p>这个协议没有指定容器中元素该如何存储，以及元素必须是何种类型。这个协议只指定了三个任何遵从 Container 协议的类型必须提供的功能。遵从协议的类型在满足这三个条件的情况下也可以提供其他额外的功能。</p>\n<p>为了定义这三个条件，Container 协议需要在不知道容器中元素的具体类型的情况下引用这种类型。Container 协议需要指定任何通过 append(_:) 方法添加到容器中的元素和容器中的元素是相同类型，并且通过容器下标返回的元素的类型也是这种类型。</p>\n<p>为了达到这个目的，Container 协议声明了一个关联类型 ItemType，写作 associatedtype ItemType。这个协议无法定义 ItemType 是什么类型的别名，这个信息将留给遵从协议的类型来提供。尽管如此，ItemType 别名提供了一种方式来引用 Container 中元素的类型，并将之用于 append(_:) 方法和下标，从而保证任何 Container 的行为都能够正如预期地被执行。</p>\n<p>下面是先前的非泛型的 IntStack 类型，这一版本采纳并符合了 Container 协议：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">IntStack</span>: <span class=\"title\">Container</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// original IntStack implementation</span></div><div class=\"line\">    <span class=\"keyword\">var</span> items = [<span class=\"type\">Int</span>]()</div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"number\">_</span> item: Int)</span></span> &#123;</div><div class=\"line\">        items.append(item)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">pop</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> items.removeLast()</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// conformance to the Container protocol</span></div><div class=\"line\">    <span class=\"keyword\">typealias</span> <span class=\"type\">ItemType</span> = <span class=\"type\">Int</span></div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">append</span><span class=\"params\">(<span class=\"number\">_</span> item: Int)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.push(item)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">count</span>: <span class=\"type\">Int</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> items.<span class=\"built_in\">count</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">subscript</span>(i: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> items[i]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>IntStack 结构体实现了 Container 协议的三个要求，其原有功能也不会和这些要求相冲突。<br>此外，IntStack 在实现 Container 的要求时，指定 ItemType 为 Int 类型，即 typealias ItemType = Int，从而将 Container 协议中抽象的 ItemType 类型转换为具体的 Int 类型。</p>\n<p>由于 Swift 的类型推断，你实际上不用在 IntStack 的定义中声明 ItemType 为 Int。因为 IntStack 符合 Container 协议的所有要求，Swift 只需通过 append(_:) 方法的 item 参数类型和下标返回值的类型，就可以推断出 ItemType 的具体类型。事实上，如果你在上面的代码中删除了 typealias ItemType = Int 这一行，一切仍旧可以正常工作，因为 Swift 清楚地知道 ItemType 应该是哪种类型。</p>\n<p>你也可以让泛型 Stack 结构体遵从 Container 协议：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Stack</span>&lt;<span class=\"title\">Element</span>&gt;: <span class=\"title\">Container</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// original Stack&lt;Element&gt; implementation</span></div><div class=\"line\">    <span class=\"keyword\">var</span> items = [<span class=\"type\">Element</span>]()</div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"number\">_</span> item: Element)</span></span> &#123;</div><div class=\"line\">        items.append(item)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">pop</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Element</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> items.removeLast()</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// conformance to the Container protocol</span></div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">append</span><span class=\"params\">(<span class=\"number\">_</span> item: Element)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.push(item)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">count</span>: <span class=\"type\">Int</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> items.<span class=\"built_in\">count</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">subscript</span>(i: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Element</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> items[i]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这一次，占位类型参数 Element 被用作 append(_:) 方法的 item 参数和下标的返回类型。Swift 可以据此推断出 Element 的类型即是 ItemType 的类型。</p>\n<h4 id=\"通过扩展一个存在的类型来指定关联类型\"><a href=\"#通过扩展一个存在的类型来指定关联类型\" class=\"headerlink\" title=\"通过扩展一个存在的类型来指定关联类型\"></a>通过扩展一个存在的类型来指定关联类型</h4><p>Swift 的 Array 类型已经提供 append(_:) 方法，一个 count 属性，以及一个接受 Int 类型索引值的下标用以检索其元素。这三个功能都符合 Container 协议的要求，也就意味着你只需简单地声明 Array 采纳该协议就可以扩展 Array，使其遵从 Container 协议。你可以通过一个空扩展来实现这点，正如通过扩展采纳协议中的描述：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Array</span>: <span class=\"title\">Container</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"泛型-Where-语句\"><a href=\"#泛型-Where-语句\" class=\"headerlink\" title=\"泛型 Where 语句\"></a>泛型 Where 语句</h3><p>类型约束让你能够为泛型函数或泛型类型的类型参数定义一些强制要求。</p>\n<p>为关联类型定义约束也是非常有用的。你可以在参数列表中通过 where 子句为关联类型定义约束。你能通过 where 子句要求一个关联类型遵从某个特定的协议，以及某个特定的类型参数和关联类型必须类型相同。你可以通过将 where 关键字紧跟在类型参数列表后面来定义 where 子句，where 子句后跟一个或者多个针对关联类型的约束，以及一个或多个类型参数和关联类型间的相等关系。你可以在函数体或者类型的大括号之前添加 where 子句。</p>\n<p>下面的例子定义了一个名为 allItemsMatch 的泛型函数，用来检查两个 Container 实例是否包含相同顺序的相同元素。如果所有的元素能够匹配，那么返回 true，否则返回 false。<br>被检查的两个 Container 可以不是相同类型的容器（虽然它们可以相同），但它们必须拥有相同类型的元素。这个要求通过一个类型约束以及一个 where 子句来表示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">allItemsMatch</span>&lt;C1: Container, C2: Container&gt;</span></div><div class=\"line\"><span class=\"function\">    <span class=\"params\">(<span class=\"number\">_</span> someContainer: C1, <span class=\"number\">_</span> anotherContainer: C2)</span></span> -&gt; <span class=\"type\">Bool</span></div><div class=\"line\">    <span class=\"keyword\">where</span> <span class=\"type\">C1</span>.<span class=\"type\">ItemType</span> == <span class=\"type\">C2</span>.<span class=\"type\">ItemType</span>, <span class=\"type\">C1</span>.<span class=\"type\">ItemType</span>: <span class=\"type\">Equatable</span> &#123;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// Check that both containers contain the same number of items.</span></div><div class=\"line\">        <span class=\"keyword\">if</span> someContainer.<span class=\"built_in\">count</span> != anotherContainer.<span class=\"built_in\">count</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// Check each pair of items to see if they are equivalent.</span></div><div class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;someContainer.<span class=\"built_in\">count</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> someContainer[i] != anotherContainer[i] &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// All items match, so return true.</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下面演示了 allItemsMatch(<em>:</em>:) 函数的使用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> stackOfStrings = <span class=\"type\">Stack</span>&lt;<span class=\"type\">String</span>&gt;()</div><div class=\"line\">stackOfStrings.push(<span class=\"string\">\"uno\"</span>)</div><div class=\"line\">stackOfStrings.push(<span class=\"string\">\"dos\"</span>)</div><div class=\"line\">stackOfStrings.push(<span class=\"string\">\"tres\"</span>)</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">var</span> arrayOfStrings = [<span class=\"string\">\"uno\"</span>, <span class=\"string\">\"dos\"</span>, <span class=\"string\">\"tres\"</span>]</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">if</span> allItemsMatch(stackOfStrings, arrayOfStrings) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"All items match.\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Not all items match.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"All items match.\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html/\" target=\"_blank\" rel=\"external\"> Protocols </a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>​<br>​    泛型代码让你编写出适用于任意类型、灵活可重用的函数及类型。它能让你避免代码的重复，用一种清晰和抽象的方式来表达代码的意图。 </p>\n<h3 id=\"泛型所解决的问题\"><a href=\"#泛型所解决的问题\" class=\"headerlink\" title=\"泛型所解决的问题\"></a>泛型所解决的问题</h3><p>下面是一个标准的非泛型函数 swapTwoInts(<em>:</em>:)，用来交换两个 Int 值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">swapTwoInts</span><span class=\"params\">(<span class=\"number\">_</span> a: <span class=\"keyword\">inout</span> Int, <span class=\"number\">_</span> b: <span class=\"keyword\">inout</span> Int)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> temporaryA = a</div><div class=\"line\">    a = b</div><div class=\"line\">    b = temporaryA</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","more":"<p>swapTwoInts(<em>:</em>:) 函数交换 b 的原始值到 a，并交换 a 的原始值到 b。你可以调用这个函数交换两个 Int 变量的值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> someInt = <span class=\"number\">3</span></div><div class=\"line\"><span class=\"keyword\">var</span> anotherInt = <span class=\"number\">107</span></div><div class=\"line\">swapTwoInts(&amp;someInt, &amp;anotherInt)</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"someInt is now <span class=\"subst\">\\(someInt)</span>, and anotherInt is now <span class=\"subst\">\\(anotherInt)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"someInt is now 107, and anotherInt is now 3\"</span></div></pre></td></tr></table></figure>\n<p>swapTwoInts(<em>:</em>:) 函数挺有用，但是它只能交换 Int 值，如果你想要交换两个 String 值或者 Double值，就不得不写更多的函数，例如 swapTwoStrings(<em>:</em>:) 和 swapTwoDoubles(<em>:</em>:)，如下所示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">swapTwoStrings</span><span class=\"params\">(<span class=\"number\">_</span> a: <span class=\"keyword\">inout</span> String, <span class=\"number\">_</span> b: <span class=\"keyword\">inout</span> String)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> temporaryA = a</div><div class=\"line\">    a = b</div><div class=\"line\">    b = temporaryA</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">swapTwoDoubles</span><span class=\"params\">(<span class=\"number\">_</span> a: <span class=\"keyword\">inout</span> Double, <span class=\"number\">_</span> b: <span class=\"keyword\">inout</span> Double)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> temporaryA = a</div><div class=\"line\">    a = b</div><div class=\"line\">    b = temporaryA</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>swapTwoInts(<em>:</em>:)、swapTwoStrings(<em>:</em>:) 和 swapTwoDoubles(<em>:</em>:) 的函数功能都是相同的，唯一不同之处就在于传入的变量类型不同，分别是 Int、String 和 Double。</p>\n<h3 id=\"泛型函数\"><a href=\"#泛型函数\" class=\"headerlink\" title=\"泛型函数\"></a>泛型函数</h3><p>泛型函数可以适用于任何类型，下面的 swapTwoValues(<em>:</em>:) 函数是上面三个函数的泛型版本：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">swapTwoValues</span>&lt;T&gt;<span class=\"params\">(<span class=\"number\">_</span> a: <span class=\"keyword\">inout</span> T, <span class=\"number\">_</span> b: <span class=\"keyword\">inout</span> T)</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> temporaryA = a</div><div class=\"line\">    a = b</div><div class=\"line\">    b = temporaryA</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>swapTwoValues(<em>:</em>:) 的函数主体和 swapTwoInts(<em>:</em>:) 函数是一样的，它们只在第一行有点不同：<br>这个函数的泛型版本使用了占位类型名（在这里用字母 T 来表示）来代替实际类型名（例如 Int、String 或 Double）。占位类型名没有指明 T 必须是什么类型，但是它指明了 a 和 b 必须是同一类型 T，无论 T 代表什么类型。只有 swapTwoValues(<em>:</em>:) 函数在调用时，才能根据所传入的实际类型决定 T 所代表的类型。<br>另外一个不同之处在于这个泛型函数名（swapTwoValues(<em>:</em>:)）后面跟着占位类型名（T），并用尖括号括起来（<t>）。这个尖括号告诉 Swift 那个 T 是 swapTwoValues(<em>:</em>:) 函数定义内的一个占位类型名，因此 Swift 不会去查找名为 T 的实际类型。</t></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> someInt = <span class=\"number\">3</span></div><div class=\"line\"><span class=\"keyword\">var</span> anotherInt = <span class=\"number\">107</span></div><div class=\"line\">swapTwoValues(&amp;someInt, &amp;anotherInt)</div><div class=\"line\"><span class=\"comment\">// someInt is now 107, and anotherInt is now 3</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">var</span> someString = <span class=\"string\">\"hello\"</span></div><div class=\"line\"><span class=\"keyword\">var</span> anotherString = <span class=\"string\">\"world\"</span></div><div class=\"line\">swapTwoValues(&amp;someString, &amp;anotherString)</div><div class=\"line\"><span class=\"comment\">// someString is now \"world\", and anotherString is now \"hello\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"类型参数\"><a href=\"#类型参数\" class=\"headerlink\" title=\"类型参数\"></a>类型参数</h3><p>类型参数指定并命名一个占位类型，并且紧随在函数名后面，使用一对尖括号括起来（例如 <t>）。<br>一旦一个类型参数被指定，你可以用它来定义一个函数的参数类型（例如 swapTwoValues(<em>:</em>:) 函数中的参数 a 和 b），或者作为函数的返回类型，还可以用作函数主体中的注释类型。在这些情况下，类型参数会在函数调用时被实际类型所替换。（在上面的 swapTwoValues(<em>:</em>:) 例子中，当函数第一次被调用时，T 被 Int 替换，第二次调用时，被 String 替换。）<br>你可提供多个类型参数，将它们都写在尖括号中，用逗号分开。</t></p>\n<h3 id=\"命名类型参数\"><a href=\"#命名类型参数\" class=\"headerlink\" title=\"命名类型参数\"></a>命名类型参数</h3><p>在大多数情况下，类型参数具有一个描述性名字，例如 Dictionary<key, value=\"\"> 中的 Key 和 Value，以及 Array<element> 中的 Element，这可以告诉阅读代码的人这些类型参数和泛型函数之间的关系。然而，当它们之间没有有意义的关系时，通常使用单个字母来命名，例如 T、U、V，正如上面演示的 swapTwoValues(<em>:</em>:) 函数中的 T 一样。<br>    请始终使用大写字母开头的驼峰命名法（例如 T 和 MyTypeParameter）来为类型参数命名，以表明它们是占位类型，而不是一个值。</element></key,></p>\n<h3 id=\"泛型类型\"><a href=\"#泛型类型\" class=\"headerlink\" title=\"泛型类型\"></a>泛型类型</h3><p>除了泛型函数，Swift 还允许你定义泛型类型。这些自定义类、结构体和枚举可以适用于任何类型，类似于 Array 和 Dictionary。</p>\n<p>这部分内容将向你展示如何编写一个名为 Stack （栈）的泛型集合类型。栈是一系列值的有序集合，和 Array 类似，但它相比 Swift 的 Array 类型有更多的操作限制。数组允许在数组的任意位置插入新元素或是删除其中任意位置的元素。而栈只允许在集合的末端添加新的元素（称之为入栈）。类似的，栈也只能从末端移除元素（称之为出栈）。</p>\n<p>下图展示了一个栈的入栈（push）和出栈（pop）的行为：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPushPop_2x.png\" alt=\"\"></p>\n<p>下面展示了如何编写一个非泛型版本的栈，以 Int 型的栈为例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">IntStack</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> items = [<span class=\"type\">Int</span>]()</div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"number\">_</span> item: Int)</span></span> &#123;</div><div class=\"line\">        items.append(item)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">pop</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> items.removeLast()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个结构体在栈中使用一个名为 items 的 Array 属性来存储值。Stack 提供了两个方法：push(_:) 和 pop()，用来向栈中压入值以及从栈中移除值。这些方法被标记为 mutating，因为它们需要修改结构体的 items 数组。<br>上面的 IntStack 结构体只能用于 Int 类型。不过，可以定义一个泛型 Stack 结构体，从而能够处理任意类型的值。</p>\n<p>下面是相同代码的泛型版本：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Stack</span>&lt;<span class=\"title\">Element</span>&gt; </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> items = [<span class=\"type\">Element</span>]()</div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"number\">_</span> item: Element)</span></span> &#123;</div><div class=\"line\">        items.append(item)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">pop</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Element</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> items.removeLast()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Element 为待提供的类型定义了一个占位名。这种待提供的类型可以在结构体的定义中通过 Element 来引用。在这个例子中，Element 在如下三个地方被用作占位符：</p>\n<ul>\n<li>创建 items 属性，使用 Element 类型的空数组对其进行初始化。</li>\n<li>指定 push(_:) 方法的唯一参数 item 的类型必须是 Element 类型。</li>\n<li>指定 pop() 方法的返回值类型必须是 Element 类型。</li>\n</ul>\n<p>由于 Stack 是泛型类型，因此可以用来创建 Swift 中任意有效类型的栈，就像 Array 和 Dictionary 那样。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> stackOfStrings = <span class=\"type\">Stack</span>&lt;<span class=\"type\">String</span>&gt;()</div><div class=\"line\">stackOfStrings.push(<span class=\"string\">\"uno\"</span>)</div><div class=\"line\">stackOfStrings.push(<span class=\"string\">\"dos\"</span>)</div><div class=\"line\">stackOfStrings.push(<span class=\"string\">\"tres\"</span>)</div><div class=\"line\">stackOfStrings.push(<span class=\"string\">\"cuatro\"</span>)</div><div class=\"line\"><span class=\"comment\">// the stack now contains 4 strings</span></div></pre></td></tr></table></figure>\n<p><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPushedFourStrings_2x.png\" alt=\"\"><br>移除并返回栈顶部的值 “cuatro”，即将其出栈：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> fromTheTop = stackOfStrings.pop()</div><div class=\"line\"><span class=\"comment\">// fromTheTop is equal to \"cuatro\", and the stack now contains 3 strings</span></div></pre></td></tr></table></figure>\n<p><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/stackPoppedOneString_2x.png\" alt=\"\"></p>\n<h3 id=\"扩展一个泛型类型\"><a href=\"#扩展一个泛型类型\" class=\"headerlink\" title=\"扩展一个泛型类型\"></a>扩展一个泛型类型</h3><p>当你扩展一个泛型类型的时候，你并不需要在扩展的定义中提供类型参数列表。原始类型定义中声明的类型参数列表在扩展中可以直接使用，并且这些来自原始类型中的参数名称会被用作原始定义中类型参数的引用。</p>\n<p>下面的例子扩展了泛型类型 Stack，为其添加了一个名为 topItem 的只读计算型属性，它将会返回当前栈顶端的元素而不会将其从栈中移除：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Stack</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> topItem: <span class=\"type\">Element</span>? &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> items.isEmpty ? <span class=\"literal\">nil</span> : items[items.<span class=\"built_in\">count</span> - <span class=\"number\">1</span>]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意，这个扩展并没有定义一个类型参数列表。相反的，Stack 类型已有的类型参数名称 Element，被用在扩展中来表示计算型属性 topItem 的可选类型。<br>计算型属性 topItem 现在可以用来访问任意 Stack 实例的顶端元素且不移除它：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> topItem = stackOfStrings.topItem &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The top item on the stack is <span class=\"subst\">\\(topItem)</span>.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"The top item on the stack is tres.\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"类型约束\"><a href=\"#类型约束\" class=\"headerlink\" title=\"类型约束\"></a>类型约束</h3><p>swapTwoValues(<em>:</em>:) 函数和 Stack 类型可以作用于任何类型。不过，有的时候如果能将使用在泛型函数和泛型类型中的类型添加一个特定的类型约束，将会是非常有用的。类型约束可以指定一个类型参数必须继承自指定类，或者符合一个特定的协议或协议组合。<br>例如，Swift 的 Dictionary 类型对字典的键的类型做了些限制。在字典的描述中，字典的键的类型必须是可哈希（hashable）的。也就是说，必须有一种方法能够唯一地表示它。Dictionary 的键之所以要是可哈希的，是为了便于检查字典是否已经包含某个特定键的值。若没有这个要求，Dictionary 将无法判断是否可以插入或者替换某个指定键的值，也不能查找到已经存储在字典中的指定键的值。<br>为了实现这个要求，一个类型约束被强制加到 Dictionary 的键类型上，要求其键类型必须符合 Hashable 协议，这是 Swift 标准库中定义的一个特定协议。所有的 Swift 基本类型（例如 String、Int、Double 和 Bool）默认都是可哈希的。<br>当你创建自定义泛型类型时，你可以定义你自己的类型约束，这些约束将提供更为强大的泛型编程能力。抽象概念，例如可哈希的，描述的是类型在概念上的特征，而不是它们的显式类型。</p>\n<h4 id=\"类型约束语法\"><a href=\"#类型约束语法\" class=\"headerlink\" title=\"类型约束语法\"></a>类型约束语法</h4><p>你可以在一个类型参数名后面放置一个类名或者协议名，并用冒号进行分隔，来定义类型约束，它们将成为类型参数列表的一部分。对泛型函数添加类型约束的基本语法如下所示（作用于泛型类型时的语法与之相同）：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someFunction</span>&lt;T: SomeClass, U: SomeProtocol&gt;<span class=\"params\">(someT: T, someU: U)</span></span> &#123;</div><div class=\"line\">    <span class=\"comment\">// function body goes here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面这个函数有两个类型参数。第一个类型参数 T，有一个要求 T 必须是 SomeClass 子类的类型约束；第二个类型参数 U，有一个要求 U 必须符合 SomeProtocol 协议的类型约束。</p>\n<h4 id=\"类型约束实践\"><a href=\"#类型约束实践\" class=\"headerlink\" title=\"类型约束实践\"></a>类型约束实践</h4><p>这里有个名为 findIndex(ofString:in:) 的非泛型函数，该函数的功能是在一个 String 数组中查找给定 String 值的索引。若查找到匹配的字符串，findIndex(ofString:in:) 函数返回该字符串在数组中的索引值，否则返回 nil：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findIndex</span><span class=\"params\">(ofString valueToFind: String, <span class=\"keyword\">in</span> array: [String])</span></span> -&gt; <span class=\"type\">Int</span>? &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (index, value) <span class=\"keyword\">in</span> array.enumerated() &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> value == valueToFind &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> index</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>findIndex(ofString:in:) 函数可以用于查找字符串数组中的某个字符串：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> strings = [<span class=\"string\">\"cat\"</span>, <span class=\"string\">\"dog\"</span>, <span class=\"string\">\"llama\"</span>, <span class=\"string\">\"parakeet\"</span>, <span class=\"string\">\"terrapin\"</span>]</div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> foundIndex = findIndex(ofString: <span class=\"string\">\"llama\"</span>, <span class=\"keyword\">in</span>: strings) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The index of llama is <span class=\"subst\">\\(foundIndex)</span>\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"The index of llama is 2\"</span></div></pre></td></tr></table></figure>\n<p>下面展示了 findIndex(ofString:in:) 函数的泛型版本 findIndex(ofString:in:)。请注意这个函数返回值的类型仍然是 Int?，这是因为函数返回的是一个可选的索引数，而不是从数组中得到的一个可选值。需要提醒的是，这个函数无法通过编译，原因会在例子后面说明：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findIndex</span>&lt;T&gt;<span class=\"params\">(of valueToFind: T, <span class=\"keyword\">in</span> array:[T])</span></span> -&gt; <span class=\"type\">Int</span>? &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (index, value) <span class=\"keyword\">in</span> array.enumerated() &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> value == valueToFind &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> index</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面所写的函数无法通过编译。问题出在相等性检查上，即 “if value == valueToFind”。不是所有的 Swift 类型都可以用等式符（==）进行比较。比如说，如果你创建一个自定义的类或结构体来表示一个复杂的数据模型，那么 Swift 无法猜到对于这个类或结构体而言“相等”意味着什么。正因如此，这部分代码无法保证适用于每个可能的类型 T，当你试图编译这部分代码时会出现相应的错误。<br>不过，所有的这些并不会让我们无从下手。Swift 标准库中定义了一个 Equatable 协议，该协议要求任何遵循该协议的类型必须实现等式符（==）及不等符(!=)，从而能对该类型的任意两个值进行比较。所有的 Swift 标准类型自动支持 Equatable 协议。</p>\n<p>任何 Equatable 类型都可以安全地使用在 findIndex(of:in:) 函数中，因为其保证支持等式操作符。为了说明这个事实，当你定义一个函数时，你可以定义一个 Equatable 类型约束作为类型参数定义的一部分：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">findIndex</span>&lt;T: Equatable&gt;<span class=\"params\">(of valueToFind: T, <span class=\"keyword\">in</span> array:[T])</span></span> -&gt; <span class=\"type\">Int</span>? &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (index, value) <span class=\"keyword\">in</span> array.enumerated() &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> value == valueToFind &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> index</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>findIndex(of:in:) 唯一的类型参数写做 T: Equatable，也就意味着“任何符合 Equatable 协议的类型 T ”。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> doubleIndex = findIndex(of: <span class=\"number\">9.3</span>, <span class=\"keyword\">in</span>: [<span class=\"number\">3.14159</span>, <span class=\"number\">0.1</span>, <span class=\"number\">0.25</span>])</div><div class=\"line\"><span class=\"comment\">// doubleIndex is an optional Int with no value, because 9.3 is not in the array</span></div><div class=\"line\"><span class=\"keyword\">let</span> stringIndex = findIndex(of: <span class=\"string\">\"Andrea\"</span>, <span class=\"keyword\">in</span>: [<span class=\"string\">\"Mike\"</span>, <span class=\"string\">\"Malcolm\"</span>, <span class=\"string\">\"Andrea\"</span>])</div><div class=\"line\"><span class=\"comment\">// stringIndex is an optional Int containing a value of 2</span></div></pre></td></tr></table></figure>\n<h3 id=\"关联类型\"><a href=\"#关联类型\" class=\"headerlink\" title=\"关联类型\"></a>关联类型</h3><p>定义一个协议时，有的时候声明一个或多个关联类型作为协议定义的一部分将会非常有用。关联类型为协议中的某个类型提供了一个占位名（或者说别名），其代表的实际类型在协议被采纳时才会被指定。你可以通过 associatedtype 关键字来指定关联类型。</p>\n<h4 id=\"关联类型实践\"><a href=\"#关联类型实践\" class=\"headerlink\" title=\"关联类型实践\"></a>关联类型实践</h4><p>下面例子定义了一个 Container 协议，该协议定义了一个关联类型 ItemType：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">Container</span> </span>&#123;</div><div class=\"line\">    associatedtype <span class=\"type\">ItemType</span></div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">append</span><span class=\"params\">(<span class=\"number\">_</span> item: ItemType)</span></span></div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">count</span>: <span class=\"type\">Int</span> &#123; <span class=\"keyword\">get</span> &#125;</div><div class=\"line\">    <span class=\"keyword\">subscript</span>(i: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">ItemType</span> &#123; <span class=\"keyword\">get</span> &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Container 协议定义了三个任何采纳了该协议的类型（即容器）必须提供的功能：</p>\n<ul>\n<li>必须可以通过 append(_:) 方法添加一个新元素到容器里。</li>\n<li>必须可以通过 count 属性获取容器中元素的数量，并返回一个 Int 值。</li>\n<li>必须可以通过索引值类型为 Int 的下标检索到容器中的每一个元素。</li>\n</ul>\n<p>这个协议没有指定容器中元素该如何存储，以及元素必须是何种类型。这个协议只指定了三个任何遵从 Container 协议的类型必须提供的功能。遵从协议的类型在满足这三个条件的情况下也可以提供其他额外的功能。</p>\n<p>为了定义这三个条件，Container 协议需要在不知道容器中元素的具体类型的情况下引用这种类型。Container 协议需要指定任何通过 append(_:) 方法添加到容器中的元素和容器中的元素是相同类型，并且通过容器下标返回的元素的类型也是这种类型。</p>\n<p>为了达到这个目的，Container 协议声明了一个关联类型 ItemType，写作 associatedtype ItemType。这个协议无法定义 ItemType 是什么类型的别名，这个信息将留给遵从协议的类型来提供。尽管如此，ItemType 别名提供了一种方式来引用 Container 中元素的类型，并将之用于 append(_:) 方法和下标，从而保证任何 Container 的行为都能够正如预期地被执行。</p>\n<p>下面是先前的非泛型的 IntStack 类型，这一版本采纳并符合了 Container 协议：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">IntStack</span>: <span class=\"title\">Container</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// original IntStack implementation</span></div><div class=\"line\">    <span class=\"keyword\">var</span> items = [<span class=\"type\">Int</span>]()</div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"number\">_</span> item: Int)</span></span> &#123;</div><div class=\"line\">        items.append(item)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">pop</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> items.removeLast()</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// conformance to the Container protocol</span></div><div class=\"line\">    <span class=\"keyword\">typealias</span> <span class=\"type\">ItemType</span> = <span class=\"type\">Int</span></div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">append</span><span class=\"params\">(<span class=\"number\">_</span> item: Int)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.push(item)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">count</span>: <span class=\"type\">Int</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> items.<span class=\"built_in\">count</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">subscript</span>(i: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> items[i]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>IntStack 结构体实现了 Container 协议的三个要求，其原有功能也不会和这些要求相冲突。<br>此外，IntStack 在实现 Container 的要求时，指定 ItemType 为 Int 类型，即 typealias ItemType = Int，从而将 Container 协议中抽象的 ItemType 类型转换为具体的 Int 类型。</p>\n<p>由于 Swift 的类型推断，你实际上不用在 IntStack 的定义中声明 ItemType 为 Int。因为 IntStack 符合 Container 协议的所有要求，Swift 只需通过 append(_:) 方法的 item 参数类型和下标返回值的类型，就可以推断出 ItemType 的具体类型。事实上，如果你在上面的代码中删除了 typealias ItemType = Int 这一行，一切仍旧可以正常工作，因为 Swift 清楚地知道 ItemType 应该是哪种类型。</p>\n<p>你也可以让泛型 Stack 结构体遵从 Container 协议：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Stack</span>&lt;<span class=\"title\">Element</span>&gt;: <span class=\"title\">Container</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// original Stack&lt;Element&gt; implementation</span></div><div class=\"line\">    <span class=\"keyword\">var</span> items = [<span class=\"type\">Element</span>]()</div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"number\">_</span> item: Element)</span></span> &#123;</div><div class=\"line\">        items.append(item)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">pop</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Element</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> items.removeLast()</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// conformance to the Container protocol</span></div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">append</span><span class=\"params\">(<span class=\"number\">_</span> item: Element)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.push(item)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">count</span>: <span class=\"type\">Int</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> items.<span class=\"built_in\">count</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">subscript</span>(i: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Element</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> items[i]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这一次，占位类型参数 Element 被用作 append(_:) 方法的 item 参数和下标的返回类型。Swift 可以据此推断出 Element 的类型即是 ItemType 的类型。</p>\n<h4 id=\"通过扩展一个存在的类型来指定关联类型\"><a href=\"#通过扩展一个存在的类型来指定关联类型\" class=\"headerlink\" title=\"通过扩展一个存在的类型来指定关联类型\"></a>通过扩展一个存在的类型来指定关联类型</h4><p>Swift 的 Array 类型已经提供 append(_:) 方法，一个 count 属性，以及一个接受 Int 类型索引值的下标用以检索其元素。这三个功能都符合 Container 协议的要求，也就意味着你只需简单地声明 Array 采纳该协议就可以扩展 Array，使其遵从 Container 协议。你可以通过一个空扩展来实现这点，正如通过扩展采纳协议中的描述：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Array</span>: <span class=\"title\">Container</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"泛型-Where-语句\"><a href=\"#泛型-Where-语句\" class=\"headerlink\" title=\"泛型 Where 语句\"></a>泛型 Where 语句</h3><p>类型约束让你能够为泛型函数或泛型类型的类型参数定义一些强制要求。</p>\n<p>为关联类型定义约束也是非常有用的。你可以在参数列表中通过 where 子句为关联类型定义约束。你能通过 where 子句要求一个关联类型遵从某个特定的协议，以及某个特定的类型参数和关联类型必须类型相同。你可以通过将 where 关键字紧跟在类型参数列表后面来定义 where 子句，where 子句后跟一个或者多个针对关联类型的约束，以及一个或多个类型参数和关联类型间的相等关系。你可以在函数体或者类型的大括号之前添加 where 子句。</p>\n<p>下面的例子定义了一个名为 allItemsMatch 的泛型函数，用来检查两个 Container 实例是否包含相同顺序的相同元素。如果所有的元素能够匹配，那么返回 true，否则返回 false。<br>被检查的两个 Container 可以不是相同类型的容器（虽然它们可以相同），但它们必须拥有相同类型的元素。这个要求通过一个类型约束以及一个 where 子句来表示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">allItemsMatch</span>&lt;C1: Container, C2: Container&gt;</span></div><div class=\"line\"><span class=\"function\">    <span class=\"params\">(<span class=\"number\">_</span> someContainer: C1, <span class=\"number\">_</span> anotherContainer: C2)</span></span> -&gt; <span class=\"type\">Bool</span></div><div class=\"line\">    <span class=\"keyword\">where</span> <span class=\"type\">C1</span>.<span class=\"type\">ItemType</span> == <span class=\"type\">C2</span>.<span class=\"type\">ItemType</span>, <span class=\"type\">C1</span>.<span class=\"type\">ItemType</span>: <span class=\"type\">Equatable</span> &#123;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// Check that both containers contain the same number of items.</span></div><div class=\"line\">        <span class=\"keyword\">if</span> someContainer.<span class=\"built_in\">count</span> != anotherContainer.<span class=\"built_in\">count</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// Check each pair of items to see if they are equivalent.</span></div><div class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;someContainer.<span class=\"built_in\">count</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> someContainer[i] != anotherContainer[i] &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">// All items match, so return true.</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下面演示了 allItemsMatch(<em>:</em>:) 函数的使用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> stackOfStrings = <span class=\"type\">Stack</span>&lt;<span class=\"type\">String</span>&gt;()</div><div class=\"line\">stackOfStrings.push(<span class=\"string\">\"uno\"</span>)</div><div class=\"line\">stackOfStrings.push(<span class=\"string\">\"dos\"</span>)</div><div class=\"line\">stackOfStrings.push(<span class=\"string\">\"tres\"</span>)</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">var</span> arrayOfStrings = [<span class=\"string\">\"uno\"</span>, <span class=\"string\">\"dos\"</span>, <span class=\"string\">\"tres\"</span>]</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">if</span> allItemsMatch(stackOfStrings, arrayOfStrings) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"All items match.\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Not all items match.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"All items match.\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html/\" target=\"_blank\" rel=\"external\"> Protocols </a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>"},{"layout":"post","title":"Swift Inheritance","date":"2016-11-25T16:20:11.000Z","author":"liangtong","catalog":true,"_content":"\n\n\n​\t一个类可以继承另一个类的方法，属性和其它特性。当一个类继承其它类时，继承类叫子类，被继承类叫超类（或父类）。在 Swift 中，继承是区分「类」与其它类型的一个基本特征。\n在 Swift 中，类可以调用和访问超类的方法，属性和下标，并且可以重写这些方法，属性和下标来优化或修改它们的行为。Swift 会检查你的重写定义在超类中是否有匹配的定义，以此确保你的重写行为是正确的。\n可以为类中继承来的属性添加属性观察器，这样一来，当属性值改变时，类就会被通知到。可以为任何属性添加属性观察器，无论它原本被定义为存储型属性还是计算型属性。\n\n\n\n### 基类\n不继承于其它类的类，称之为基类。\n\tSwift 中的类并不是从一个通用的基类继承而来。如果你不为你定义的类指定一个超类的话，这个类就自动成为基类。\n\n下面的例子定义了一个叫Vehicle的基类。包含一个currentSpeed存储属性，一个description的只读计算属性，一个makeNoise方法，方法什么都不做，子类会重写该方法。\n\n```Swift\nclass Vehicle {\n    var currentSpeed = 0.0\n    var description: String {\n        return \"traveling at \\(currentSpeed) miles per hour\"\n    }\n    func makeNoise() {\n        // do nothing - an arbitrary vehicle doesn't necessarily make a noise\n    }\n}\n```\n\n<!-- more -->\n\n实例化对象，并访问其属性：\n\n```Swift\nlet someVehicle = Vehicle()\n\nprint(\"Vehicle: \\(someVehicle.description)\")\n// Vehicle: traveling at 0.0 miles per hour\n```\n\n### 子类\n子类是在一个已有类的基础上创建一个新的类，你可以重新定义子类继承已有类的特性，也可以为子类添加新特性来完善子类。类继承使用冒号分割，将超类写在冒号后边：\n\n```Swift\nclass SomeSubclass: SomeSuperclass {\n    // subclass definition goes here\n}\n```\n\n下一个例子，定义一个叫Bicycle的子类，继承成父类Vehicle：\n\n```Swift\nclass Bicycle: Vehicle {\n    var hasBasket = false\n}\n```\n\n新的Bicycle类自动获得Vehicle类的所有特性，Bicycle类还定义了一个默认值为false的存储型属性hasBasket（属性推断为Bool）。\n\n```Swift\nlet bicycle = Bicycle()\nbicycle.hasBasket = true\n\nbicycle.currentSpeed = 15.0\nprint(\"Bicycle: \\(bicycle.description)\")\n// Bicycle: traveling at 15.0 miles per hour\n```\n\n子类还可以继续被其它类继承，下面的示例为Bicycle创建了一个名为Tandem（双人自行车）的子类：\n\n```Swift\nclass Tandem: Bicycle {\n    var currentNumberOfPassengers = 0\n}\n\nlet tandem = Tandem()\ntandem.hasBasket = true\ntandem.currentNumberOfPassengers = 2\ntandem.currentSpeed = 22.0\nprint(\"Tandem: \\(tandem.description)\")\n// Tandem: traveling at 22.0 miles per hour\n```\n\n### 重写\n子类可以为继承来的实例方法，类方法，实例属性，或下标提供自己定制的实现。我们把这种行为叫重写。\n如果要重写某个特性，你需要在重写定义的前面加上 `override` 关键字。这么做，你就表明了你是想提供一个重写版本，而非错误地提供了一个相同的定义。任何缺少override关键字的重写都会在编译时被诊断为错误。override关键字会提醒 Swift 编译器去检查该类的超类（或其中一个父类）是否有匹配重写版本的声明。这个检查可以确保你的重写定义是正确的。\n\n#### 访问超类的方法，属性及下标\n当你在子类中重写超类的方法，属性或下标时，有时在你的重写版本中使用已经存在的超类实现会大有裨益。比如，你可以完善已有实现的行为，或在一个继承来的变量中存储一个修改过的值。\n你可以通过使用 `super` 前缀来访问超类版本的方法，属性或下标：\n\n * 在方法someMethod()的重写实现中，可以通过super.someMethod()来调用超类版本的someMethod()方法。\n * 在属性someProperty的 getter 或 setter 的重写实现中，可以通过super.someProperty来访问超类版本的someProperty属性。\n * 在下标的重写实现中，可以通过super[someIndex]来访问超类版本中的相同下标。\n\n#### 重写方法\n在子类中，你可以重写继承来的实例方法或类方法，提供一个定制或替代的方法实现。\n下面的例子定义了Vehicle的一个新的子类，叫Train，它重写了从Vehicle类继承来的makeNoise()方法：\n\n```Swift\nclass Train: Vehicle {\n    override func makeNoise() {\n        print(\"Choo Choo\")\n    }\n}\n\nlet train = Train()\ntrain.makeNoise()\n// Prints \"Choo Choo\"\n```\n\n#### 重写属性\n你可以重写继承来的实例属性或类型属性，提供自己定制的 getter 和 setter，或添加属性观察器使重写的属性可以观察属性值什么时候发生改变。\n\n##### 重写属性的 Getters 和 Setters\n你可以提供定制的 getter（或 setter）来重写任意继承来的属性，无论继承来的属性是存储型的还是计算型的属性。子类并不知道继承来的属性是存储型的还是计算型的，它只知道继承来的属性会有一个名字和类型。你在重写一个属性时，必需将它的名字和类型都写出来。这样才能使编译器去检查你重写的属性是与超类中同名同类型的属性相匹配的。\n你可以将一个继承来的只读属性重写为一个读写属性，只需要在重写版本的属性里提供 getter 和 setter 即可。但是，你不可以将一个继承来的读写属性重写为一个只读属性。\n\t如果你在重写属性中提供了 setter，那么你也一定要提供 getter。如果你不想在重写版本中的 getter 里修改继承来的属性值，你可以直接通过super.someProperty来返回继承来的值，其中someProperty是你要重写的属性的名字。\n\n以下的例子定义了一个新类，叫Car，它是Vehicle的子类。这个类引入了一个新的存储型属性叫做gear，默认值为整数1。Car类重写了继承自Vehicle的description属性，提供包含当前档位的自定义描述：\n\n```Swift\nclass Car: Vehicle {\n    var gear = 1\n    override var description: String {\n        return super.description + \" in gear \\(gear)\"\n    }\n}\n```\n\n如果你创建了Car的实例并且设置了它的gear和currentSpeed属性，你可以看到它的description返回了Car中的自定义描述：\n\n```Swift\nlet car = Car()\ncar.currentSpeed = 25.0\ncar.gear = 3\nprint(\"Car: \\(car.description)\")\n// Car: traveling at 25.0 miles per hour in gear 3\n```\n\n##### 重写属性观察器\n你可以通过重写属性为一个继承来的属性添加属性观察器。这样一来，当继承来的属性值发生改变时，你就会被通知到，无论那个属性原本是如何实现的。\n\t你不可以为继承来的常量存储型属性或继承来的只读计算型属性添加属性观察器。这些属性的值是不可以被设置的，所以，为它们提供willSet或didSet实现是不恰当。\n此外还要注意，你不可以同时提供重写的 setter 和重写的属性观察器。如果你想观察属性值的变化，并且你已经为那个属性提供了定制的 setter，那么你在 setter 中就可以观察到任何值变化了。\n\n下面的例子定义了一个新类叫AutomaticCar，它是Car的子类。AutomaticCar表示自动挡汽车，它可以根据当前的速度自动选择合适的挡位:\n\n```Swift\nclass AutomaticCar: Car {\n    override var currentSpeed: Double {\n        didSet {\n            gear = Int(currentSpeed / 10.0) + 1\n        }\n    }\n}\n\nlet automatic = AutomaticCar()\nautomatic.currentSpeed = 35.0\nprint(\"AutomaticCar: \\(automatic.description)\")\n// AutomaticCar: traveling at 35.0 miles per hour in gear 4\n```\n\n### 防止重写\n你可以通过把方法，属性或下标标记为final来防止它们被重写，只需要在声明关键字前加上 `final` 修饰符即可（例如：final var，final func，final class func，以及final subscript）。\n\n如果你重写了带有 `final` 标记的方法，属性或下标，在编译时会报错。在类扩展中的方法，属性或下标也可以在扩展的定义里标记为 `final` 的。\n\n你可以通过在关键字 `class` 前添加 `final` 修饰符（final class）来将整个类标记为 `final` 的。这样的类是不可被继承的，试图继承这样的类会导致编译报错。\n\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Inheritance.html/\"> Inheritance </a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","source":"_posts/iOS_Swift_language_note_Inheritance.md","raw":"---\nlayout:     post\ntitle:      Swift Inheritance\ndate:       2016-11-26 00:20:11\nauthor:     liangtong\ncatalog: true\ncategories: iOS\ntags: Swift \n\n---\n\n\n\n​\t一个类可以继承另一个类的方法，属性和其它特性。当一个类继承其它类时，继承类叫子类，被继承类叫超类（或父类）。在 Swift 中，继承是区分「类」与其它类型的一个基本特征。\n在 Swift 中，类可以调用和访问超类的方法，属性和下标，并且可以重写这些方法，属性和下标来优化或修改它们的行为。Swift 会检查你的重写定义在超类中是否有匹配的定义，以此确保你的重写行为是正确的。\n可以为类中继承来的属性添加属性观察器，这样一来，当属性值改变时，类就会被通知到。可以为任何属性添加属性观察器，无论它原本被定义为存储型属性还是计算型属性。\n\n\n\n### 基类\n不继承于其它类的类，称之为基类。\n\tSwift 中的类并不是从一个通用的基类继承而来。如果你不为你定义的类指定一个超类的话，这个类就自动成为基类。\n\n下面的例子定义了一个叫Vehicle的基类。包含一个currentSpeed存储属性，一个description的只读计算属性，一个makeNoise方法，方法什么都不做，子类会重写该方法。\n\n```Swift\nclass Vehicle {\n    var currentSpeed = 0.0\n    var description: String {\n        return \"traveling at \\(currentSpeed) miles per hour\"\n    }\n    func makeNoise() {\n        // do nothing - an arbitrary vehicle doesn't necessarily make a noise\n    }\n}\n```\n\n<!-- more -->\n\n实例化对象，并访问其属性：\n\n```Swift\nlet someVehicle = Vehicle()\n\nprint(\"Vehicle: \\(someVehicle.description)\")\n// Vehicle: traveling at 0.0 miles per hour\n```\n\n### 子类\n子类是在一个已有类的基础上创建一个新的类，你可以重新定义子类继承已有类的特性，也可以为子类添加新特性来完善子类。类继承使用冒号分割，将超类写在冒号后边：\n\n```Swift\nclass SomeSubclass: SomeSuperclass {\n    // subclass definition goes here\n}\n```\n\n下一个例子，定义一个叫Bicycle的子类，继承成父类Vehicle：\n\n```Swift\nclass Bicycle: Vehicle {\n    var hasBasket = false\n}\n```\n\n新的Bicycle类自动获得Vehicle类的所有特性，Bicycle类还定义了一个默认值为false的存储型属性hasBasket（属性推断为Bool）。\n\n```Swift\nlet bicycle = Bicycle()\nbicycle.hasBasket = true\n\nbicycle.currentSpeed = 15.0\nprint(\"Bicycle: \\(bicycle.description)\")\n// Bicycle: traveling at 15.0 miles per hour\n```\n\n子类还可以继续被其它类继承，下面的示例为Bicycle创建了一个名为Tandem（双人自行车）的子类：\n\n```Swift\nclass Tandem: Bicycle {\n    var currentNumberOfPassengers = 0\n}\n\nlet tandem = Tandem()\ntandem.hasBasket = true\ntandem.currentNumberOfPassengers = 2\ntandem.currentSpeed = 22.0\nprint(\"Tandem: \\(tandem.description)\")\n// Tandem: traveling at 22.0 miles per hour\n```\n\n### 重写\n子类可以为继承来的实例方法，类方法，实例属性，或下标提供自己定制的实现。我们把这种行为叫重写。\n如果要重写某个特性，你需要在重写定义的前面加上 `override` 关键字。这么做，你就表明了你是想提供一个重写版本，而非错误地提供了一个相同的定义。任何缺少override关键字的重写都会在编译时被诊断为错误。override关键字会提醒 Swift 编译器去检查该类的超类（或其中一个父类）是否有匹配重写版本的声明。这个检查可以确保你的重写定义是正确的。\n\n#### 访问超类的方法，属性及下标\n当你在子类中重写超类的方法，属性或下标时，有时在你的重写版本中使用已经存在的超类实现会大有裨益。比如，你可以完善已有实现的行为，或在一个继承来的变量中存储一个修改过的值。\n你可以通过使用 `super` 前缀来访问超类版本的方法，属性或下标：\n\n * 在方法someMethod()的重写实现中，可以通过super.someMethod()来调用超类版本的someMethod()方法。\n * 在属性someProperty的 getter 或 setter 的重写实现中，可以通过super.someProperty来访问超类版本的someProperty属性。\n * 在下标的重写实现中，可以通过super[someIndex]来访问超类版本中的相同下标。\n\n#### 重写方法\n在子类中，你可以重写继承来的实例方法或类方法，提供一个定制或替代的方法实现。\n下面的例子定义了Vehicle的一个新的子类，叫Train，它重写了从Vehicle类继承来的makeNoise()方法：\n\n```Swift\nclass Train: Vehicle {\n    override func makeNoise() {\n        print(\"Choo Choo\")\n    }\n}\n\nlet train = Train()\ntrain.makeNoise()\n// Prints \"Choo Choo\"\n```\n\n#### 重写属性\n你可以重写继承来的实例属性或类型属性，提供自己定制的 getter 和 setter，或添加属性观察器使重写的属性可以观察属性值什么时候发生改变。\n\n##### 重写属性的 Getters 和 Setters\n你可以提供定制的 getter（或 setter）来重写任意继承来的属性，无论继承来的属性是存储型的还是计算型的属性。子类并不知道继承来的属性是存储型的还是计算型的，它只知道继承来的属性会有一个名字和类型。你在重写一个属性时，必需将它的名字和类型都写出来。这样才能使编译器去检查你重写的属性是与超类中同名同类型的属性相匹配的。\n你可以将一个继承来的只读属性重写为一个读写属性，只需要在重写版本的属性里提供 getter 和 setter 即可。但是，你不可以将一个继承来的读写属性重写为一个只读属性。\n\t如果你在重写属性中提供了 setter，那么你也一定要提供 getter。如果你不想在重写版本中的 getter 里修改继承来的属性值，你可以直接通过super.someProperty来返回继承来的值，其中someProperty是你要重写的属性的名字。\n\n以下的例子定义了一个新类，叫Car，它是Vehicle的子类。这个类引入了一个新的存储型属性叫做gear，默认值为整数1。Car类重写了继承自Vehicle的description属性，提供包含当前档位的自定义描述：\n\n```Swift\nclass Car: Vehicle {\n    var gear = 1\n    override var description: String {\n        return super.description + \" in gear \\(gear)\"\n    }\n}\n```\n\n如果你创建了Car的实例并且设置了它的gear和currentSpeed属性，你可以看到它的description返回了Car中的自定义描述：\n\n```Swift\nlet car = Car()\ncar.currentSpeed = 25.0\ncar.gear = 3\nprint(\"Car: \\(car.description)\")\n// Car: traveling at 25.0 miles per hour in gear 3\n```\n\n##### 重写属性观察器\n你可以通过重写属性为一个继承来的属性添加属性观察器。这样一来，当继承来的属性值发生改变时，你就会被通知到，无论那个属性原本是如何实现的。\n\t你不可以为继承来的常量存储型属性或继承来的只读计算型属性添加属性观察器。这些属性的值是不可以被设置的，所以，为它们提供willSet或didSet实现是不恰当。\n此外还要注意，你不可以同时提供重写的 setter 和重写的属性观察器。如果你想观察属性值的变化，并且你已经为那个属性提供了定制的 setter，那么你在 setter 中就可以观察到任何值变化了。\n\n下面的例子定义了一个新类叫AutomaticCar，它是Car的子类。AutomaticCar表示自动挡汽车，它可以根据当前的速度自动选择合适的挡位:\n\n```Swift\nclass AutomaticCar: Car {\n    override var currentSpeed: Double {\n        didSet {\n            gear = Int(currentSpeed / 10.0) + 1\n        }\n    }\n}\n\nlet automatic = AutomaticCar()\nautomatic.currentSpeed = 35.0\nprint(\"AutomaticCar: \\(automatic.description)\")\n// AutomaticCar: traveling at 35.0 miles per hour in gear 4\n```\n\n### 防止重写\n你可以通过把方法，属性或下标标记为final来防止它们被重写，只需要在声明关键字前加上 `final` 修饰符即可（例如：final var，final func，final class func，以及final subscript）。\n\n如果你重写了带有 `final` 标记的方法，属性或下标，在编译时会报错。在类扩展中的方法，属性或下标也可以在扩展的定义里标记为 `final` 的。\n\n你可以通过在关键字 `class` 前添加 `final` 修饰符（final class）来将整个类标记为 `final` 的。这样的类是不可被继承的，试图继承这样的类会导致编译报错。\n\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Inheritance.html/\"> Inheritance </a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","slug":"iOS_Swift_language_note_Inheritance","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4uf0038oko8exqiibtb","content":"<p>​    一个类可以继承另一个类的方法，属性和其它特性。当一个类继承其它类时，继承类叫子类，被继承类叫超类（或父类）。在 Swift 中，继承是区分「类」与其它类型的一个基本特征。<br>在 Swift 中，类可以调用和访问超类的方法，属性和下标，并且可以重写这些方法，属性和下标来优化或修改它们的行为。Swift 会检查你的重写定义在超类中是否有匹配的定义，以此确保你的重写行为是正确的。<br>可以为类中继承来的属性添加属性观察器，这样一来，当属性值改变时，类就会被通知到。可以为任何属性添加属性观察器，无论它原本被定义为存储型属性还是计算型属性。</p>\n<h3 id=\"基类\"><a href=\"#基类\" class=\"headerlink\" title=\"基类\"></a>基类</h3><p>不继承于其它类的类，称之为基类。<br>    Swift 中的类并不是从一个通用的基类继承而来。如果你不为你定义的类指定一个超类的话，这个类就自动成为基类。</p>\n<p>下面的例子定义了一个叫Vehicle的基类。包含一个currentSpeed存储属性，一个description的只读计算属性，一个makeNoise方法，方法什么都不做，子类会重写该方法。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vehicle</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> currentSpeed = <span class=\"number\">0.0</span></div><div class=\"line\">    <span class=\"keyword\">var</span> description: <span class=\"type\">String</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"traveling at <span class=\"subst\">\\(currentSpeed)</span> miles per hour\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeNoise</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"comment\">// do nothing - an arbitrary vehicle doesn't necessarily make a noise</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>实例化对象，并访问其属性：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> someVehicle = <span class=\"type\">Vehicle</span>()</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Vehicle: <span class=\"subst\">\\(someVehicle.description)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Vehicle: traveling at 0.0 miles per hour</span></div></pre></td></tr></table></figure>\n<h3 id=\"子类\"><a href=\"#子类\" class=\"headerlink\" title=\"子类\"></a>子类</h3><p>子类是在一个已有类的基础上创建一个新的类，你可以重新定义子类继承已有类的特性，也可以为子类添加新特性来完善子类。类继承使用冒号分割，将超类写在冒号后边：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeSubclass</span>: <span class=\"title\">SomeSuperclass</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// subclass definition goes here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下一个例子，定义一个叫Bicycle的子类，继承成父类Vehicle：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bicycle</span>: <span class=\"title\">Vehicle</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> hasBasket = <span class=\"literal\">false</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>新的Bicycle类自动获得Vehicle类的所有特性，Bicycle类还定义了一个默认值为false的存储型属性hasBasket（属性推断为Bool）。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> bicycle = <span class=\"type\">Bicycle</span>()</div><div class=\"line\">bicycle.hasBasket = <span class=\"literal\">true</span></div><div class=\"line\"></div><div class=\"line\">bicycle.currentSpeed = <span class=\"number\">15.0</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Bicycle: <span class=\"subst\">\\(bicycle.description)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Bicycle: traveling at 15.0 miles per hour</span></div></pre></td></tr></table></figure>\n<p>子类还可以继续被其它类继承，下面的示例为Bicycle创建了一个名为Tandem（双人自行车）的子类：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tandem</span>: <span class=\"title\">Bicycle</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> currentNumberOfPassengers = <span class=\"number\">0</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> tandem = <span class=\"type\">Tandem</span>()</div><div class=\"line\">tandem.hasBasket = <span class=\"literal\">true</span></div><div class=\"line\">tandem.currentNumberOfPassengers = <span class=\"number\">2</span></div><div class=\"line\">tandem.currentSpeed = <span class=\"number\">22.0</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Tandem: <span class=\"subst\">\\(tandem.description)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Tandem: traveling at 22.0 miles per hour</span></div></pre></td></tr></table></figure>\n<h3 id=\"重写\"><a href=\"#重写\" class=\"headerlink\" title=\"重写\"></a>重写</h3><p>子类可以为继承来的实例方法，类方法，实例属性，或下标提供自己定制的实现。我们把这种行为叫重写。<br>如果要重写某个特性，你需要在重写定义的前面加上 <code>override</code> 关键字。这么做，你就表明了你是想提供一个重写版本，而非错误地提供了一个相同的定义。任何缺少override关键字的重写都会在编译时被诊断为错误。override关键字会提醒 Swift 编译器去检查该类的超类（或其中一个父类）是否有匹配重写版本的声明。这个检查可以确保你的重写定义是正确的。</p>\n<h4 id=\"访问超类的方法，属性及下标\"><a href=\"#访问超类的方法，属性及下标\" class=\"headerlink\" title=\"访问超类的方法，属性及下标\"></a>访问超类的方法，属性及下标</h4><p>当你在子类中重写超类的方法，属性或下标时，有时在你的重写版本中使用已经存在的超类实现会大有裨益。比如，你可以完善已有实现的行为，或在一个继承来的变量中存储一个修改过的值。<br>你可以通过使用 <code>super</code> 前缀来访问超类版本的方法，属性或下标：</p>\n<ul>\n<li>在方法someMethod()的重写实现中，可以通过super.someMethod()来调用超类版本的someMethod()方法。</li>\n<li>在属性someProperty的 getter 或 setter 的重写实现中，可以通过super.someProperty来访问超类版本的someProperty属性。</li>\n<li>在下标的重写实现中，可以通过super[someIndex]来访问超类版本中的相同下标。</li>\n</ul>\n<h4 id=\"重写方法\"><a href=\"#重写方法\" class=\"headerlink\" title=\"重写方法\"></a>重写方法</h4><p>在子类中，你可以重写继承来的实例方法或类方法，提供一个定制或替代的方法实现。<br>下面的例子定义了Vehicle的一个新的子类，叫Train，它重写了从Vehicle类继承来的makeNoise()方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Train</span>: <span class=\"title\">Vehicle</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeNoise</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Choo Choo\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> train = <span class=\"type\">Train</span>()</div><div class=\"line\">train.makeNoise()</div><div class=\"line\"><span class=\"comment\">// Prints \"Choo Choo\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"重写属性\"><a href=\"#重写属性\" class=\"headerlink\" title=\"重写属性\"></a>重写属性</h4><p>你可以重写继承来的实例属性或类型属性，提供自己定制的 getter 和 setter，或添加属性观察器使重写的属性可以观察属性值什么时候发生改变。</p>\n<h5 id=\"重写属性的-Getters-和-Setters\"><a href=\"#重写属性的-Getters-和-Setters\" class=\"headerlink\" title=\"重写属性的 Getters 和 Setters\"></a>重写属性的 Getters 和 Setters</h5><p>你可以提供定制的 getter（或 setter）来重写任意继承来的属性，无论继承来的属性是存储型的还是计算型的属性。子类并不知道继承来的属性是存储型的还是计算型的，它只知道继承来的属性会有一个名字和类型。你在重写一个属性时，必需将它的名字和类型都写出来。这样才能使编译器去检查你重写的属性是与超类中同名同类型的属性相匹配的。<br>你可以将一个继承来的只读属性重写为一个读写属性，只需要在重写版本的属性里提供 getter 和 setter 即可。但是，你不可以将一个继承来的读写属性重写为一个只读属性。<br>    如果你在重写属性中提供了 setter，那么你也一定要提供 getter。如果你不想在重写版本中的 getter 里修改继承来的属性值，你可以直接通过super.someProperty来返回继承来的值，其中someProperty是你要重写的属性的名字。</p>\n<p>以下的例子定义了一个新类，叫Car，它是Vehicle的子类。这个类引入了一个新的存储型属性叫做gear，默认值为整数1。Car类重写了继承自Vehicle的description属性，提供包含当前档位的自定义描述：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Car</span>: <span class=\"title\">Vehicle</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> gear = <span class=\"number\">1</span></div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">var</span> description: <span class=\"type\">String</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.description + <span class=\"string\">\" in gear <span class=\"subst\">\\(gear)</span>\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果你创建了Car的实例并且设置了它的gear和currentSpeed属性，你可以看到它的description返回了Car中的自定义描述：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> car = <span class=\"type\">Car</span>()</div><div class=\"line\">car.currentSpeed = <span class=\"number\">25.0</span></div><div class=\"line\">car.gear = <span class=\"number\">3</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Car: <span class=\"subst\">\\(car.description)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Car: traveling at 25.0 miles per hour in gear 3</span></div></pre></td></tr></table></figure>\n<h5 id=\"重写属性观察器\"><a href=\"#重写属性观察器\" class=\"headerlink\" title=\"重写属性观察器\"></a>重写属性观察器</h5><p>你可以通过重写属性为一个继承来的属性添加属性观察器。这样一来，当继承来的属性值发生改变时，你就会被通知到，无论那个属性原本是如何实现的。<br>    你不可以为继承来的常量存储型属性或继承来的只读计算型属性添加属性观察器。这些属性的值是不可以被设置的，所以，为它们提供willSet或didSet实现是不恰当。<br>此外还要注意，你不可以同时提供重写的 setter 和重写的属性观察器。如果你想观察属性值的变化，并且你已经为那个属性提供了定制的 setter，那么你在 setter 中就可以观察到任何值变化了。</p>\n<p>下面的例子定义了一个新类叫AutomaticCar，它是Car的子类。AutomaticCar表示自动挡汽车，它可以根据当前的速度自动选择合适的挡位:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AutomaticCar</span>: <span class=\"title\">Car</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">var</span> currentSpeed: <span class=\"type\">Double</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">didSet</span> &#123;</div><div class=\"line\">            gear = <span class=\"type\">Int</span>(currentSpeed / <span class=\"number\">10.0</span>) + <span class=\"number\">1</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> automatic = <span class=\"type\">AutomaticCar</span>()</div><div class=\"line\">automatic.currentSpeed = <span class=\"number\">35.0</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"AutomaticCar: <span class=\"subst\">\\(automatic.description)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// AutomaticCar: traveling at 35.0 miles per hour in gear 4</span></div></pre></td></tr></table></figure>\n<h3 id=\"防止重写\"><a href=\"#防止重写\" class=\"headerlink\" title=\"防止重写\"></a>防止重写</h3><p>你可以通过把方法，属性或下标标记为final来防止它们被重写，只需要在声明关键字前加上 <code>final</code> 修饰符即可（例如：final var，final func，final class func，以及final subscript）。</p>\n<p>如果你重写了带有 <code>final</code> 标记的方法，属性或下标，在编译时会报错。在类扩展中的方法，属性或下标也可以在扩展的定义里标记为 <code>final</code> 的。</p>\n<p>你可以通过在关键字 <code>class</code> 前添加 <code>final</code> 修饰符（final class）来将整个类标记为 <code>final</code> 的。这样的类是不可被继承的，试图继承这样的类会导致编译报错。</p>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Inheritance.html/\" target=\"_blank\" rel=\"external\"> Inheritance </a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>​    一个类可以继承另一个类的方法，属性和其它特性。当一个类继承其它类时，继承类叫子类，被继承类叫超类（或父类）。在 Swift 中，继承是区分「类」与其它类型的一个基本特征。<br>在 Swift 中，类可以调用和访问超类的方法，属性和下标，并且可以重写这些方法，属性和下标来优化或修改它们的行为。Swift 会检查你的重写定义在超类中是否有匹配的定义，以此确保你的重写行为是正确的。<br>可以为类中继承来的属性添加属性观察器，这样一来，当属性值改变时，类就会被通知到。可以为任何属性添加属性观察器，无论它原本被定义为存储型属性还是计算型属性。</p>\n<h3 id=\"基类\"><a href=\"#基类\" class=\"headerlink\" title=\"基类\"></a>基类</h3><p>不继承于其它类的类，称之为基类。<br>    Swift 中的类并不是从一个通用的基类继承而来。如果你不为你定义的类指定一个超类的话，这个类就自动成为基类。</p>\n<p>下面的例子定义了一个叫Vehicle的基类。包含一个currentSpeed存储属性，一个description的只读计算属性，一个makeNoise方法，方法什么都不做，子类会重写该方法。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vehicle</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> currentSpeed = <span class=\"number\">0.0</span></div><div class=\"line\">    <span class=\"keyword\">var</span> description: <span class=\"type\">String</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"traveling at <span class=\"subst\">\\(currentSpeed)</span> miles per hour\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeNoise</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"comment\">// do nothing - an arbitrary vehicle doesn't necessarily make a noise</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","more":"<p>实例化对象，并访问其属性：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> someVehicle = <span class=\"type\">Vehicle</span>()</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Vehicle: <span class=\"subst\">\\(someVehicle.description)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Vehicle: traveling at 0.0 miles per hour</span></div></pre></td></tr></table></figure>\n<h3 id=\"子类\"><a href=\"#子类\" class=\"headerlink\" title=\"子类\"></a>子类</h3><p>子类是在一个已有类的基础上创建一个新的类，你可以重新定义子类继承已有类的特性，也可以为子类添加新特性来完善子类。类继承使用冒号分割，将超类写在冒号后边：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeSubclass</span>: <span class=\"title\">SomeSuperclass</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// subclass definition goes here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下一个例子，定义一个叫Bicycle的子类，继承成父类Vehicle：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bicycle</span>: <span class=\"title\">Vehicle</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> hasBasket = <span class=\"literal\">false</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>新的Bicycle类自动获得Vehicle类的所有特性，Bicycle类还定义了一个默认值为false的存储型属性hasBasket（属性推断为Bool）。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> bicycle = <span class=\"type\">Bicycle</span>()</div><div class=\"line\">bicycle.hasBasket = <span class=\"literal\">true</span></div><div class=\"line\"></div><div class=\"line\">bicycle.currentSpeed = <span class=\"number\">15.0</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Bicycle: <span class=\"subst\">\\(bicycle.description)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Bicycle: traveling at 15.0 miles per hour</span></div></pre></td></tr></table></figure>\n<p>子类还可以继续被其它类继承，下面的示例为Bicycle创建了一个名为Tandem（双人自行车）的子类：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tandem</span>: <span class=\"title\">Bicycle</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> currentNumberOfPassengers = <span class=\"number\">0</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> tandem = <span class=\"type\">Tandem</span>()</div><div class=\"line\">tandem.hasBasket = <span class=\"literal\">true</span></div><div class=\"line\">tandem.currentNumberOfPassengers = <span class=\"number\">2</span></div><div class=\"line\">tandem.currentSpeed = <span class=\"number\">22.0</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Tandem: <span class=\"subst\">\\(tandem.description)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Tandem: traveling at 22.0 miles per hour</span></div></pre></td></tr></table></figure>\n<h3 id=\"重写\"><a href=\"#重写\" class=\"headerlink\" title=\"重写\"></a>重写</h3><p>子类可以为继承来的实例方法，类方法，实例属性，或下标提供自己定制的实现。我们把这种行为叫重写。<br>如果要重写某个特性，你需要在重写定义的前面加上 <code>override</code> 关键字。这么做，你就表明了你是想提供一个重写版本，而非错误地提供了一个相同的定义。任何缺少override关键字的重写都会在编译时被诊断为错误。override关键字会提醒 Swift 编译器去检查该类的超类（或其中一个父类）是否有匹配重写版本的声明。这个检查可以确保你的重写定义是正确的。</p>\n<h4 id=\"访问超类的方法，属性及下标\"><a href=\"#访问超类的方法，属性及下标\" class=\"headerlink\" title=\"访问超类的方法，属性及下标\"></a>访问超类的方法，属性及下标</h4><p>当你在子类中重写超类的方法，属性或下标时，有时在你的重写版本中使用已经存在的超类实现会大有裨益。比如，你可以完善已有实现的行为，或在一个继承来的变量中存储一个修改过的值。<br>你可以通过使用 <code>super</code> 前缀来访问超类版本的方法，属性或下标：</p>\n<ul>\n<li>在方法someMethod()的重写实现中，可以通过super.someMethod()来调用超类版本的someMethod()方法。</li>\n<li>在属性someProperty的 getter 或 setter 的重写实现中，可以通过super.someProperty来访问超类版本的someProperty属性。</li>\n<li>在下标的重写实现中，可以通过super[someIndex]来访问超类版本中的相同下标。</li>\n</ul>\n<h4 id=\"重写方法\"><a href=\"#重写方法\" class=\"headerlink\" title=\"重写方法\"></a>重写方法</h4><p>在子类中，你可以重写继承来的实例方法或类方法，提供一个定制或替代的方法实现。<br>下面的例子定义了Vehicle的一个新的子类，叫Train，它重写了从Vehicle类继承来的makeNoise()方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Train</span>: <span class=\"title\">Vehicle</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">makeNoise</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Choo Choo\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> train = <span class=\"type\">Train</span>()</div><div class=\"line\">train.makeNoise()</div><div class=\"line\"><span class=\"comment\">// Prints \"Choo Choo\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"重写属性\"><a href=\"#重写属性\" class=\"headerlink\" title=\"重写属性\"></a>重写属性</h4><p>你可以重写继承来的实例属性或类型属性，提供自己定制的 getter 和 setter，或添加属性观察器使重写的属性可以观察属性值什么时候发生改变。</p>\n<h5 id=\"重写属性的-Getters-和-Setters\"><a href=\"#重写属性的-Getters-和-Setters\" class=\"headerlink\" title=\"重写属性的 Getters 和 Setters\"></a>重写属性的 Getters 和 Setters</h5><p>你可以提供定制的 getter（或 setter）来重写任意继承来的属性，无论继承来的属性是存储型的还是计算型的属性。子类并不知道继承来的属性是存储型的还是计算型的，它只知道继承来的属性会有一个名字和类型。你在重写一个属性时，必需将它的名字和类型都写出来。这样才能使编译器去检查你重写的属性是与超类中同名同类型的属性相匹配的。<br>你可以将一个继承来的只读属性重写为一个读写属性，只需要在重写版本的属性里提供 getter 和 setter 即可。但是，你不可以将一个继承来的读写属性重写为一个只读属性。<br>    如果你在重写属性中提供了 setter，那么你也一定要提供 getter。如果你不想在重写版本中的 getter 里修改继承来的属性值，你可以直接通过super.someProperty来返回继承来的值，其中someProperty是你要重写的属性的名字。</p>\n<p>以下的例子定义了一个新类，叫Car，它是Vehicle的子类。这个类引入了一个新的存储型属性叫做gear，默认值为整数1。Car类重写了继承自Vehicle的description属性，提供包含当前档位的自定义描述：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Car</span>: <span class=\"title\">Vehicle</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> gear = <span class=\"number\">1</span></div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">var</span> description: <span class=\"type\">String</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.description + <span class=\"string\">\" in gear <span class=\"subst\">\\(gear)</span>\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果你创建了Car的实例并且设置了它的gear和currentSpeed属性，你可以看到它的description返回了Car中的自定义描述：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> car = <span class=\"type\">Car</span>()</div><div class=\"line\">car.currentSpeed = <span class=\"number\">25.0</span></div><div class=\"line\">car.gear = <span class=\"number\">3</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Car: <span class=\"subst\">\\(car.description)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Car: traveling at 25.0 miles per hour in gear 3</span></div></pre></td></tr></table></figure>\n<h5 id=\"重写属性观察器\"><a href=\"#重写属性观察器\" class=\"headerlink\" title=\"重写属性观察器\"></a>重写属性观察器</h5><p>你可以通过重写属性为一个继承来的属性添加属性观察器。这样一来，当继承来的属性值发生改变时，你就会被通知到，无论那个属性原本是如何实现的。<br>    你不可以为继承来的常量存储型属性或继承来的只读计算型属性添加属性观察器。这些属性的值是不可以被设置的，所以，为它们提供willSet或didSet实现是不恰当。<br>此外还要注意，你不可以同时提供重写的 setter 和重写的属性观察器。如果你想观察属性值的变化，并且你已经为那个属性提供了定制的 setter，那么你在 setter 中就可以观察到任何值变化了。</p>\n<p>下面的例子定义了一个新类叫AutomaticCar，它是Car的子类。AutomaticCar表示自动挡汽车，它可以根据当前的速度自动选择合适的挡位:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AutomaticCar</span>: <span class=\"title\">Car</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">var</span> currentSpeed: <span class=\"type\">Double</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">didSet</span> &#123;</div><div class=\"line\">            gear = <span class=\"type\">Int</span>(currentSpeed / <span class=\"number\">10.0</span>) + <span class=\"number\">1</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> automatic = <span class=\"type\">AutomaticCar</span>()</div><div class=\"line\">automatic.currentSpeed = <span class=\"number\">35.0</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"AutomaticCar: <span class=\"subst\">\\(automatic.description)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// AutomaticCar: traveling at 35.0 miles per hour in gear 4</span></div></pre></td></tr></table></figure>\n<h3 id=\"防止重写\"><a href=\"#防止重写\" class=\"headerlink\" title=\"防止重写\"></a>防止重写</h3><p>你可以通过把方法，属性或下标标记为final来防止它们被重写，只需要在声明关键字前加上 <code>final</code> 修饰符即可（例如：final var，final func，final class func，以及final subscript）。</p>\n<p>如果你重写了带有 <code>final</code> 标记的方法，属性或下标，在编译时会报错。在类扩展中的方法，属性或下标也可以在扩展的定义里标记为 <code>final</code> 的。</p>\n<p>你可以通过在关键字 <code>class</code> 前添加 <code>final</code> 修饰符（final class）来将整个类标记为 <code>final</code> 的。这样的类是不可被继承的，试图继承这样的类会导致编译报错。</p>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Inheritance.html/\" target=\"_blank\" rel=\"external\"> Inheritance </a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>"},{"layout":"post","title":"Swift Initialization","date":"2016-11-26T16:20:11.000Z","author":"liangtong","catalog":true,"_content":"\n\n\n​\t构造过程是使用类、结构体、枚举的实例之前的准备过程。具体操作包括设置实例中每个存储型属性的初始值和执行其他必须的设置或初始化工作。在新实例可用前必须执行这个过程。\n通过定义构造器来实现构造过程，这些构造器可以看做是用来创建特定类型新实例的特殊方法。与 Objective-C 中的构造器不同，Swift 的构造器无需返回值，它们的主要任务是保证新实例在第一次使用前完成正确的初始化。\n类的实例也可以通过定义析构器在实例释放之前执行特定的清除工作。\n\n\n\n### 存储属性的初始化值\n类和结构体在创建实例时，必须为所有存储型属性设置合适的初始值。存储型属性的值不能处于一个未知的状态。你可以在构造器中为存储型属性赋初值，也可以在定义属性时为其设置默认值。\n\t为存储型属性设置默认值或者在构造器中为其赋值时，它们的值是被直接设置的，不会触发任何属性观察者。\n\n<!-- more -->\n\n#### 构造器\n构造器在创建某个特定类型的新实例时被调用。它的最简形式类似于一个不带任何参数的实例方法，以关键字 `init` 命名：\n\n```Swift\ninit() {\n    // perform some initialization here\n}\n```\n\n下面例子中定义了一个用来保存华氏温度的结构体Fahrenheit，它拥有一个Double类型的存储型属性temperature：\n\n```Swift\nstruct Fahrenheit {\n    var temperature: Double\n    init() {\n        temperature = 32.0\n    }\n}\nvar f = Fahrenheit()\nprint(\"The default temperature is \\(f.temperature)° Fahrenheit\")\n// Prints \"The default temperature is 32.0° Fahrenheit\"\n```\n\n#### 默认属性值\n可以在构造器中为存储型属性设置初始值。也可以在属性声明时为其设置默认值。\n\t如果一个属性总是使用相同的初始值，那么为其设置一个默认值比每次都在构造器中赋值要好。两种方法的效果是一样的，只不过使用默认值让属性的初始化和声明结合得更紧密。使用默认值能让你的构造器更简洁、更清晰，且能通过默认值自动推导出属性的类型；同时，它也能让你充分利用默认构造器、构造器继承等特性。\n\n你可以使用更简单的方式在定义结构体Fahrenheit时为属性temperature设置默认值：\n\n```Swift\nstruct Fahrenheit {\n    var temperature = 32.0\n}\n```\n\n### 自定义构造函数\n可以通过输入参数和可选类型的属性来自定义构造过程，也可以在构造过程中修改 ` 常量 ` 属性。\n\n#### 构造参数\n可以在构造器定义中提供构造参数，指定所需值的类型和名字。构造参数的功能和语法跟函数和方法的参数相同。\n下面例子中定义了一个包含摄氏度温度的结构体Celsius。它定义了两个不同的构造器：init(fromFahrenheit:)和init(fromKelvin:)，二者分别通过接受不同温标下的温度值来创建新的实例：\n\n```Swift\nstruct Celsius {\n    var temperatureInCelsius: Double\n    init(fromFahrenheit fahrenheit: Double) {\n        temperatureInCelsius = (fahrenheit - 32.0) / 1.8\n    }\n    init(fromKelvin kelvin: Double) {\n        temperatureInCelsius = kelvin - 273.15\n    }\n}\nlet boilingPointOfWater = Celsius(fromFahrenheit: 212.0)\n// boilingPointOfWater.temperatureInCelsius is 100.0\nlet freezingPointOfWater = Celsius(fromKelvin: 273.15)\n// freezingPointOfWater.temperatureInCelsius is 0.0\n```\n\n#### 参数的参数名和标签名(内部名称和外部名称)\n跟函数和方法参数相同，构造参数也拥有一个在构造器内部使用的参数名字和一个在调用构造器时使用的外部参数名字（标签名）。\n构造器并不像函数和方法那样在括号前有一个可辨别的名字（只有init）。因此在调用构造器时，主要通过构造器中的参数名和类型来确定应该被调用的构造器。正因为参数如此重要，如果你在定义构造器时没有提供参数的外部名字，Swift 会为构造器的每个参数自动生成一个跟内部名字相同的外部名。\n\n以下例子中定义了一个结构体Color，它包含了三个常量：red、green和blue。这些属性可以存储0.0到1.0之间的值，用来指示颜色中红、绿、蓝成分的含量。Color提供了一个构造器，其中包含三个Double类型的构造参数。Color也可以提供第二个构造器，它只包含名为white的Double类型的参数，它被用于给上述三个构造参数赋予同样的值。\n\n```Swift\nstruct Color {\n    let red, green, blue: Double\n    init(red: Double, green: Double, blue: Double) {\n        self.red   = red\n        self.green = green\n        self.blue  = blue\n    }\n    init(white: Double) {\n        red   = white\n        green = white\n        blue  = white\n    }\n}\n\nlet magenta = Color(red: 1.0, green: 0.0, blue: 1.0)\nlet halfGray = Color(white: 0.5)\n```\n\n\t如果不通过外部参数名字传值，你是没法调用这个构造器的。只要构造器定义了某个外部参数名，你就必须使用它，忽略它将导致编译错误：\n\n\n```Swift\nlet veryGreen = Color(0.0, 1.0, 0.0)\n// this reports a compile-time error - argument labels are required\n```\n\n#### 不带标签（外部名）的构造器参数\n如果你不希望为构造器的某个参数提供外部名字，你可以使用下划线(`_`)来显式描述它的外部名，以此重写上面所说的默认行为。\n\n下面是之前Celsius例子的扩展，跟之前相比添加了一个带有Double类型参数的构造器，其外部名用_代替。调用Celsius(37.0)意图明确，不需要外部参数名称。因此适合使用init(_ celsius: Double)这样的构造器，从而可以通过提供Double类型的参数值调用构造器，而不需要加上外部名。：\n\n```Swift\nstruct Celsius {\n    var temperatureInCelsius: Double\n    init(fromFahrenheit fahrenheit: Double) {\n        temperatureInCelsius = (fahrenheit - 32.0) / 1.8\n    }\n    init(fromKelvin kelvin: Double) {\n        temperatureInCelsius = kelvin - 273.15\n    }\n    init(_ celsius: Double) {\n        temperatureInCelsius = celsius\n    }\n}\nlet bodyTemperature = Celsius(37.0)\n// bodyTemperature.temperatureInCelsius is 37.0\n```\n\n#### 可选属性类型\n如果你定制的类型包含一个逻辑上允许取值为空的存储型属性，你都需要将它定义为可选类型。可选类型的属性将自动初始化为nil，表示这个属性是有意在初始化时设置为空的。\n\n```Swift\nclass SurveyQuestion {\n    var text: String\n    var response: String?\n    init(text: String) {\n        self.text = text\n    }\n    func ask() {\n        print(text)\n    }\n}\nlet cheeseQuestion = SurveyQuestion(text: \"Do you like cheese?\")\ncheeseQuestion.ask()\n// Prints \"Do you like cheese?\"\ncheeseQuestion.response = \"Yes, I do like cheese.\"\n```\n\n#### 构造过程中常量属性的修改\n你可以在构造过程中的任意时间点给常量属性指定一个值，只要在构造过程结束时是一个确定的值。一旦常量属性被赋值，它将永远不可更改。\n\t对于类的实例来说，它的常量属性只能在定义它的类的构造过程中修改；不能在子类中修改。\n\n你可以修改上面的SurveyQuestion示例，用常量属性替代变量属性text，表示问题内容text在SurveyQuestion的实例被创建之后不会再被修改。尽管text属性现在是常量，我们仍然可以在类的构造器中设置它的值：\n\n```Swift\nclass SurveyQuestion {\n    let text: String\n    var response: String?\n    init(text: String) {\n        self.text = text\n    }\n    func ask() {\n        print(text)\n    }\n}\nlet beetsQuestion = SurveyQuestion(text: \"How about beets?\")\nbeetsQuestion.ask()\n// Prints \"How about beets?\"\nbeetsQuestion.response = \"I also like beets. (But not with cheese.)\"\n```\n\n### 默认构造器\n如果结构体或类的所有属性都有默认值，同时没有自定义的构造器，那么 Swift 会给这些结构体或类提供一个默认构造器（default initializers）。这个默认构造器将简单地创建一个所有属性值都设置为默认值的实例。\n\n下面例子中创建了一个类ShoppingListItem，它封装了购物清单中的某一物品的属性：名字（name）、数量（quantity）和购买状态 purchase state：\n\n```Swift\nclass ShoppingListItem {\n    var name: String?\n    var quantity = 1\n    var purchased = false\n}\nvar item = ShoppingListItem()\n```\n\n#### 结构体的逐一成员构造器\n除了上面提到的默认构造器，如果结构体没有提供自定义的构造器，它们将自动获得一个逐一成员构造器，即使结构体的存储型属性没有默认值。\n\n逐一成员构造器是用来初始化结构体新实例里成员属性的快捷方法。我们在调用逐一成员构造器时，通过与成员属性名相同的参数名进行传值来完成对成员属性的初始赋值。\n\n```Swift\nstruct Size {\n    var width = 0.0, height = 0.0\n}\nlet twoByTwo = Size(width: 2.0, height: 2.0)\n```\n\n### 值类型的构造器代理\n构造器可以通过调用其它构造器来完成实例的部分构造过程。这一过程称为构造器代理，它能减少多个构造器间的代码重复。\n\n构造器代理的实现规则和形式在值类型和类类型中有所不同。值类型（结构体和枚举类型）不支持继承，所以构造器代理的过程相对简单，因为它们只能代理给自己的其它构造器。类则不同，它可以继承自其它类，这意味着类有责任保证其所有继承的存储型属性在构造时也能正确的初始化。\n\n对于值类型，你可以使用self.init在自定义的构造器中引用相同类型中的其它构造器。并且你只能在构造器内部调用self.init。\n\t如果你为某个值类型定义了一个自定义的构造器，你将无法访问到默认构造器（如果是结构体，还将无法访问逐一成员构造器）。假如你希望默认构造器、逐一成员构造器以及你自己的自定义构造器都能用来创建实例，可以将自定义的构造器写到扩展（extension）中，而不是写在值类型的原始定义中。\n\n```Swift\nstruct Size {\n    var width = 0.0, height = 0.0\n}\nstruct Point {\n    var x = 0.0, y = 0.0\n}\n\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n    init() {}\n    init(origin: Point, size: Size) {\n        self.origin = origin\n        self.size = size\n    }\n    init(center: Point, size: Size) {\n        let originX = center.x - (size.width / 2)\n        let originY = center.y - (size.height / 2)\n        self.init(origin: Point(x: originX, y: originY), size: size)\n    }\n}\n```\n\n以上代码中，3中构造方法方式如下：\n\n```Swift\nlet basicRect = Rect()\n// basicRect's origin is (0.0, 0.0) and its size is (0.0, 0.0)\n\nlet originRect = Rect(origin: Point(x: 2.0, y: 2.0),\n                      size: Size(width: 5.0, height: 5.0))\n// originRect's origin is (2.0, 2.0) and its size is (5.0, 5.0)\n\nlet centerRect = Rect(center: Point(x: 4.0, y: 4.0),\n                      size: Size(width: 3.0, height: 3.0))\n// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)\n```\n\n\t如果你想用另外一种不需要自己定义init()和init(origin:size:)的方式来实现这个例子，可以通过扩展（Extensions）实现\n\n### 类的继承和构造过程\n类里面的所有存储型属性都必须在构造过程中设置初始值，包括所有继承自父类的属性。\nSwift 为类类型提供了两种构造器来确保实例中所有存储型属性都能获得初始值，它们分别是指定构造器和便利构造器。\n\n#### 指定构造器和便利构造器\n指定构造器是类中最主要的构造器。一个指定构造器将初始化类中提供的所有属性，并根据父类链往上调用父类的构造器来实现父类的初始化。一般情况下，类通常只有一个指定构造器。\n每一个类都必须拥有至少一个指定构造器。在某些情况下，许多类通过继承了父类中的指定构造器而满足了这个条件。\n\n便利构造器是类中比较次要的、辅助型的构造器。你可以定义便利构造器来调用同一个类中的指定构造器，并为其参数提供默认值。你也可以定义便利构造器来创建一个特殊用途或特定输入值的实例。\n便利构造器不是必需的。只在必要的时候为类提供便利构造器，比方说某种情况下通过使用便利构造器来快捷调用某个指定构造器，能够节省更多开发时间并让类的构造过程更清晰明了。\n\n#### 指定构造器和便利构造器的语法\n类的指定构造器的写法跟值类型简单构造器一样：\n\n```Swift\ninit(parameters) {\n    statements\n}\n```\n\n便利构造器也采用相同样式的写法，但需要在 `init` 关键字之前放置 `convenience` 关键字，并使用空格将它们俩分开：\n\n```Swift\nconvenience init(parameters) {\n    statements\n}\n```\n\n#### 类的构造器代理规则\n为了简化指定构造器和便利构造器之间的调用关系，Swift 采用以下三条规则来限制构造器之间的代理调用：\n\n * 指定构造器必须调用其直接父类的的指定构造器。\n * 便利构造器必须调用同类中定义的其它构造器。\n * 便利构造器必须最终导致一个指定构造器被调用。\n\n可以通过如下方法进行记忆：\n\n * 指定构造器必须总是向上代理\n * 便利构造器必须总是横向代理\n\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializerDelegation01_2x.png)\n\n下面图例中展示了一种涉及四个类的更复杂的类层级结构。它演示了指定构造器是如何在类层级中充当“管道”的作用，在类的构造器链上简化了类之间的相互关系。\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializerDelegation02_2x.png)\n\n#### 两段式构造过程\nSwift 中类的构造过程包含两个阶段。第一个阶段，每个存储型属性被引入它们的类指定一个初始值。当每个存储型属性的初始值被确定后，第二阶段开始，它给每个类一次机会，在新实例准备使用之前进一步定制它们的存储型属性。\n\n两段式构造过程的使用让构造过程更安全，同时在整个类层级结构中给予了每个类完全的灵活性。两段式构造过程可以防止属性值在初始化之前被访问，也可以防止属性被另外一个构造器意外地赋予不同的值。\n\n > 说明白点儿就是：第一阶段是使用内存的申请与属性的初始化，第二阶段是属性的初始化赋值。\n\tSwift 的两段式构造过程跟 Objective-C 中的构造过程类似。最主要的区别在于阶段 1，Objective-C 给每一个属性赋值0或空值（比如说0或nil）。Swift 的构造流程则更加灵活，它允许你设置定制的初始值，并自如应对某些属性不能以0或nil作为合法默认值的情况。\n\nSwift 编译器将执行 4 种有效的安全检查，以确保两段式构造过程能不出错地完成：\n\n * 安全检查 1\n\t* 指定构造器必须保证它所在类引入的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类中的构造器。\n\t如上所述，一个对象的内存只有在其所有存储型属性确定之后才能完全初始化。为了满足这一规则，指定构造器必须保证它所在类引入的属性在它往上代理之前先完成初始化。\n * 安全检查 2\n\t* 指定构造器必须先向上代理调用父类构造器，然后再为继承的属性设置新值。如果没这么做，指定构造器赋予的新值将被父类中的构造器所覆盖。\n * 安全检查 3\n\t* 指便利构造器必须先代理调用同一类中的其它构造器，然后再为任意属性赋新值。如果没这么做，便利构造器赋予的新值将被同一类中其它指定构造器所覆盖。\n * 安全检查 4\n\t* 构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用self作为一个值。\n\n类实例在第一阶段结束以前并不是完全有效的。只有第一阶段完成后，该实例才会成为有效实例，才能访问属性和调用方法。\n\n以下是两段式构造过程中基于上述安全检查的构造流程展示：\n\n * 阶段 1\n\t* 某个指定构造器或便利构造器被调用。\n\t* 完成新实例内存的分配，但此时内存还没有被初始化。\n\t* 指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化。\n\t* 指定构造器将调用父类的构造器，完成父类属性的初始化。\n\t* 这个调用父类构造器的过程沿着构造器链一直往上执行，直到到达构造器链的最顶部。\n\t* 当到达了构造器链最顶部，且已确保所有实例包含的存储型属性都已经赋值，这个实例的内存被认为已经完全初始化。此时阶段 1 完成。\n * 阶段 2\n\t* 从顶部构造器链一直往下，每个构造器链中类的指定构造器都有机会进一步定制实例。构造器此时可以访问self、修改它的属性并调用实例方法等等。\n\t* 最终，任意构造器链中的便利构造器可以有机会定制实例和使用self。\n\n下图展示了在假定的子类和父类之间的构造阶段 1：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/twoPhaseInitialization01_2x.png)\n在这个例子中，构造过程从对子类中一个便利构造器的调用开始。这个便利构造器此时没法修改任何属性，它把构造任务代理给同一类中的指定构造器。\n如安全检查 1 所示，指定构造器将确保所有子类的属性都有值。然后它将调用父类的指定构造器，并沿着构造器链一直往上完成父类的构造过程。\n父类中的指定构造器确保所有父类的属性都有值。由于没有更多的父类需要初始化，也就无需继续向上代理。一旦父类中所有属性都有了初始值，实例的内存被认为是完全初始化，阶段 1 完成。\n\n以下展示了相同构造过程的阶段 2：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/twoPhaseInitialization02_2x.png)\n父类中的指定构造器现在有机会进一步来定制实例（尽管这不是必须的）。\n一旦父类中的指定构造器完成调用，子类中的指定构造器可以执行更多的定制操作（这也不是必须的）。\n最终，一旦子类的指定构造器完成调用，最开始被调用的便利构造器可以执行更多的定制操作。\n\n#### 构造器的继承和重写\n跟 Objective-C 中的子类不同，Swift 中的子类默认情况下不会继承父类的构造器。Swift 的这种机制可以防止一个父类的简单构造器被一个更精细的子类继承，并被错误地用来创建子类的实例。\n\t父类的构造器仅会在安全和适当的情况下被继承。\n\n假如你希望自定义的子类中能提供一个或多个跟父类相同的构造器，你可以在子类中提供这些构造器的自定义实现。\n当你在编写一个和父类中指定构造器相匹配的子类构造器时，你实际上是在重写父类的这个指定构造器。因此，你必须在定义子类构造器时带上 `override` 修饰符。即使你重写的是系统自动提供的默认构造器，也需要带上override修饰符。\n正如重写属性，方法或者是下标，override修饰符会让编译器去检查父类中是否有相匹配的指定构造器，并验证构造器参数是否正确。\n\t当你重写一个父类的指定构造器时，你总是需要写override修饰符，即使你的子类将父类的指定构造器重写为了便利构造器。\n\n如果你编写了一个和父类便利构造器相匹配的子类构造器，由于子类不能直接调用父类的便利构造器（每个规则都在上文类的构造器代理规则有所描述）。因此，严格意义上来讲，你的子类并未对一个父类构造器提供重写。最后的结果就是，你在子类中“重写”一个父类便利构造器时，不需要加override前缀。\n\n在下面的例子中定义了一个叫Vehicle的基类。基类中声明了一个存储型属性numberOfWheels，它是值为0的Int类型的存储型属性。numberOfWheels属性用于创建名为descrpiption的String类型的计算型属性：\n\n```Swift\nclass Vehicle {\n    var numberOfWheels = 0\n    var description: String {\n        return \"\\(numberOfWheels) wheel(s)\"\n    }\n}\n\nlet vehicle = Vehicle()\nprint(\"Vehicle: \\(vehicle.description)\")\n// Vehicle: 0 wheel(s)\n```\n\n下面例子中定义了一个Vehicle的子类Bicycle：\n\n```Swift\nclass Bicycle: Vehicle {\n    override init() {\n        super.init()\n        numberOfWheels = 2\n    }\n}\n\nlet bicycle = Bicycle()\nprint(\"Bicycle: \\(bicycle.description)\")\n// Bicycle: 2 wheel(s)\n```\n\n子类Bicycle定义了一个自定义指定构造器init()。这个指定构造器和父类的指定构造器相匹配，所以Bicycle中的指定构造器需要带上override修饰符。\nBicycle的构造器init()以调用super.init()方法开始，这个方法的作用是调用Bicycle的父类Vehicle的默认构造器。这样可以确保Bicycle在修改属性之前，它所继承的属性numberOfWheels能被Vehicle类初始化。在调用super.init()之后，属性numberOfWheels的原值被新值2替换。\n\t子类可以在初始化时修改继承来的变量属性，但是不能修改继承来的常量属性。\n\n\n#### 构造器的自动继承\n如上所述，子类在默认情况下不会继承父类的构造器。但是如果满足特定条件，父类构造器是可以被自动继承的。在实践中，这意味着对于许多常见场景你不必重写父类的构造器，并且可以在安全的情况下以最小的代价继承父类的构造器。\n假设你为子类中引入的所有新属性都提供了默认值，以下 2 个规则适用：\n\n * 规则 1\n\t* 如果子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。\n * 规则 2\n\t* 如果子类提供了所有父类指定构造器的实现——无论是通过规则 1 继承过来的，还是提供了自定义实现——它将自动继承所有父类的便利构造器。\n\n即使你在子类中添加了更多的便利构造器，这两条规则仍然适用。\n\t对于规则 2，子类可以将父类的指定构造器实现为便利构造器。\n\n\n#### 指定构造器和便利构造器实践\n接下来的例子将在实践中展示指定构造器、便利构造器以及构造器的自动继承。这个例子定义了包含三个类Food、RecipeIngredient以及ShoppingListItem的类层次结构，并将演示它们的构造器是如何相互作用的。\n类层次中的基类是Food，它是一个简单的用来封装食物名字的类。Food类引入了一个叫做name的String类型的属性，并且提供了两个构造器来创建Food实例：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializersExample01_2x.png)\n```Swift\nclass Food {\n    var name: String\n    init(name: String) {\n        self.name = name\n    }\n    convenience init() {\n        self.init(name: \"[Unnamed]\")\n    }\n}\n```\n\n类没有默认的逐一成员构造器，所以Food类提供了一个接受单一参数name的指定构造器。这个构造器可以使用一个特定的名字来创建新的Food实例。同样提供了一个没有参数的便利构造器init()。这个init()构造器为新食物提供了一个默认的占位名字，通过横向代理到指定构造器init(name: String)并给参数name传值[Unnamed]来实现：\n\n```Swift\nlet namedMeat = Food(name: \"Bacon\")\n// namedMeat's name is \"Bacon\"\n\nlet mysteryMeat = Food()\n// mysteryMeat's name is \"[Unnamed]\"\n```\n\n类层级中的第二个类是Food的子类RecipeIngredient。RecipeIngredient类用来表示食谱中的一项原料。它引入了Int类型的属性quantity（以及从Food继承过来的name属性），并且定义了两个构造器来创建RecipeIngredient实例：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializersExample02_2x.png)\n```Swift\nclass RecipeIngredient: Food {\n    var quantity: Int\n    init(name: String, quantity: Int) {\n        self.quantity = quantity\n        super.init(name: name)\n    }\n    override convenience init(name: String) {\n        self.init(name: name, quantity: 1)\n    }\n}\n```\n\nRecipeIngredient类拥有一个指定构造器init(name: String, quantity: Int)，它可以用来填充RecipeIngredient实例的所有属性值。这个构造器一开始先将传入的quantity参数赋值给quantity属性，这个属性也是唯一在RecipeIngredient中新引入的属性。随后，构造器向上代理到父类Food的init(name: String)。这个过程满足两段式构造过程中的安全检查 1。\n\nRecipeIngredient还定义了一个便利构造器init(name: String)，它只通过name来创建RecipeIngredient的实例。这个便利构造器假设任意RecipeIngredient实例的quantity为1，所以不需要显式指明数量即可创建出实例。这个便利构造器的定义可以更加方便和快捷地创建实例，并且避免了创建多个quantity为1的RecipeIngredient实例时的代码重复。这个便利构造器只是简单地横向代理到类中的指定构造器，并为quantity参数传递1。\n注意，RecipeIngredient的便利构造器init(name: String)使用了跟Food中指定构造器init(name: String)相同的参数。由于这个便利构造器重写了父类的指定构造器init(name: String)，因此必须在前面使用override修饰符\n\n尽管RecipeIngredient将父类的指定构造器重写为了便利构造器，它依然提供了父类的所有指定构造器的实现。因此，RecipeIngredient会自动继承父类的所有便利构造器。\n在这个例子中，RecipeIngredient的父类是Food，它有一个便利构造器init()。这个便利构造器会被RecipeIngredient继承。这个继承版本的init()在功能上跟Food提供的版本是一样的，只是它会代理到RecipeIngredient版本的init(name: String)而不是Food提供的版本。\n\n所有的这三种构造器都可以用来创建新的RecipeIngredient实例：\n\n```Swift\nlet oneMysteryItem = RecipeIngredient()\nlet oneBacon = RecipeIngredient(name: \"Bacon\")\nlet sixEggs = RecipeIngredient(name: \"Eggs\", quantity: 6)\n```\n\n类层级中第三个也是最后一个类是RecipeIngredient的子类，叫做ShoppingListItem。这个类构建了购物单中出现的某一种食谱原料。\n\n购物单中的每一项总是从未购买状态开始的。为了呈现这一事实，ShoppingListItem引入了一个布尔类型的属性purchased，它的默认值是false。ShoppingListItem还添加了一个计算型属性description，它提供了关于ShoppingListItem实例的一些文字描述：\n\n```Swift\nclass ShoppingListItem: RecipeIngredient {\n    var purchased = false\n    var description: String {\n        var output = \"\\(quantity) x \\(name)\"\n        output += purchased ? \" ✔\" : \" ✘\"\n        return output\n    }\n}\n```\n\n\tShoppingListItem没有定义构造器来为purchased提供初始值，因为添加到购物单的物品的初始状态总是未购买。\n\n由于它为自己引入的所有属性都提供了默认值，并且自己没有定义任何构造器，ShoppingListItem将自动继承所有父类中的指定构造器和便利构造器。\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializersExample03_2x.png)\n你可以使用全部三个继承来的构造器来创建ShoppingListItem的新实例：\n\n```Swift\nvar breakfastList = [\n    ShoppingListItem(),\n    ShoppingListItem(name: \"Bacon\"),\n    ShoppingListItem(name: \"Eggs\", quantity: 6),\n]\nbreakfastList[0].name = \"Orange juice\"\nbreakfastList[0].purchased = true\nfor item in breakfastList {\n    print(item.description)\n}\n// 1 x Orange juice ✔\n// 1 x Bacon ✘\n// 6 x Eggs ✘\n```\n\n### 可失败构造器\n如果一个类、结构体或枚举类型的对象，在构造过程中有可能失败，则为其定义一个可失败构造器。这里所指的“失败”是指，如给构造器传入无效的参数值，或缺少某种所需的外部资源，又或是不满足某种必要的条件等。\n为了妥善处理这种构造过程中可能会失败的情况。你可以在一个类，结构体或是枚举类型的定义中，添加一个或多个可失败构造器。其语法为在 `init` 关键字后面添加问号( `init?` )。\n\t可失败构造器的参数名和参数类型，不能与其它非可失败构造器的参数名，及其参数类型相同。\n\n可失败构造器会创建一个类型为自身类型的可选类型的对象。你通过return nil语句来表明可失败构造器在何种情况下应该“失败”。\n\t严格来说，构造器都不支持返回值。因为构造器本身的作用，只是为了确保对象能被正确构造。因此你只是用return nil表明可失败构造器构造失败，而不要用关键字return来表明构造成功。\n\n下例中，定义了一个名为Animal的结构体，其中有一个名为species的String类型的常量属性。同时该结构体还定义了一个接受一个名为species的String类型参数的可失败构造器。这个可失败构造器检查传入的参数是否为一个空字符串。如果为空字符串，则构造失败。否则，species属性被赋值，构造成功。\n\n```Swift\nstruct Animal {\n    let species: String\n    init?(species: String) {\n        if species.isEmpty { return nil }\n        self.species = species\n    }\n}\n```\n\n你可以通过该可失败构造器来构建一个Animal的实例，并检查构造过程是否成功：\n\n```Swift\nlet someCreature = Animal(species: \"Giraffe\")\n// someCreature is of type Animal?, not Animal\n \nif let giraffe = someCreature {\n    print(\"An animal was initialized with a species of \\(giraffe.species)\")\n}\n// Prints \"An animal was initialized with a species of Giraffe\"\n\n\nlet anonymousCreature = Animal(species: \"\")\n// anonymousCreature is of type Animal?, not Animal\n \nif anonymousCreature == nil {\n    print(\"The anonymous creature could not be initialized\")\n}\n// Prints \"The anonymous creature could not be initialized\"\n```\n\n#### 枚举类型的可失败构造器\n你可以通过一个带一个或多个参数的可失败构造器来获取枚举类型中特定的枚举成员。如果提供的参数无法匹配任何枚举成员，则构造失败。\n\n下例中，定义了一个名为TemperatureUnit的枚举类型。其中包含了三个可能的枚举成员(Kelvin，Celsius，和Fahrenheit)，以及一个根据Character值找出所对应的枚举成员的可失败构造器：\n\n```Swift\nenum TemperatureUnit {\n    case kelvin, celsius, fahrenheit\n    init?(symbol: Character) {\n        switch symbol {\n        case \"K\":\n            self = .kelvin\n        case \"C\":\n            self = .celsius\n        case \"F\":\n            self = .fahrenheit\n        default:\n            return nil\n        }\n    }\n}\n```\n\n你可以利用该可失败构造器在三个枚举成员中获取一个相匹配的枚举成员，当参数的值不能与任何枚举成员相匹配时，则构造失败：\n\n```Swift\nlet fahrenheitUnit = TemperatureUnit(symbol: \"F\")\nif fahrenheitUnit != nil {\n    print(\"This is a defined temperature unit, so initialization succeeded.\")\n}\n// Prints \"This is a defined temperature unit, so initialization succeeded.\"\n \nlet unknownUnit = TemperatureUnit(symbol: \"X\")\nif unknownUnit == nil {\n    print(\"This is not a defined temperature unit, so initialization failed.\")\n}\n// Prints \"This is not a defined temperature unit, so initialization failed.\"\n```\n\n#### 带原始值的枚举类型的可失败构造器\n带原始值的枚举类型会自带一个可失败构造器init?(rawValue:)，该可失败构造器有一个名为rawValue的参数，其类型和枚举类型的原始值类型一致，如果该参数的值能够和某个枚举成员的原始值匹配，则该构造器会构造相应的枚举成员，否则构造失败。\n\n因此上面的TemperatureUnit的例子可以重写为：\n\n```Swift\nenum TemperatureUnit: Character {\n    case kelvin = \"K\", celsius = \"C\", fahrenheit = \"F\"\n}\n \nlet fahrenheitUnit = TemperatureUnit(rawValue: \"F\")\nif fahrenheitUnit != nil {\n    print(\"This is a defined temperature unit, so initialization succeeded.\")\n}\n// Prints \"This is a defined temperature unit, so initialization succeeded.\"\n \nlet unknownUnit = TemperatureUnit(rawValue: \"X\")\nif unknownUnit == nil {\n    print(\"This is not a defined temperature unit, so initialization failed.\")\n}\n// Prints \"This is not a defined temperature unit, so initialization failed.\"\n```\n\n#### 构造失败的传递\n类，结构体，枚举的可失败构造器可以横向代理到类型中的其他可失败构造器。类似的，子类的可失败构造器也能向上代理到父类的可失败构造器。\n无论是向上代理还是横向代理，如果你代理到的其他可失败构造器触发构造失败，整个构造过程将立即终止，接下来的任何构造代码不会再被执行。\n\t可失败构造器也可以代理到其它的非可失败构造器。通过这种方式，你可以增加一个可能的失败状态到现有的构造过程中。\n\n下面这个例子，定义了一个名为CartItem的Product类的子类。这个类建立了一个在线购物车中的物品的模型，它有一个名为quantity的常量存储型属性，并确保该属性的值至少为1：\n\n```Swift\nclass Product {\n    let name: String\n    init?(name: String) {\n        if name.isEmpty { return nil }\n        self.name = name\n    }\n}\n \nclass CartItem: Product {\n    let quantity: Int\n    init?(name: String, quantity: Int) {\n        if quantity < 1 { return nil }\n        self.quantity = quantity\n        super.init(name: name)\n    }\n}\n```\n\nCartItem 可失败构造器首先验证接收的 quantity 值是否大于等于 1 。倘若 quantity 值无效，则立即终止整个构造过程，返回失败结果，且不再执行余下代码。同样地，Product 的可失败构造器首先检查 name 值，假如 name 值为空字符串，则构造器立即执行失败。\n\n如果你通过传入一个非空字符串 name 以及一个值大于等于 1 的 quantity 来创建一个 CartItem 实例，那么构造方法能够成功被执行：\n\n```Swift\nif let twoSocks = CartItem(name: \"sock\", quantity: 2) {\n    print(\"Item: \\(twoSocks.name), quantity: \\(twoSocks.quantity)\")\n}\n// Prints \"Item: sock, quantity: 2\"\n```\n\n倘若你以一个值为 0 的 quantity 来创建一个 CartItem 实例，那么将导致 CartItem 构造器失败：\n\n```Swift\nif let zeroShirts = CartItem(name: \"shirt\", quantity: 0) {\n    print(\"Item: \\(zeroShirts.name), quantity: \\(zeroShirts.quantity)\")\n} else {\n    print(\"Unable to initialize zero shirts\")\n}\n// Prints \"Unable to initialize zero shirts\"\n```\n\n同样地，如果你尝试传入一个值为空字符串的 name来创建一个 CartItem 实例，那么将导致父类 Product 的构造过程失败：\n\n```Swift\nif let oneUnnamed = CartItem(name: \"\", quantity: 1) {\n    print(\"Item: \\(oneUnnamed.name), quantity: \\(oneUnnamed.quantity)\")\n} else {\n    print(\"Unable to initialize one unnamed product\")\n}\n// Prints \"Unable to initialize one unnamed product\"\n```\n\n#### 重写一个可失败构造器\n如同其它的构造器，你可以在子类中重写父类的可失败构造器。或者你也可以用子类的非可失败构造器重写一个父类的可失败构造器。这使你可以定义一个不会构造失败的子类，即使父类的构造器允许构造失败。\n当你用子类的非可失败构造器重写父类的可失败构造器时，向上代理到父类的可失败构造器的唯一方式是对父类的可失败构造器的返回值进行强制解包。\n\t你可以用非可失败构造器重写可失败构造器，但反过来却不行。\n\n下例定义了一个名为Document的类，name属性的值必须为一个非空字符串或nil，但不能是一个空字符串：\n\n```Swift\nclass Document {\n    var name: String?\n    // this initializer creates a document with a nil name value\n    init() {}\n    // this initializer creates a document with a nonempty name value\n    init?(name: String) {\n        if name.isEmpty { return nil }\n        self.name = name\n    }\n}\n```\n\n下面这个例子，定义了一个Document类的子类AutomaticallyNamedDocument。这个子类重写了父类的两个指定构造器，确保了无论是使用init()构造器，还是使用init(name:)构造器并为参数传递空字符串，生成的实例中的name属性总有初始\"[Untitled]\"：\n\n```Swift\nclass AutomaticallyNamedDocument: Document {\n    override init() {\n        super.init()\n        self.name = \"[Untitled]\"\n    }\n    override init(name: String) {\n        super.init()\n        if name.isEmpty {\n            self.name = \"[Untitled]\"\n        } else {\n            self.name = name\n        }\n    }\n}\n```\n\nAutomaticallyNamedDocument用一个非可失败构造器init(name:)重写了父类的可失败构造器init?(name:)。因为子类用另一种方式处理了空字符串的情况，所以不再需要一个可失败构造器，因此子类用一个非可失败构造器代替了父类的可失败构造器。\n\n你可以在子类的非可失败构造器中使用强制解包来调用父类的可失败构造器。比如，下面的UntitledDocument子类的name属性的值总是\"[Untitled]\"，它在构造过程中使用了父类的可失败构造器init?(name:)：\n\n```Swift\nclass UntitledDocument: Document {\n    override init() {\n        super.init(name: \"[Untitled]\")!\n    }\n}\n```\n\n#### 可失败构造器 init!\n通常来说我们通过在init关键字后添加问号的方式（init?）来定义一个可失败构造器，但你也可以通过在init后面添加惊叹号的方式来定义一个可失败构造器（init!），该可失败构造器将会构建一个对应类型的隐式解包可选类型的对象。\n\n你可以在init?中代理到init!，反之亦然。你也可以用init?重写init!，反之亦然。你还可以用init代理到init!，不过，一旦init!构造失败，则会触发一个断言。\n\n### 必要构造器\n在类的构造器前添加 `required` 修饰符表明所有该类的子类都必须实现该构造器：\n\n```Swift\nclass SomeClass {\n    required init() {\n        // initializer implementation goes here\n    }\n}\n```\n\n在子类重写父类的必要构造器时，必须在子类的构造器前也添加required修饰符，表明该构造器要求也应用于继承链后面的子类。在重写父类中必要的指定构造器时，不需要添加override修饰符：\n\n```Swift\nclass SomeSubclass: SomeClass {\n    required init() {\n        // subclass implementation of the required initializer goes here\n    }\n}\n```\n\n\t如果子类继承的构造器能满足必要构造器的要求，则无须在子类中显式提供必要构造器的实现。\n\n\n### 通过闭包或函数设置属性的默认值\n如果某个存储型属性的默认值需要一些定制或设置，你可以使用闭包或全局函数为其提供定制的默认值。每当某个属性所在类型的新实例被创建时，对应的闭包或函数会被调用，而它们的返回值会当做默认值赋值给这个属性。\n这种类型的闭包或函数通常会创建一个跟属性类型相同的临时变量，然后修改它的值以满足预期的初始状态，最后返回这个临时变量，作为属性的默认值。\n\n下面介绍了如何用闭包为属性提供默认值：\n\n```Swift\nclass SomeClass {\n    let someProperty: SomeType = {\n        // create a default value for someProperty inside this closure\n        // someValue must be of the same type as SomeType\n        return someValue\n    }()\n}\n```\n\n注意闭包结尾的大括号后面接了一对空的小括号。这用来告诉 Swift 立即执行此闭包。如果你忽略了这对括号，相当于将闭包本身作为值赋值给了属性，而不是将闭包的返回值赋值给属性。\n\t如果你使用闭包来初始化属性，请记住在闭包执行时，实例的其它部分都还没有初始化。这意味着你不能在闭包里访问其它属性，即使这些属性有默认值。同样，你也不能使用隐式的self属性，或者调用任何实例方法。\n\n下面例子中定义了一个结构体Checkerboard，它构建了西洋跳棋游戏的棋盘：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/chessBoard_2x.png)\n西洋跳棋游戏在一副黑白格交替的10x10的棋盘中进行。为了呈现这副游戏棋盘，Checkerboard结构体定义了一个属性boardColors，它是一个包含100个Bool值的数组。在数组中，值为true的元素表示一个黑格，值为false的元素表示一个白格。数组中第一个元素代表棋盘上左上角的格子，最后一个元素代表棋盘上右下角的格子。\n\nboardColor数组是通过一个闭包来初始化并设置颜色值的：\n\n```Swift\nstruct Chessboard {\n    let boardColors: [Bool] = {\n        var temporaryBoard = [Bool]()\n        var isBlack = false\n        for i in 1...8 {\n            for j in 1...8 {\n                temporaryBoard.append(isBlack)\n                isBlack = !isBlack\n            }\n            isBlack = !isBlack\n        }\n        return temporaryBoard\n    }()\n    func squareIsBlackAt(row: Int, column: Int) -> Bool {\n        return boardColors[(row * 8) + column]\n    }\n}\n```\n\n每当一个新的Checkerboard实例被创建时，赋值闭包会被执行，boardColors的默认值会被计算出来并返回。上面例子中描述的闭包将计算出棋盘中每个格子对应的颜色，并将这些值保存到一个临时数组temporaryBoard中，最后在构建完成时将此数组作为闭包返回值返回。这个返回的数组会保存到boardColors中，并可以通过工具函数squareIsBlackAtRow来查询：\n\n```Swift\nlet board = Chessboard()\nprint(board.squareIsBlackAt(row: 0, column: 1))\n// Prints \"true\"\nprint(board.squareIsBlackAt(row: 7, column: 7))\n// Prints \"false\"\n```\n\n\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html/\"> Initialization </a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","source":"_posts/iOS_Swift_language_note_Initialization.md","raw":"---\nlayout:     post\ntitle:      Swift Initialization\ndate:       2016-11-27 00:20:11\nauthor:     liangtong\ncatalog: true\ncategories: iOS\ntags: Swift \n\n---\n\n\n\n​\t构造过程是使用类、结构体、枚举的实例之前的准备过程。具体操作包括设置实例中每个存储型属性的初始值和执行其他必须的设置或初始化工作。在新实例可用前必须执行这个过程。\n通过定义构造器来实现构造过程，这些构造器可以看做是用来创建特定类型新实例的特殊方法。与 Objective-C 中的构造器不同，Swift 的构造器无需返回值，它们的主要任务是保证新实例在第一次使用前完成正确的初始化。\n类的实例也可以通过定义析构器在实例释放之前执行特定的清除工作。\n\n\n\n### 存储属性的初始化值\n类和结构体在创建实例时，必须为所有存储型属性设置合适的初始值。存储型属性的值不能处于一个未知的状态。你可以在构造器中为存储型属性赋初值，也可以在定义属性时为其设置默认值。\n\t为存储型属性设置默认值或者在构造器中为其赋值时，它们的值是被直接设置的，不会触发任何属性观察者。\n\n<!-- more -->\n\n#### 构造器\n构造器在创建某个特定类型的新实例时被调用。它的最简形式类似于一个不带任何参数的实例方法，以关键字 `init` 命名：\n\n```Swift\ninit() {\n    // perform some initialization here\n}\n```\n\n下面例子中定义了一个用来保存华氏温度的结构体Fahrenheit，它拥有一个Double类型的存储型属性temperature：\n\n```Swift\nstruct Fahrenheit {\n    var temperature: Double\n    init() {\n        temperature = 32.0\n    }\n}\nvar f = Fahrenheit()\nprint(\"The default temperature is \\(f.temperature)° Fahrenheit\")\n// Prints \"The default temperature is 32.0° Fahrenheit\"\n```\n\n#### 默认属性值\n可以在构造器中为存储型属性设置初始值。也可以在属性声明时为其设置默认值。\n\t如果一个属性总是使用相同的初始值，那么为其设置一个默认值比每次都在构造器中赋值要好。两种方法的效果是一样的，只不过使用默认值让属性的初始化和声明结合得更紧密。使用默认值能让你的构造器更简洁、更清晰，且能通过默认值自动推导出属性的类型；同时，它也能让你充分利用默认构造器、构造器继承等特性。\n\n你可以使用更简单的方式在定义结构体Fahrenheit时为属性temperature设置默认值：\n\n```Swift\nstruct Fahrenheit {\n    var temperature = 32.0\n}\n```\n\n### 自定义构造函数\n可以通过输入参数和可选类型的属性来自定义构造过程，也可以在构造过程中修改 ` 常量 ` 属性。\n\n#### 构造参数\n可以在构造器定义中提供构造参数，指定所需值的类型和名字。构造参数的功能和语法跟函数和方法的参数相同。\n下面例子中定义了一个包含摄氏度温度的结构体Celsius。它定义了两个不同的构造器：init(fromFahrenheit:)和init(fromKelvin:)，二者分别通过接受不同温标下的温度值来创建新的实例：\n\n```Swift\nstruct Celsius {\n    var temperatureInCelsius: Double\n    init(fromFahrenheit fahrenheit: Double) {\n        temperatureInCelsius = (fahrenheit - 32.0) / 1.8\n    }\n    init(fromKelvin kelvin: Double) {\n        temperatureInCelsius = kelvin - 273.15\n    }\n}\nlet boilingPointOfWater = Celsius(fromFahrenheit: 212.0)\n// boilingPointOfWater.temperatureInCelsius is 100.0\nlet freezingPointOfWater = Celsius(fromKelvin: 273.15)\n// freezingPointOfWater.temperatureInCelsius is 0.0\n```\n\n#### 参数的参数名和标签名(内部名称和外部名称)\n跟函数和方法参数相同，构造参数也拥有一个在构造器内部使用的参数名字和一个在调用构造器时使用的外部参数名字（标签名）。\n构造器并不像函数和方法那样在括号前有一个可辨别的名字（只有init）。因此在调用构造器时，主要通过构造器中的参数名和类型来确定应该被调用的构造器。正因为参数如此重要，如果你在定义构造器时没有提供参数的外部名字，Swift 会为构造器的每个参数自动生成一个跟内部名字相同的外部名。\n\n以下例子中定义了一个结构体Color，它包含了三个常量：red、green和blue。这些属性可以存储0.0到1.0之间的值，用来指示颜色中红、绿、蓝成分的含量。Color提供了一个构造器，其中包含三个Double类型的构造参数。Color也可以提供第二个构造器，它只包含名为white的Double类型的参数，它被用于给上述三个构造参数赋予同样的值。\n\n```Swift\nstruct Color {\n    let red, green, blue: Double\n    init(red: Double, green: Double, blue: Double) {\n        self.red   = red\n        self.green = green\n        self.blue  = blue\n    }\n    init(white: Double) {\n        red   = white\n        green = white\n        blue  = white\n    }\n}\n\nlet magenta = Color(red: 1.0, green: 0.0, blue: 1.0)\nlet halfGray = Color(white: 0.5)\n```\n\n\t如果不通过外部参数名字传值，你是没法调用这个构造器的。只要构造器定义了某个外部参数名，你就必须使用它，忽略它将导致编译错误：\n\n\n```Swift\nlet veryGreen = Color(0.0, 1.0, 0.0)\n// this reports a compile-time error - argument labels are required\n```\n\n#### 不带标签（外部名）的构造器参数\n如果你不希望为构造器的某个参数提供外部名字，你可以使用下划线(`_`)来显式描述它的外部名，以此重写上面所说的默认行为。\n\n下面是之前Celsius例子的扩展，跟之前相比添加了一个带有Double类型参数的构造器，其外部名用_代替。调用Celsius(37.0)意图明确，不需要外部参数名称。因此适合使用init(_ celsius: Double)这样的构造器，从而可以通过提供Double类型的参数值调用构造器，而不需要加上外部名。：\n\n```Swift\nstruct Celsius {\n    var temperatureInCelsius: Double\n    init(fromFahrenheit fahrenheit: Double) {\n        temperatureInCelsius = (fahrenheit - 32.0) / 1.8\n    }\n    init(fromKelvin kelvin: Double) {\n        temperatureInCelsius = kelvin - 273.15\n    }\n    init(_ celsius: Double) {\n        temperatureInCelsius = celsius\n    }\n}\nlet bodyTemperature = Celsius(37.0)\n// bodyTemperature.temperatureInCelsius is 37.0\n```\n\n#### 可选属性类型\n如果你定制的类型包含一个逻辑上允许取值为空的存储型属性，你都需要将它定义为可选类型。可选类型的属性将自动初始化为nil，表示这个属性是有意在初始化时设置为空的。\n\n```Swift\nclass SurveyQuestion {\n    var text: String\n    var response: String?\n    init(text: String) {\n        self.text = text\n    }\n    func ask() {\n        print(text)\n    }\n}\nlet cheeseQuestion = SurveyQuestion(text: \"Do you like cheese?\")\ncheeseQuestion.ask()\n// Prints \"Do you like cheese?\"\ncheeseQuestion.response = \"Yes, I do like cheese.\"\n```\n\n#### 构造过程中常量属性的修改\n你可以在构造过程中的任意时间点给常量属性指定一个值，只要在构造过程结束时是一个确定的值。一旦常量属性被赋值，它将永远不可更改。\n\t对于类的实例来说，它的常量属性只能在定义它的类的构造过程中修改；不能在子类中修改。\n\n你可以修改上面的SurveyQuestion示例，用常量属性替代变量属性text，表示问题内容text在SurveyQuestion的实例被创建之后不会再被修改。尽管text属性现在是常量，我们仍然可以在类的构造器中设置它的值：\n\n```Swift\nclass SurveyQuestion {\n    let text: String\n    var response: String?\n    init(text: String) {\n        self.text = text\n    }\n    func ask() {\n        print(text)\n    }\n}\nlet beetsQuestion = SurveyQuestion(text: \"How about beets?\")\nbeetsQuestion.ask()\n// Prints \"How about beets?\"\nbeetsQuestion.response = \"I also like beets. (But not with cheese.)\"\n```\n\n### 默认构造器\n如果结构体或类的所有属性都有默认值，同时没有自定义的构造器，那么 Swift 会给这些结构体或类提供一个默认构造器（default initializers）。这个默认构造器将简单地创建一个所有属性值都设置为默认值的实例。\n\n下面例子中创建了一个类ShoppingListItem，它封装了购物清单中的某一物品的属性：名字（name）、数量（quantity）和购买状态 purchase state：\n\n```Swift\nclass ShoppingListItem {\n    var name: String?\n    var quantity = 1\n    var purchased = false\n}\nvar item = ShoppingListItem()\n```\n\n#### 结构体的逐一成员构造器\n除了上面提到的默认构造器，如果结构体没有提供自定义的构造器，它们将自动获得一个逐一成员构造器，即使结构体的存储型属性没有默认值。\n\n逐一成员构造器是用来初始化结构体新实例里成员属性的快捷方法。我们在调用逐一成员构造器时，通过与成员属性名相同的参数名进行传值来完成对成员属性的初始赋值。\n\n```Swift\nstruct Size {\n    var width = 0.0, height = 0.0\n}\nlet twoByTwo = Size(width: 2.0, height: 2.0)\n```\n\n### 值类型的构造器代理\n构造器可以通过调用其它构造器来完成实例的部分构造过程。这一过程称为构造器代理，它能减少多个构造器间的代码重复。\n\n构造器代理的实现规则和形式在值类型和类类型中有所不同。值类型（结构体和枚举类型）不支持继承，所以构造器代理的过程相对简单，因为它们只能代理给自己的其它构造器。类则不同，它可以继承自其它类，这意味着类有责任保证其所有继承的存储型属性在构造时也能正确的初始化。\n\n对于值类型，你可以使用self.init在自定义的构造器中引用相同类型中的其它构造器。并且你只能在构造器内部调用self.init。\n\t如果你为某个值类型定义了一个自定义的构造器，你将无法访问到默认构造器（如果是结构体，还将无法访问逐一成员构造器）。假如你希望默认构造器、逐一成员构造器以及你自己的自定义构造器都能用来创建实例，可以将自定义的构造器写到扩展（extension）中，而不是写在值类型的原始定义中。\n\n```Swift\nstruct Size {\n    var width = 0.0, height = 0.0\n}\nstruct Point {\n    var x = 0.0, y = 0.0\n}\n\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n    init() {}\n    init(origin: Point, size: Size) {\n        self.origin = origin\n        self.size = size\n    }\n    init(center: Point, size: Size) {\n        let originX = center.x - (size.width / 2)\n        let originY = center.y - (size.height / 2)\n        self.init(origin: Point(x: originX, y: originY), size: size)\n    }\n}\n```\n\n以上代码中，3中构造方法方式如下：\n\n```Swift\nlet basicRect = Rect()\n// basicRect's origin is (0.0, 0.0) and its size is (0.0, 0.0)\n\nlet originRect = Rect(origin: Point(x: 2.0, y: 2.0),\n                      size: Size(width: 5.0, height: 5.0))\n// originRect's origin is (2.0, 2.0) and its size is (5.0, 5.0)\n\nlet centerRect = Rect(center: Point(x: 4.0, y: 4.0),\n                      size: Size(width: 3.0, height: 3.0))\n// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)\n```\n\n\t如果你想用另外一种不需要自己定义init()和init(origin:size:)的方式来实现这个例子，可以通过扩展（Extensions）实现\n\n### 类的继承和构造过程\n类里面的所有存储型属性都必须在构造过程中设置初始值，包括所有继承自父类的属性。\nSwift 为类类型提供了两种构造器来确保实例中所有存储型属性都能获得初始值，它们分别是指定构造器和便利构造器。\n\n#### 指定构造器和便利构造器\n指定构造器是类中最主要的构造器。一个指定构造器将初始化类中提供的所有属性，并根据父类链往上调用父类的构造器来实现父类的初始化。一般情况下，类通常只有一个指定构造器。\n每一个类都必须拥有至少一个指定构造器。在某些情况下，许多类通过继承了父类中的指定构造器而满足了这个条件。\n\n便利构造器是类中比较次要的、辅助型的构造器。你可以定义便利构造器来调用同一个类中的指定构造器，并为其参数提供默认值。你也可以定义便利构造器来创建一个特殊用途或特定输入值的实例。\n便利构造器不是必需的。只在必要的时候为类提供便利构造器，比方说某种情况下通过使用便利构造器来快捷调用某个指定构造器，能够节省更多开发时间并让类的构造过程更清晰明了。\n\n#### 指定构造器和便利构造器的语法\n类的指定构造器的写法跟值类型简单构造器一样：\n\n```Swift\ninit(parameters) {\n    statements\n}\n```\n\n便利构造器也采用相同样式的写法，但需要在 `init` 关键字之前放置 `convenience` 关键字，并使用空格将它们俩分开：\n\n```Swift\nconvenience init(parameters) {\n    statements\n}\n```\n\n#### 类的构造器代理规则\n为了简化指定构造器和便利构造器之间的调用关系，Swift 采用以下三条规则来限制构造器之间的代理调用：\n\n * 指定构造器必须调用其直接父类的的指定构造器。\n * 便利构造器必须调用同类中定义的其它构造器。\n * 便利构造器必须最终导致一个指定构造器被调用。\n\n可以通过如下方法进行记忆：\n\n * 指定构造器必须总是向上代理\n * 便利构造器必须总是横向代理\n\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializerDelegation01_2x.png)\n\n下面图例中展示了一种涉及四个类的更复杂的类层级结构。它演示了指定构造器是如何在类层级中充当“管道”的作用，在类的构造器链上简化了类之间的相互关系。\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializerDelegation02_2x.png)\n\n#### 两段式构造过程\nSwift 中类的构造过程包含两个阶段。第一个阶段，每个存储型属性被引入它们的类指定一个初始值。当每个存储型属性的初始值被确定后，第二阶段开始，它给每个类一次机会，在新实例准备使用之前进一步定制它们的存储型属性。\n\n两段式构造过程的使用让构造过程更安全，同时在整个类层级结构中给予了每个类完全的灵活性。两段式构造过程可以防止属性值在初始化之前被访问，也可以防止属性被另外一个构造器意外地赋予不同的值。\n\n > 说明白点儿就是：第一阶段是使用内存的申请与属性的初始化，第二阶段是属性的初始化赋值。\n\tSwift 的两段式构造过程跟 Objective-C 中的构造过程类似。最主要的区别在于阶段 1，Objective-C 给每一个属性赋值0或空值（比如说0或nil）。Swift 的构造流程则更加灵活，它允许你设置定制的初始值，并自如应对某些属性不能以0或nil作为合法默认值的情况。\n\nSwift 编译器将执行 4 种有效的安全检查，以确保两段式构造过程能不出错地完成：\n\n * 安全检查 1\n\t* 指定构造器必须保证它所在类引入的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类中的构造器。\n\t如上所述，一个对象的内存只有在其所有存储型属性确定之后才能完全初始化。为了满足这一规则，指定构造器必须保证它所在类引入的属性在它往上代理之前先完成初始化。\n * 安全检查 2\n\t* 指定构造器必须先向上代理调用父类构造器，然后再为继承的属性设置新值。如果没这么做，指定构造器赋予的新值将被父类中的构造器所覆盖。\n * 安全检查 3\n\t* 指便利构造器必须先代理调用同一类中的其它构造器，然后再为任意属性赋新值。如果没这么做，便利构造器赋予的新值将被同一类中其它指定构造器所覆盖。\n * 安全检查 4\n\t* 构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用self作为一个值。\n\n类实例在第一阶段结束以前并不是完全有效的。只有第一阶段完成后，该实例才会成为有效实例，才能访问属性和调用方法。\n\n以下是两段式构造过程中基于上述安全检查的构造流程展示：\n\n * 阶段 1\n\t* 某个指定构造器或便利构造器被调用。\n\t* 完成新实例内存的分配，但此时内存还没有被初始化。\n\t* 指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化。\n\t* 指定构造器将调用父类的构造器，完成父类属性的初始化。\n\t* 这个调用父类构造器的过程沿着构造器链一直往上执行，直到到达构造器链的最顶部。\n\t* 当到达了构造器链最顶部，且已确保所有实例包含的存储型属性都已经赋值，这个实例的内存被认为已经完全初始化。此时阶段 1 完成。\n * 阶段 2\n\t* 从顶部构造器链一直往下，每个构造器链中类的指定构造器都有机会进一步定制实例。构造器此时可以访问self、修改它的属性并调用实例方法等等。\n\t* 最终，任意构造器链中的便利构造器可以有机会定制实例和使用self。\n\n下图展示了在假定的子类和父类之间的构造阶段 1：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/twoPhaseInitialization01_2x.png)\n在这个例子中，构造过程从对子类中一个便利构造器的调用开始。这个便利构造器此时没法修改任何属性，它把构造任务代理给同一类中的指定构造器。\n如安全检查 1 所示，指定构造器将确保所有子类的属性都有值。然后它将调用父类的指定构造器，并沿着构造器链一直往上完成父类的构造过程。\n父类中的指定构造器确保所有父类的属性都有值。由于没有更多的父类需要初始化，也就无需继续向上代理。一旦父类中所有属性都有了初始值，实例的内存被认为是完全初始化，阶段 1 完成。\n\n以下展示了相同构造过程的阶段 2：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/twoPhaseInitialization02_2x.png)\n父类中的指定构造器现在有机会进一步来定制实例（尽管这不是必须的）。\n一旦父类中的指定构造器完成调用，子类中的指定构造器可以执行更多的定制操作（这也不是必须的）。\n最终，一旦子类的指定构造器完成调用，最开始被调用的便利构造器可以执行更多的定制操作。\n\n#### 构造器的继承和重写\n跟 Objective-C 中的子类不同，Swift 中的子类默认情况下不会继承父类的构造器。Swift 的这种机制可以防止一个父类的简单构造器被一个更精细的子类继承，并被错误地用来创建子类的实例。\n\t父类的构造器仅会在安全和适当的情况下被继承。\n\n假如你希望自定义的子类中能提供一个或多个跟父类相同的构造器，你可以在子类中提供这些构造器的自定义实现。\n当你在编写一个和父类中指定构造器相匹配的子类构造器时，你实际上是在重写父类的这个指定构造器。因此，你必须在定义子类构造器时带上 `override` 修饰符。即使你重写的是系统自动提供的默认构造器，也需要带上override修饰符。\n正如重写属性，方法或者是下标，override修饰符会让编译器去检查父类中是否有相匹配的指定构造器，并验证构造器参数是否正确。\n\t当你重写一个父类的指定构造器时，你总是需要写override修饰符，即使你的子类将父类的指定构造器重写为了便利构造器。\n\n如果你编写了一个和父类便利构造器相匹配的子类构造器，由于子类不能直接调用父类的便利构造器（每个规则都在上文类的构造器代理规则有所描述）。因此，严格意义上来讲，你的子类并未对一个父类构造器提供重写。最后的结果就是，你在子类中“重写”一个父类便利构造器时，不需要加override前缀。\n\n在下面的例子中定义了一个叫Vehicle的基类。基类中声明了一个存储型属性numberOfWheels，它是值为0的Int类型的存储型属性。numberOfWheels属性用于创建名为descrpiption的String类型的计算型属性：\n\n```Swift\nclass Vehicle {\n    var numberOfWheels = 0\n    var description: String {\n        return \"\\(numberOfWheels) wheel(s)\"\n    }\n}\n\nlet vehicle = Vehicle()\nprint(\"Vehicle: \\(vehicle.description)\")\n// Vehicle: 0 wheel(s)\n```\n\n下面例子中定义了一个Vehicle的子类Bicycle：\n\n```Swift\nclass Bicycle: Vehicle {\n    override init() {\n        super.init()\n        numberOfWheels = 2\n    }\n}\n\nlet bicycle = Bicycle()\nprint(\"Bicycle: \\(bicycle.description)\")\n// Bicycle: 2 wheel(s)\n```\n\n子类Bicycle定义了一个自定义指定构造器init()。这个指定构造器和父类的指定构造器相匹配，所以Bicycle中的指定构造器需要带上override修饰符。\nBicycle的构造器init()以调用super.init()方法开始，这个方法的作用是调用Bicycle的父类Vehicle的默认构造器。这样可以确保Bicycle在修改属性之前，它所继承的属性numberOfWheels能被Vehicle类初始化。在调用super.init()之后，属性numberOfWheels的原值被新值2替换。\n\t子类可以在初始化时修改继承来的变量属性，但是不能修改继承来的常量属性。\n\n\n#### 构造器的自动继承\n如上所述，子类在默认情况下不会继承父类的构造器。但是如果满足特定条件，父类构造器是可以被自动继承的。在实践中，这意味着对于许多常见场景你不必重写父类的构造器，并且可以在安全的情况下以最小的代价继承父类的构造器。\n假设你为子类中引入的所有新属性都提供了默认值，以下 2 个规则适用：\n\n * 规则 1\n\t* 如果子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。\n * 规则 2\n\t* 如果子类提供了所有父类指定构造器的实现——无论是通过规则 1 继承过来的，还是提供了自定义实现——它将自动继承所有父类的便利构造器。\n\n即使你在子类中添加了更多的便利构造器，这两条规则仍然适用。\n\t对于规则 2，子类可以将父类的指定构造器实现为便利构造器。\n\n\n#### 指定构造器和便利构造器实践\n接下来的例子将在实践中展示指定构造器、便利构造器以及构造器的自动继承。这个例子定义了包含三个类Food、RecipeIngredient以及ShoppingListItem的类层次结构，并将演示它们的构造器是如何相互作用的。\n类层次中的基类是Food，它是一个简单的用来封装食物名字的类。Food类引入了一个叫做name的String类型的属性，并且提供了两个构造器来创建Food实例：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializersExample01_2x.png)\n```Swift\nclass Food {\n    var name: String\n    init(name: String) {\n        self.name = name\n    }\n    convenience init() {\n        self.init(name: \"[Unnamed]\")\n    }\n}\n```\n\n类没有默认的逐一成员构造器，所以Food类提供了一个接受单一参数name的指定构造器。这个构造器可以使用一个特定的名字来创建新的Food实例。同样提供了一个没有参数的便利构造器init()。这个init()构造器为新食物提供了一个默认的占位名字，通过横向代理到指定构造器init(name: String)并给参数name传值[Unnamed]来实现：\n\n```Swift\nlet namedMeat = Food(name: \"Bacon\")\n// namedMeat's name is \"Bacon\"\n\nlet mysteryMeat = Food()\n// mysteryMeat's name is \"[Unnamed]\"\n```\n\n类层级中的第二个类是Food的子类RecipeIngredient。RecipeIngredient类用来表示食谱中的一项原料。它引入了Int类型的属性quantity（以及从Food继承过来的name属性），并且定义了两个构造器来创建RecipeIngredient实例：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializersExample02_2x.png)\n```Swift\nclass RecipeIngredient: Food {\n    var quantity: Int\n    init(name: String, quantity: Int) {\n        self.quantity = quantity\n        super.init(name: name)\n    }\n    override convenience init(name: String) {\n        self.init(name: name, quantity: 1)\n    }\n}\n```\n\nRecipeIngredient类拥有一个指定构造器init(name: String, quantity: Int)，它可以用来填充RecipeIngredient实例的所有属性值。这个构造器一开始先将传入的quantity参数赋值给quantity属性，这个属性也是唯一在RecipeIngredient中新引入的属性。随后，构造器向上代理到父类Food的init(name: String)。这个过程满足两段式构造过程中的安全检查 1。\n\nRecipeIngredient还定义了一个便利构造器init(name: String)，它只通过name来创建RecipeIngredient的实例。这个便利构造器假设任意RecipeIngredient实例的quantity为1，所以不需要显式指明数量即可创建出实例。这个便利构造器的定义可以更加方便和快捷地创建实例，并且避免了创建多个quantity为1的RecipeIngredient实例时的代码重复。这个便利构造器只是简单地横向代理到类中的指定构造器，并为quantity参数传递1。\n注意，RecipeIngredient的便利构造器init(name: String)使用了跟Food中指定构造器init(name: String)相同的参数。由于这个便利构造器重写了父类的指定构造器init(name: String)，因此必须在前面使用override修饰符\n\n尽管RecipeIngredient将父类的指定构造器重写为了便利构造器，它依然提供了父类的所有指定构造器的实现。因此，RecipeIngredient会自动继承父类的所有便利构造器。\n在这个例子中，RecipeIngredient的父类是Food，它有一个便利构造器init()。这个便利构造器会被RecipeIngredient继承。这个继承版本的init()在功能上跟Food提供的版本是一样的，只是它会代理到RecipeIngredient版本的init(name: String)而不是Food提供的版本。\n\n所有的这三种构造器都可以用来创建新的RecipeIngredient实例：\n\n```Swift\nlet oneMysteryItem = RecipeIngredient()\nlet oneBacon = RecipeIngredient(name: \"Bacon\")\nlet sixEggs = RecipeIngredient(name: \"Eggs\", quantity: 6)\n```\n\n类层级中第三个也是最后一个类是RecipeIngredient的子类，叫做ShoppingListItem。这个类构建了购物单中出现的某一种食谱原料。\n\n购物单中的每一项总是从未购买状态开始的。为了呈现这一事实，ShoppingListItem引入了一个布尔类型的属性purchased，它的默认值是false。ShoppingListItem还添加了一个计算型属性description，它提供了关于ShoppingListItem实例的一些文字描述：\n\n```Swift\nclass ShoppingListItem: RecipeIngredient {\n    var purchased = false\n    var description: String {\n        var output = \"\\(quantity) x \\(name)\"\n        output += purchased ? \" ✔\" : \" ✘\"\n        return output\n    }\n}\n```\n\n\tShoppingListItem没有定义构造器来为purchased提供初始值，因为添加到购物单的物品的初始状态总是未购买。\n\n由于它为自己引入的所有属性都提供了默认值，并且自己没有定义任何构造器，ShoppingListItem将自动继承所有父类中的指定构造器和便利构造器。\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializersExample03_2x.png)\n你可以使用全部三个继承来的构造器来创建ShoppingListItem的新实例：\n\n```Swift\nvar breakfastList = [\n    ShoppingListItem(),\n    ShoppingListItem(name: \"Bacon\"),\n    ShoppingListItem(name: \"Eggs\", quantity: 6),\n]\nbreakfastList[0].name = \"Orange juice\"\nbreakfastList[0].purchased = true\nfor item in breakfastList {\n    print(item.description)\n}\n// 1 x Orange juice ✔\n// 1 x Bacon ✘\n// 6 x Eggs ✘\n```\n\n### 可失败构造器\n如果一个类、结构体或枚举类型的对象，在构造过程中有可能失败，则为其定义一个可失败构造器。这里所指的“失败”是指，如给构造器传入无效的参数值，或缺少某种所需的外部资源，又或是不满足某种必要的条件等。\n为了妥善处理这种构造过程中可能会失败的情况。你可以在一个类，结构体或是枚举类型的定义中，添加一个或多个可失败构造器。其语法为在 `init` 关键字后面添加问号( `init?` )。\n\t可失败构造器的参数名和参数类型，不能与其它非可失败构造器的参数名，及其参数类型相同。\n\n可失败构造器会创建一个类型为自身类型的可选类型的对象。你通过return nil语句来表明可失败构造器在何种情况下应该“失败”。\n\t严格来说，构造器都不支持返回值。因为构造器本身的作用，只是为了确保对象能被正确构造。因此你只是用return nil表明可失败构造器构造失败，而不要用关键字return来表明构造成功。\n\n下例中，定义了一个名为Animal的结构体，其中有一个名为species的String类型的常量属性。同时该结构体还定义了一个接受一个名为species的String类型参数的可失败构造器。这个可失败构造器检查传入的参数是否为一个空字符串。如果为空字符串，则构造失败。否则，species属性被赋值，构造成功。\n\n```Swift\nstruct Animal {\n    let species: String\n    init?(species: String) {\n        if species.isEmpty { return nil }\n        self.species = species\n    }\n}\n```\n\n你可以通过该可失败构造器来构建一个Animal的实例，并检查构造过程是否成功：\n\n```Swift\nlet someCreature = Animal(species: \"Giraffe\")\n// someCreature is of type Animal?, not Animal\n \nif let giraffe = someCreature {\n    print(\"An animal was initialized with a species of \\(giraffe.species)\")\n}\n// Prints \"An animal was initialized with a species of Giraffe\"\n\n\nlet anonymousCreature = Animal(species: \"\")\n// anonymousCreature is of type Animal?, not Animal\n \nif anonymousCreature == nil {\n    print(\"The anonymous creature could not be initialized\")\n}\n// Prints \"The anonymous creature could not be initialized\"\n```\n\n#### 枚举类型的可失败构造器\n你可以通过一个带一个或多个参数的可失败构造器来获取枚举类型中特定的枚举成员。如果提供的参数无法匹配任何枚举成员，则构造失败。\n\n下例中，定义了一个名为TemperatureUnit的枚举类型。其中包含了三个可能的枚举成员(Kelvin，Celsius，和Fahrenheit)，以及一个根据Character值找出所对应的枚举成员的可失败构造器：\n\n```Swift\nenum TemperatureUnit {\n    case kelvin, celsius, fahrenheit\n    init?(symbol: Character) {\n        switch symbol {\n        case \"K\":\n            self = .kelvin\n        case \"C\":\n            self = .celsius\n        case \"F\":\n            self = .fahrenheit\n        default:\n            return nil\n        }\n    }\n}\n```\n\n你可以利用该可失败构造器在三个枚举成员中获取一个相匹配的枚举成员，当参数的值不能与任何枚举成员相匹配时，则构造失败：\n\n```Swift\nlet fahrenheitUnit = TemperatureUnit(symbol: \"F\")\nif fahrenheitUnit != nil {\n    print(\"This is a defined temperature unit, so initialization succeeded.\")\n}\n// Prints \"This is a defined temperature unit, so initialization succeeded.\"\n \nlet unknownUnit = TemperatureUnit(symbol: \"X\")\nif unknownUnit == nil {\n    print(\"This is not a defined temperature unit, so initialization failed.\")\n}\n// Prints \"This is not a defined temperature unit, so initialization failed.\"\n```\n\n#### 带原始值的枚举类型的可失败构造器\n带原始值的枚举类型会自带一个可失败构造器init?(rawValue:)，该可失败构造器有一个名为rawValue的参数，其类型和枚举类型的原始值类型一致，如果该参数的值能够和某个枚举成员的原始值匹配，则该构造器会构造相应的枚举成员，否则构造失败。\n\n因此上面的TemperatureUnit的例子可以重写为：\n\n```Swift\nenum TemperatureUnit: Character {\n    case kelvin = \"K\", celsius = \"C\", fahrenheit = \"F\"\n}\n \nlet fahrenheitUnit = TemperatureUnit(rawValue: \"F\")\nif fahrenheitUnit != nil {\n    print(\"This is a defined temperature unit, so initialization succeeded.\")\n}\n// Prints \"This is a defined temperature unit, so initialization succeeded.\"\n \nlet unknownUnit = TemperatureUnit(rawValue: \"X\")\nif unknownUnit == nil {\n    print(\"This is not a defined temperature unit, so initialization failed.\")\n}\n// Prints \"This is not a defined temperature unit, so initialization failed.\"\n```\n\n#### 构造失败的传递\n类，结构体，枚举的可失败构造器可以横向代理到类型中的其他可失败构造器。类似的，子类的可失败构造器也能向上代理到父类的可失败构造器。\n无论是向上代理还是横向代理，如果你代理到的其他可失败构造器触发构造失败，整个构造过程将立即终止，接下来的任何构造代码不会再被执行。\n\t可失败构造器也可以代理到其它的非可失败构造器。通过这种方式，你可以增加一个可能的失败状态到现有的构造过程中。\n\n下面这个例子，定义了一个名为CartItem的Product类的子类。这个类建立了一个在线购物车中的物品的模型，它有一个名为quantity的常量存储型属性，并确保该属性的值至少为1：\n\n```Swift\nclass Product {\n    let name: String\n    init?(name: String) {\n        if name.isEmpty { return nil }\n        self.name = name\n    }\n}\n \nclass CartItem: Product {\n    let quantity: Int\n    init?(name: String, quantity: Int) {\n        if quantity < 1 { return nil }\n        self.quantity = quantity\n        super.init(name: name)\n    }\n}\n```\n\nCartItem 可失败构造器首先验证接收的 quantity 值是否大于等于 1 。倘若 quantity 值无效，则立即终止整个构造过程，返回失败结果，且不再执行余下代码。同样地，Product 的可失败构造器首先检查 name 值，假如 name 值为空字符串，则构造器立即执行失败。\n\n如果你通过传入一个非空字符串 name 以及一个值大于等于 1 的 quantity 来创建一个 CartItem 实例，那么构造方法能够成功被执行：\n\n```Swift\nif let twoSocks = CartItem(name: \"sock\", quantity: 2) {\n    print(\"Item: \\(twoSocks.name), quantity: \\(twoSocks.quantity)\")\n}\n// Prints \"Item: sock, quantity: 2\"\n```\n\n倘若你以一个值为 0 的 quantity 来创建一个 CartItem 实例，那么将导致 CartItem 构造器失败：\n\n```Swift\nif let zeroShirts = CartItem(name: \"shirt\", quantity: 0) {\n    print(\"Item: \\(zeroShirts.name), quantity: \\(zeroShirts.quantity)\")\n} else {\n    print(\"Unable to initialize zero shirts\")\n}\n// Prints \"Unable to initialize zero shirts\"\n```\n\n同样地，如果你尝试传入一个值为空字符串的 name来创建一个 CartItem 实例，那么将导致父类 Product 的构造过程失败：\n\n```Swift\nif let oneUnnamed = CartItem(name: \"\", quantity: 1) {\n    print(\"Item: \\(oneUnnamed.name), quantity: \\(oneUnnamed.quantity)\")\n} else {\n    print(\"Unable to initialize one unnamed product\")\n}\n// Prints \"Unable to initialize one unnamed product\"\n```\n\n#### 重写一个可失败构造器\n如同其它的构造器，你可以在子类中重写父类的可失败构造器。或者你也可以用子类的非可失败构造器重写一个父类的可失败构造器。这使你可以定义一个不会构造失败的子类，即使父类的构造器允许构造失败。\n当你用子类的非可失败构造器重写父类的可失败构造器时，向上代理到父类的可失败构造器的唯一方式是对父类的可失败构造器的返回值进行强制解包。\n\t你可以用非可失败构造器重写可失败构造器，但反过来却不行。\n\n下例定义了一个名为Document的类，name属性的值必须为一个非空字符串或nil，但不能是一个空字符串：\n\n```Swift\nclass Document {\n    var name: String?\n    // this initializer creates a document with a nil name value\n    init() {}\n    // this initializer creates a document with a nonempty name value\n    init?(name: String) {\n        if name.isEmpty { return nil }\n        self.name = name\n    }\n}\n```\n\n下面这个例子，定义了一个Document类的子类AutomaticallyNamedDocument。这个子类重写了父类的两个指定构造器，确保了无论是使用init()构造器，还是使用init(name:)构造器并为参数传递空字符串，生成的实例中的name属性总有初始\"[Untitled]\"：\n\n```Swift\nclass AutomaticallyNamedDocument: Document {\n    override init() {\n        super.init()\n        self.name = \"[Untitled]\"\n    }\n    override init(name: String) {\n        super.init()\n        if name.isEmpty {\n            self.name = \"[Untitled]\"\n        } else {\n            self.name = name\n        }\n    }\n}\n```\n\nAutomaticallyNamedDocument用一个非可失败构造器init(name:)重写了父类的可失败构造器init?(name:)。因为子类用另一种方式处理了空字符串的情况，所以不再需要一个可失败构造器，因此子类用一个非可失败构造器代替了父类的可失败构造器。\n\n你可以在子类的非可失败构造器中使用强制解包来调用父类的可失败构造器。比如，下面的UntitledDocument子类的name属性的值总是\"[Untitled]\"，它在构造过程中使用了父类的可失败构造器init?(name:)：\n\n```Swift\nclass UntitledDocument: Document {\n    override init() {\n        super.init(name: \"[Untitled]\")!\n    }\n}\n```\n\n#### 可失败构造器 init!\n通常来说我们通过在init关键字后添加问号的方式（init?）来定义一个可失败构造器，但你也可以通过在init后面添加惊叹号的方式来定义一个可失败构造器（init!），该可失败构造器将会构建一个对应类型的隐式解包可选类型的对象。\n\n你可以在init?中代理到init!，反之亦然。你也可以用init?重写init!，反之亦然。你还可以用init代理到init!，不过，一旦init!构造失败，则会触发一个断言。\n\n### 必要构造器\n在类的构造器前添加 `required` 修饰符表明所有该类的子类都必须实现该构造器：\n\n```Swift\nclass SomeClass {\n    required init() {\n        // initializer implementation goes here\n    }\n}\n```\n\n在子类重写父类的必要构造器时，必须在子类的构造器前也添加required修饰符，表明该构造器要求也应用于继承链后面的子类。在重写父类中必要的指定构造器时，不需要添加override修饰符：\n\n```Swift\nclass SomeSubclass: SomeClass {\n    required init() {\n        // subclass implementation of the required initializer goes here\n    }\n}\n```\n\n\t如果子类继承的构造器能满足必要构造器的要求，则无须在子类中显式提供必要构造器的实现。\n\n\n### 通过闭包或函数设置属性的默认值\n如果某个存储型属性的默认值需要一些定制或设置，你可以使用闭包或全局函数为其提供定制的默认值。每当某个属性所在类型的新实例被创建时，对应的闭包或函数会被调用，而它们的返回值会当做默认值赋值给这个属性。\n这种类型的闭包或函数通常会创建一个跟属性类型相同的临时变量，然后修改它的值以满足预期的初始状态，最后返回这个临时变量，作为属性的默认值。\n\n下面介绍了如何用闭包为属性提供默认值：\n\n```Swift\nclass SomeClass {\n    let someProperty: SomeType = {\n        // create a default value for someProperty inside this closure\n        // someValue must be of the same type as SomeType\n        return someValue\n    }()\n}\n```\n\n注意闭包结尾的大括号后面接了一对空的小括号。这用来告诉 Swift 立即执行此闭包。如果你忽略了这对括号，相当于将闭包本身作为值赋值给了属性，而不是将闭包的返回值赋值给属性。\n\t如果你使用闭包来初始化属性，请记住在闭包执行时，实例的其它部分都还没有初始化。这意味着你不能在闭包里访问其它属性，即使这些属性有默认值。同样，你也不能使用隐式的self属性，或者调用任何实例方法。\n\n下面例子中定义了一个结构体Checkerboard，它构建了西洋跳棋游戏的棋盘：\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/chessBoard_2x.png)\n西洋跳棋游戏在一副黑白格交替的10x10的棋盘中进行。为了呈现这副游戏棋盘，Checkerboard结构体定义了一个属性boardColors，它是一个包含100个Bool值的数组。在数组中，值为true的元素表示一个黑格，值为false的元素表示一个白格。数组中第一个元素代表棋盘上左上角的格子，最后一个元素代表棋盘上右下角的格子。\n\nboardColor数组是通过一个闭包来初始化并设置颜色值的：\n\n```Swift\nstruct Chessboard {\n    let boardColors: [Bool] = {\n        var temporaryBoard = [Bool]()\n        var isBlack = false\n        for i in 1...8 {\n            for j in 1...8 {\n                temporaryBoard.append(isBlack)\n                isBlack = !isBlack\n            }\n            isBlack = !isBlack\n        }\n        return temporaryBoard\n    }()\n    func squareIsBlackAt(row: Int, column: Int) -> Bool {\n        return boardColors[(row * 8) + column]\n    }\n}\n```\n\n每当一个新的Checkerboard实例被创建时，赋值闭包会被执行，boardColors的默认值会被计算出来并返回。上面例子中描述的闭包将计算出棋盘中每个格子对应的颜色，并将这些值保存到一个临时数组temporaryBoard中，最后在构建完成时将此数组作为闭包返回值返回。这个返回的数组会保存到boardColors中，并可以通过工具函数squareIsBlackAtRow来查询：\n\n```Swift\nlet board = Chessboard()\nprint(board.squareIsBlackAt(row: 0, column: 1))\n// Prints \"true\"\nprint(board.squareIsBlackAt(row: 7, column: 7))\n// Prints \"false\"\n```\n\n\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html/\"> Initialization </a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","slug":"iOS_Swift_language_note_Initialization","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4ug003boko89uqip9gk","content":"<p>​    构造过程是使用类、结构体、枚举的实例之前的准备过程。具体操作包括设置实例中每个存储型属性的初始值和执行其他必须的设置或初始化工作。在新实例可用前必须执行这个过程。<br>通过定义构造器来实现构造过程，这些构造器可以看做是用来创建特定类型新实例的特殊方法。与 Objective-C 中的构造器不同，Swift 的构造器无需返回值，它们的主要任务是保证新实例在第一次使用前完成正确的初始化。<br>类的实例也可以通过定义析构器在实例释放之前执行特定的清除工作。</p>\n<h3 id=\"存储属性的初始化值\"><a href=\"#存储属性的初始化值\" class=\"headerlink\" title=\"存储属性的初始化值\"></a>存储属性的初始化值</h3><p>类和结构体在创建实例时，必须为所有存储型属性设置合适的初始值。存储型属性的值不能处于一个未知的状态。你可以在构造器中为存储型属性赋初值，也可以在定义属性时为其设置默认值。<br>    为存储型属性设置默认值或者在构造器中为其赋值时，它们的值是被直接设置的，不会触发任何属性观察者。</p>\n<a id=\"more\"></a>\n<h4 id=\"构造器\"><a href=\"#构造器\" class=\"headerlink\" title=\"构造器\"></a>构造器</h4><p>构造器在创建某个特定类型的新实例时被调用。它的最简形式类似于一个不带任何参数的实例方法，以关键字 <code>init</code> 命名：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">init</span>() &#123;</div><div class=\"line\">    <span class=\"comment\">// perform some initialization here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下面例子中定义了一个用来保存华氏温度的结构体Fahrenheit，它拥有一个Double类型的存储型属性temperature：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Fahrenheit</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> temperature: <span class=\"type\">Double</span></div><div class=\"line\">    <span class=\"keyword\">init</span>() &#123;</div><div class=\"line\">        temperature = <span class=\"number\">32.0</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"type\">Fahrenheit</span>()</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The default temperature is <span class=\"subst\">\\(f.temperature)</span>° Fahrenheit\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"The default temperature is 32.0° Fahrenheit\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"默认属性值\"><a href=\"#默认属性值\" class=\"headerlink\" title=\"默认属性值\"></a>默认属性值</h4><p>可以在构造器中为存储型属性设置初始值。也可以在属性声明时为其设置默认值。<br>    如果一个属性总是使用相同的初始值，那么为其设置一个默认值比每次都在构造器中赋值要好。两种方法的效果是一样的，只不过使用默认值让属性的初始化和声明结合得更紧密。使用默认值能让你的构造器更简洁、更清晰，且能通过默认值自动推导出属性的类型；同时，它也能让你充分利用默认构造器、构造器继承等特性。</p>\n<p>你可以使用更简单的方式在定义结构体Fahrenheit时为属性temperature设置默认值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Fahrenheit</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> temperature = <span class=\"number\">32.0</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"自定义构造函数\"><a href=\"#自定义构造函数\" class=\"headerlink\" title=\"自定义构造函数\"></a>自定义构造函数</h3><p>可以通过输入参数和可选类型的属性来自定义构造过程，也可以在构造过程中修改 <code>常量</code> 属性。</p>\n<h4 id=\"构造参数\"><a href=\"#构造参数\" class=\"headerlink\" title=\"构造参数\"></a>构造参数</h4><p>可以在构造器定义中提供构造参数，指定所需值的类型和名字。构造参数的功能和语法跟函数和方法的参数相同。<br>下面例子中定义了一个包含摄氏度温度的结构体Celsius。它定义了两个不同的构造器：init(fromFahrenheit:)和init(fromKelvin:)，二者分别通过接受不同温标下的温度值来创建新的实例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Celsius</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> temperatureInCelsius: <span class=\"type\">Double</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(fromFahrenheit fahrenheit: <span class=\"type\">Double</span>) &#123;</div><div class=\"line\">        temperatureInCelsius = (fahrenheit - <span class=\"number\">32.0</span>) / <span class=\"number\">1.8</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">init</span>(fromKelvin kelvin: <span class=\"type\">Double</span>) &#123;</div><div class=\"line\">        temperatureInCelsius = kelvin - <span class=\"number\">273.15</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> boilingPointOfWater = <span class=\"type\">Celsius</span>(fromFahrenheit: <span class=\"number\">212.0</span>)</div><div class=\"line\"><span class=\"comment\">// boilingPointOfWater.temperatureInCelsius is 100.0</span></div><div class=\"line\"><span class=\"keyword\">let</span> freezingPointOfWater = <span class=\"type\">Celsius</span>(fromKelvin: <span class=\"number\">273.15</span>)</div><div class=\"line\"><span class=\"comment\">// freezingPointOfWater.temperatureInCelsius is 0.0</span></div></pre></td></tr></table></figure>\n<h4 id=\"参数的参数名和标签名-内部名称和外部名称\"><a href=\"#参数的参数名和标签名-内部名称和外部名称\" class=\"headerlink\" title=\"参数的参数名和标签名(内部名称和外部名称)\"></a>参数的参数名和标签名(内部名称和外部名称)</h4><p>跟函数和方法参数相同，构造参数也拥有一个在构造器内部使用的参数名字和一个在调用构造器时使用的外部参数名字（标签名）。<br>构造器并不像函数和方法那样在括号前有一个可辨别的名字（只有init）。因此在调用构造器时，主要通过构造器中的参数名和类型来确定应该被调用的构造器。正因为参数如此重要，如果你在定义构造器时没有提供参数的外部名字，Swift 会为构造器的每个参数自动生成一个跟内部名字相同的外部名。</p>\n<p>以下例子中定义了一个结构体Color，它包含了三个常量：red、green和blue。这些属性可以存储0.0到1.0之间的值，用来指示颜色中红、绿、蓝成分的含量。Color提供了一个构造器，其中包含三个Double类型的构造参数。Color也可以提供第二个构造器，它只包含名为white的Double类型的参数，它被用于给上述三个构造参数赋予同样的值。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Color</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> red, green, blue: <span class=\"type\">Double</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(red: <span class=\"type\">Double</span>, green: <span class=\"type\">Double</span>, blue: <span class=\"type\">Double</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.red   = red</div><div class=\"line\">        <span class=\"keyword\">self</span>.green = green</div><div class=\"line\">        <span class=\"keyword\">self</span>.blue  = blue</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">init</span>(white: <span class=\"type\">Double</span>) &#123;</div><div class=\"line\">        red   = white</div><div class=\"line\">        green = white</div><div class=\"line\">        blue  = white</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> magenta = <span class=\"type\">Color</span>(red: <span class=\"number\">1.0</span>, green: <span class=\"number\">0.0</span>, blue: <span class=\"number\">1.0</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> halfGray = <span class=\"type\">Color</span>(white: <span class=\"number\">0.5</span>)</div></pre></td></tr></table></figure>\n<pre><code>如果不通过外部参数名字传值，你是没法调用这个构造器的。只要构造器定义了某个外部参数名，你就必须使用它，忽略它将导致编译错误：\n</code></pre><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> veryGreen = <span class=\"type\">Color</span>(<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>)</div><div class=\"line\"><span class=\"comment\">// this reports a compile-time error - argument labels are required</span></div></pre></td></tr></table></figure>\n<h4 id=\"不带标签（外部名）的构造器参数\"><a href=\"#不带标签（外部名）的构造器参数\" class=\"headerlink\" title=\"不带标签（外部名）的构造器参数\"></a>不带标签（外部名）的构造器参数</h4><p>如果你不希望为构造器的某个参数提供外部名字，你可以使用下划线(<code>_</code>)来显式描述它的外部名，以此重写上面所说的默认行为。</p>\n<p>下面是之前Celsius例子的扩展，跟之前相比添加了一个带有Double类型参数的构造器，其外部名用<em>代替。调用Celsius(37.0)意图明确，不需要外部参数名称。因此适合使用init(</em> celsius: Double)这样的构造器，从而可以通过提供Double类型的参数值调用构造器，而不需要加上外部名。：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Celsius</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> temperatureInCelsius: <span class=\"type\">Double</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(fromFahrenheit fahrenheit: <span class=\"type\">Double</span>) &#123;</div><div class=\"line\">        temperatureInCelsius = (fahrenheit - <span class=\"number\">32.0</span>) / <span class=\"number\">1.8</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">init</span>(fromKelvin kelvin: <span class=\"type\">Double</span>) &#123;</div><div class=\"line\">        temperatureInCelsius = kelvin - <span class=\"number\">273.15</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"number\">_</span> celsius: <span class=\"type\">Double</span>) &#123;</div><div class=\"line\">        temperatureInCelsius = celsius</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> bodyTemperature = <span class=\"type\">Celsius</span>(<span class=\"number\">37.0</span>)</div><div class=\"line\"><span class=\"comment\">// bodyTemperature.temperatureInCelsius is 37.0</span></div></pre></td></tr></table></figure>\n<h4 id=\"可选属性类型\"><a href=\"#可选属性类型\" class=\"headerlink\" title=\"可选属性类型\"></a>可选属性类型</h4><p>如果你定制的类型包含一个逻辑上允许取值为空的存储型属性，你都需要将它定义为可选类型。可选类型的属性将自动初始化为nil，表示这个属性是有意在初始化时设置为空的。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SurveyQuestion</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> text: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">var</span> response: <span class=\"type\">String</span>?</div><div class=\"line\">    <span class=\"keyword\">init</span>(text: <span class=\"type\">String</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.text = text</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ask</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(text)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> cheeseQuestion = <span class=\"type\">SurveyQuestion</span>(text: <span class=\"string\">\"Do you like cheese?\"</span>)</div><div class=\"line\">cheeseQuestion.ask()</div><div class=\"line\"><span class=\"comment\">// Prints \"Do you like cheese?\"</span></div><div class=\"line\">cheeseQuestion.response = <span class=\"string\">\"Yes, I do like cheese.\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"构造过程中常量属性的修改\"><a href=\"#构造过程中常量属性的修改\" class=\"headerlink\" title=\"构造过程中常量属性的修改\"></a>构造过程中常量属性的修改</h4><p>你可以在构造过程中的任意时间点给常量属性指定一个值，只要在构造过程结束时是一个确定的值。一旦常量属性被赋值，它将永远不可更改。<br>    对于类的实例来说，它的常量属性只能在定义它的类的构造过程中修改；不能在子类中修改。</p>\n<p>你可以修改上面的SurveyQuestion示例，用常量属性替代变量属性text，表示问题内容text在SurveyQuestion的实例被创建之后不会再被修改。尽管text属性现在是常量，我们仍然可以在类的构造器中设置它的值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SurveyQuestion</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> text: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">var</span> response: <span class=\"type\">String</span>?</div><div class=\"line\">    <span class=\"keyword\">init</span>(text: <span class=\"type\">String</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.text = text</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ask</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(text)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> beetsQuestion = <span class=\"type\">SurveyQuestion</span>(text: <span class=\"string\">\"How about beets?\"</span>)</div><div class=\"line\">beetsQuestion.ask()</div><div class=\"line\"><span class=\"comment\">// Prints \"How about beets?\"</span></div><div class=\"line\">beetsQuestion.response = <span class=\"string\">\"I also like beets. (But not with cheese.)\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"默认构造器\"><a href=\"#默认构造器\" class=\"headerlink\" title=\"默认构造器\"></a>默认构造器</h3><p>如果结构体或类的所有属性都有默认值，同时没有自定义的构造器，那么 Swift 会给这些结构体或类提供一个默认构造器（default initializers）。这个默认构造器将简单地创建一个所有属性值都设置为默认值的实例。</p>\n<p>下面例子中创建了一个类ShoppingListItem，它封装了购物清单中的某一物品的属性：名字（name）、数量（quantity）和购买状态 purchase state：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShoppingListItem</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span>?</div><div class=\"line\">    <span class=\"keyword\">var</span> quantity = <span class=\"number\">1</span></div><div class=\"line\">    <span class=\"keyword\">var</span> purchased = <span class=\"literal\">false</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> item = <span class=\"type\">ShoppingListItem</span>()</div></pre></td></tr></table></figure>\n<h4 id=\"结构体的逐一成员构造器\"><a href=\"#结构体的逐一成员构造器\" class=\"headerlink\" title=\"结构体的逐一成员构造器\"></a>结构体的逐一成员构造器</h4><p>除了上面提到的默认构造器，如果结构体没有提供自定义的构造器，它们将自动获得一个逐一成员构造器，即使结构体的存储型属性没有默认值。</p>\n<p>逐一成员构造器是用来初始化结构体新实例里成员属性的快捷方法。我们在调用逐一成员构造器时，通过与成员属性名相同的参数名进行传值来完成对成员属性的初始赋值。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Size</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> width = <span class=\"number\">0.0</span>, height = <span class=\"number\">0.0</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> twoByTwo = <span class=\"type\">Size</span>(width: <span class=\"number\">2.0</span>, height: <span class=\"number\">2.0</span>)</div></pre></td></tr></table></figure>\n<h3 id=\"值类型的构造器代理\"><a href=\"#值类型的构造器代理\" class=\"headerlink\" title=\"值类型的构造器代理\"></a>值类型的构造器代理</h3><p>构造器可以通过调用其它构造器来完成实例的部分构造过程。这一过程称为构造器代理，它能减少多个构造器间的代码重复。</p>\n<p>构造器代理的实现规则和形式在值类型和类类型中有所不同。值类型（结构体和枚举类型）不支持继承，所以构造器代理的过程相对简单，因为它们只能代理给自己的其它构造器。类则不同，它可以继承自其它类，这意味着类有责任保证其所有继承的存储型属性在构造时也能正确的初始化。</p>\n<p>对于值类型，你可以使用self.init在自定义的构造器中引用相同类型中的其它构造器。并且你只能在构造器内部调用self.init。<br>    如果你为某个值类型定义了一个自定义的构造器，你将无法访问到默认构造器（如果是结构体，还将无法访问逐一成员构造器）。假如你希望默认构造器、逐一成员构造器以及你自己的自定义构造器都能用来创建实例，可以将自定义的构造器写到扩展（extension）中，而不是写在值类型的原始定义中。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Size</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> width = <span class=\"number\">0.0</span>, height = <span class=\"number\">0.0</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">0.0</span>, y = <span class=\"number\">0.0</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Rect</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> origin = <span class=\"type\">Point</span>()</div><div class=\"line\">    <span class=\"keyword\">var</span> size = <span class=\"type\">Size</span>()</div><div class=\"line\">    <span class=\"keyword\">init</span>() &#123;&#125;</div><div class=\"line\">    <span class=\"keyword\">init</span>(origin: <span class=\"type\">Point</span>, size: <span class=\"type\">Size</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.origin = origin</div><div class=\"line\">        <span class=\"keyword\">self</span>.size = size</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">init</span>(center: <span class=\"type\">Point</span>, size: <span class=\"type\">Size</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> originX = center.x - (size.width / <span class=\"number\">2</span>)</div><div class=\"line\">        <span class=\"keyword\">let</span> originY = center.y - (size.height / <span class=\"number\">2</span>)</div><div class=\"line\">        <span class=\"keyword\">self</span>.<span class=\"keyword\">init</span>(origin: <span class=\"type\">Point</span>(x: originX, y: originY), size: size)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上代码中，3中构造方法方式如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> basicRect = <span class=\"type\">Rect</span>()</div><div class=\"line\"><span class=\"comment\">// basicRect's origin is (0.0, 0.0) and its size is (0.0, 0.0)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> originRect = <span class=\"type\">Rect</span>(origin: <span class=\"type\">Point</span>(x: <span class=\"number\">2.0</span>, y: <span class=\"number\">2.0</span>),</div><div class=\"line\">                      size: <span class=\"type\">Size</span>(width: <span class=\"number\">5.0</span>, height: <span class=\"number\">5.0</span>))</div><div class=\"line\"><span class=\"comment\">// originRect's origin is (2.0, 2.0) and its size is (5.0, 5.0)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> centerRect = <span class=\"type\">Rect</span>(center: <span class=\"type\">Point</span>(x: <span class=\"number\">4.0</span>, y: <span class=\"number\">4.0</span>),</div><div class=\"line\">                      size: <span class=\"type\">Size</span>(width: <span class=\"number\">3.0</span>, height: <span class=\"number\">3.0</span>))</div><div class=\"line\"><span class=\"comment\">// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)</span></div></pre></td></tr></table></figure>\n<pre><code>如果你想用另外一种不需要自己定义init()和init(origin:size:)的方式来实现这个例子，可以通过扩展（Extensions）实现\n</code></pre><h3 id=\"类的继承和构造过程\"><a href=\"#类的继承和构造过程\" class=\"headerlink\" title=\"类的继承和构造过程\"></a>类的继承和构造过程</h3><p>类里面的所有存储型属性都必须在构造过程中设置初始值，包括所有继承自父类的属性。<br>Swift 为类类型提供了两种构造器来确保实例中所有存储型属性都能获得初始值，它们分别是指定构造器和便利构造器。</p>\n<h4 id=\"指定构造器和便利构造器\"><a href=\"#指定构造器和便利构造器\" class=\"headerlink\" title=\"指定构造器和便利构造器\"></a>指定构造器和便利构造器</h4><p>指定构造器是类中最主要的构造器。一个指定构造器将初始化类中提供的所有属性，并根据父类链往上调用父类的构造器来实现父类的初始化。一般情况下，类通常只有一个指定构造器。<br>每一个类都必须拥有至少一个指定构造器。在某些情况下，许多类通过继承了父类中的指定构造器而满足了这个条件。</p>\n<p>便利构造器是类中比较次要的、辅助型的构造器。你可以定义便利构造器来调用同一个类中的指定构造器，并为其参数提供默认值。你也可以定义便利构造器来创建一个特殊用途或特定输入值的实例。<br>便利构造器不是必需的。只在必要的时候为类提供便利构造器，比方说某种情况下通过使用便利构造器来快捷调用某个指定构造器，能够节省更多开发时间并让类的构造过程更清晰明了。</p>\n<h4 id=\"指定构造器和便利构造器的语法\"><a href=\"#指定构造器和便利构造器的语法\" class=\"headerlink\" title=\"指定构造器和便利构造器的语法\"></a>指定构造器和便利构造器的语法</h4><p>类的指定构造器的写法跟值类型简单构造器一样：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">init</span>(parameters) &#123;</div><div class=\"line\">    statements</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>便利构造器也采用相同样式的写法，但需要在 <code>init</code> 关键字之前放置 <code>convenience</code> 关键字，并使用空格将它们俩分开：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">convenience</span> <span class=\"keyword\">init</span>(parameters) &#123;</div><div class=\"line\">    statements</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"类的构造器代理规则\"><a href=\"#类的构造器代理规则\" class=\"headerlink\" title=\"类的构造器代理规则\"></a>类的构造器代理规则</h4><p>为了简化指定构造器和便利构造器之间的调用关系，Swift 采用以下三条规则来限制构造器之间的代理调用：</p>\n<ul>\n<li>指定构造器必须调用其直接父类的的指定构造器。</li>\n<li>便利构造器必须调用同类中定义的其它构造器。</li>\n<li>便利构造器必须最终导致一个指定构造器被调用。</li>\n</ul>\n<p>可以通过如下方法进行记忆：</p>\n<ul>\n<li>指定构造器必须总是向上代理</li>\n<li>便利构造器必须总是横向代理</li>\n</ul>\n<p><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializerDelegation01_2x.png\" alt=\"\"></p>\n<p>下面图例中展示了一种涉及四个类的更复杂的类层级结构。它演示了指定构造器是如何在类层级中充当“管道”的作用，在类的构造器链上简化了类之间的相互关系。<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializerDelegation02_2x.png\" alt=\"\"></p>\n<h4 id=\"两段式构造过程\"><a href=\"#两段式构造过程\" class=\"headerlink\" title=\"两段式构造过程\"></a>两段式构造过程</h4><p>Swift 中类的构造过程包含两个阶段。第一个阶段，每个存储型属性被引入它们的类指定一个初始值。当每个存储型属性的初始值被确定后，第二阶段开始，它给每个类一次机会，在新实例准备使用之前进一步定制它们的存储型属性。</p>\n<p>两段式构造过程的使用让构造过程更安全，同时在整个类层级结构中给予了每个类完全的灵活性。两段式构造过程可以防止属性值在初始化之前被访问，也可以防止属性被另外一个构造器意外地赋予不同的值。</p>\n<blockquote>\n<p>说明白点儿就是：第一阶段是使用内存的申请与属性的初始化，第二阶段是属性的初始化赋值。<br>    Swift 的两段式构造过程跟 Objective-C 中的构造过程类似。最主要的区别在于阶段 1，Objective-C 给每一个属性赋值0或空值（比如说0或nil）。Swift 的构造流程则更加灵活，它允许你设置定制的初始值，并自如应对某些属性不能以0或nil作为合法默认值的情况。</p>\n</blockquote>\n<p>Swift 编译器将执行 4 种有效的安全检查，以确保两段式构造过程能不出错地完成：</p>\n<ul>\n<li>安全检查 1<ul>\n<li>指定构造器必须保证它所在类引入的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类中的构造器。<br>如上所述，一个对象的内存只有在其所有存储型属性确定之后才能完全初始化。为了满足这一规则，指定构造器必须保证它所在类引入的属性在它往上代理之前先完成初始化。</li>\n</ul>\n</li>\n<li>安全检查 2<ul>\n<li>指定构造器必须先向上代理调用父类构造器，然后再为继承的属性设置新值。如果没这么做，指定构造器赋予的新值将被父类中的构造器所覆盖。</li>\n</ul>\n</li>\n<li>安全检查 3<ul>\n<li>指便利构造器必须先代理调用同一类中的其它构造器，然后再为任意属性赋新值。如果没这么做，便利构造器赋予的新值将被同一类中其它指定构造器所覆盖。</li>\n</ul>\n</li>\n<li>安全检查 4<ul>\n<li>构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用self作为一个值。</li>\n</ul>\n</li>\n</ul>\n<p>类实例在第一阶段结束以前并不是完全有效的。只有第一阶段完成后，该实例才会成为有效实例，才能访问属性和调用方法。</p>\n<p>以下是两段式构造过程中基于上述安全检查的构造流程展示：</p>\n<ul>\n<li>阶段 1<ul>\n<li>某个指定构造器或便利构造器被调用。</li>\n<li>完成新实例内存的分配，但此时内存还没有被初始化。</li>\n<li>指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化。</li>\n<li>指定构造器将调用父类的构造器，完成父类属性的初始化。</li>\n<li>这个调用父类构造器的过程沿着构造器链一直往上执行，直到到达构造器链的最顶部。</li>\n<li>当到达了构造器链最顶部，且已确保所有实例包含的存储型属性都已经赋值，这个实例的内存被认为已经完全初始化。此时阶段 1 完成。</li>\n</ul>\n</li>\n<li>阶段 2<ul>\n<li>从顶部构造器链一直往下，每个构造器链中类的指定构造器都有机会进一步定制实例。构造器此时可以访问self、修改它的属性并调用实例方法等等。</li>\n<li>最终，任意构造器链中的便利构造器可以有机会定制实例和使用self。</li>\n</ul>\n</li>\n</ul>\n<p>下图展示了在假定的子类和父类之间的构造阶段 1：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/twoPhaseInitialization01_2x.png\" alt=\"\"><br>在这个例子中，构造过程从对子类中一个便利构造器的调用开始。这个便利构造器此时没法修改任何属性，它把构造任务代理给同一类中的指定构造器。<br>如安全检查 1 所示，指定构造器将确保所有子类的属性都有值。然后它将调用父类的指定构造器，并沿着构造器链一直往上完成父类的构造过程。<br>父类中的指定构造器确保所有父类的属性都有值。由于没有更多的父类需要初始化，也就无需继续向上代理。一旦父类中所有属性都有了初始值，实例的内存被认为是完全初始化，阶段 1 完成。</p>\n<p>以下展示了相同构造过程的阶段 2：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/twoPhaseInitialization02_2x.png\" alt=\"\"><br>父类中的指定构造器现在有机会进一步来定制实例（尽管这不是必须的）。<br>一旦父类中的指定构造器完成调用，子类中的指定构造器可以执行更多的定制操作（这也不是必须的）。<br>最终，一旦子类的指定构造器完成调用，最开始被调用的便利构造器可以执行更多的定制操作。</p>\n<h4 id=\"构造器的继承和重写\"><a href=\"#构造器的继承和重写\" class=\"headerlink\" title=\"构造器的继承和重写\"></a>构造器的继承和重写</h4><p>跟 Objective-C 中的子类不同，Swift 中的子类默认情况下不会继承父类的构造器。Swift 的这种机制可以防止一个父类的简单构造器被一个更精细的子类继承，并被错误地用来创建子类的实例。<br>    父类的构造器仅会在安全和适当的情况下被继承。</p>\n<p>假如你希望自定义的子类中能提供一个或多个跟父类相同的构造器，你可以在子类中提供这些构造器的自定义实现。<br>当你在编写一个和父类中指定构造器相匹配的子类构造器时，你实际上是在重写父类的这个指定构造器。因此，你必须在定义子类构造器时带上 <code>override</code> 修饰符。即使你重写的是系统自动提供的默认构造器，也需要带上override修饰符。<br>正如重写属性，方法或者是下标，override修饰符会让编译器去检查父类中是否有相匹配的指定构造器，并验证构造器参数是否正确。<br>    当你重写一个父类的指定构造器时，你总是需要写override修饰符，即使你的子类将父类的指定构造器重写为了便利构造器。</p>\n<p>如果你编写了一个和父类便利构造器相匹配的子类构造器，由于子类不能直接调用父类的便利构造器（每个规则都在上文类的构造器代理规则有所描述）。因此，严格意义上来讲，你的子类并未对一个父类构造器提供重写。最后的结果就是，你在子类中“重写”一个父类便利构造器时，不需要加override前缀。</p>\n<p>在下面的例子中定义了一个叫Vehicle的基类。基类中声明了一个存储型属性numberOfWheels，它是值为0的Int类型的存储型属性。numberOfWheels属性用于创建名为descrpiption的String类型的计算型属性：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vehicle</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> numberOfWheels = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">var</span> description: <span class=\"type\">String</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"<span class=\"subst\">\\(numberOfWheels)</span> wheel(s)\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> vehicle = <span class=\"type\">Vehicle</span>()</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Vehicle: <span class=\"subst\">\\(vehicle.description)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Vehicle: 0 wheel(s)</span></div></pre></td></tr></table></figure>\n<p>下面例子中定义了一个Vehicle的子类Bicycle：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bicycle</span>: <span class=\"title\">Vehicle</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">init</span>() &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>()</div><div class=\"line\">        numberOfWheels = <span class=\"number\">2</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> bicycle = <span class=\"type\">Bicycle</span>()</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Bicycle: <span class=\"subst\">\\(bicycle.description)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Bicycle: 2 wheel(s)</span></div></pre></td></tr></table></figure>\n<p>子类Bicycle定义了一个自定义指定构造器init()。这个指定构造器和父类的指定构造器相匹配，所以Bicycle中的指定构造器需要带上override修饰符。<br>Bicycle的构造器init()以调用super.init()方法开始，这个方法的作用是调用Bicycle的父类Vehicle的默认构造器。这样可以确保Bicycle在修改属性之前，它所继承的属性numberOfWheels能被Vehicle类初始化。在调用super.init()之后，属性numberOfWheels的原值被新值2替换。<br>    子类可以在初始化时修改继承来的变量属性，但是不能修改继承来的常量属性。</p>\n<h4 id=\"构造器的自动继承\"><a href=\"#构造器的自动继承\" class=\"headerlink\" title=\"构造器的自动继承\"></a>构造器的自动继承</h4><p>如上所述，子类在默认情况下不会继承父类的构造器。但是如果满足特定条件，父类构造器是可以被自动继承的。在实践中，这意味着对于许多常见场景你不必重写父类的构造器，并且可以在安全的情况下以最小的代价继承父类的构造器。<br>假设你为子类中引入的所有新属性都提供了默认值，以下 2 个规则适用：</p>\n<ul>\n<li>规则 1<ul>\n<li>如果子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。</li>\n</ul>\n</li>\n<li>规则 2<ul>\n<li>如果子类提供了所有父类指定构造器的实现——无论是通过规则 1 继承过来的，还是提供了自定义实现——它将自动继承所有父类的便利构造器。</li>\n</ul>\n</li>\n</ul>\n<p>即使你在子类中添加了更多的便利构造器，这两条规则仍然适用。<br>    对于规则 2，子类可以将父类的指定构造器实现为便利构造器。</p>\n<h4 id=\"指定构造器和便利构造器实践\"><a href=\"#指定构造器和便利构造器实践\" class=\"headerlink\" title=\"指定构造器和便利构造器实践\"></a>指定构造器和便利构造器实践</h4><p>接下来的例子将在实践中展示指定构造器、便利构造器以及构造器的自动继承。这个例子定义了包含三个类Food、RecipeIngredient以及ShoppingListItem的类层次结构，并将演示它们的构造器是如何相互作用的。<br>类层次中的基类是Food，它是一个简单的用来封装食物名字的类。Food类引入了一个叫做name的String类型的属性，并且提供了两个构造器来创建Food实例：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializersExample01_2x.png\" alt=\"\"><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Food</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.name = name</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">convenience</span> <span class=\"keyword\">init</span>() &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.<span class=\"keyword\">init</span>(name: <span class=\"string\">\"[Unnamed]\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>类没有默认的逐一成员构造器，所以Food类提供了一个接受单一参数name的指定构造器。这个构造器可以使用一个特定的名字来创建新的Food实例。同样提供了一个没有参数的便利构造器init()。这个init()构造器为新食物提供了一个默认的占位名字，通过横向代理到指定构造器init(name: String)并给参数name传值[Unnamed]来实现：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> namedMeat = <span class=\"type\">Food</span>(name: <span class=\"string\">\"Bacon\"</span>)</div><div class=\"line\"><span class=\"comment\">// namedMeat's name is \"Bacon\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> mysteryMeat = <span class=\"type\">Food</span>()</div><div class=\"line\"><span class=\"comment\">// mysteryMeat's name is \"[Unnamed]\"</span></div></pre></td></tr></table></figure>\n<p>类层级中的第二个类是Food的子类RecipeIngredient。RecipeIngredient类用来表示食谱中的一项原料。它引入了Int类型的属性quantity（以及从Food继承过来的name属性），并且定义了两个构造器来创建RecipeIngredient实例：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializersExample02_2x.png\" alt=\"\"><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RecipeIngredient</span>: <span class=\"title\">Food</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> quantity: <span class=\"type\">Int</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>, quantity: <span class=\"type\">Int</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.quantity = quantity</div><div class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(name: name)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">convenience</span> <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.<span class=\"keyword\">init</span>(name: name, quantity: <span class=\"number\">1</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>RecipeIngredient类拥有一个指定构造器init(name: String, quantity: Int)，它可以用来填充RecipeIngredient实例的所有属性值。这个构造器一开始先将传入的quantity参数赋值给quantity属性，这个属性也是唯一在RecipeIngredient中新引入的属性。随后，构造器向上代理到父类Food的init(name: String)。这个过程满足两段式构造过程中的安全检查 1。</p>\n<p>RecipeIngredient还定义了一个便利构造器init(name: String)，它只通过name来创建RecipeIngredient的实例。这个便利构造器假设任意RecipeIngredient实例的quantity为1，所以不需要显式指明数量即可创建出实例。这个便利构造器的定义可以更加方便和快捷地创建实例，并且避免了创建多个quantity为1的RecipeIngredient实例时的代码重复。这个便利构造器只是简单地横向代理到类中的指定构造器，并为quantity参数传递1。<br>注意，RecipeIngredient的便利构造器init(name: String)使用了跟Food中指定构造器init(name: String)相同的参数。由于这个便利构造器重写了父类的指定构造器init(name: String)，因此必须在前面使用override修饰符</p>\n<p>尽管RecipeIngredient将父类的指定构造器重写为了便利构造器，它依然提供了父类的所有指定构造器的实现。因此，RecipeIngredient会自动继承父类的所有便利构造器。<br>在这个例子中，RecipeIngredient的父类是Food，它有一个便利构造器init()。这个便利构造器会被RecipeIngredient继承。这个继承版本的init()在功能上跟Food提供的版本是一样的，只是它会代理到RecipeIngredient版本的init(name: String)而不是Food提供的版本。</p>\n<p>所有的这三种构造器都可以用来创建新的RecipeIngredient实例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> oneMysteryItem = <span class=\"type\">RecipeIngredient</span>()</div><div class=\"line\"><span class=\"keyword\">let</span> oneBacon = <span class=\"type\">RecipeIngredient</span>(name: <span class=\"string\">\"Bacon\"</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> sixEggs = <span class=\"type\">RecipeIngredient</span>(name: <span class=\"string\">\"Eggs\"</span>, quantity: <span class=\"number\">6</span>)</div></pre></td></tr></table></figure>\n<p>类层级中第三个也是最后一个类是RecipeIngredient的子类，叫做ShoppingListItem。这个类构建了购物单中出现的某一种食谱原料。</p>\n<p>购物单中的每一项总是从未购买状态开始的。为了呈现这一事实，ShoppingListItem引入了一个布尔类型的属性purchased，它的默认值是false。ShoppingListItem还添加了一个计算型属性description，它提供了关于ShoppingListItem实例的一些文字描述：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShoppingListItem</span>: <span class=\"title\">RecipeIngredient</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> purchased = <span class=\"literal\">false</span></div><div class=\"line\">    <span class=\"keyword\">var</span> description: <span class=\"type\">String</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> output = <span class=\"string\">\"<span class=\"subst\">\\(quantity)</span> x <span class=\"subst\">\\(name)</span>\"</span></div><div class=\"line\">        output += purchased ? <span class=\"string\">\" ✔\"</span> : <span class=\"string\">\" ✘\"</span></div><div class=\"line\">        <span class=\"keyword\">return</span> output</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<pre><code>ShoppingListItem没有定义构造器来为purchased提供初始值，因为添加到购物单的物品的初始状态总是未购买。\n</code></pre><p>由于它为自己引入的所有属性都提供了默认值，并且自己没有定义任何构造器，ShoppingListItem将自动继承所有父类中的指定构造器和便利构造器。<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializersExample03_2x.png\" alt=\"\"><br>你可以使用全部三个继承来的构造器来创建ShoppingListItem的新实例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> breakfastList = [</div><div class=\"line\">    <span class=\"type\">ShoppingListItem</span>(),</div><div class=\"line\">    <span class=\"type\">ShoppingListItem</span>(name: <span class=\"string\">\"Bacon\"</span>),</div><div class=\"line\">    <span class=\"type\">ShoppingListItem</span>(name: <span class=\"string\">\"Eggs\"</span>, quantity: <span class=\"number\">6</span>),</div><div class=\"line\">]</div><div class=\"line\">breakfastList[<span class=\"number\">0</span>].name = <span class=\"string\">\"Orange juice\"</span></div><div class=\"line\">breakfastList[<span class=\"number\">0</span>].purchased = <span class=\"literal\">true</span></div><div class=\"line\"><span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> breakfastList &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(item.description)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 1 x Orange juice ✔</span></div><div class=\"line\"><span class=\"comment\">// 1 x Bacon ✘</span></div><div class=\"line\"><span class=\"comment\">// 6 x Eggs ✘</span></div></pre></td></tr></table></figure>\n<h3 id=\"可失败构造器\"><a href=\"#可失败构造器\" class=\"headerlink\" title=\"可失败构造器\"></a>可失败构造器</h3><p>如果一个类、结构体或枚举类型的对象，在构造过程中有可能失败，则为其定义一个可失败构造器。这里所指的“失败”是指，如给构造器传入无效的参数值，或缺少某种所需的外部资源，又或是不满足某种必要的条件等。<br>为了妥善处理这种构造过程中可能会失败的情况。你可以在一个类，结构体或是枚举类型的定义中，添加一个或多个可失败构造器。其语法为在 <code>init</code> 关键字后面添加问号( <code>init?</code> )。<br>    可失败构造器的参数名和参数类型，不能与其它非可失败构造器的参数名，及其参数类型相同。</p>\n<p>可失败构造器会创建一个类型为自身类型的可选类型的对象。你通过return nil语句来表明可失败构造器在何种情况下应该“失败”。<br>    严格来说，构造器都不支持返回值。因为构造器本身的作用，只是为了确保对象能被正确构造。因此你只是用return nil表明可失败构造器构造失败，而不要用关键字return来表明构造成功。</p>\n<p>下例中，定义了一个名为Animal的结构体，其中有一个名为species的String类型的常量属性。同时该结构体还定义了一个接受一个名为species的String类型参数的可失败构造器。这个可失败构造器检查传入的参数是否为一个空字符串。如果为空字符串，则构造失败。否则，species属性被赋值，构造成功。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Animal</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> species: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">init</span>?(species: <span class=\"type\">String</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> species.isEmpty &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</div><div class=\"line\">        <span class=\"keyword\">self</span>.species = species</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你可以通过该可失败构造器来构建一个Animal的实例，并检查构造过程是否成功：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> someCreature = <span class=\"type\">Animal</span>(species: <span class=\"string\">\"Giraffe\"</span>)</div><div class=\"line\"><span class=\"comment\">// someCreature is of type Animal?, not Animal</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> giraffe = someCreature &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"An animal was initialized with a species of <span class=\"subst\">\\(giraffe.species)</span>\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"An animal was initialized with a species of Giraffe\"</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> anonymousCreature = <span class=\"type\">Animal</span>(species: <span class=\"string\">\"\"</span>)</div><div class=\"line\"><span class=\"comment\">// anonymousCreature is of type Animal?, not Animal</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">if</span> anonymousCreature == <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The anonymous creature could not be initialized\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"The anonymous creature could not be initialized\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"枚举类型的可失败构造器\"><a href=\"#枚举类型的可失败构造器\" class=\"headerlink\" title=\"枚举类型的可失败构造器\"></a>枚举类型的可失败构造器</h4><p>你可以通过一个带一个或多个参数的可失败构造器来获取枚举类型中特定的枚举成员。如果提供的参数无法匹配任何枚举成员，则构造失败。</p>\n<p>下例中，定义了一个名为TemperatureUnit的枚举类型。其中包含了三个可能的枚举成员(Kelvin，Celsius，和Fahrenheit)，以及一个根据Character值找出所对应的枚举成员的可失败构造器：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">TemperatureUnit</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> kelvin, celsius, fahrenheit</div><div class=\"line\">    <span class=\"keyword\">init</span>?(symbol: <span class=\"type\">Character</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> symbol &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"K\"</span>:</div><div class=\"line\">            <span class=\"keyword\">self</span> = .kelvin</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"C\"</span>:</div><div class=\"line\">            <span class=\"keyword\">self</span> = .celsius</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"F\"</span>:</div><div class=\"line\">            <span class=\"keyword\">self</span> = .fahrenheit</div><div class=\"line\">        <span class=\"keyword\">default</span>:</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你可以利用该可失败构造器在三个枚举成员中获取一个相匹配的枚举成员，当参数的值不能与任何枚举成员相匹配时，则构造失败：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> fahrenheitUnit = <span class=\"type\">TemperatureUnit</span>(symbol: <span class=\"string\">\"F\"</span>)</div><div class=\"line\"><span class=\"keyword\">if</span> fahrenheitUnit != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"This is a defined temperature unit, so initialization succeeded.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"This is a defined temperature unit, so initialization succeeded.\"</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">let</span> unknownUnit = <span class=\"type\">TemperatureUnit</span>(symbol: <span class=\"string\">\"X\"</span>)</div><div class=\"line\"><span class=\"keyword\">if</span> unknownUnit == <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"This is not a defined temperature unit, so initialization failed.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"This is not a defined temperature unit, so initialization failed.\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"带原始值的枚举类型的可失败构造器\"><a href=\"#带原始值的枚举类型的可失败构造器\" class=\"headerlink\" title=\"带原始值的枚举类型的可失败构造器\"></a>带原始值的枚举类型的可失败构造器</h4><p>带原始值的枚举类型会自带一个可失败构造器init?(rawValue:)，该可失败构造器有一个名为rawValue的参数，其类型和枚举类型的原始值类型一致，如果该参数的值能够和某个枚举成员的原始值匹配，则该构造器会构造相应的枚举成员，否则构造失败。</p>\n<p>因此上面的TemperatureUnit的例子可以重写为：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">TemperatureUnit</span>: <span class=\"title\">Character</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> kelvin = <span class=\"string\">\"K\"</span>, celsius = <span class=\"string\">\"C\"</span>, fahrenheit = <span class=\"string\">\"F\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">let</span> fahrenheitUnit = <span class=\"type\">TemperatureUnit</span>(rawValue: <span class=\"string\">\"F\"</span>)</div><div class=\"line\"><span class=\"keyword\">if</span> fahrenheitUnit != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"This is a defined temperature unit, so initialization succeeded.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"This is a defined temperature unit, so initialization succeeded.\"</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">let</span> unknownUnit = <span class=\"type\">TemperatureUnit</span>(rawValue: <span class=\"string\">\"X\"</span>)</div><div class=\"line\"><span class=\"keyword\">if</span> unknownUnit == <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"This is not a defined temperature unit, so initialization failed.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"This is not a defined temperature unit, so initialization failed.\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"构造失败的传递\"><a href=\"#构造失败的传递\" class=\"headerlink\" title=\"构造失败的传递\"></a>构造失败的传递</h4><p>类，结构体，枚举的可失败构造器可以横向代理到类型中的其他可失败构造器。类似的，子类的可失败构造器也能向上代理到父类的可失败构造器。<br>无论是向上代理还是横向代理，如果你代理到的其他可失败构造器触发构造失败，整个构造过程将立即终止，接下来的任何构造代码不会再被执行。<br>    可失败构造器也可以代理到其它的非可失败构造器。通过这种方式，你可以增加一个可能的失败状态到现有的构造过程中。</p>\n<p>下面这个例子，定义了一个名为CartItem的Product类的子类。这个类建立了一个在线购物车中的物品的模型，它有一个名为quantity的常量存储型属性，并确保该属性的值至少为1：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Product</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> name: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">init</span>?(name: <span class=\"type\">String</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> name.isEmpty &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</div><div class=\"line\">        <span class=\"keyword\">self</span>.name = name</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CartItem</span>: <span class=\"title\">Product</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> quantity: <span class=\"type\">Int</span></div><div class=\"line\">    <span class=\"keyword\">init</span>?(name: <span class=\"type\">String</span>, quantity: <span class=\"type\">Int</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> quantity &lt; <span class=\"number\">1</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</div><div class=\"line\">        <span class=\"keyword\">self</span>.quantity = quantity</div><div class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(name: name)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>CartItem 可失败构造器首先验证接收的 quantity 值是否大于等于 1 。倘若 quantity 值无效，则立即终止整个构造过程，返回失败结果，且不再执行余下代码。同样地，Product 的可失败构造器首先检查 name 值，假如 name 值为空字符串，则构造器立即执行失败。</p>\n<p>如果你通过传入一个非空字符串 name 以及一个值大于等于 1 的 quantity 来创建一个 CartItem 实例，那么构造方法能够成功被执行：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> twoSocks = <span class=\"type\">CartItem</span>(name: <span class=\"string\">\"sock\"</span>, quantity: <span class=\"number\">2</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Item: <span class=\"subst\">\\(twoSocks.name)</span>, quantity: <span class=\"subst\">\\(twoSocks.quantity)</span>\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"Item: sock, quantity: 2\"</span></div></pre></td></tr></table></figure>\n<p>倘若你以一个值为 0 的 quantity 来创建一个 CartItem 实例，那么将导致 CartItem 构造器失败：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> zeroShirts = <span class=\"type\">CartItem</span>(name: <span class=\"string\">\"shirt\"</span>, quantity: <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Item: <span class=\"subst\">\\(zeroShirts.name)</span>, quantity: <span class=\"subst\">\\(zeroShirts.quantity)</span>\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Unable to initialize zero shirts\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"Unable to initialize zero shirts\"</span></div></pre></td></tr></table></figure>\n<p>同样地，如果你尝试传入一个值为空字符串的 name来创建一个 CartItem 实例，那么将导致父类 Product 的构造过程失败：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> oneUnnamed = <span class=\"type\">CartItem</span>(name: <span class=\"string\">\"\"</span>, quantity: <span class=\"number\">1</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Item: <span class=\"subst\">\\(oneUnnamed.name)</span>, quantity: <span class=\"subst\">\\(oneUnnamed.quantity)</span>\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Unable to initialize one unnamed product\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"Unable to initialize one unnamed product\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"重写一个可失败构造器\"><a href=\"#重写一个可失败构造器\" class=\"headerlink\" title=\"重写一个可失败构造器\"></a>重写一个可失败构造器</h4><p>如同其它的构造器，你可以在子类中重写父类的可失败构造器。或者你也可以用子类的非可失败构造器重写一个父类的可失败构造器。这使你可以定义一个不会构造失败的子类，即使父类的构造器允许构造失败。<br>当你用子类的非可失败构造器重写父类的可失败构造器时，向上代理到父类的可失败构造器的唯一方式是对父类的可失败构造器的返回值进行强制解包。<br>    你可以用非可失败构造器重写可失败构造器，但反过来却不行。</p>\n<p>下例定义了一个名为Document的类，name属性的值必须为一个非空字符串或nil，但不能是一个空字符串：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Document</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span>?</div><div class=\"line\">    <span class=\"comment\">// this initializer creates a document with a nil name value</span></div><div class=\"line\">    <span class=\"keyword\">init</span>() &#123;&#125;</div><div class=\"line\">    <span class=\"comment\">// this initializer creates a document with a nonempty name value</span></div><div class=\"line\">    <span class=\"keyword\">init</span>?(name: <span class=\"type\">String</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> name.isEmpty &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</div><div class=\"line\">        <span class=\"keyword\">self</span>.name = name</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下面这个例子，定义了一个Document类的子类AutomaticallyNamedDocument。这个子类重写了父类的两个指定构造器，确保了无论是使用init()构造器，还是使用init(name:)构造器并为参数传递空字符串，生成的实例中的name属性总有初始”[Untitled]”：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AutomaticallyNamedDocument</span>: <span class=\"title\">Document</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">init</span>() &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>()</div><div class=\"line\">        <span class=\"keyword\">self</span>.name = <span class=\"string\">\"[Untitled]\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>()</div><div class=\"line\">        <span class=\"keyword\">if</span> name.isEmpty &#123;</div><div class=\"line\">            <span class=\"keyword\">self</span>.name = <span class=\"string\">\"[Untitled]\"</span></div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">self</span>.name = name</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>AutomaticallyNamedDocument用一个非可失败构造器init(name:)重写了父类的可失败构造器init?(name:)。因为子类用另一种方式处理了空字符串的情况，所以不再需要一个可失败构造器，因此子类用一个非可失败构造器代替了父类的可失败构造器。</p>\n<p>你可以在子类的非可失败构造器中使用强制解包来调用父类的可失败构造器。比如，下面的UntitledDocument子类的name属性的值总是”[Untitled]”，它在构造过程中使用了父类的可失败构造器init?(name:)：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UntitledDocument</span>: <span class=\"title\">Document</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">init</span>() &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(name: <span class=\"string\">\"[Untitled]\"</span>)!</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"可失败构造器-init\"><a href=\"#可失败构造器-init\" class=\"headerlink\" title=\"可失败构造器 init!\"></a>可失败构造器 init!</h4><p>通常来说我们通过在init关键字后添加问号的方式（init?）来定义一个可失败构造器，但你也可以通过在init后面添加惊叹号的方式来定义一个可失败构造器（init!），该可失败构造器将会构建一个对应类型的隐式解包可选类型的对象。</p>\n<p>你可以在init?中代理到init!，反之亦然。你也可以用init?重写init!，反之亦然。你还可以用init代理到init!，不过，一旦init!构造失败，则会触发一个断言。</p>\n<h3 id=\"必要构造器\"><a href=\"#必要构造器\" class=\"headerlink\" title=\"必要构造器\"></a>必要构造器</h3><p>在类的构造器前添加 <code>required</code> 修饰符表明所有该类的子类都必须实现该构造器：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClass</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">required</span> <span class=\"keyword\">init</span>() &#123;</div><div class=\"line\">        <span class=\"comment\">// initializer implementation goes here</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在子类重写父类的必要构造器时，必须在子类的构造器前也添加required修饰符，表明该构造器要求也应用于继承链后面的子类。在重写父类中必要的指定构造器时，不需要添加override修饰符：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeSubclass</span>: <span class=\"title\">SomeClass</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">required</span> <span class=\"keyword\">init</span>() &#123;</div><div class=\"line\">        <span class=\"comment\">// subclass implementation of the required initializer goes here</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<pre><code>如果子类继承的构造器能满足必要构造器的要求，则无须在子类中显式提供必要构造器的实现。\n</code></pre><h3 id=\"通过闭包或函数设置属性的默认值\"><a href=\"#通过闭包或函数设置属性的默认值\" class=\"headerlink\" title=\"通过闭包或函数设置属性的默认值\"></a>通过闭包或函数设置属性的默认值</h3><p>如果某个存储型属性的默认值需要一些定制或设置，你可以使用闭包或全局函数为其提供定制的默认值。每当某个属性所在类型的新实例被创建时，对应的闭包或函数会被调用，而它们的返回值会当做默认值赋值给这个属性。<br>这种类型的闭包或函数通常会创建一个跟属性类型相同的临时变量，然后修改它的值以满足预期的初始状态，最后返回这个临时变量，作为属性的默认值。</p>\n<p>下面介绍了如何用闭包为属性提供默认值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClass</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> someProperty: <span class=\"type\">SomeType</span> = &#123;</div><div class=\"line\">        <span class=\"comment\">// create a default value for someProperty inside this closure</span></div><div class=\"line\">        <span class=\"comment\">// someValue must be of the same type as SomeType</span></div><div class=\"line\">        <span class=\"keyword\">return</span> someValue</div><div class=\"line\">    &#125;()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意闭包结尾的大括号后面接了一对空的小括号。这用来告诉 Swift 立即执行此闭包。如果你忽略了这对括号，相当于将闭包本身作为值赋值给了属性，而不是将闭包的返回值赋值给属性。<br>    如果你使用闭包来初始化属性，请记住在闭包执行时，实例的其它部分都还没有初始化。这意味着你不能在闭包里访问其它属性，即使这些属性有默认值。同样，你也不能使用隐式的self属性，或者调用任何实例方法。</p>\n<p>下面例子中定义了一个结构体Checkerboard，它构建了西洋跳棋游戏的棋盘：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/chessBoard_2x.png\" alt=\"\"><br>西洋跳棋游戏在一副黑白格交替的10x10的棋盘中进行。为了呈现这副游戏棋盘，Checkerboard结构体定义了一个属性boardColors，它是一个包含100个Bool值的数组。在数组中，值为true的元素表示一个黑格，值为false的元素表示一个白格。数组中第一个元素代表棋盘上左上角的格子，最后一个元素代表棋盘上右下角的格子。</p>\n<p>boardColor数组是通过一个闭包来初始化并设置颜色值的：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Chessboard</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> boardColors: [<span class=\"type\">Bool</span>] = &#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> temporaryBoard = [<span class=\"type\">Bool</span>]()</div><div class=\"line\">        <span class=\"keyword\">var</span> isBlack = <span class=\"literal\">false</span></div><div class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">1</span>...<span class=\"number\">8</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"number\">1</span>...<span class=\"number\">8</span> &#123;</div><div class=\"line\">                temporaryBoard.append(isBlack)</div><div class=\"line\">                isBlack = !isBlack</div><div class=\"line\">            &#125;</div><div class=\"line\">            isBlack = !isBlack</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> temporaryBoard</div><div class=\"line\">    &#125;()</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">squareIsBlackAt</span><span class=\"params\">(row: Int, column: Int)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> boardColors[(row * <span class=\"number\">8</span>) + column]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>每当一个新的Checkerboard实例被创建时，赋值闭包会被执行，boardColors的默认值会被计算出来并返回。上面例子中描述的闭包将计算出棋盘中每个格子对应的颜色，并将这些值保存到一个临时数组temporaryBoard中，最后在构建完成时将此数组作为闭包返回值返回。这个返回的数组会保存到boardColors中，并可以通过工具函数squareIsBlackAtRow来查询：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> board = <span class=\"type\">Chessboard</span>()</div><div class=\"line\"><span class=\"built_in\">print</span>(board.squareIsBlackAt(row: <span class=\"number\">0</span>, column: <span class=\"number\">1</span>))</div><div class=\"line\"><span class=\"comment\">// Prints \"true\"</span></div><div class=\"line\"><span class=\"built_in\">print</span>(board.squareIsBlackAt(row: <span class=\"number\">7</span>, column: <span class=\"number\">7</span>))</div><div class=\"line\"><span class=\"comment\">// Prints \"false\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html/\" target=\"_blank\" rel=\"external\"> Initialization </a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>​    构造过程是使用类、结构体、枚举的实例之前的准备过程。具体操作包括设置实例中每个存储型属性的初始值和执行其他必须的设置或初始化工作。在新实例可用前必须执行这个过程。<br>通过定义构造器来实现构造过程，这些构造器可以看做是用来创建特定类型新实例的特殊方法。与 Objective-C 中的构造器不同，Swift 的构造器无需返回值，它们的主要任务是保证新实例在第一次使用前完成正确的初始化。<br>类的实例也可以通过定义析构器在实例释放之前执行特定的清除工作。</p>\n<h3 id=\"存储属性的初始化值\"><a href=\"#存储属性的初始化值\" class=\"headerlink\" title=\"存储属性的初始化值\"></a>存储属性的初始化值</h3><p>类和结构体在创建实例时，必须为所有存储型属性设置合适的初始值。存储型属性的值不能处于一个未知的状态。你可以在构造器中为存储型属性赋初值，也可以在定义属性时为其设置默认值。<br>    为存储型属性设置默认值或者在构造器中为其赋值时，它们的值是被直接设置的，不会触发任何属性观察者。</p>","more":"<h4 id=\"构造器\"><a href=\"#构造器\" class=\"headerlink\" title=\"构造器\"></a>构造器</h4><p>构造器在创建某个特定类型的新实例时被调用。它的最简形式类似于一个不带任何参数的实例方法，以关键字 <code>init</code> 命名：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">init</span>() &#123;</div><div class=\"line\">    <span class=\"comment\">// perform some initialization here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下面例子中定义了一个用来保存华氏温度的结构体Fahrenheit，它拥有一个Double类型的存储型属性temperature：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Fahrenheit</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> temperature: <span class=\"type\">Double</span></div><div class=\"line\">    <span class=\"keyword\">init</span>() &#123;</div><div class=\"line\">        temperature = <span class=\"number\">32.0</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"type\">Fahrenheit</span>()</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The default temperature is <span class=\"subst\">\\(f.temperature)</span>° Fahrenheit\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"The default temperature is 32.0° Fahrenheit\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"默认属性值\"><a href=\"#默认属性值\" class=\"headerlink\" title=\"默认属性值\"></a>默认属性值</h4><p>可以在构造器中为存储型属性设置初始值。也可以在属性声明时为其设置默认值。<br>    如果一个属性总是使用相同的初始值，那么为其设置一个默认值比每次都在构造器中赋值要好。两种方法的效果是一样的，只不过使用默认值让属性的初始化和声明结合得更紧密。使用默认值能让你的构造器更简洁、更清晰，且能通过默认值自动推导出属性的类型；同时，它也能让你充分利用默认构造器、构造器继承等特性。</p>\n<p>你可以使用更简单的方式在定义结构体Fahrenheit时为属性temperature设置默认值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Fahrenheit</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> temperature = <span class=\"number\">32.0</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"自定义构造函数\"><a href=\"#自定义构造函数\" class=\"headerlink\" title=\"自定义构造函数\"></a>自定义构造函数</h3><p>可以通过输入参数和可选类型的属性来自定义构造过程，也可以在构造过程中修改 <code>常量</code> 属性。</p>\n<h4 id=\"构造参数\"><a href=\"#构造参数\" class=\"headerlink\" title=\"构造参数\"></a>构造参数</h4><p>可以在构造器定义中提供构造参数，指定所需值的类型和名字。构造参数的功能和语法跟函数和方法的参数相同。<br>下面例子中定义了一个包含摄氏度温度的结构体Celsius。它定义了两个不同的构造器：init(fromFahrenheit:)和init(fromKelvin:)，二者分别通过接受不同温标下的温度值来创建新的实例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Celsius</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> temperatureInCelsius: <span class=\"type\">Double</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(fromFahrenheit fahrenheit: <span class=\"type\">Double</span>) &#123;</div><div class=\"line\">        temperatureInCelsius = (fahrenheit - <span class=\"number\">32.0</span>) / <span class=\"number\">1.8</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">init</span>(fromKelvin kelvin: <span class=\"type\">Double</span>) &#123;</div><div class=\"line\">        temperatureInCelsius = kelvin - <span class=\"number\">273.15</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> boilingPointOfWater = <span class=\"type\">Celsius</span>(fromFahrenheit: <span class=\"number\">212.0</span>)</div><div class=\"line\"><span class=\"comment\">// boilingPointOfWater.temperatureInCelsius is 100.0</span></div><div class=\"line\"><span class=\"keyword\">let</span> freezingPointOfWater = <span class=\"type\">Celsius</span>(fromKelvin: <span class=\"number\">273.15</span>)</div><div class=\"line\"><span class=\"comment\">// freezingPointOfWater.temperatureInCelsius is 0.0</span></div></pre></td></tr></table></figure>\n<h4 id=\"参数的参数名和标签名-内部名称和外部名称\"><a href=\"#参数的参数名和标签名-内部名称和外部名称\" class=\"headerlink\" title=\"参数的参数名和标签名(内部名称和外部名称)\"></a>参数的参数名和标签名(内部名称和外部名称)</h4><p>跟函数和方法参数相同，构造参数也拥有一个在构造器内部使用的参数名字和一个在调用构造器时使用的外部参数名字（标签名）。<br>构造器并不像函数和方法那样在括号前有一个可辨别的名字（只有init）。因此在调用构造器时，主要通过构造器中的参数名和类型来确定应该被调用的构造器。正因为参数如此重要，如果你在定义构造器时没有提供参数的外部名字，Swift 会为构造器的每个参数自动生成一个跟内部名字相同的外部名。</p>\n<p>以下例子中定义了一个结构体Color，它包含了三个常量：red、green和blue。这些属性可以存储0.0到1.0之间的值，用来指示颜色中红、绿、蓝成分的含量。Color提供了一个构造器，其中包含三个Double类型的构造参数。Color也可以提供第二个构造器，它只包含名为white的Double类型的参数，它被用于给上述三个构造参数赋予同样的值。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Color</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> red, green, blue: <span class=\"type\">Double</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(red: <span class=\"type\">Double</span>, green: <span class=\"type\">Double</span>, blue: <span class=\"type\">Double</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.red   = red</div><div class=\"line\">        <span class=\"keyword\">self</span>.green = green</div><div class=\"line\">        <span class=\"keyword\">self</span>.blue  = blue</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">init</span>(white: <span class=\"type\">Double</span>) &#123;</div><div class=\"line\">        red   = white</div><div class=\"line\">        green = white</div><div class=\"line\">        blue  = white</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> magenta = <span class=\"type\">Color</span>(red: <span class=\"number\">1.0</span>, green: <span class=\"number\">0.0</span>, blue: <span class=\"number\">1.0</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> halfGray = <span class=\"type\">Color</span>(white: <span class=\"number\">0.5</span>)</div></pre></td></tr></table></figure>\n<pre><code>如果不通过外部参数名字传值，你是没法调用这个构造器的。只要构造器定义了某个外部参数名，你就必须使用它，忽略它将导致编译错误：\n</code></pre><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> veryGreen = <span class=\"type\">Color</span>(<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">0.0</span>)</div><div class=\"line\"><span class=\"comment\">// this reports a compile-time error - argument labels are required</span></div></pre></td></tr></table></figure>\n<h4 id=\"不带标签（外部名）的构造器参数\"><a href=\"#不带标签（外部名）的构造器参数\" class=\"headerlink\" title=\"不带标签（外部名）的构造器参数\"></a>不带标签（外部名）的构造器参数</h4><p>如果你不希望为构造器的某个参数提供外部名字，你可以使用下划线(<code>_</code>)来显式描述它的外部名，以此重写上面所说的默认行为。</p>\n<p>下面是之前Celsius例子的扩展，跟之前相比添加了一个带有Double类型参数的构造器，其外部名用<em>代替。调用Celsius(37.0)意图明确，不需要外部参数名称。因此适合使用init(</em> celsius: Double)这样的构造器，从而可以通过提供Double类型的参数值调用构造器，而不需要加上外部名。：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Celsius</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> temperatureInCelsius: <span class=\"type\">Double</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(fromFahrenheit fahrenheit: <span class=\"type\">Double</span>) &#123;</div><div class=\"line\">        temperatureInCelsius = (fahrenheit - <span class=\"number\">32.0</span>) / <span class=\"number\">1.8</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">init</span>(fromKelvin kelvin: <span class=\"type\">Double</span>) &#123;</div><div class=\"line\">        temperatureInCelsius = kelvin - <span class=\"number\">273.15</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"number\">_</span> celsius: <span class=\"type\">Double</span>) &#123;</div><div class=\"line\">        temperatureInCelsius = celsius</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> bodyTemperature = <span class=\"type\">Celsius</span>(<span class=\"number\">37.0</span>)</div><div class=\"line\"><span class=\"comment\">// bodyTemperature.temperatureInCelsius is 37.0</span></div></pre></td></tr></table></figure>\n<h4 id=\"可选属性类型\"><a href=\"#可选属性类型\" class=\"headerlink\" title=\"可选属性类型\"></a>可选属性类型</h4><p>如果你定制的类型包含一个逻辑上允许取值为空的存储型属性，你都需要将它定义为可选类型。可选类型的属性将自动初始化为nil，表示这个属性是有意在初始化时设置为空的。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SurveyQuestion</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> text: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">var</span> response: <span class=\"type\">String</span>?</div><div class=\"line\">    <span class=\"keyword\">init</span>(text: <span class=\"type\">String</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.text = text</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ask</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(text)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> cheeseQuestion = <span class=\"type\">SurveyQuestion</span>(text: <span class=\"string\">\"Do you like cheese?\"</span>)</div><div class=\"line\">cheeseQuestion.ask()</div><div class=\"line\"><span class=\"comment\">// Prints \"Do you like cheese?\"</span></div><div class=\"line\">cheeseQuestion.response = <span class=\"string\">\"Yes, I do like cheese.\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"构造过程中常量属性的修改\"><a href=\"#构造过程中常量属性的修改\" class=\"headerlink\" title=\"构造过程中常量属性的修改\"></a>构造过程中常量属性的修改</h4><p>你可以在构造过程中的任意时间点给常量属性指定一个值，只要在构造过程结束时是一个确定的值。一旦常量属性被赋值，它将永远不可更改。<br>    对于类的实例来说，它的常量属性只能在定义它的类的构造过程中修改；不能在子类中修改。</p>\n<p>你可以修改上面的SurveyQuestion示例，用常量属性替代变量属性text，表示问题内容text在SurveyQuestion的实例被创建之后不会再被修改。尽管text属性现在是常量，我们仍然可以在类的构造器中设置它的值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SurveyQuestion</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> text: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">var</span> response: <span class=\"type\">String</span>?</div><div class=\"line\">    <span class=\"keyword\">init</span>(text: <span class=\"type\">String</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.text = text</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ask</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(text)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> beetsQuestion = <span class=\"type\">SurveyQuestion</span>(text: <span class=\"string\">\"How about beets?\"</span>)</div><div class=\"line\">beetsQuestion.ask()</div><div class=\"line\"><span class=\"comment\">// Prints \"How about beets?\"</span></div><div class=\"line\">beetsQuestion.response = <span class=\"string\">\"I also like beets. (But not with cheese.)\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"默认构造器\"><a href=\"#默认构造器\" class=\"headerlink\" title=\"默认构造器\"></a>默认构造器</h3><p>如果结构体或类的所有属性都有默认值，同时没有自定义的构造器，那么 Swift 会给这些结构体或类提供一个默认构造器（default initializers）。这个默认构造器将简单地创建一个所有属性值都设置为默认值的实例。</p>\n<p>下面例子中创建了一个类ShoppingListItem，它封装了购物清单中的某一物品的属性：名字（name）、数量（quantity）和购买状态 purchase state：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShoppingListItem</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span>?</div><div class=\"line\">    <span class=\"keyword\">var</span> quantity = <span class=\"number\">1</span></div><div class=\"line\">    <span class=\"keyword\">var</span> purchased = <span class=\"literal\">false</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> item = <span class=\"type\">ShoppingListItem</span>()</div></pre></td></tr></table></figure>\n<h4 id=\"结构体的逐一成员构造器\"><a href=\"#结构体的逐一成员构造器\" class=\"headerlink\" title=\"结构体的逐一成员构造器\"></a>结构体的逐一成员构造器</h4><p>除了上面提到的默认构造器，如果结构体没有提供自定义的构造器，它们将自动获得一个逐一成员构造器，即使结构体的存储型属性没有默认值。</p>\n<p>逐一成员构造器是用来初始化结构体新实例里成员属性的快捷方法。我们在调用逐一成员构造器时，通过与成员属性名相同的参数名进行传值来完成对成员属性的初始赋值。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Size</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> width = <span class=\"number\">0.0</span>, height = <span class=\"number\">0.0</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> twoByTwo = <span class=\"type\">Size</span>(width: <span class=\"number\">2.0</span>, height: <span class=\"number\">2.0</span>)</div></pre></td></tr></table></figure>\n<h3 id=\"值类型的构造器代理\"><a href=\"#值类型的构造器代理\" class=\"headerlink\" title=\"值类型的构造器代理\"></a>值类型的构造器代理</h3><p>构造器可以通过调用其它构造器来完成实例的部分构造过程。这一过程称为构造器代理，它能减少多个构造器间的代码重复。</p>\n<p>构造器代理的实现规则和形式在值类型和类类型中有所不同。值类型（结构体和枚举类型）不支持继承，所以构造器代理的过程相对简单，因为它们只能代理给自己的其它构造器。类则不同，它可以继承自其它类，这意味着类有责任保证其所有继承的存储型属性在构造时也能正确的初始化。</p>\n<p>对于值类型，你可以使用self.init在自定义的构造器中引用相同类型中的其它构造器。并且你只能在构造器内部调用self.init。<br>    如果你为某个值类型定义了一个自定义的构造器，你将无法访问到默认构造器（如果是结构体，还将无法访问逐一成员构造器）。假如你希望默认构造器、逐一成员构造器以及你自己的自定义构造器都能用来创建实例，可以将自定义的构造器写到扩展（extension）中，而不是写在值类型的原始定义中。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Size</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> width = <span class=\"number\">0.0</span>, height = <span class=\"number\">0.0</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">0.0</span>, y = <span class=\"number\">0.0</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Rect</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> origin = <span class=\"type\">Point</span>()</div><div class=\"line\">    <span class=\"keyword\">var</span> size = <span class=\"type\">Size</span>()</div><div class=\"line\">    <span class=\"keyword\">init</span>() &#123;&#125;</div><div class=\"line\">    <span class=\"keyword\">init</span>(origin: <span class=\"type\">Point</span>, size: <span class=\"type\">Size</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.origin = origin</div><div class=\"line\">        <span class=\"keyword\">self</span>.size = size</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">init</span>(center: <span class=\"type\">Point</span>, size: <span class=\"type\">Size</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> originX = center.x - (size.width / <span class=\"number\">2</span>)</div><div class=\"line\">        <span class=\"keyword\">let</span> originY = center.y - (size.height / <span class=\"number\">2</span>)</div><div class=\"line\">        <span class=\"keyword\">self</span>.<span class=\"keyword\">init</span>(origin: <span class=\"type\">Point</span>(x: originX, y: originY), size: size)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上代码中，3中构造方法方式如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> basicRect = <span class=\"type\">Rect</span>()</div><div class=\"line\"><span class=\"comment\">// basicRect's origin is (0.0, 0.0) and its size is (0.0, 0.0)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> originRect = <span class=\"type\">Rect</span>(origin: <span class=\"type\">Point</span>(x: <span class=\"number\">2.0</span>, y: <span class=\"number\">2.0</span>),</div><div class=\"line\">                      size: <span class=\"type\">Size</span>(width: <span class=\"number\">5.0</span>, height: <span class=\"number\">5.0</span>))</div><div class=\"line\"><span class=\"comment\">// originRect's origin is (2.0, 2.0) and its size is (5.0, 5.0)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> centerRect = <span class=\"type\">Rect</span>(center: <span class=\"type\">Point</span>(x: <span class=\"number\">4.0</span>, y: <span class=\"number\">4.0</span>),</div><div class=\"line\">                      size: <span class=\"type\">Size</span>(width: <span class=\"number\">3.0</span>, height: <span class=\"number\">3.0</span>))</div><div class=\"line\"><span class=\"comment\">// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)</span></div></pre></td></tr></table></figure>\n<pre><code>如果你想用另外一种不需要自己定义init()和init(origin:size:)的方式来实现这个例子，可以通过扩展（Extensions）实现\n</code></pre><h3 id=\"类的继承和构造过程\"><a href=\"#类的继承和构造过程\" class=\"headerlink\" title=\"类的继承和构造过程\"></a>类的继承和构造过程</h3><p>类里面的所有存储型属性都必须在构造过程中设置初始值，包括所有继承自父类的属性。<br>Swift 为类类型提供了两种构造器来确保实例中所有存储型属性都能获得初始值，它们分别是指定构造器和便利构造器。</p>\n<h4 id=\"指定构造器和便利构造器\"><a href=\"#指定构造器和便利构造器\" class=\"headerlink\" title=\"指定构造器和便利构造器\"></a>指定构造器和便利构造器</h4><p>指定构造器是类中最主要的构造器。一个指定构造器将初始化类中提供的所有属性，并根据父类链往上调用父类的构造器来实现父类的初始化。一般情况下，类通常只有一个指定构造器。<br>每一个类都必须拥有至少一个指定构造器。在某些情况下，许多类通过继承了父类中的指定构造器而满足了这个条件。</p>\n<p>便利构造器是类中比较次要的、辅助型的构造器。你可以定义便利构造器来调用同一个类中的指定构造器，并为其参数提供默认值。你也可以定义便利构造器来创建一个特殊用途或特定输入值的实例。<br>便利构造器不是必需的。只在必要的时候为类提供便利构造器，比方说某种情况下通过使用便利构造器来快捷调用某个指定构造器，能够节省更多开发时间并让类的构造过程更清晰明了。</p>\n<h4 id=\"指定构造器和便利构造器的语法\"><a href=\"#指定构造器和便利构造器的语法\" class=\"headerlink\" title=\"指定构造器和便利构造器的语法\"></a>指定构造器和便利构造器的语法</h4><p>类的指定构造器的写法跟值类型简单构造器一样：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">init</span>(parameters) &#123;</div><div class=\"line\">    statements</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>便利构造器也采用相同样式的写法，但需要在 <code>init</code> 关键字之前放置 <code>convenience</code> 关键字，并使用空格将它们俩分开：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">convenience</span> <span class=\"keyword\">init</span>(parameters) &#123;</div><div class=\"line\">    statements</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"类的构造器代理规则\"><a href=\"#类的构造器代理规则\" class=\"headerlink\" title=\"类的构造器代理规则\"></a>类的构造器代理规则</h4><p>为了简化指定构造器和便利构造器之间的调用关系，Swift 采用以下三条规则来限制构造器之间的代理调用：</p>\n<ul>\n<li>指定构造器必须调用其直接父类的的指定构造器。</li>\n<li>便利构造器必须调用同类中定义的其它构造器。</li>\n<li>便利构造器必须最终导致一个指定构造器被调用。</li>\n</ul>\n<p>可以通过如下方法进行记忆：</p>\n<ul>\n<li>指定构造器必须总是向上代理</li>\n<li>便利构造器必须总是横向代理</li>\n</ul>\n<p><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializerDelegation01_2x.png\" alt=\"\"></p>\n<p>下面图例中展示了一种涉及四个类的更复杂的类层级结构。它演示了指定构造器是如何在类层级中充当“管道”的作用，在类的构造器链上简化了类之间的相互关系。<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializerDelegation02_2x.png\" alt=\"\"></p>\n<h4 id=\"两段式构造过程\"><a href=\"#两段式构造过程\" class=\"headerlink\" title=\"两段式构造过程\"></a>两段式构造过程</h4><p>Swift 中类的构造过程包含两个阶段。第一个阶段，每个存储型属性被引入它们的类指定一个初始值。当每个存储型属性的初始值被确定后，第二阶段开始，它给每个类一次机会，在新实例准备使用之前进一步定制它们的存储型属性。</p>\n<p>两段式构造过程的使用让构造过程更安全，同时在整个类层级结构中给予了每个类完全的灵活性。两段式构造过程可以防止属性值在初始化之前被访问，也可以防止属性被另外一个构造器意外地赋予不同的值。</p>\n<blockquote>\n<p>说明白点儿就是：第一阶段是使用内存的申请与属性的初始化，第二阶段是属性的初始化赋值。<br>    Swift 的两段式构造过程跟 Objective-C 中的构造过程类似。最主要的区别在于阶段 1，Objective-C 给每一个属性赋值0或空值（比如说0或nil）。Swift 的构造流程则更加灵活，它允许你设置定制的初始值，并自如应对某些属性不能以0或nil作为合法默认值的情况。</p>\n</blockquote>\n<p>Swift 编译器将执行 4 种有效的安全检查，以确保两段式构造过程能不出错地完成：</p>\n<ul>\n<li>安全检查 1<ul>\n<li>指定构造器必须保证它所在类引入的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类中的构造器。<br>如上所述，一个对象的内存只有在其所有存储型属性确定之后才能完全初始化。为了满足这一规则，指定构造器必须保证它所在类引入的属性在它往上代理之前先完成初始化。</li>\n</ul>\n</li>\n<li>安全检查 2<ul>\n<li>指定构造器必须先向上代理调用父类构造器，然后再为继承的属性设置新值。如果没这么做，指定构造器赋予的新值将被父类中的构造器所覆盖。</li>\n</ul>\n</li>\n<li>安全检查 3<ul>\n<li>指便利构造器必须先代理调用同一类中的其它构造器，然后再为任意属性赋新值。如果没这么做，便利构造器赋予的新值将被同一类中其它指定构造器所覆盖。</li>\n</ul>\n</li>\n<li>安全检查 4<ul>\n<li>构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用self作为一个值。</li>\n</ul>\n</li>\n</ul>\n<p>类实例在第一阶段结束以前并不是完全有效的。只有第一阶段完成后，该实例才会成为有效实例，才能访问属性和调用方法。</p>\n<p>以下是两段式构造过程中基于上述安全检查的构造流程展示：</p>\n<ul>\n<li>阶段 1<ul>\n<li>某个指定构造器或便利构造器被调用。</li>\n<li>完成新实例内存的分配，但此时内存还没有被初始化。</li>\n<li>指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化。</li>\n<li>指定构造器将调用父类的构造器，完成父类属性的初始化。</li>\n<li>这个调用父类构造器的过程沿着构造器链一直往上执行，直到到达构造器链的最顶部。</li>\n<li>当到达了构造器链最顶部，且已确保所有实例包含的存储型属性都已经赋值，这个实例的内存被认为已经完全初始化。此时阶段 1 完成。</li>\n</ul>\n</li>\n<li>阶段 2<ul>\n<li>从顶部构造器链一直往下，每个构造器链中类的指定构造器都有机会进一步定制实例。构造器此时可以访问self、修改它的属性并调用实例方法等等。</li>\n<li>最终，任意构造器链中的便利构造器可以有机会定制实例和使用self。</li>\n</ul>\n</li>\n</ul>\n<p>下图展示了在假定的子类和父类之间的构造阶段 1：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/twoPhaseInitialization01_2x.png\" alt=\"\"><br>在这个例子中，构造过程从对子类中一个便利构造器的调用开始。这个便利构造器此时没法修改任何属性，它把构造任务代理给同一类中的指定构造器。<br>如安全检查 1 所示，指定构造器将确保所有子类的属性都有值。然后它将调用父类的指定构造器，并沿着构造器链一直往上完成父类的构造过程。<br>父类中的指定构造器确保所有父类的属性都有值。由于没有更多的父类需要初始化，也就无需继续向上代理。一旦父类中所有属性都有了初始值，实例的内存被认为是完全初始化，阶段 1 完成。</p>\n<p>以下展示了相同构造过程的阶段 2：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/twoPhaseInitialization02_2x.png\" alt=\"\"><br>父类中的指定构造器现在有机会进一步来定制实例（尽管这不是必须的）。<br>一旦父类中的指定构造器完成调用，子类中的指定构造器可以执行更多的定制操作（这也不是必须的）。<br>最终，一旦子类的指定构造器完成调用，最开始被调用的便利构造器可以执行更多的定制操作。</p>\n<h4 id=\"构造器的继承和重写\"><a href=\"#构造器的继承和重写\" class=\"headerlink\" title=\"构造器的继承和重写\"></a>构造器的继承和重写</h4><p>跟 Objective-C 中的子类不同，Swift 中的子类默认情况下不会继承父类的构造器。Swift 的这种机制可以防止一个父类的简单构造器被一个更精细的子类继承，并被错误地用来创建子类的实例。<br>    父类的构造器仅会在安全和适当的情况下被继承。</p>\n<p>假如你希望自定义的子类中能提供一个或多个跟父类相同的构造器，你可以在子类中提供这些构造器的自定义实现。<br>当你在编写一个和父类中指定构造器相匹配的子类构造器时，你实际上是在重写父类的这个指定构造器。因此，你必须在定义子类构造器时带上 <code>override</code> 修饰符。即使你重写的是系统自动提供的默认构造器，也需要带上override修饰符。<br>正如重写属性，方法或者是下标，override修饰符会让编译器去检查父类中是否有相匹配的指定构造器，并验证构造器参数是否正确。<br>    当你重写一个父类的指定构造器时，你总是需要写override修饰符，即使你的子类将父类的指定构造器重写为了便利构造器。</p>\n<p>如果你编写了一个和父类便利构造器相匹配的子类构造器，由于子类不能直接调用父类的便利构造器（每个规则都在上文类的构造器代理规则有所描述）。因此，严格意义上来讲，你的子类并未对一个父类构造器提供重写。最后的结果就是，你在子类中“重写”一个父类便利构造器时，不需要加override前缀。</p>\n<p>在下面的例子中定义了一个叫Vehicle的基类。基类中声明了一个存储型属性numberOfWheels，它是值为0的Int类型的存储型属性。numberOfWheels属性用于创建名为descrpiption的String类型的计算型属性：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vehicle</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> numberOfWheels = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">var</span> description: <span class=\"type\">String</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"<span class=\"subst\">\\(numberOfWheels)</span> wheel(s)\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> vehicle = <span class=\"type\">Vehicle</span>()</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Vehicle: <span class=\"subst\">\\(vehicle.description)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Vehicle: 0 wheel(s)</span></div></pre></td></tr></table></figure>\n<p>下面例子中定义了一个Vehicle的子类Bicycle：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bicycle</span>: <span class=\"title\">Vehicle</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">init</span>() &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>()</div><div class=\"line\">        numberOfWheels = <span class=\"number\">2</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> bicycle = <span class=\"type\">Bicycle</span>()</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Bicycle: <span class=\"subst\">\\(bicycle.description)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Bicycle: 2 wheel(s)</span></div></pre></td></tr></table></figure>\n<p>子类Bicycle定义了一个自定义指定构造器init()。这个指定构造器和父类的指定构造器相匹配，所以Bicycle中的指定构造器需要带上override修饰符。<br>Bicycle的构造器init()以调用super.init()方法开始，这个方法的作用是调用Bicycle的父类Vehicle的默认构造器。这样可以确保Bicycle在修改属性之前，它所继承的属性numberOfWheels能被Vehicle类初始化。在调用super.init()之后，属性numberOfWheels的原值被新值2替换。<br>    子类可以在初始化时修改继承来的变量属性，但是不能修改继承来的常量属性。</p>\n<h4 id=\"构造器的自动继承\"><a href=\"#构造器的自动继承\" class=\"headerlink\" title=\"构造器的自动继承\"></a>构造器的自动继承</h4><p>如上所述，子类在默认情况下不会继承父类的构造器。但是如果满足特定条件，父类构造器是可以被自动继承的。在实践中，这意味着对于许多常见场景你不必重写父类的构造器，并且可以在安全的情况下以最小的代价继承父类的构造器。<br>假设你为子类中引入的所有新属性都提供了默认值，以下 2 个规则适用：</p>\n<ul>\n<li>规则 1<ul>\n<li>如果子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。</li>\n</ul>\n</li>\n<li>规则 2<ul>\n<li>如果子类提供了所有父类指定构造器的实现——无论是通过规则 1 继承过来的，还是提供了自定义实现——它将自动继承所有父类的便利构造器。</li>\n</ul>\n</li>\n</ul>\n<p>即使你在子类中添加了更多的便利构造器，这两条规则仍然适用。<br>    对于规则 2，子类可以将父类的指定构造器实现为便利构造器。</p>\n<h4 id=\"指定构造器和便利构造器实践\"><a href=\"#指定构造器和便利构造器实践\" class=\"headerlink\" title=\"指定构造器和便利构造器实践\"></a>指定构造器和便利构造器实践</h4><p>接下来的例子将在实践中展示指定构造器、便利构造器以及构造器的自动继承。这个例子定义了包含三个类Food、RecipeIngredient以及ShoppingListItem的类层次结构，并将演示它们的构造器是如何相互作用的。<br>类层次中的基类是Food，它是一个简单的用来封装食物名字的类。Food类引入了一个叫做name的String类型的属性，并且提供了两个构造器来创建Food实例：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializersExample01_2x.png\" alt=\"\"><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Food</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.name = name</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">convenience</span> <span class=\"keyword\">init</span>() &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.<span class=\"keyword\">init</span>(name: <span class=\"string\">\"[Unnamed]\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>类没有默认的逐一成员构造器，所以Food类提供了一个接受单一参数name的指定构造器。这个构造器可以使用一个特定的名字来创建新的Food实例。同样提供了一个没有参数的便利构造器init()。这个init()构造器为新食物提供了一个默认的占位名字，通过横向代理到指定构造器init(name: String)并给参数name传值[Unnamed]来实现：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> namedMeat = <span class=\"type\">Food</span>(name: <span class=\"string\">\"Bacon\"</span>)</div><div class=\"line\"><span class=\"comment\">// namedMeat's name is \"Bacon\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> mysteryMeat = <span class=\"type\">Food</span>()</div><div class=\"line\"><span class=\"comment\">// mysteryMeat's name is \"[Unnamed]\"</span></div></pre></td></tr></table></figure>\n<p>类层级中的第二个类是Food的子类RecipeIngredient。RecipeIngredient类用来表示食谱中的一项原料。它引入了Int类型的属性quantity（以及从Food继承过来的name属性），并且定义了两个构造器来创建RecipeIngredient实例：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializersExample02_2x.png\" alt=\"\"><br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RecipeIngredient</span>: <span class=\"title\">Food</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> quantity: <span class=\"type\">Int</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>, quantity: <span class=\"type\">Int</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.quantity = quantity</div><div class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(name: name)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">convenience</span> <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.<span class=\"keyword\">init</span>(name: name, quantity: <span class=\"number\">1</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>RecipeIngredient类拥有一个指定构造器init(name: String, quantity: Int)，它可以用来填充RecipeIngredient实例的所有属性值。这个构造器一开始先将传入的quantity参数赋值给quantity属性，这个属性也是唯一在RecipeIngredient中新引入的属性。随后，构造器向上代理到父类Food的init(name: String)。这个过程满足两段式构造过程中的安全检查 1。</p>\n<p>RecipeIngredient还定义了一个便利构造器init(name: String)，它只通过name来创建RecipeIngredient的实例。这个便利构造器假设任意RecipeIngredient实例的quantity为1，所以不需要显式指明数量即可创建出实例。这个便利构造器的定义可以更加方便和快捷地创建实例，并且避免了创建多个quantity为1的RecipeIngredient实例时的代码重复。这个便利构造器只是简单地横向代理到类中的指定构造器，并为quantity参数传递1。<br>注意，RecipeIngredient的便利构造器init(name: String)使用了跟Food中指定构造器init(name: String)相同的参数。由于这个便利构造器重写了父类的指定构造器init(name: String)，因此必须在前面使用override修饰符</p>\n<p>尽管RecipeIngredient将父类的指定构造器重写为了便利构造器，它依然提供了父类的所有指定构造器的实现。因此，RecipeIngredient会自动继承父类的所有便利构造器。<br>在这个例子中，RecipeIngredient的父类是Food，它有一个便利构造器init()。这个便利构造器会被RecipeIngredient继承。这个继承版本的init()在功能上跟Food提供的版本是一样的，只是它会代理到RecipeIngredient版本的init(name: String)而不是Food提供的版本。</p>\n<p>所有的这三种构造器都可以用来创建新的RecipeIngredient实例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> oneMysteryItem = <span class=\"type\">RecipeIngredient</span>()</div><div class=\"line\"><span class=\"keyword\">let</span> oneBacon = <span class=\"type\">RecipeIngredient</span>(name: <span class=\"string\">\"Bacon\"</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> sixEggs = <span class=\"type\">RecipeIngredient</span>(name: <span class=\"string\">\"Eggs\"</span>, quantity: <span class=\"number\">6</span>)</div></pre></td></tr></table></figure>\n<p>类层级中第三个也是最后一个类是RecipeIngredient的子类，叫做ShoppingListItem。这个类构建了购物单中出现的某一种食谱原料。</p>\n<p>购物单中的每一项总是从未购买状态开始的。为了呈现这一事实，ShoppingListItem引入了一个布尔类型的属性purchased，它的默认值是false。ShoppingListItem还添加了一个计算型属性description，它提供了关于ShoppingListItem实例的一些文字描述：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShoppingListItem</span>: <span class=\"title\">RecipeIngredient</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> purchased = <span class=\"literal\">false</span></div><div class=\"line\">    <span class=\"keyword\">var</span> description: <span class=\"type\">String</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> output = <span class=\"string\">\"<span class=\"subst\">\\(quantity)</span> x <span class=\"subst\">\\(name)</span>\"</span></div><div class=\"line\">        output += purchased ? <span class=\"string\">\" ✔\"</span> : <span class=\"string\">\" ✘\"</span></div><div class=\"line\">        <span class=\"keyword\">return</span> output</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<pre><code>ShoppingListItem没有定义构造器来为purchased提供初始值，因为添加到购物单的物品的初始状态总是未购买。\n</code></pre><p>由于它为自己引入的所有属性都提供了默认值，并且自己没有定义任何构造器，ShoppingListItem将自动继承所有父类中的指定构造器和便利构造器。<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/initializersExample03_2x.png\" alt=\"\"><br>你可以使用全部三个继承来的构造器来创建ShoppingListItem的新实例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> breakfastList = [</div><div class=\"line\">    <span class=\"type\">ShoppingListItem</span>(),</div><div class=\"line\">    <span class=\"type\">ShoppingListItem</span>(name: <span class=\"string\">\"Bacon\"</span>),</div><div class=\"line\">    <span class=\"type\">ShoppingListItem</span>(name: <span class=\"string\">\"Eggs\"</span>, quantity: <span class=\"number\">6</span>),</div><div class=\"line\">]</div><div class=\"line\">breakfastList[<span class=\"number\">0</span>].name = <span class=\"string\">\"Orange juice\"</span></div><div class=\"line\">breakfastList[<span class=\"number\">0</span>].purchased = <span class=\"literal\">true</span></div><div class=\"line\"><span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> breakfastList &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(item.description)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 1 x Orange juice ✔</span></div><div class=\"line\"><span class=\"comment\">// 1 x Bacon ✘</span></div><div class=\"line\"><span class=\"comment\">// 6 x Eggs ✘</span></div></pre></td></tr></table></figure>\n<h3 id=\"可失败构造器\"><a href=\"#可失败构造器\" class=\"headerlink\" title=\"可失败构造器\"></a>可失败构造器</h3><p>如果一个类、结构体或枚举类型的对象，在构造过程中有可能失败，则为其定义一个可失败构造器。这里所指的“失败”是指，如给构造器传入无效的参数值，或缺少某种所需的外部资源，又或是不满足某种必要的条件等。<br>为了妥善处理这种构造过程中可能会失败的情况。你可以在一个类，结构体或是枚举类型的定义中，添加一个或多个可失败构造器。其语法为在 <code>init</code> 关键字后面添加问号( <code>init?</code> )。<br>    可失败构造器的参数名和参数类型，不能与其它非可失败构造器的参数名，及其参数类型相同。</p>\n<p>可失败构造器会创建一个类型为自身类型的可选类型的对象。你通过return nil语句来表明可失败构造器在何种情况下应该“失败”。<br>    严格来说，构造器都不支持返回值。因为构造器本身的作用，只是为了确保对象能被正确构造。因此你只是用return nil表明可失败构造器构造失败，而不要用关键字return来表明构造成功。</p>\n<p>下例中，定义了一个名为Animal的结构体，其中有一个名为species的String类型的常量属性。同时该结构体还定义了一个接受一个名为species的String类型参数的可失败构造器。这个可失败构造器检查传入的参数是否为一个空字符串。如果为空字符串，则构造失败。否则，species属性被赋值，构造成功。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Animal</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> species: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">init</span>?(species: <span class=\"type\">String</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> species.isEmpty &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</div><div class=\"line\">        <span class=\"keyword\">self</span>.species = species</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你可以通过该可失败构造器来构建一个Animal的实例，并检查构造过程是否成功：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> someCreature = <span class=\"type\">Animal</span>(species: <span class=\"string\">\"Giraffe\"</span>)</div><div class=\"line\"><span class=\"comment\">// someCreature is of type Animal?, not Animal</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> giraffe = someCreature &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"An animal was initialized with a species of <span class=\"subst\">\\(giraffe.species)</span>\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"An animal was initialized with a species of Giraffe\"</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> anonymousCreature = <span class=\"type\">Animal</span>(species: <span class=\"string\">\"\"</span>)</div><div class=\"line\"><span class=\"comment\">// anonymousCreature is of type Animal?, not Animal</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">if</span> anonymousCreature == <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The anonymous creature could not be initialized\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"The anonymous creature could not be initialized\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"枚举类型的可失败构造器\"><a href=\"#枚举类型的可失败构造器\" class=\"headerlink\" title=\"枚举类型的可失败构造器\"></a>枚举类型的可失败构造器</h4><p>你可以通过一个带一个或多个参数的可失败构造器来获取枚举类型中特定的枚举成员。如果提供的参数无法匹配任何枚举成员，则构造失败。</p>\n<p>下例中，定义了一个名为TemperatureUnit的枚举类型。其中包含了三个可能的枚举成员(Kelvin，Celsius，和Fahrenheit)，以及一个根据Character值找出所对应的枚举成员的可失败构造器：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">TemperatureUnit</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> kelvin, celsius, fahrenheit</div><div class=\"line\">    <span class=\"keyword\">init</span>?(symbol: <span class=\"type\">Character</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> symbol &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"K\"</span>:</div><div class=\"line\">            <span class=\"keyword\">self</span> = .kelvin</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"C\"</span>:</div><div class=\"line\">            <span class=\"keyword\">self</span> = .celsius</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"F\"</span>:</div><div class=\"line\">            <span class=\"keyword\">self</span> = .fahrenheit</div><div class=\"line\">        <span class=\"keyword\">default</span>:</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你可以利用该可失败构造器在三个枚举成员中获取一个相匹配的枚举成员，当参数的值不能与任何枚举成员相匹配时，则构造失败：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> fahrenheitUnit = <span class=\"type\">TemperatureUnit</span>(symbol: <span class=\"string\">\"F\"</span>)</div><div class=\"line\"><span class=\"keyword\">if</span> fahrenheitUnit != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"This is a defined temperature unit, so initialization succeeded.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"This is a defined temperature unit, so initialization succeeded.\"</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">let</span> unknownUnit = <span class=\"type\">TemperatureUnit</span>(symbol: <span class=\"string\">\"X\"</span>)</div><div class=\"line\"><span class=\"keyword\">if</span> unknownUnit == <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"This is not a defined temperature unit, so initialization failed.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"This is not a defined temperature unit, so initialization failed.\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"带原始值的枚举类型的可失败构造器\"><a href=\"#带原始值的枚举类型的可失败构造器\" class=\"headerlink\" title=\"带原始值的枚举类型的可失败构造器\"></a>带原始值的枚举类型的可失败构造器</h4><p>带原始值的枚举类型会自带一个可失败构造器init?(rawValue:)，该可失败构造器有一个名为rawValue的参数，其类型和枚举类型的原始值类型一致，如果该参数的值能够和某个枚举成员的原始值匹配，则该构造器会构造相应的枚举成员，否则构造失败。</p>\n<p>因此上面的TemperatureUnit的例子可以重写为：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">TemperatureUnit</span>: <span class=\"title\">Character</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> kelvin = <span class=\"string\">\"K\"</span>, celsius = <span class=\"string\">\"C\"</span>, fahrenheit = <span class=\"string\">\"F\"</span></div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">let</span> fahrenheitUnit = <span class=\"type\">TemperatureUnit</span>(rawValue: <span class=\"string\">\"F\"</span>)</div><div class=\"line\"><span class=\"keyword\">if</span> fahrenheitUnit != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"This is a defined temperature unit, so initialization succeeded.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"This is a defined temperature unit, so initialization succeeded.\"</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">let</span> unknownUnit = <span class=\"type\">TemperatureUnit</span>(rawValue: <span class=\"string\">\"X\"</span>)</div><div class=\"line\"><span class=\"keyword\">if</span> unknownUnit == <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"This is not a defined temperature unit, so initialization failed.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"This is not a defined temperature unit, so initialization failed.\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"构造失败的传递\"><a href=\"#构造失败的传递\" class=\"headerlink\" title=\"构造失败的传递\"></a>构造失败的传递</h4><p>类，结构体，枚举的可失败构造器可以横向代理到类型中的其他可失败构造器。类似的，子类的可失败构造器也能向上代理到父类的可失败构造器。<br>无论是向上代理还是横向代理，如果你代理到的其他可失败构造器触发构造失败，整个构造过程将立即终止，接下来的任何构造代码不会再被执行。<br>    可失败构造器也可以代理到其它的非可失败构造器。通过这种方式，你可以增加一个可能的失败状态到现有的构造过程中。</p>\n<p>下面这个例子，定义了一个名为CartItem的Product类的子类。这个类建立了一个在线购物车中的物品的模型，它有一个名为quantity的常量存储型属性，并确保该属性的值至少为1：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Product</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> name: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">init</span>?(name: <span class=\"type\">String</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> name.isEmpty &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</div><div class=\"line\">        <span class=\"keyword\">self</span>.name = name</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CartItem</span>: <span class=\"title\">Product</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> quantity: <span class=\"type\">Int</span></div><div class=\"line\">    <span class=\"keyword\">init</span>?(name: <span class=\"type\">String</span>, quantity: <span class=\"type\">Int</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> quantity &lt; <span class=\"number\">1</span> &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</div><div class=\"line\">        <span class=\"keyword\">self</span>.quantity = quantity</div><div class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(name: name)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>CartItem 可失败构造器首先验证接收的 quantity 值是否大于等于 1 。倘若 quantity 值无效，则立即终止整个构造过程，返回失败结果，且不再执行余下代码。同样地，Product 的可失败构造器首先检查 name 值，假如 name 值为空字符串，则构造器立即执行失败。</p>\n<p>如果你通过传入一个非空字符串 name 以及一个值大于等于 1 的 quantity 来创建一个 CartItem 实例，那么构造方法能够成功被执行：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> twoSocks = <span class=\"type\">CartItem</span>(name: <span class=\"string\">\"sock\"</span>, quantity: <span class=\"number\">2</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Item: <span class=\"subst\">\\(twoSocks.name)</span>, quantity: <span class=\"subst\">\\(twoSocks.quantity)</span>\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"Item: sock, quantity: 2\"</span></div></pre></td></tr></table></figure>\n<p>倘若你以一个值为 0 的 quantity 来创建一个 CartItem 实例，那么将导致 CartItem 构造器失败：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> zeroShirts = <span class=\"type\">CartItem</span>(name: <span class=\"string\">\"shirt\"</span>, quantity: <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Item: <span class=\"subst\">\\(zeroShirts.name)</span>, quantity: <span class=\"subst\">\\(zeroShirts.quantity)</span>\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Unable to initialize zero shirts\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"Unable to initialize zero shirts\"</span></div></pre></td></tr></table></figure>\n<p>同样地，如果你尝试传入一个值为空字符串的 name来创建一个 CartItem 实例，那么将导致父类 Product 的构造过程失败：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> oneUnnamed = <span class=\"type\">CartItem</span>(name: <span class=\"string\">\"\"</span>, quantity: <span class=\"number\">1</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Item: <span class=\"subst\">\\(oneUnnamed.name)</span>, quantity: <span class=\"subst\">\\(oneUnnamed.quantity)</span>\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Unable to initialize one unnamed product\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"Unable to initialize one unnamed product\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"重写一个可失败构造器\"><a href=\"#重写一个可失败构造器\" class=\"headerlink\" title=\"重写一个可失败构造器\"></a>重写一个可失败构造器</h4><p>如同其它的构造器，你可以在子类中重写父类的可失败构造器。或者你也可以用子类的非可失败构造器重写一个父类的可失败构造器。这使你可以定义一个不会构造失败的子类，即使父类的构造器允许构造失败。<br>当你用子类的非可失败构造器重写父类的可失败构造器时，向上代理到父类的可失败构造器的唯一方式是对父类的可失败构造器的返回值进行强制解包。<br>    你可以用非可失败构造器重写可失败构造器，但反过来却不行。</p>\n<p>下例定义了一个名为Document的类，name属性的值必须为一个非空字符串或nil，但不能是一个空字符串：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Document</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span>?</div><div class=\"line\">    <span class=\"comment\">// this initializer creates a document with a nil name value</span></div><div class=\"line\">    <span class=\"keyword\">init</span>() &#123;&#125;</div><div class=\"line\">    <span class=\"comment\">// this initializer creates a document with a nonempty name value</span></div><div class=\"line\">    <span class=\"keyword\">init</span>?(name: <span class=\"type\">String</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> name.isEmpty &#123; <span class=\"keyword\">return</span> <span class=\"literal\">nil</span> &#125;</div><div class=\"line\">        <span class=\"keyword\">self</span>.name = name</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下面这个例子，定义了一个Document类的子类AutomaticallyNamedDocument。这个子类重写了父类的两个指定构造器，确保了无论是使用init()构造器，还是使用init(name:)构造器并为参数传递空字符串，生成的实例中的name属性总有初始”[Untitled]”：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AutomaticallyNamedDocument</span>: <span class=\"title\">Document</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">init</span>() &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>()</div><div class=\"line\">        <span class=\"keyword\">self</span>.name = <span class=\"string\">\"[Untitled]\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>()</div><div class=\"line\">        <span class=\"keyword\">if</span> name.isEmpty &#123;</div><div class=\"line\">            <span class=\"keyword\">self</span>.name = <span class=\"string\">\"[Untitled]\"</span></div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">self</span>.name = name</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>AutomaticallyNamedDocument用一个非可失败构造器init(name:)重写了父类的可失败构造器init?(name:)。因为子类用另一种方式处理了空字符串的情况，所以不再需要一个可失败构造器，因此子类用一个非可失败构造器代替了父类的可失败构造器。</p>\n<p>你可以在子类的非可失败构造器中使用强制解包来调用父类的可失败构造器。比如，下面的UntitledDocument子类的name属性的值总是”[Untitled]”，它在构造过程中使用了父类的可失败构造器init?(name:)：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UntitledDocument</span>: <span class=\"title\">Document</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">init</span>() &#123;</div><div class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(name: <span class=\"string\">\"[Untitled]\"</span>)!</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"可失败构造器-init\"><a href=\"#可失败构造器-init\" class=\"headerlink\" title=\"可失败构造器 init!\"></a>可失败构造器 init!</h4><p>通常来说我们通过在init关键字后添加问号的方式（init?）来定义一个可失败构造器，但你也可以通过在init后面添加惊叹号的方式来定义一个可失败构造器（init!），该可失败构造器将会构建一个对应类型的隐式解包可选类型的对象。</p>\n<p>你可以在init?中代理到init!，反之亦然。你也可以用init?重写init!，反之亦然。你还可以用init代理到init!，不过，一旦init!构造失败，则会触发一个断言。</p>\n<h3 id=\"必要构造器\"><a href=\"#必要构造器\" class=\"headerlink\" title=\"必要构造器\"></a>必要构造器</h3><p>在类的构造器前添加 <code>required</code> 修饰符表明所有该类的子类都必须实现该构造器：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClass</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">required</span> <span class=\"keyword\">init</span>() &#123;</div><div class=\"line\">        <span class=\"comment\">// initializer implementation goes here</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在子类重写父类的必要构造器时，必须在子类的构造器前也添加required修饰符，表明该构造器要求也应用于继承链后面的子类。在重写父类中必要的指定构造器时，不需要添加override修饰符：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeSubclass</span>: <span class=\"title\">SomeClass</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">required</span> <span class=\"keyword\">init</span>() &#123;</div><div class=\"line\">        <span class=\"comment\">// subclass implementation of the required initializer goes here</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<pre><code>如果子类继承的构造器能满足必要构造器的要求，则无须在子类中显式提供必要构造器的实现。\n</code></pre><h3 id=\"通过闭包或函数设置属性的默认值\"><a href=\"#通过闭包或函数设置属性的默认值\" class=\"headerlink\" title=\"通过闭包或函数设置属性的默认值\"></a>通过闭包或函数设置属性的默认值</h3><p>如果某个存储型属性的默认值需要一些定制或设置，你可以使用闭包或全局函数为其提供定制的默认值。每当某个属性所在类型的新实例被创建时，对应的闭包或函数会被调用，而它们的返回值会当做默认值赋值给这个属性。<br>这种类型的闭包或函数通常会创建一个跟属性类型相同的临时变量，然后修改它的值以满足预期的初始状态，最后返回这个临时变量，作为属性的默认值。</p>\n<p>下面介绍了如何用闭包为属性提供默认值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClass</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> someProperty: <span class=\"type\">SomeType</span> = &#123;</div><div class=\"line\">        <span class=\"comment\">// create a default value for someProperty inside this closure</span></div><div class=\"line\">        <span class=\"comment\">// someValue must be of the same type as SomeType</span></div><div class=\"line\">        <span class=\"keyword\">return</span> someValue</div><div class=\"line\">    &#125;()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意闭包结尾的大括号后面接了一对空的小括号。这用来告诉 Swift 立即执行此闭包。如果你忽略了这对括号，相当于将闭包本身作为值赋值给了属性，而不是将闭包的返回值赋值给属性。<br>    如果你使用闭包来初始化属性，请记住在闭包执行时，实例的其它部分都还没有初始化。这意味着你不能在闭包里访问其它属性，即使这些属性有默认值。同样，你也不能使用隐式的self属性，或者调用任何实例方法。</p>\n<p>下面例子中定义了一个结构体Checkerboard，它构建了西洋跳棋游戏的棋盘：<br><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/chessBoard_2x.png\" alt=\"\"><br>西洋跳棋游戏在一副黑白格交替的10x10的棋盘中进行。为了呈现这副游戏棋盘，Checkerboard结构体定义了一个属性boardColors，它是一个包含100个Bool值的数组。在数组中，值为true的元素表示一个黑格，值为false的元素表示一个白格。数组中第一个元素代表棋盘上左上角的格子，最后一个元素代表棋盘上右下角的格子。</p>\n<p>boardColor数组是通过一个闭包来初始化并设置颜色值的：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Chessboard</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> boardColors: [<span class=\"type\">Bool</span>] = &#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> temporaryBoard = [<span class=\"type\">Bool</span>]()</div><div class=\"line\">        <span class=\"keyword\">var</span> isBlack = <span class=\"literal\">false</span></div><div class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">1</span>...<span class=\"number\">8</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"number\">1</span>...<span class=\"number\">8</span> &#123;</div><div class=\"line\">                temporaryBoard.append(isBlack)</div><div class=\"line\">                isBlack = !isBlack</div><div class=\"line\">            &#125;</div><div class=\"line\">            isBlack = !isBlack</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> temporaryBoard</div><div class=\"line\">    &#125;()</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">squareIsBlackAt</span><span class=\"params\">(row: Int, column: Int)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> boardColors[(row * <span class=\"number\">8</span>) + column]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>每当一个新的Checkerboard实例被创建时，赋值闭包会被执行，boardColors的默认值会被计算出来并返回。上面例子中描述的闭包将计算出棋盘中每个格子对应的颜色，并将这些值保存到一个临时数组temporaryBoard中，最后在构建完成时将此数组作为闭包返回值返回。这个返回的数组会保存到boardColors中，并可以通过工具函数squareIsBlackAtRow来查询：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> board = <span class=\"type\">Chessboard</span>()</div><div class=\"line\"><span class=\"built_in\">print</span>(board.squareIsBlackAt(row: <span class=\"number\">0</span>, column: <span class=\"number\">1</span>))</div><div class=\"line\"><span class=\"comment\">// Prints \"true\"</span></div><div class=\"line\"><span class=\"built_in\">print</span>(board.squareIsBlackAt(row: <span class=\"number\">7</span>, column: <span class=\"number\">7</span>))</div><div class=\"line\"><span class=\"comment\">// Prints \"false\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html/\" target=\"_blank\" rel=\"external\"> Initialization </a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>"},{"layout":"post","title":"Swift Methods","date":"2016-11-24T16:20:11.000Z","author":"liangtong","catalog":true,"_content":"\n\n\n​\t方法是与某些特定类型相关联的函数。类、结构体、枚举都可以定义实例方法；实例方法为给定类型的实例封装了具体的任务与功能。类、结构体、枚举也可以定义类型方法；类型方法与类型本身相关联。类型方法与 Objective-C 中的类方法（class methods）相似。\n结构体和枚举能够定义方法是 Swift 与 C/Objective-C 的主要区别之一。在 Objective-C 中，类是唯一能定义方法的类型。但在 Swift 中，你不仅能选择是否要定义一个类/结构体/枚举，还能灵活地在你创建的类型（类/结构体/枚举）上定义方法。\n\n\n\n### 实例方法\n实例方法是属于某个特定类、结构体或者枚举类型实例的方法。实例方法提供访问和修改实例属性的方法或提供与实例目的相关的功能，并以此来支撑实例的功能。实例方法的语法与函数完全一致。\n实例方法要写在它所属的类型的前后大括号之间。实例方法能够隐式访问它所属类型的所有的其他实例方法和属性。实例方法只能被它所属的类的某个特定实例调用。实例方法只能由实例调用。\n下面的例子，定义一个很简单的Counter类，Counter能被用来对一个动作发生的次数进行计数：\n\n<!-- more -->\n\n\n```Swift\nclass Counter {\n    var count = 0\n    func increment() {\n        count += 1\n    }\n    func increment(by amount: Int) {\n        count += amount\n    }\n    func reset() {\n        count = 0\n    }\n}\n```\n\nCounter这个类定义了一个属性和3个方法，其实例可以通过点语法来调用属性和方法\n\n```Swift\nlet counter = Counter()\n// the initial counter value is 0\ncounter.increment()\n// the counter's value is now 1\ncounter.increment(by: 5)\n// the counter's value is now 6\ncounter.reset()\n// the counter's value is now 0\n```\n\n#### self属性\n类型的每一个实例都有一个隐含属性叫做self，self完全等同于该实例本身。你可以在一个实例的实例方法中使用这个隐含的self属性来引用当前实例。\n上面例子中的increment方法还可以这样写：\n\n```Swift\nfunc increment() {\n    self.count += 1\n}\n```\n\n实际上，你不必在你的代码里面经常写self。如果你没有明确地写self，Swift 假定你是指当前实例的属性或者方法。使用这条规则的主要场景是实例方法的某个参数名称与实例的某个属性名称相同的时候。在这种情况下，参数名称享有优先权，并且在引用属性时必须使用一种更严格的方式。这时你可以使用self属性来区分参数名称和属性名称。\n下面的例子中，self消除方法参数x和实例属性x之间的歧义：\n\n```Swift\nstruct Point {\n    var x = 0.0, y = 0.0\n    func isToTheRightOf(x: Double) -> Bool {\n        return self.x > x\n    }\n}\nlet somePoint = Point(x: 4.0, y: 5.0)\nif somePoint.isToTheRightOf(x: 1.0) {\n    print(\"This point is to the right of the line where x == 1.0\")\n}\n// Prints \"This point is to the right of the line where x == 1.0\"\n```\n\n#### 在实例方法中修改值类型\n结构体和枚举是值类型。默认情况下，值类型的属性不能在它的实例方法中被修改。\n但是，如果你确实需要在某个特定的方法中修改结构体或者枚举的属性，你可以为这个方法选择可变(mutating)行为，然后就可以从其方法内部改变它的属性；并且这个方法做的任何改变都会在方法执行结束时写回到原始结构中。方法还可以给它隐含的self属性赋予一个全新的实例，这个新实例在方法结束时会替换现存实例。\n要使用可变方法，将关键字 `mutating` 放到方法的 `func` 关键字之前就可以了：\n\n```Swift\nstruct Point {\n    var x = 0.0, y = 0.0\n    mutating func moveBy(x deltaX: Double, y deltaY: Double) {\n        x += deltaX\n        y += deltaY\n    }\n}\nvar somePoint = Point(x: 1.0, y: 1.0)\nsomePoint.moveBy(x: 2.0, y: 3.0)\nprint(\"The point is now at (\\(somePoint.x), \\(somePoint.y))\")\n// Prints \"The point is now at (3.0, 4.0)\"\n```\n\n注意，不能在结构体类型的常量（a constant of structure type）上调用可变方法，因为其属性不能被改变，即使属性是变量属性。\n\n```Swift\nlet fixedPoint = Point(x: 3.0, y: 3.0)\nfixedPoint.moveBy(x: 2.0, y: 3.0)\n// this will report an error\n```\n\n#### 在可变方法中给 self 赋值\n可变方法能够赋给隐含属性self一个全新的实例。\n上面Point的例子可以用下面的方式改写：\n\n```Swift\nstruct Point {\n    var x = 0.0, y = 0.0\n    mutating func moveBy(x deltaX: Double, y deltaY: Double) {\n        self = Point(x: x + deltaX, y: y + deltaY)\n    }\n}\n```\n\n枚举的可变方法可以把self设置为同一枚举类型中不同的成员：\n\n```Swift\nenum TriStateSwitch {\n    case off, low, high\n    mutating func next() {\n        switch self {\n        case .off:\n            self = .low\n        case .low:\n            self = .high\n        case .high:\n            self = .off\n        }\n    }\n}\nvar ovenLight = TriStateSwitch.low\novenLight.next()\n// ovenLight is now equal to .high\novenLight.next()\n// ovenLight is now equal to .off\n```\n\n简单的状态模式。\n\n### 类型方法\n实例方法是被某个类型的实例调用的方法。你也可以定义在类型本身上调用的方法，这种方法就叫做类型方法。在方法的func关键字之前加上关键字 `static`，来指定类型方法。类还可以用关键字 `class` 来允许子类重写父类的方法实现。\n\t在 Objective-C 中，你只能为 Objective-C 的类类型（classes）定义类型方法（type-level methods）。在 Swift 中，你可以为所有的类、结构体和枚举定义类型方法。每一个类型方法都被它所支持的类型显式包含。\n\n类型方法和实例方法一样用点语法调用。但是，你是在类型上调用这个方法，而不是在实例上调用。\n下面是如何在SomeClass类上调用类型方法的例子：\n\n```Swift\nclass SomeClass {\n    class func someTypeMethod() {\n        // type method implementation goes here\n    }\n}\nSomeClass.someTypeMethod()\n```\n\n在类型方法的方法体（body）中，self指向这个类型本身，而不是类型的某个实例。这意味着你可以用self来消除类型属性和类型方法参数之间的歧义（类似于我们在前面处理实例属性和实例方法参数时做的那样）。\n\n一般而言，在一个类型中，类型方法可以调用类型方法或类型属性，不需要在被调用的类型方法或者类型属性前不需要添加类型名称。类似的，在结构体和枚举中，也能够直接通过类型属性的名称访问本类中的类型属性，而不需要前面加上类型名称。\n\n下面的例子定义了一个名为LevelTracker结构体。它监测玩家的游戏发展情况（游戏的不同层次或阶段）。这是一个单人游戏，但也可以存储多个玩家在同一设备上的游戏信息。\n\n游戏初始时，所有的游戏等级（除了等级 1）都被锁定。每次有玩家完成一个等级，这个等级就对这个设备上的所有玩家解锁。LevelTracker结构体用类型属性和方法监测游戏的哪个等级已经被解锁。它还监测每个玩家的当前等级。\n\n```Swift\nstruct LevelTracker {\n//记录最高解锁等级\n    static var highestUnlockedLevel = 1\n//记录当前玩家等级\n    var currentLevel = 1\n    \n//解锁新等级\n    static func unlock(_ level: Int) {\n        if level > highestUnlockedLevel { highestUnlockedLevel = level }\n    }\n    \n//判断某个等级是否被解锁\n    static func isUnlocked(_ level: Int) -> Bool {\n        return level <= highestUnlockedLevel\n    }\n    \n//忽略调用该方法时不使用返回值的警告，更新当前玩家等级前检查是否已经解锁最新等级了\n    @discardableResult\n    mutating func advance(to level: Int) -> Bool {\n        if LevelTracker.isUnlocked(level) {\n            currentLevel = level\n            return true\n        } else {\n            return false\n        }\n    }\n}\n```\n\n下面，Player类使用LevelTracker来监测和更新每个玩家的发展进度：\n\n```Swift\nclass Player {\n    var tracker = LevelTracker()\n    let playerName: String\n    func complete(level: Int) {\n        LevelTracker.unlock(level + 1)\n        tracker.advance(to: level + 1)\n    }\n    init(name: String) {\n        playerName = name\n    }\n}\n```\n\nPlayer类创建一个新的LevelTracker实例来监测这个用户的进度。它提供了complete(level:)方法，一旦玩家完成某个指定等级就调用它。这个方法为所有玩家解锁下一等级，并且将当前玩家的进度更新为下一等级。（我们忽略了advance(to:)返回的布尔值，因为之前调用LevelTracker.unlock(_:)时就知道了这个等级已经被解锁了）。\n\n你还可以为一个新的玩家创建一个Player的实例，然后看这个玩家完成等级一时发生了什么：\n\n```Swift\nvar player = Player(name: \"Argyrios\")\nplayer.complete(level: 1)\nprint(\"highest unlocked level is now \\(LevelTracker.highestUnlockedLevel)\")\n// Prints \"highest unlocked level is now 2\"\n```\n\n如果你创建了第二个玩家，并尝试让他开始一个没有被任何玩家解锁的等级，那么试图设置玩家当前等级将会失败：\n\n```Swift\nplayer = Player(name: \"Beto\")\nif player.tracker.advance(to: 6) {\n    print(\"player is now on level 6\")\n} else {\n    print(\"level 6 has not yet been unlocked\")\n}\n// Prints \"level 6 has not yet been unlocked\"\n```\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Methods.html/\">Methods</a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","source":"_posts/iOS_Swift_language_note_Methods.md","raw":"---\nlayout:     post\ntitle:      Swift Methods\ndate:       2016-11-25 00:20:11\nauthor:     liangtong\ncatalog: true\ncategories: iOS\ntags: Swift \n\n---\n\n\n\n​\t方法是与某些特定类型相关联的函数。类、结构体、枚举都可以定义实例方法；实例方法为给定类型的实例封装了具体的任务与功能。类、结构体、枚举也可以定义类型方法；类型方法与类型本身相关联。类型方法与 Objective-C 中的类方法（class methods）相似。\n结构体和枚举能够定义方法是 Swift 与 C/Objective-C 的主要区别之一。在 Objective-C 中，类是唯一能定义方法的类型。但在 Swift 中，你不仅能选择是否要定义一个类/结构体/枚举，还能灵活地在你创建的类型（类/结构体/枚举）上定义方法。\n\n\n\n### 实例方法\n实例方法是属于某个特定类、结构体或者枚举类型实例的方法。实例方法提供访问和修改实例属性的方法或提供与实例目的相关的功能，并以此来支撑实例的功能。实例方法的语法与函数完全一致。\n实例方法要写在它所属的类型的前后大括号之间。实例方法能够隐式访问它所属类型的所有的其他实例方法和属性。实例方法只能被它所属的类的某个特定实例调用。实例方法只能由实例调用。\n下面的例子，定义一个很简单的Counter类，Counter能被用来对一个动作发生的次数进行计数：\n\n<!-- more -->\n\n\n```Swift\nclass Counter {\n    var count = 0\n    func increment() {\n        count += 1\n    }\n    func increment(by amount: Int) {\n        count += amount\n    }\n    func reset() {\n        count = 0\n    }\n}\n```\n\nCounter这个类定义了一个属性和3个方法，其实例可以通过点语法来调用属性和方法\n\n```Swift\nlet counter = Counter()\n// the initial counter value is 0\ncounter.increment()\n// the counter's value is now 1\ncounter.increment(by: 5)\n// the counter's value is now 6\ncounter.reset()\n// the counter's value is now 0\n```\n\n#### self属性\n类型的每一个实例都有一个隐含属性叫做self，self完全等同于该实例本身。你可以在一个实例的实例方法中使用这个隐含的self属性来引用当前实例。\n上面例子中的increment方法还可以这样写：\n\n```Swift\nfunc increment() {\n    self.count += 1\n}\n```\n\n实际上，你不必在你的代码里面经常写self。如果你没有明确地写self，Swift 假定你是指当前实例的属性或者方法。使用这条规则的主要场景是实例方法的某个参数名称与实例的某个属性名称相同的时候。在这种情况下，参数名称享有优先权，并且在引用属性时必须使用一种更严格的方式。这时你可以使用self属性来区分参数名称和属性名称。\n下面的例子中，self消除方法参数x和实例属性x之间的歧义：\n\n```Swift\nstruct Point {\n    var x = 0.0, y = 0.0\n    func isToTheRightOf(x: Double) -> Bool {\n        return self.x > x\n    }\n}\nlet somePoint = Point(x: 4.0, y: 5.0)\nif somePoint.isToTheRightOf(x: 1.0) {\n    print(\"This point is to the right of the line where x == 1.0\")\n}\n// Prints \"This point is to the right of the line where x == 1.0\"\n```\n\n#### 在实例方法中修改值类型\n结构体和枚举是值类型。默认情况下，值类型的属性不能在它的实例方法中被修改。\n但是，如果你确实需要在某个特定的方法中修改结构体或者枚举的属性，你可以为这个方法选择可变(mutating)行为，然后就可以从其方法内部改变它的属性；并且这个方法做的任何改变都会在方法执行结束时写回到原始结构中。方法还可以给它隐含的self属性赋予一个全新的实例，这个新实例在方法结束时会替换现存实例。\n要使用可变方法，将关键字 `mutating` 放到方法的 `func` 关键字之前就可以了：\n\n```Swift\nstruct Point {\n    var x = 0.0, y = 0.0\n    mutating func moveBy(x deltaX: Double, y deltaY: Double) {\n        x += deltaX\n        y += deltaY\n    }\n}\nvar somePoint = Point(x: 1.0, y: 1.0)\nsomePoint.moveBy(x: 2.0, y: 3.0)\nprint(\"The point is now at (\\(somePoint.x), \\(somePoint.y))\")\n// Prints \"The point is now at (3.0, 4.0)\"\n```\n\n注意，不能在结构体类型的常量（a constant of structure type）上调用可变方法，因为其属性不能被改变，即使属性是变量属性。\n\n```Swift\nlet fixedPoint = Point(x: 3.0, y: 3.0)\nfixedPoint.moveBy(x: 2.0, y: 3.0)\n// this will report an error\n```\n\n#### 在可变方法中给 self 赋值\n可变方法能够赋给隐含属性self一个全新的实例。\n上面Point的例子可以用下面的方式改写：\n\n```Swift\nstruct Point {\n    var x = 0.0, y = 0.0\n    mutating func moveBy(x deltaX: Double, y deltaY: Double) {\n        self = Point(x: x + deltaX, y: y + deltaY)\n    }\n}\n```\n\n枚举的可变方法可以把self设置为同一枚举类型中不同的成员：\n\n```Swift\nenum TriStateSwitch {\n    case off, low, high\n    mutating func next() {\n        switch self {\n        case .off:\n            self = .low\n        case .low:\n            self = .high\n        case .high:\n            self = .off\n        }\n    }\n}\nvar ovenLight = TriStateSwitch.low\novenLight.next()\n// ovenLight is now equal to .high\novenLight.next()\n// ovenLight is now equal to .off\n```\n\n简单的状态模式。\n\n### 类型方法\n实例方法是被某个类型的实例调用的方法。你也可以定义在类型本身上调用的方法，这种方法就叫做类型方法。在方法的func关键字之前加上关键字 `static`，来指定类型方法。类还可以用关键字 `class` 来允许子类重写父类的方法实现。\n\t在 Objective-C 中，你只能为 Objective-C 的类类型（classes）定义类型方法（type-level methods）。在 Swift 中，你可以为所有的类、结构体和枚举定义类型方法。每一个类型方法都被它所支持的类型显式包含。\n\n类型方法和实例方法一样用点语法调用。但是，你是在类型上调用这个方法，而不是在实例上调用。\n下面是如何在SomeClass类上调用类型方法的例子：\n\n```Swift\nclass SomeClass {\n    class func someTypeMethod() {\n        // type method implementation goes here\n    }\n}\nSomeClass.someTypeMethod()\n```\n\n在类型方法的方法体（body）中，self指向这个类型本身，而不是类型的某个实例。这意味着你可以用self来消除类型属性和类型方法参数之间的歧义（类似于我们在前面处理实例属性和实例方法参数时做的那样）。\n\n一般而言，在一个类型中，类型方法可以调用类型方法或类型属性，不需要在被调用的类型方法或者类型属性前不需要添加类型名称。类似的，在结构体和枚举中，也能够直接通过类型属性的名称访问本类中的类型属性，而不需要前面加上类型名称。\n\n下面的例子定义了一个名为LevelTracker结构体。它监测玩家的游戏发展情况（游戏的不同层次或阶段）。这是一个单人游戏，但也可以存储多个玩家在同一设备上的游戏信息。\n\n游戏初始时，所有的游戏等级（除了等级 1）都被锁定。每次有玩家完成一个等级，这个等级就对这个设备上的所有玩家解锁。LevelTracker结构体用类型属性和方法监测游戏的哪个等级已经被解锁。它还监测每个玩家的当前等级。\n\n```Swift\nstruct LevelTracker {\n//记录最高解锁等级\n    static var highestUnlockedLevel = 1\n//记录当前玩家等级\n    var currentLevel = 1\n    \n//解锁新等级\n    static func unlock(_ level: Int) {\n        if level > highestUnlockedLevel { highestUnlockedLevel = level }\n    }\n    \n//判断某个等级是否被解锁\n    static func isUnlocked(_ level: Int) -> Bool {\n        return level <= highestUnlockedLevel\n    }\n    \n//忽略调用该方法时不使用返回值的警告，更新当前玩家等级前检查是否已经解锁最新等级了\n    @discardableResult\n    mutating func advance(to level: Int) -> Bool {\n        if LevelTracker.isUnlocked(level) {\n            currentLevel = level\n            return true\n        } else {\n            return false\n        }\n    }\n}\n```\n\n下面，Player类使用LevelTracker来监测和更新每个玩家的发展进度：\n\n```Swift\nclass Player {\n    var tracker = LevelTracker()\n    let playerName: String\n    func complete(level: Int) {\n        LevelTracker.unlock(level + 1)\n        tracker.advance(to: level + 1)\n    }\n    init(name: String) {\n        playerName = name\n    }\n}\n```\n\nPlayer类创建一个新的LevelTracker实例来监测这个用户的进度。它提供了complete(level:)方法，一旦玩家完成某个指定等级就调用它。这个方法为所有玩家解锁下一等级，并且将当前玩家的进度更新为下一等级。（我们忽略了advance(to:)返回的布尔值，因为之前调用LevelTracker.unlock(_:)时就知道了这个等级已经被解锁了）。\n\n你还可以为一个新的玩家创建一个Player的实例，然后看这个玩家完成等级一时发生了什么：\n\n```Swift\nvar player = Player(name: \"Argyrios\")\nplayer.complete(level: 1)\nprint(\"highest unlocked level is now \\(LevelTracker.highestUnlockedLevel)\")\n// Prints \"highest unlocked level is now 2\"\n```\n\n如果你创建了第二个玩家，并尝试让他开始一个没有被任何玩家解锁的等级，那么试图设置玩家当前等级将会失败：\n\n```Swift\nplayer = Player(name: \"Beto\")\nif player.tracker.advance(to: 6) {\n    print(\"player is now on level 6\")\n} else {\n    print(\"level 6 has not yet been unlocked\")\n}\n// Prints \"level 6 has not yet been unlocked\"\n```\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Methods.html/\">Methods</a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","slug":"iOS_Swift_language_note_Methods","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4ui003eoko8uosvsb4l","content":"<p>​    方法是与某些特定类型相关联的函数。类、结构体、枚举都可以定义实例方法；实例方法为给定类型的实例封装了具体的任务与功能。类、结构体、枚举也可以定义类型方法；类型方法与类型本身相关联。类型方法与 Objective-C 中的类方法（class methods）相似。<br>结构体和枚举能够定义方法是 Swift 与 C/Objective-C 的主要区别之一。在 Objective-C 中，类是唯一能定义方法的类型。但在 Swift 中，你不仅能选择是否要定义一个类/结构体/枚举，还能灵活地在你创建的类型（类/结构体/枚举）上定义方法。</p>\n<h3 id=\"实例方法\"><a href=\"#实例方法\" class=\"headerlink\" title=\"实例方法\"></a>实例方法</h3><p>实例方法是属于某个特定类、结构体或者枚举类型实例的方法。实例方法提供访问和修改实例属性的方法或提供与实例目的相关的功能，并以此来支撑实例的功能。实例方法的语法与函数完全一致。<br>实例方法要写在它所属的类型的前后大括号之间。实例方法能够隐式访问它所属类型的所有的其他实例方法和属性。实例方法只能被它所属的类的某个特定实例调用。实例方法只能由实例调用。<br>下面的例子，定义一个很简单的Counter类，Counter能被用来对一个动作发生的次数进行计数：</p>\n<a id=\"more\"></a>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">count</span> = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">increment</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"built_in\">count</span> += <span class=\"number\">1</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">increment</span><span class=\"params\">(by amount: Int)</span></span> &#123;</div><div class=\"line\">        <span class=\"built_in\">count</span> += amount</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reset</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"built_in\">count</span> = <span class=\"number\">0</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Counter这个类定义了一个属性和3个方法，其实例可以通过点语法来调用属性和方法</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> counter = <span class=\"type\">Counter</span>()</div><div class=\"line\"><span class=\"comment\">// the initial counter value is 0</span></div><div class=\"line\">counter.increment()</div><div class=\"line\"><span class=\"comment\">// the counter's value is now 1</span></div><div class=\"line\">counter.increment(by: <span class=\"number\">5</span>)</div><div class=\"line\"><span class=\"comment\">// the counter's value is now 6</span></div><div class=\"line\">counter.reset()</div><div class=\"line\"><span class=\"comment\">// the counter's value is now 0</span></div></pre></td></tr></table></figure>\n<h4 id=\"self属性\"><a href=\"#self属性\" class=\"headerlink\" title=\"self属性\"></a>self属性</h4><p>类型的每一个实例都有一个隐含属性叫做self，self完全等同于该实例本身。你可以在一个实例的实例方法中使用这个隐含的self属性来引用当前实例。<br>上面例子中的increment方法还可以这样写：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">increment</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">self</span>.<span class=\"built_in\">count</span> += <span class=\"number\">1</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>实际上，你不必在你的代码里面经常写self。如果你没有明确地写self，Swift 假定你是指当前实例的属性或者方法。使用这条规则的主要场景是实例方法的某个参数名称与实例的某个属性名称相同的时候。在这种情况下，参数名称享有优先权，并且在引用属性时必须使用一种更严格的方式。这时你可以使用self属性来区分参数名称和属性名称。<br>下面的例子中，self消除方法参数x和实例属性x之间的歧义：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">0.0</span>, y = <span class=\"number\">0.0</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isToTheRightOf</span><span class=\"params\">(x: Double)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.x &gt; x</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> somePoint = <span class=\"type\">Point</span>(x: <span class=\"number\">4.0</span>, y: <span class=\"number\">5.0</span>)</div><div class=\"line\"><span class=\"keyword\">if</span> somePoint.isToTheRightOf(x: <span class=\"number\">1.0</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"This point is to the right of the line where x == 1.0\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"This point is to the right of the line where x == 1.0\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"在实例方法中修改值类型\"><a href=\"#在实例方法中修改值类型\" class=\"headerlink\" title=\"在实例方法中修改值类型\"></a>在实例方法中修改值类型</h4><p>结构体和枚举是值类型。默认情况下，值类型的属性不能在它的实例方法中被修改。<br>但是，如果你确实需要在某个特定的方法中修改结构体或者枚举的属性，你可以为这个方法选择可变(mutating)行为，然后就可以从其方法内部改变它的属性；并且这个方法做的任何改变都会在方法执行结束时写回到原始结构中。方法还可以给它隐含的self属性赋予一个全新的实例，这个新实例在方法结束时会替换现存实例。<br>要使用可变方法，将关键字 <code>mutating</code> 放到方法的 <code>func</code> 关键字之前就可以了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">0.0</span>, y = <span class=\"number\">0.0</span></div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">moveBy</span><span class=\"params\">(x deltaX: Double, y deltaY: Double)</span></span> &#123;</div><div class=\"line\">        x += deltaX</div><div class=\"line\">        y += deltaY</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> somePoint = <span class=\"type\">Point</span>(x: <span class=\"number\">1.0</span>, y: <span class=\"number\">1.0</span>)</div><div class=\"line\">somePoint.moveBy(x: <span class=\"number\">2.0</span>, y: <span class=\"number\">3.0</span>)</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The point is now at (<span class=\"subst\">\\(somePoint.x)</span>, <span class=\"subst\">\\(somePoint.y)</span>)\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"The point is now at (3.0, 4.0)\"</span></div></pre></td></tr></table></figure>\n<p>注意，不能在结构体类型的常量（a constant of structure type）上调用可变方法，因为其属性不能被改变，即使属性是变量属性。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> fixedPoint = <span class=\"type\">Point</span>(x: <span class=\"number\">3.0</span>, y: <span class=\"number\">3.0</span>)</div><div class=\"line\">fixedPoint.moveBy(x: <span class=\"number\">2.0</span>, y: <span class=\"number\">3.0</span>)</div><div class=\"line\"><span class=\"comment\">// this will report an error</span></div></pre></td></tr></table></figure>\n<h4 id=\"在可变方法中给-self-赋值\"><a href=\"#在可变方法中给-self-赋值\" class=\"headerlink\" title=\"在可变方法中给 self 赋值\"></a>在可变方法中给 self 赋值</h4><p>可变方法能够赋给隐含属性self一个全新的实例。<br>上面Point的例子可以用下面的方式改写：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">0.0</span>, y = <span class=\"number\">0.0</span></div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">moveBy</span><span class=\"params\">(x deltaX: Double, y deltaY: Double)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span> = <span class=\"type\">Point</span>(x: x + deltaX, y: y + deltaY)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>枚举的可变方法可以把self设置为同一枚举类型中不同的成员：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">TriStateSwitch</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> off, low, high</div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">next</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> <span class=\"keyword\">self</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> .off:</div><div class=\"line\">            <span class=\"keyword\">self</span> = .low</div><div class=\"line\">        <span class=\"keyword\">case</span> .low:</div><div class=\"line\">            <span class=\"keyword\">self</span> = .high</div><div class=\"line\">        <span class=\"keyword\">case</span> .high:</div><div class=\"line\">            <span class=\"keyword\">self</span> = .off</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> ovenLight = <span class=\"type\">TriStateSwitch</span>.low</div><div class=\"line\">ovenLight.next()</div><div class=\"line\"><span class=\"comment\">// ovenLight is now equal to .high</span></div><div class=\"line\">ovenLight.next()</div><div class=\"line\"><span class=\"comment\">// ovenLight is now equal to .off</span></div></pre></td></tr></table></figure>\n<p>简单的状态模式。</p>\n<h3 id=\"类型方法\"><a href=\"#类型方法\" class=\"headerlink\" title=\"类型方法\"></a>类型方法</h3><p>实例方法是被某个类型的实例调用的方法。你也可以定义在类型本身上调用的方法，这种方法就叫做类型方法。在方法的func关键字之前加上关键字 <code>static</code>，来指定类型方法。类还可以用关键字 <code>class</code> 来允许子类重写父类的方法实现。<br>    在 Objective-C 中，你只能为 Objective-C 的类类型（classes）定义类型方法（type-level methods）。在 Swift 中，你可以为所有的类、结构体和枚举定义类型方法。每一个类型方法都被它所支持的类型显式包含。</p>\n<p>类型方法和实例方法一样用点语法调用。但是，你是在类型上调用这个方法，而不是在实例上调用。<br>下面是如何在SomeClass类上调用类型方法的例子：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClass</span> </span>&#123;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">func</span> <span class=\"title\">someTypeMethod</span>() </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// type method implementation goes here</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"type\">SomeClass</span>.someTypeMethod()</div></pre></td></tr></table></figure>\n<p>在类型方法的方法体（body）中，self指向这个类型本身，而不是类型的某个实例。这意味着你可以用self来消除类型属性和类型方法参数之间的歧义（类似于我们在前面处理实例属性和实例方法参数时做的那样）。</p>\n<p>一般而言，在一个类型中，类型方法可以调用类型方法或类型属性，不需要在被调用的类型方法或者类型属性前不需要添加类型名称。类似的，在结构体和枚举中，也能够直接通过类型属性的名称访问本类中的类型属性，而不需要前面加上类型名称。</p>\n<p>下面的例子定义了一个名为LevelTracker结构体。它监测玩家的游戏发展情况（游戏的不同层次或阶段）。这是一个单人游戏，但也可以存储多个玩家在同一设备上的游戏信息。</p>\n<p>游戏初始时，所有的游戏等级（除了等级 1）都被锁定。每次有玩家完成一个等级，这个等级就对这个设备上的所有玩家解锁。LevelTracker结构体用类型属性和方法监测游戏的哪个等级已经被解锁。它还监测每个玩家的当前等级。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LevelTracker</span> </span>&#123;</div><div class=\"line\"><span class=\"comment\">//记录最高解锁等级</span></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> highestUnlockedLevel = <span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">//记录当前玩家等级</span></div><div class=\"line\">    <span class=\"keyword\">var</span> currentLevel = <span class=\"number\">1</span></div><div class=\"line\">    </div><div class=\"line\"><span class=\"comment\">//解锁新等级</span></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">unlock</span><span class=\"params\">(<span class=\"number\">_</span> level: Int)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> level &gt; highestUnlockedLevel &#123; highestUnlockedLevel = level &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\"><span class=\"comment\">//判断某个等级是否被解锁</span></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isUnlocked</span><span class=\"params\">(<span class=\"number\">_</span> level: Int)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> level &lt;= highestUnlockedLevel</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\"><span class=\"comment\">//忽略调用该方法时不使用返回值的警告，更新当前玩家等级前检查是否已经解锁最新等级了</span></div><div class=\"line\">    @discardableResult</div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">advance</span><span class=\"params\">(to level: Int)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"type\">LevelTracker</span>.isUnlocked(level) &#123;</div><div class=\"line\">            currentLevel = level</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span></div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下面，Player类使用LevelTracker来监测和更新每个玩家的发展进度：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Player</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> tracker = <span class=\"type\">LevelTracker</span>()</div><div class=\"line\">    <span class=\"keyword\">let</span> playerName: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">complete</span><span class=\"params\">(level: Int)</span></span> &#123;</div><div class=\"line\">        <span class=\"type\">LevelTracker</span>.unlock(level + <span class=\"number\">1</span>)</div><div class=\"line\">        tracker.<span class=\"built_in\">advance</span>(to: level + <span class=\"number\">1</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>) &#123;</div><div class=\"line\">        playerName = name</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Player类创建一个新的LevelTracker实例来监测这个用户的进度。它提供了complete(level:)方法，一旦玩家完成某个指定等级就调用它。这个方法为所有玩家解锁下一等级，并且将当前玩家的进度更新为下一等级。（我们忽略了advance(to:)返回的布尔值，因为之前调用LevelTracker.unlock(_:)时就知道了这个等级已经被解锁了）。</p>\n<p>你还可以为一个新的玩家创建一个Player的实例，然后看这个玩家完成等级一时发生了什么：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> player = <span class=\"type\">Player</span>(name: <span class=\"string\">\"Argyrios\"</span>)</div><div class=\"line\">player.complete(level: <span class=\"number\">1</span>)</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"highest unlocked level is now <span class=\"subst\">\\(LevelTracker.highestUnlockedLevel)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"highest unlocked level is now 2\"</span></div></pre></td></tr></table></figure>\n<p>如果你创建了第二个玩家，并尝试让他开始一个没有被任何玩家解锁的等级，那么试图设置玩家当前等级将会失败：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">player = <span class=\"type\">Player</span>(name: <span class=\"string\">\"Beto\"</span>)</div><div class=\"line\"><span class=\"keyword\">if</span> player.tracker.<span class=\"built_in\">advance</span>(to: <span class=\"number\">6</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"player is now on level 6\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"level 6 has not yet been unlocked\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"level 6 has not yet been unlocked\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Methods.html/\" target=\"_blank\" rel=\"external\">Methods</a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>​    方法是与某些特定类型相关联的函数。类、结构体、枚举都可以定义实例方法；实例方法为给定类型的实例封装了具体的任务与功能。类、结构体、枚举也可以定义类型方法；类型方法与类型本身相关联。类型方法与 Objective-C 中的类方法（class methods）相似。<br>结构体和枚举能够定义方法是 Swift 与 C/Objective-C 的主要区别之一。在 Objective-C 中，类是唯一能定义方法的类型。但在 Swift 中，你不仅能选择是否要定义一个类/结构体/枚举，还能灵活地在你创建的类型（类/结构体/枚举）上定义方法。</p>\n<h3 id=\"实例方法\"><a href=\"#实例方法\" class=\"headerlink\" title=\"实例方法\"></a>实例方法</h3><p>实例方法是属于某个特定类、结构体或者枚举类型实例的方法。实例方法提供访问和修改实例属性的方法或提供与实例目的相关的功能，并以此来支撑实例的功能。实例方法的语法与函数完全一致。<br>实例方法要写在它所属的类型的前后大括号之间。实例方法能够隐式访问它所属类型的所有的其他实例方法和属性。实例方法只能被它所属的类的某个特定实例调用。实例方法只能由实例调用。<br>下面的例子，定义一个很简单的Counter类，Counter能被用来对一个动作发生的次数进行计数：</p>","more":"<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">count</span> = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">increment</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"built_in\">count</span> += <span class=\"number\">1</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">increment</span><span class=\"params\">(by amount: Int)</span></span> &#123;</div><div class=\"line\">        <span class=\"built_in\">count</span> += amount</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reset</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"built_in\">count</span> = <span class=\"number\">0</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Counter这个类定义了一个属性和3个方法，其实例可以通过点语法来调用属性和方法</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> counter = <span class=\"type\">Counter</span>()</div><div class=\"line\"><span class=\"comment\">// the initial counter value is 0</span></div><div class=\"line\">counter.increment()</div><div class=\"line\"><span class=\"comment\">// the counter's value is now 1</span></div><div class=\"line\">counter.increment(by: <span class=\"number\">5</span>)</div><div class=\"line\"><span class=\"comment\">// the counter's value is now 6</span></div><div class=\"line\">counter.reset()</div><div class=\"line\"><span class=\"comment\">// the counter's value is now 0</span></div></pre></td></tr></table></figure>\n<h4 id=\"self属性\"><a href=\"#self属性\" class=\"headerlink\" title=\"self属性\"></a>self属性</h4><p>类型的每一个实例都有一个隐含属性叫做self，self完全等同于该实例本身。你可以在一个实例的实例方法中使用这个隐含的self属性来引用当前实例。<br>上面例子中的increment方法还可以这样写：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">increment</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    <span class=\"keyword\">self</span>.<span class=\"built_in\">count</span> += <span class=\"number\">1</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>实际上，你不必在你的代码里面经常写self。如果你没有明确地写self，Swift 假定你是指当前实例的属性或者方法。使用这条规则的主要场景是实例方法的某个参数名称与实例的某个属性名称相同的时候。在这种情况下，参数名称享有优先权，并且在引用属性时必须使用一种更严格的方式。这时你可以使用self属性来区分参数名称和属性名称。<br>下面的例子中，self消除方法参数x和实例属性x之间的歧义：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">0.0</span>, y = <span class=\"number\">0.0</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isToTheRightOf</span><span class=\"params\">(x: Double)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.x &gt; x</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> somePoint = <span class=\"type\">Point</span>(x: <span class=\"number\">4.0</span>, y: <span class=\"number\">5.0</span>)</div><div class=\"line\"><span class=\"keyword\">if</span> somePoint.isToTheRightOf(x: <span class=\"number\">1.0</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"This point is to the right of the line where x == 1.0\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"This point is to the right of the line where x == 1.0\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"在实例方法中修改值类型\"><a href=\"#在实例方法中修改值类型\" class=\"headerlink\" title=\"在实例方法中修改值类型\"></a>在实例方法中修改值类型</h4><p>结构体和枚举是值类型。默认情况下，值类型的属性不能在它的实例方法中被修改。<br>但是，如果你确实需要在某个特定的方法中修改结构体或者枚举的属性，你可以为这个方法选择可变(mutating)行为，然后就可以从其方法内部改变它的属性；并且这个方法做的任何改变都会在方法执行结束时写回到原始结构中。方法还可以给它隐含的self属性赋予一个全新的实例，这个新实例在方法结束时会替换现存实例。<br>要使用可变方法，将关键字 <code>mutating</code> 放到方法的 <code>func</code> 关键字之前就可以了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">0.0</span>, y = <span class=\"number\">0.0</span></div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">moveBy</span><span class=\"params\">(x deltaX: Double, y deltaY: Double)</span></span> &#123;</div><div class=\"line\">        x += deltaX</div><div class=\"line\">        y += deltaY</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> somePoint = <span class=\"type\">Point</span>(x: <span class=\"number\">1.0</span>, y: <span class=\"number\">1.0</span>)</div><div class=\"line\">somePoint.moveBy(x: <span class=\"number\">2.0</span>, y: <span class=\"number\">3.0</span>)</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The point is now at (<span class=\"subst\">\\(somePoint.x)</span>, <span class=\"subst\">\\(somePoint.y)</span>)\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"The point is now at (3.0, 4.0)\"</span></div></pre></td></tr></table></figure>\n<p>注意，不能在结构体类型的常量（a constant of structure type）上调用可变方法，因为其属性不能被改变，即使属性是变量属性。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> fixedPoint = <span class=\"type\">Point</span>(x: <span class=\"number\">3.0</span>, y: <span class=\"number\">3.0</span>)</div><div class=\"line\">fixedPoint.moveBy(x: <span class=\"number\">2.0</span>, y: <span class=\"number\">3.0</span>)</div><div class=\"line\"><span class=\"comment\">// this will report an error</span></div></pre></td></tr></table></figure>\n<h4 id=\"在可变方法中给-self-赋值\"><a href=\"#在可变方法中给-self-赋值\" class=\"headerlink\" title=\"在可变方法中给 self 赋值\"></a>在可变方法中给 self 赋值</h4><p>可变方法能够赋给隐含属性self一个全新的实例。<br>上面Point的例子可以用下面的方式改写：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">0.0</span>, y = <span class=\"number\">0.0</span></div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">moveBy</span><span class=\"params\">(x deltaX: Double, y deltaY: Double)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span> = <span class=\"type\">Point</span>(x: x + deltaX, y: y + deltaY)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>枚举的可变方法可以把self设置为同一枚举类型中不同的成员：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">TriStateSwitch</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> off, low, high</div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">next</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> <span class=\"keyword\">self</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> .off:</div><div class=\"line\">            <span class=\"keyword\">self</span> = .low</div><div class=\"line\">        <span class=\"keyword\">case</span> .low:</div><div class=\"line\">            <span class=\"keyword\">self</span> = .high</div><div class=\"line\">        <span class=\"keyword\">case</span> .high:</div><div class=\"line\">            <span class=\"keyword\">self</span> = .off</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> ovenLight = <span class=\"type\">TriStateSwitch</span>.low</div><div class=\"line\">ovenLight.next()</div><div class=\"line\"><span class=\"comment\">// ovenLight is now equal to .high</span></div><div class=\"line\">ovenLight.next()</div><div class=\"line\"><span class=\"comment\">// ovenLight is now equal to .off</span></div></pre></td></tr></table></figure>\n<p>简单的状态模式。</p>\n<h3 id=\"类型方法\"><a href=\"#类型方法\" class=\"headerlink\" title=\"类型方法\"></a>类型方法</h3><p>实例方法是被某个类型的实例调用的方法。你也可以定义在类型本身上调用的方法，这种方法就叫做类型方法。在方法的func关键字之前加上关键字 <code>static</code>，来指定类型方法。类还可以用关键字 <code>class</code> 来允许子类重写父类的方法实现。<br>    在 Objective-C 中，你只能为 Objective-C 的类类型（classes）定义类型方法（type-level methods）。在 Swift 中，你可以为所有的类、结构体和枚举定义类型方法。每一个类型方法都被它所支持的类型显式包含。</p>\n<p>类型方法和实例方法一样用点语法调用。但是，你是在类型上调用这个方法，而不是在实例上调用。<br>下面是如何在SomeClass类上调用类型方法的例子：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClass</span> </span>&#123;</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">func</span> <span class=\"title\">someTypeMethod</span>() </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// type method implementation goes here</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"type\">SomeClass</span>.someTypeMethod()</div></pre></td></tr></table></figure>\n<p>在类型方法的方法体（body）中，self指向这个类型本身，而不是类型的某个实例。这意味着你可以用self来消除类型属性和类型方法参数之间的歧义（类似于我们在前面处理实例属性和实例方法参数时做的那样）。</p>\n<p>一般而言，在一个类型中，类型方法可以调用类型方法或类型属性，不需要在被调用的类型方法或者类型属性前不需要添加类型名称。类似的，在结构体和枚举中，也能够直接通过类型属性的名称访问本类中的类型属性，而不需要前面加上类型名称。</p>\n<p>下面的例子定义了一个名为LevelTracker结构体。它监测玩家的游戏发展情况（游戏的不同层次或阶段）。这是一个单人游戏，但也可以存储多个玩家在同一设备上的游戏信息。</p>\n<p>游戏初始时，所有的游戏等级（除了等级 1）都被锁定。每次有玩家完成一个等级，这个等级就对这个设备上的所有玩家解锁。LevelTracker结构体用类型属性和方法监测游戏的哪个等级已经被解锁。它还监测每个玩家的当前等级。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LevelTracker</span> </span>&#123;</div><div class=\"line\"><span class=\"comment\">//记录最高解锁等级</span></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> highestUnlockedLevel = <span class=\"number\">1</span></div><div class=\"line\"><span class=\"comment\">//记录当前玩家等级</span></div><div class=\"line\">    <span class=\"keyword\">var</span> currentLevel = <span class=\"number\">1</span></div><div class=\"line\">    </div><div class=\"line\"><span class=\"comment\">//解锁新等级</span></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">unlock</span><span class=\"params\">(<span class=\"number\">_</span> level: Int)</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> level &gt; highestUnlockedLevel &#123; highestUnlockedLevel = level &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\"><span class=\"comment\">//判断某个等级是否被解锁</span></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isUnlocked</span><span class=\"params\">(<span class=\"number\">_</span> level: Int)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> level &lt;= highestUnlockedLevel</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\"><span class=\"comment\">//忽略调用该方法时不使用返回值的警告，更新当前玩家等级前检查是否已经解锁最新等级了</span></div><div class=\"line\">    @discardableResult</div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">advance</span><span class=\"params\">(to level: Int)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"type\">LevelTracker</span>.isUnlocked(level) &#123;</div><div class=\"line\">            currentLevel = level</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span></div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下面，Player类使用LevelTracker来监测和更新每个玩家的发展进度：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Player</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> tracker = <span class=\"type\">LevelTracker</span>()</div><div class=\"line\">    <span class=\"keyword\">let</span> playerName: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">complete</span><span class=\"params\">(level: Int)</span></span> &#123;</div><div class=\"line\">        <span class=\"type\">LevelTracker</span>.unlock(level + <span class=\"number\">1</span>)</div><div class=\"line\">        tracker.<span class=\"built_in\">advance</span>(to: level + <span class=\"number\">1</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>) &#123;</div><div class=\"line\">        playerName = name</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Player类创建一个新的LevelTracker实例来监测这个用户的进度。它提供了complete(level:)方法，一旦玩家完成某个指定等级就调用它。这个方法为所有玩家解锁下一等级，并且将当前玩家的进度更新为下一等级。（我们忽略了advance(to:)返回的布尔值，因为之前调用LevelTracker.unlock(_:)时就知道了这个等级已经被解锁了）。</p>\n<p>你还可以为一个新的玩家创建一个Player的实例，然后看这个玩家完成等级一时发生了什么：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> player = <span class=\"type\">Player</span>(name: <span class=\"string\">\"Argyrios\"</span>)</div><div class=\"line\">player.complete(level: <span class=\"number\">1</span>)</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"highest unlocked level is now <span class=\"subst\">\\(LevelTracker.highestUnlockedLevel)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"highest unlocked level is now 2\"</span></div></pre></td></tr></table></figure>\n<p>如果你创建了第二个玩家，并尝试让他开始一个没有被任何玩家解锁的等级，那么试图设置玩家当前等级将会失败：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">player = <span class=\"type\">Player</span>(name: <span class=\"string\">\"Beto\"</span>)</div><div class=\"line\"><span class=\"keyword\">if</span> player.tracker.<span class=\"built_in\">advance</span>(to: <span class=\"number\">6</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"player is now on level 6\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"level 6 has not yet been unlocked\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"level 6 has not yet been unlocked\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Methods.html/\" target=\"_blank\" rel=\"external\">Methods</a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>"},{"layout":"post","title":"Swift Nested Types","date":"2016-12-01T11:20:11.000Z","author":"liangtong","catalog":true,"_content":"\n\n\n​\t枚举常被用于为特定类或结构体实现某些功能。类似的，枚举可以方便的定义工具类或结构体，从而为某个复杂的类型所使用。为了实现这种功能，Swift 允许你定义嵌套类型，可以在支持的类型中定义嵌套的枚举、类和结构体。\n要在一个类型中嵌套另一个类型，将嵌套类型的定义写在其外部类型的{}内，而且可以根据需要定义多级嵌套。\n\n\n\n### 嵌套类型实践\n下面这个例子定义了一个结构体BlackjackCard，用来模拟BlackjackCard中的扑克牌点数。BlackjackCard结构体包含两个嵌套定义的枚举类型Suit和Rank。\n在BlackjackCard中，Ace牌可以表示1或者11，Ace牌的这一特征通过一个嵌套在Rank枚举中的结构体Values来表示：\n\n<!-- more -->\n\n\n```Swift\nstruct BlackjackCard {\n    \n    // nested Suit enumeration\n    enum Suit: Character {\n        case spades = \"♠\", hearts = \"♡\", diamonds = \"♢\", clubs = \"♣\"\n    }\n    \n    // nested Rank enumeration\n    enum Rank: Int {\n        case two = 2, three, four, five, six, seven, eight, nine, ten\n        case jack, queen, king, ace\n        struct Values {\n            let first: Int, second: Int?\n        }\n        var values: Values {\n            switch self {\n            case .ace:\n                return Values(first: 1, second: 11)\n            case .jack, .queen, .king:\n                return Values(first: 10, second: nil)\n            default:\n                return Values(first: self.rawValue, second: nil)\n            }\n        }\n    }\n    \n    // BlackjackCard properties and methods\n    let rank: Rank, suit: Suit\n    var description: String {\n        var output = \"suit is \\(suit.rawValue),\"\n        output += \" value is \\(rank.values.first)\"\n        if let second = rank.values.second {\n            output += \" or \\(second)\"\n        }\n        return output\n    }\n}\n```\n\nSuit枚举用来描述扑克牌的四种花色，并用一个Character类型的原始值表示花色符号。\nRank枚举用来描述扑克牌从Ace~10，以及J、Q、K，这13种牌，并用一个Int类型的原始值表示牌的面值。（这个Int类型的原始值未用于Ace、J、Q、K这4种牌。）\n如上所述，Rank枚举在内部定义了一个嵌套结构体Values。结构体Values中定义了两个属性，用于反映只有Ace有两个数值，其余牌都只有一个数值：\n\n* first, of type Int\n* second, of type Int?, or “optional Int”\n\nRank还定义了一个计算型属性values，它将会返回一个Values结构体的实例。这个计算型属性会根据牌的面值，用适当的数值去初始化Values实例。对于J、Q、K、Ace这四种牌，会使用特殊数值。对于数字面值的牌，使用枚举实例的原始值。\n\nBlackjackCard结构体拥有两个属性——rank与suit。它也同样定义了一个计算型属性description，description属性用rank和suit中的内容来构建对扑克牌名字和数值的描述。该属性使用可选绑定来检查可选类型second是否有值，若有值，则在原有的描述中增加对second的描述。\n\n因为BlackjackCard是一个没有自定义构造器的结构体,有默认的成员构造器，所以你可以用默认的构造器去初始化新常量theAceOfSpades：\n\n```Swift\nlet theAceOfSpades = BlackjackCard(rank: .ace, suit: .spades)\nprint(\"theAceOfSpades: \\(theAceOfSpades.description)\")\n// Prints \"theAceOfSpades: suit is ♠, value is 1 or 11\"\n```\n\n尽管Rank和Suit嵌套在BlackjackCard中，但它们的类型仍可从上下文中推断出来，所以在初始化实例时能够单独通过成员名称（.Ace和.Spades）引用枚举实例。在上面的例子中，description属性正确地反映了黑桃A牌具有1和11两个值。\n\n### 引用嵌套类型\n在外部引用嵌套类型时，在嵌套类型的类型名前加上其外部类型的类型名作为前缀：\n\n```Swift\nlet heartsSymbol = BlackjackCard.Suit.hearts.rawValue\n// heartsSymbol is \"♡\"\n```\n\n对于上面这个例子，这样可以使Suit、Rank和Values的名字尽可能的短，因为它们的名字可以由定义它们的上下文来限定。\n\n\n\n\n\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/NestedTypes.html/\"> NestedTypes </a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","source":"_posts/iOS_Swift_language_note_Nested-Types.md","raw":"---\nlayout:     post\ntitle:      Swift Nested Types\ndate:       2016-12-01 19:20:11\nauthor:     liangtong\ncatalog: true\ncategories: iOS\ntags: Swift \n\n---\n\n\n\n​\t枚举常被用于为特定类或结构体实现某些功能。类似的，枚举可以方便的定义工具类或结构体，从而为某个复杂的类型所使用。为了实现这种功能，Swift 允许你定义嵌套类型，可以在支持的类型中定义嵌套的枚举、类和结构体。\n要在一个类型中嵌套另一个类型，将嵌套类型的定义写在其外部类型的{}内，而且可以根据需要定义多级嵌套。\n\n\n\n### 嵌套类型实践\n下面这个例子定义了一个结构体BlackjackCard，用来模拟BlackjackCard中的扑克牌点数。BlackjackCard结构体包含两个嵌套定义的枚举类型Suit和Rank。\n在BlackjackCard中，Ace牌可以表示1或者11，Ace牌的这一特征通过一个嵌套在Rank枚举中的结构体Values来表示：\n\n<!-- more -->\n\n\n```Swift\nstruct BlackjackCard {\n    \n    // nested Suit enumeration\n    enum Suit: Character {\n        case spades = \"♠\", hearts = \"♡\", diamonds = \"♢\", clubs = \"♣\"\n    }\n    \n    // nested Rank enumeration\n    enum Rank: Int {\n        case two = 2, three, four, five, six, seven, eight, nine, ten\n        case jack, queen, king, ace\n        struct Values {\n            let first: Int, second: Int?\n        }\n        var values: Values {\n            switch self {\n            case .ace:\n                return Values(first: 1, second: 11)\n            case .jack, .queen, .king:\n                return Values(first: 10, second: nil)\n            default:\n                return Values(first: self.rawValue, second: nil)\n            }\n        }\n    }\n    \n    // BlackjackCard properties and methods\n    let rank: Rank, suit: Suit\n    var description: String {\n        var output = \"suit is \\(suit.rawValue),\"\n        output += \" value is \\(rank.values.first)\"\n        if let second = rank.values.second {\n            output += \" or \\(second)\"\n        }\n        return output\n    }\n}\n```\n\nSuit枚举用来描述扑克牌的四种花色，并用一个Character类型的原始值表示花色符号。\nRank枚举用来描述扑克牌从Ace~10，以及J、Q、K，这13种牌，并用一个Int类型的原始值表示牌的面值。（这个Int类型的原始值未用于Ace、J、Q、K这4种牌。）\n如上所述，Rank枚举在内部定义了一个嵌套结构体Values。结构体Values中定义了两个属性，用于反映只有Ace有两个数值，其余牌都只有一个数值：\n\n* first, of type Int\n* second, of type Int?, or “optional Int”\n\nRank还定义了一个计算型属性values，它将会返回一个Values结构体的实例。这个计算型属性会根据牌的面值，用适当的数值去初始化Values实例。对于J、Q、K、Ace这四种牌，会使用特殊数值。对于数字面值的牌，使用枚举实例的原始值。\n\nBlackjackCard结构体拥有两个属性——rank与suit。它也同样定义了一个计算型属性description，description属性用rank和suit中的内容来构建对扑克牌名字和数值的描述。该属性使用可选绑定来检查可选类型second是否有值，若有值，则在原有的描述中增加对second的描述。\n\n因为BlackjackCard是一个没有自定义构造器的结构体,有默认的成员构造器，所以你可以用默认的构造器去初始化新常量theAceOfSpades：\n\n```Swift\nlet theAceOfSpades = BlackjackCard(rank: .ace, suit: .spades)\nprint(\"theAceOfSpades: \\(theAceOfSpades.description)\")\n// Prints \"theAceOfSpades: suit is ♠, value is 1 or 11\"\n```\n\n尽管Rank和Suit嵌套在BlackjackCard中，但它们的类型仍可从上下文中推断出来，所以在初始化实例时能够单独通过成员名称（.Ace和.Spades）引用枚举实例。在上面的例子中，description属性正确地反映了黑桃A牌具有1和11两个值。\n\n### 引用嵌套类型\n在外部引用嵌套类型时，在嵌套类型的类型名前加上其外部类型的类型名作为前缀：\n\n```Swift\nlet heartsSymbol = BlackjackCard.Suit.hearts.rawValue\n// heartsSymbol is \"♡\"\n```\n\n对于上面这个例子，这样可以使Suit、Rank和Values的名字尽可能的短，因为它们的名字可以由定义它们的上下文来限定。\n\n\n\n\n\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/NestedTypes.html/\"> NestedTypes </a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","slug":"iOS_Swift_language_note_Nested-Types","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4uk003hoko8u7zniiii","content":"<p>​    枚举常被用于为特定类或结构体实现某些功能。类似的，枚举可以方便的定义工具类或结构体，从而为某个复杂的类型所使用。为了实现这种功能，Swift 允许你定义嵌套类型，可以在支持的类型中定义嵌套的枚举、类和结构体。<br>要在一个类型中嵌套另一个类型，将嵌套类型的定义写在其外部类型的{}内，而且可以根据需要定义多级嵌套。</p>\n<h3 id=\"嵌套类型实践\"><a href=\"#嵌套类型实践\" class=\"headerlink\" title=\"嵌套类型实践\"></a>嵌套类型实践</h3><p>下面这个例子定义了一个结构体BlackjackCard，用来模拟BlackjackCard中的扑克牌点数。BlackjackCard结构体包含两个嵌套定义的枚举类型Suit和Rank。<br>在BlackjackCard中，Ace牌可以表示1或者11，Ace牌的这一特征通过一个嵌套在Rank枚举中的结构体Values来表示：</p>\n<a id=\"more\"></a>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BlackjackCard</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// nested Suit enumeration</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Suit</span>: <span class=\"title\">Character</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> spades = <span class=\"string\">\"♠\"</span>, hearts = <span class=\"string\">\"♡\"</span>, diamonds = <span class=\"string\">\"♢\"</span>, clubs = <span class=\"string\">\"♣\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// nested Rank enumeration</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Rank</span>: <span class=\"title\">Int</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> two = <span class=\"number\">2</span>, three, four, five, six, seven, eight, nine, ten</div><div class=\"line\">        <span class=\"keyword\">case</span> jack, queen, king, ace</div><div class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Values</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">let</span> first: <span class=\"type\">Int</span>, second: <span class=\"type\">Int</span>?</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">var</span> values: <span class=\"type\">Values</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">switch</span> <span class=\"keyword\">self</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> .ace:</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"type\">Values</span>(first: <span class=\"number\">1</span>, second: <span class=\"number\">11</span>)</div><div class=\"line\">            <span class=\"keyword\">case</span> .jack, .queen, .king:</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"type\">Values</span>(first: <span class=\"number\">10</span>, second: <span class=\"literal\">nil</span>)</div><div class=\"line\">            <span class=\"keyword\">default</span>:</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"type\">Values</span>(first: <span class=\"keyword\">self</span>.rawValue, second: <span class=\"literal\">nil</span>)</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// BlackjackCard properties and methods</span></div><div class=\"line\">    <span class=\"keyword\">let</span> rank: <span class=\"type\">Rank</span>, suit: <span class=\"type\">Suit</span></div><div class=\"line\">    <span class=\"keyword\">var</span> description: <span class=\"type\">String</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> output = <span class=\"string\">\"suit is <span class=\"subst\">\\(suit.rawValue)</span>,\"</span></div><div class=\"line\">        output += <span class=\"string\">\" value is <span class=\"subst\">\\(rank.values.first)</span>\"</span></div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> second = rank.values.second &#123;</div><div class=\"line\">            output += <span class=\"string\">\" or <span class=\"subst\">\\(second)</span>\"</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> output</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Suit枚举用来描述扑克牌的四种花色，并用一个Character类型的原始值表示花色符号。<br>Rank枚举用来描述扑克牌从Ace~10，以及J、Q、K，这13种牌，并用一个Int类型的原始值表示牌的面值。（这个Int类型的原始值未用于Ace、J、Q、K这4种牌。）<br>如上所述，Rank枚举在内部定义了一个嵌套结构体Values。结构体Values中定义了两个属性，用于反映只有Ace有两个数值，其余牌都只有一个数值：</p>\n<ul>\n<li>first, of type Int</li>\n<li>second, of type Int?, or “optional Int”</li>\n</ul>\n<p>Rank还定义了一个计算型属性values，它将会返回一个Values结构体的实例。这个计算型属性会根据牌的面值，用适当的数值去初始化Values实例。对于J、Q、K、Ace这四种牌，会使用特殊数值。对于数字面值的牌，使用枚举实例的原始值。</p>\n<p>BlackjackCard结构体拥有两个属性——rank与suit。它也同样定义了一个计算型属性description，description属性用rank和suit中的内容来构建对扑克牌名字和数值的描述。该属性使用可选绑定来检查可选类型second是否有值，若有值，则在原有的描述中增加对second的描述。</p>\n<p>因为BlackjackCard是一个没有自定义构造器的结构体,有默认的成员构造器，所以你可以用默认的构造器去初始化新常量theAceOfSpades：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> theAceOfSpades = <span class=\"type\">BlackjackCard</span>(rank: .ace, suit: .spades)</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"theAceOfSpades: <span class=\"subst\">\\(theAceOfSpades.description)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"theAceOfSpades: suit is ♠, value is 1 or 11\"</span></div></pre></td></tr></table></figure>\n<p>尽管Rank和Suit嵌套在BlackjackCard中，但它们的类型仍可从上下文中推断出来，所以在初始化实例时能够单独通过成员名称（.Ace和.Spades）引用枚举实例。在上面的例子中，description属性正确地反映了黑桃A牌具有1和11两个值。</p>\n<h3 id=\"引用嵌套类型\"><a href=\"#引用嵌套类型\" class=\"headerlink\" title=\"引用嵌套类型\"></a>引用嵌套类型</h3><p>在外部引用嵌套类型时，在嵌套类型的类型名前加上其外部类型的类型名作为前缀：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> heartsSymbol = <span class=\"type\">BlackjackCard</span>.<span class=\"type\">Suit</span>.hearts.rawValue</div><div class=\"line\"><span class=\"comment\">// heartsSymbol is \"♡\"</span></div></pre></td></tr></table></figure>\n<p>对于上面这个例子，这样可以使Suit、Rank和Values的名字尽可能的短，因为它们的名字可以由定义它们的上下文来限定。</p>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/NestedTypes.html/\" target=\"_blank\" rel=\"external\"> NestedTypes </a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>​    枚举常被用于为特定类或结构体实现某些功能。类似的，枚举可以方便的定义工具类或结构体，从而为某个复杂的类型所使用。为了实现这种功能，Swift 允许你定义嵌套类型，可以在支持的类型中定义嵌套的枚举、类和结构体。<br>要在一个类型中嵌套另一个类型，将嵌套类型的定义写在其外部类型的{}内，而且可以根据需要定义多级嵌套。</p>\n<h3 id=\"嵌套类型实践\"><a href=\"#嵌套类型实践\" class=\"headerlink\" title=\"嵌套类型实践\"></a>嵌套类型实践</h3><p>下面这个例子定义了一个结构体BlackjackCard，用来模拟BlackjackCard中的扑克牌点数。BlackjackCard结构体包含两个嵌套定义的枚举类型Suit和Rank。<br>在BlackjackCard中，Ace牌可以表示1或者11，Ace牌的这一特征通过一个嵌套在Rank枚举中的结构体Values来表示：</p>","more":"<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BlackjackCard</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// nested Suit enumeration</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Suit</span>: <span class=\"title\">Character</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> spades = <span class=\"string\">\"♠\"</span>, hearts = <span class=\"string\">\"♡\"</span>, diamonds = <span class=\"string\">\"♢\"</span>, clubs = <span class=\"string\">\"♣\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// nested Rank enumeration</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Rank</span>: <span class=\"title\">Int</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> two = <span class=\"number\">2</span>, three, four, five, six, seven, eight, nine, ten</div><div class=\"line\">        <span class=\"keyword\">case</span> jack, queen, king, ace</div><div class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Values</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">let</span> first: <span class=\"type\">Int</span>, second: <span class=\"type\">Int</span>?</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">var</span> values: <span class=\"type\">Values</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">switch</span> <span class=\"keyword\">self</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> .ace:</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"type\">Values</span>(first: <span class=\"number\">1</span>, second: <span class=\"number\">11</span>)</div><div class=\"line\">            <span class=\"keyword\">case</span> .jack, .queen, .king:</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"type\">Values</span>(first: <span class=\"number\">10</span>, second: <span class=\"literal\">nil</span>)</div><div class=\"line\">            <span class=\"keyword\">default</span>:</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"type\">Values</span>(first: <span class=\"keyword\">self</span>.rawValue, second: <span class=\"literal\">nil</span>)</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\">// BlackjackCard properties and methods</span></div><div class=\"line\">    <span class=\"keyword\">let</span> rank: <span class=\"type\">Rank</span>, suit: <span class=\"type\">Suit</span></div><div class=\"line\">    <span class=\"keyword\">var</span> description: <span class=\"type\">String</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> output = <span class=\"string\">\"suit is <span class=\"subst\">\\(suit.rawValue)</span>,\"</span></div><div class=\"line\">        output += <span class=\"string\">\" value is <span class=\"subst\">\\(rank.values.first)</span>\"</span></div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> second = rank.values.second &#123;</div><div class=\"line\">            output += <span class=\"string\">\" or <span class=\"subst\">\\(second)</span>\"</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> output</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Suit枚举用来描述扑克牌的四种花色，并用一个Character类型的原始值表示花色符号。<br>Rank枚举用来描述扑克牌从Ace~10，以及J、Q、K，这13种牌，并用一个Int类型的原始值表示牌的面值。（这个Int类型的原始值未用于Ace、J、Q、K这4种牌。）<br>如上所述，Rank枚举在内部定义了一个嵌套结构体Values。结构体Values中定义了两个属性，用于反映只有Ace有两个数值，其余牌都只有一个数值：</p>\n<ul>\n<li>first, of type Int</li>\n<li>second, of type Int?, or “optional Int”</li>\n</ul>\n<p>Rank还定义了一个计算型属性values，它将会返回一个Values结构体的实例。这个计算型属性会根据牌的面值，用适当的数值去初始化Values实例。对于J、Q、K、Ace这四种牌，会使用特殊数值。对于数字面值的牌，使用枚举实例的原始值。</p>\n<p>BlackjackCard结构体拥有两个属性——rank与suit。它也同样定义了一个计算型属性description，description属性用rank和suit中的内容来构建对扑克牌名字和数值的描述。该属性使用可选绑定来检查可选类型second是否有值，若有值，则在原有的描述中增加对second的描述。</p>\n<p>因为BlackjackCard是一个没有自定义构造器的结构体,有默认的成员构造器，所以你可以用默认的构造器去初始化新常量theAceOfSpades：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> theAceOfSpades = <span class=\"type\">BlackjackCard</span>(rank: .ace, suit: .spades)</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"theAceOfSpades: <span class=\"subst\">\\(theAceOfSpades.description)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"theAceOfSpades: suit is ♠, value is 1 or 11\"</span></div></pre></td></tr></table></figure>\n<p>尽管Rank和Suit嵌套在BlackjackCard中，但它们的类型仍可从上下文中推断出来，所以在初始化实例时能够单独通过成员名称（.Ace和.Spades）引用枚举实例。在上面的例子中，description属性正确地反映了黑桃A牌具有1和11两个值。</p>\n<h3 id=\"引用嵌套类型\"><a href=\"#引用嵌套类型\" class=\"headerlink\" title=\"引用嵌套类型\"></a>引用嵌套类型</h3><p>在外部引用嵌套类型时，在嵌套类型的类型名前加上其外部类型的类型名作为前缀：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> heartsSymbol = <span class=\"type\">BlackjackCard</span>.<span class=\"type\">Suit</span>.hearts.rawValue</div><div class=\"line\"><span class=\"comment\">// heartsSymbol is \"♡\"</span></div></pre></td></tr></table></figure>\n<p>对于上面这个例子，这样可以使Suit、Rank和Values的名字尽可能的短，因为它们的名字可以由定义它们的上下文来限定。</p>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/NestedTypes.html/\" target=\"_blank\" rel=\"external\"> NestedTypes </a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>"},{"layout":"post","title":"Swift Optional Chaining","date":"2016-11-29T17:20:11.000Z","author":"liangtong","catalog":true,"_content":"\n\n\n​\t可选链式调用是一种可以在当前值可能为nil的可选值上请求和调用属性、方法及下标的方法。如果可选值有值，那么调用就会成功；如果可选值是nil，那么调用将返回nil。多个调用可以连接在一起形成一个调用链，如果其中任何一个节点为nil，整个调用链都会失败，即返回nil。\n\tSwift 的可选链式调用和 Objective-C 中向nil发送消息有些相像，但是 Swift 的可选链式调用可以应用于任意类型，并且能检查调用是否成功。\n\n\n\n### 使用可选链式调用代替强制展开\n通过在想调用的属性、方法、或下标的可选值后面放一个问号（?），可以定义一个可选链。这一点很像在可选值后面放一个叹号（!）来强制展开它的值。它们的主要区别在于当可选值为空时可选链式调用只会调用失败，然而强制展开将会触发运行时错误。\n\n为了反映可选链式调用可以在空值（nil）上调用的事实，不论这个调用的属性、方法及下标返回的值是不是可选值，它的返回结果都是一个可选值。你可以利用这个返回值来判断你的可选链式调用是否调用成功，如果调用有返回值则说明调用成功，返回nil则说明调用失败。\n\n特别地，可选链式调用的返回结果与原本的返回结果具有相同的类型，但是被包装成了一个可选值。例如，使用可选链式调用访问属性，当可选链式调用成功时，如果属性原本的返回结果是Int类型，则会变为Int?类型。\n\n\n<!-- more -->\n\n下面几段代码将解释可选链式调用和强制展开的不同。首先定义两个类Person和Residence：\n\n```Swift\nclass Person {\n    var residence: Residence?\n}\n \nclass Residence {\n    var numberOfRooms = 1\n}\n```\n\nResidence有一个Int类型的属性numberOfRooms，其默认值为1。Person具有一个可选的residence属性，其类型为Residence?。\n假如你创建了一个新的Person实例,它的residence属性由于是是可选型而将初始化为nil,在下面的代码中,john有一个值为nil的residence属性：\n\n```Swift\nlet john = Person()\n```\n\n如果使用叹号（!）强制展开获得这个john的residence属性中的numberOfRooms值，会触发运行时错误，因为这时residence没有可以展开的值：\n\n```Swift\nlet roomCount = john.residence!.numberOfRooms\n// this triggers a runtime error\n```\n\njohn.residence为非nil值的时候，上面的调用会成功，并且把roomCount设置为Int类型的房间数量。正如上面提到的，当residence为nil的时候上面这段代码会触发运行时错误。\n\n可选链式调用提供了另一种访问numberOfRooms的方式，使用问号（?）来替代原来的叹号（!）：\n\n```Swift\nif let roomCount = john.residence?.numberOfRooms {\n    print(\"John's residence has \\(roomCount) room(s).\")\n} else {\n    print(\"Unable to retrieve the number of rooms.\")\n}\n// Prints \"Unable to retrieve the number of rooms.\"\n```\n\n在residence后面添加问号之后，Swift 就会在residence不为nil的情况下访问numberOfRooms。\n因为访问numberOfRooms有可能失败，可选链式调用会返回Int?类型，或称为“可选的 Int”。如上例所示，当residence为nil的时候，可选的Int将会为nil，表明无法访问numberOfRooms。访问成功时，可选的Int值会通过可选绑定展开，并赋值给非可选类型的roomCount常量。\n要注意的是，即使numberOfRooms是非可选的Int时，这一点也成立。只要使用可选链式调用就意味着numberOfRooms会返回一个Int?而不是Int。\n可以将一个Residence的实例赋给john.residence，这样它就不再是nil了：\n\n```Swift\njohn.residence = Residence()\n```\n\njohn.residence现在包含一个实际的Residence实例，而不再是nil。如果你试图使用先前的可选链式调用访问numberOfRooms，它现在将返回值为1的Int?类型的值：\n\n```Swift\nif let roomCount = john.residence?.numberOfRooms {\n    print(\"John's residence has \\(roomCount) room(s).\")\n} else {\n    print(\"Unable to retrieve the number of rooms.\")\n}\n// Prints \"John's residence has 1 room(s).\"\n```\n\n### 为可选链式调用定义模型类\n通过使用可选链式调用可以调用多层属性、方法和下标。这样可以在复杂的模型中向下访问各种子属性，并且判断能否访问子属性的属性、方法或下标。\n下面这段代码定义了四个模型类，这些例子包括多层可选链式调用。为了方便说明，在Person和Residence的基础上增加了Room类和Address类，以及相关的属性、方法以及下标。\n\n```Swift\nclass Person {\n    var residence: Residence?\n}\n\nclass Residence {\n    var rooms = [Room]()\n    var numberOfRooms: Int {\n        return rooms.count\n    }\n    subscript(i: Int) -> Room {\n        get {\n            return rooms[i]\n        }\n        set {\n            rooms[i] = newValue\n        }\n    }\n    func printNumberOfRooms() {\n        print(\"The number of rooms is \\(numberOfRooms)\")\n    }\n    var address: Address?\n}\n```\n\n现在Residence有了一个存储Room实例的数组，numberOfRooms属性被实现为计算型属性，而不是存储型属性。numberOfRooms属性简单地返回rooms数组的count属性的值。\n\nResidence还提供了访问rooms数组的快捷方式，即提供可读写的下标来访问rooms数组中指定位置的元素。\n此外，Residence还提供了printNumberOfRooms方法，这个方法的作用是打印numberOfRooms的值。\n最后，Residence还定义了一个可选属性address，其类型为Address?。Address类的定义在下面会说明。\n\nRoom类是一个简单类，其实例被存储在rooms数组中。该类只包含一个属性name，以及一个用于将该属性设置为适当的房间名的初始化函数：\n\n```Swift\nclass Room {\n    let name: String\n    init(name: String) { self.name = name }\n}\n```\n\n最后一个类是Address，这个类有三个String?类型的可选属性。buildingName以及buildingNumber属性分别表示某个大厦的名称和号码，第三个属性street表示大厦所在街道的名称：\n\n```Swift\nclass Address {\n    var buildingName: String?\n    var buildingNumber: String?\n    var street: String?\n    func buildingIdentifier() -> String? {\n        if buildingNumber != nil && street != nil {\n            return \"\\(buildingNumber) \\(street)\"\n        } else if buildingName != nil {\n            return buildingName\n        } else {\n            return nil\n        }\n    }\n}\n```\n\nAddress类提供了buildingIdentifier()方法，返回值为String?。 如果buildingName有值则返回buildingName。或者，如果buildingNumber和street均有值则返回buildingNumber。否则，返回nil。\n\n### 通过可选链式调用访问属性\n可以通过可选链式调用在一个可选值上访问它的属性，并判断访问是否成功。\n下面的代码创建了一个Person实例，然后像之前一样，尝试访问numberOfRooms属性：\n\n```Swift\nlet john = Person()\nif let roomCount = john.residence?.numberOfRooms {\n    print(\"John's residence has \\(roomCount) room(s).\")\n} else {\n    print(\"Unable to retrieve the number of rooms.\")\n}\n// Prints \"Unable to retrieve the number of rooms.\"\n```\n\n因为john.residence为nil，所以这个可选链式调用依旧会像先前一样失败。\n还可以通过可选链式调用来设置属性值：\n\n```Swift\nlet someAddress = Address()\nsomeAddress.buildingNumber = \"29\"\nsomeAddress.street = \"Acacia Road\"\njohn.residence?.address = someAddress\n```\n\n在这个例子中，通过john.residence来设定address属性也会失败，因为john.residence当前为nil。\n\n上面代码中的赋值过程是可选链式调用的一部分，这意味着可选链式调用失败时，等号右侧的代码不会被执行。对于上面的代码来说，很难验证这一点，因为像这样赋值一个常量没有任何副作用。下面的代码完成了同样的事情，但是它使用一个函数来创建Address实例，然后将该实例返回用于赋值。该函数会在返回前打印“Function was called”，这使你能验证等号右侧的代码是否被执行。\n\n```Swift\nfunc createAddress() -> Address {\n    print(\"Function was called.\")\n    \n    let someAddress = Address()\n    someAddress.buildingNumber = \"29\"\n    someAddress.street = \"Acacia Road\"\n    \n    return someAddress\n}\njohn.residence?.address = createAddress()\n```\n\n没有任何打印消息，可以看出createAddress()函数并未被执行。\n\n### 通过可选链式调用调用方法\n可以通过可选链式调用来调用方法，并判断是否调用成功，即使这个方法没有返回值。\nResidence类中的printNumberOfRooms()方法打印当前的numberOfRooms值，如下所示：\n\n```Swift\nfunc printNumberOfRooms() {\n    print(\"The number of rooms is \\(numberOfRooms)\")\n}\n```\n\n这个方法没有返回值。然而，没有返回值的方法具有隐式的返回类型Void。这意味着没有返回值的方法也会返回()，或者说空的元组。\n\n如果在可选值上通过可选链式调用来调用这个方法，该方法的返回类型会是Void?，而不是Void，因为通过可选链式调用得到的返回值都是可选的。这样我们就可以使用if语句来判断能否成功调用printNumberOfRooms()方法，即使方法本身没有定义返回值。通过判断返回值是否为nil可以判断调用是否成功：\n\n```Swift\nif john.residence?.printNumberOfRooms() != nil {\n    print(\"It was possible to print the number of rooms.\")\n} else {\n    print(\"It was not possible to print the number of rooms.\")\n}\n// Prints \"It was not possible to print the number of rooms.\"\n```\n\n同样的，可以据此判断通过可选链式调用为属性赋值是否成功。在上面的通过可选链式调用访问属性的例子中，我们尝试给john.residence中的address属性赋值，即使residence为nil。通过可选链式调用给属性赋值会返回Void?，通过判断返回值是否为nil就可以知道赋值是否成功：\n\n```Swift\nif (john.residence?.address = someAddress) != nil {\n    print(\"It was possible to set the address.\")\n} else {\n    print(\"It was not possible to set the address.\")\n}\n// Prints \"It was not possible to set the address.\"\n```\n\n### 通过可选链式调用访问下标\n通过可选链式调用，我们可以在一个可选值上访问下标，并且判断下标调用是否成功。\n\t通过可选链式调用访问可选值的下标时，应该将问号放在下标方括号的前面而不是后面。可选链式调用的问号一般直接跟在可选表达式的后面。\n\n下面这个例子用下标访问john.residence属性存储的Residence实例的rooms数组中的第一个房间的名称，因为john.residence为nil，所以下标调用失败了：\n\n```Swift\nif let firstRoomName = john.residence?[0].name {\n    print(\"The first room name is \\(firstRoomName).\")\n} else {\n    print(\"Unable to retrieve the first room name.\")\n}\n// Prints \"Unable to retrieve the first room name.\"\n```\n\n在这个例子中，问号直接放在john.residence的后面，并且在方括号的前面，因为john.residence是可选值。\n类似的，可以通过下标，用可选链式调用来赋值：\n\n```Swift\njohn.residence?[0] = Room(name: \"Bathroom\")\n```\n\n这次赋值同样会失败，因为residence目前是nil。\n如果你创建一个Residence实例，并为其rooms数组添加一些Room实例，然后将Residence实例赋值给john.residence，那就可以通过可选链和下标来访问数组中的元素：\n\n```Swift\nlet johnsHouse = Residence()\njohnsHouse.rooms.append(Room(name: \"Living Room\"))\njohnsHouse.rooms.append(Room(name: \"Kitchen\"))\njohn.residence = johnsHouse\n \nif let firstRoomName = john.residence?[0].name {\n    print(\"The first room name is \\(firstRoomName).\")\n} else {\n    print(\"Unable to retrieve the first room name.\")\n}\n// Prints \"The first room name is Living Room.\"\n```\n\n#### 访问可选类型的下标 \n如果下标返回可选类型值，比如 Swift 中Dictionary类型的键的下标，可以在下标的结尾括号后面放一个问号来在其可选返回值上进行可选链式调用：\n\n```Swift\nvar testScores = [\"Dave\": [86, 82, 84], \"Bev\": [79, 94, 81]]\ntestScores[\"Dave\"]?[0] = 91\ntestScores[\"Bev\"]?[0] += 1\ntestScores[\"Brian\"]?[0] = 72\n// the \"Dave\" array is now [91, 82, 84] and the \"Bev\" array is now [80, 94, 81]\n```\n\n上面的例子中定义了一个testScores数组，包含了两个键值对，把String类型的键映射到一个Int值的数组。这个例子用可选链式调用把\"Dave\"数组中第一个元素设为91，把\"Bev\"数组的第一个元素+1，然后尝试把\"Brian\"数组中的第一个元素设为72。前两个调用成功，因为testScores字典中包含\"Dave\"和\"Bev\"这两个键。但是testScores字典中没有\"Brian\"这个键，所以第三个调用失败。\n\n### 连接多层可选链式调用\n可以通过连接多个可选链式调用在更深的模型层级中访问属性、方法以及下标。然而，多层可选链式调用不会增加返回值的可选层级。\n\n * 如果你访问的值不是可选的，可选链式调用将会返回可选值。\n * 如果你访问的值就是可选的，可选链式调用不会让可选返回值变得“更可选”。\n\n因此：\n\n * 通过可选链式调用访问一个Int值，将会返回Int?，无论使用了多少层可选链式调用。\n * 类似的，通过可选链式调用访问Int?值，依旧会返回Int?值，并不会返回Int??。\n\n下面的例子尝试访问john中的residence属性中的address属性中的street属性。这里使用了两层可选链式调用，residence以及address都是可选值：\n\n```Swift\nif let johnsStreet = john.residence?.address?.street {\n    print(\"John's street name is \\(johnsStreet).\")\n} else {\n    print(\"Unable to retrieve the address.\")\n}\n// Prints \"Unable to retrieve the address.\"\n```\n\njohn.residence现在包含一个有效的Residence实例。然而，john.residence.address的值当前为nil。因此，调用john.residence?.address?.street会失败。\n需要注意的是，上面的例子中，street的属性为String?。john.residence?.address?.street的返回值也依然是String?，即使已经使用了两层可选链式调用。\n\n如果为john.residence.address赋值一个Address实例，并且为address中的street属性设置一个有效值，我们就能过通过可选链式调用来访问street属性：\n\n```Swift\nlet johnsAddress = Address()\njohnsAddress.buildingName = \"The Larches\"\njohnsAddress.street = \"Laurel Street\"\njohn.residence?.address = johnsAddress\n \nif let johnsStreet = john.residence?.address?.street {\n    print(\"John's street name is \\(johnsStreet).\")\n} else {\n    print(\"Unable to retrieve the address.\")\n}\n// Prints \"John's street name is Laurel Street.\"\n```\n\n### 在方法的可选返回值上进行可选链式调用\n上面的例子展示了如何在一个可选值上通过可选链式调用来获取它的属性值。我们还可以在一个可选值上通过可选链式调用来调用方法，并且可以根据需要继续在方法的可选返回值上进行可选链式调用。\n\n在下面的例子中，通过可选链式调用来调用Address的buildingIdentifier()方法。这个方法返回String?类型的值。如上所述，通过可选链式调用来调用该方法，最终的返回值依旧会是String?类型：\n\n```Swift\nif let buildingIdentifier = john.residence?.address?.buildingIdentifier() {\n    print(\"John's building identifier is \\(buildingIdentifier).\")\n}\n// Prints \"John's building identifier is The Larches.\"\n```\n\n如果要在该方法的返回值上进行可选链式调用，在方法的圆括号后面加上问号即可：\n\n```Swift\nif let beginsWithThe =\n    john.residence?.address?.buildingIdentifier()?.hasPrefix(\"The\") {\n    if beginsWithThe {\n        print(\"John's building identifier begins with \\\"The\\\".\")\n    } else {\n        print(\"John's building identifier does not begin with \\\"The\\\".\")\n    }\n}\n// Prints \"John's building identifier begins with \"The\".\"\n```\n\n\t在上面的例子中，在方法的圆括号后面加上问号是因为你要在buildingIdentifier()方法的可选返回值上进行可选链式调用，而不是方法本身。\n\n\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html/\"> OptionalChaining </a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","source":"_posts/iOS_Swift_language_note_Optional-Chaining.md","raw":"---\nlayout:     post\ntitle:      Swift Optional Chaining\ndate:       2016-11-30 01:20:11\nauthor:     liangtong\ncatalog: true\ncategories: iOS\ntags: Swift \n\n---\n\n\n\n​\t可选链式调用是一种可以在当前值可能为nil的可选值上请求和调用属性、方法及下标的方法。如果可选值有值，那么调用就会成功；如果可选值是nil，那么调用将返回nil。多个调用可以连接在一起形成一个调用链，如果其中任何一个节点为nil，整个调用链都会失败，即返回nil。\n\tSwift 的可选链式调用和 Objective-C 中向nil发送消息有些相像，但是 Swift 的可选链式调用可以应用于任意类型，并且能检查调用是否成功。\n\n\n\n### 使用可选链式调用代替强制展开\n通过在想调用的属性、方法、或下标的可选值后面放一个问号（?），可以定义一个可选链。这一点很像在可选值后面放一个叹号（!）来强制展开它的值。它们的主要区别在于当可选值为空时可选链式调用只会调用失败，然而强制展开将会触发运行时错误。\n\n为了反映可选链式调用可以在空值（nil）上调用的事实，不论这个调用的属性、方法及下标返回的值是不是可选值，它的返回结果都是一个可选值。你可以利用这个返回值来判断你的可选链式调用是否调用成功，如果调用有返回值则说明调用成功，返回nil则说明调用失败。\n\n特别地，可选链式调用的返回结果与原本的返回结果具有相同的类型，但是被包装成了一个可选值。例如，使用可选链式调用访问属性，当可选链式调用成功时，如果属性原本的返回结果是Int类型，则会变为Int?类型。\n\n\n<!-- more -->\n\n下面几段代码将解释可选链式调用和强制展开的不同。首先定义两个类Person和Residence：\n\n```Swift\nclass Person {\n    var residence: Residence?\n}\n \nclass Residence {\n    var numberOfRooms = 1\n}\n```\n\nResidence有一个Int类型的属性numberOfRooms，其默认值为1。Person具有一个可选的residence属性，其类型为Residence?。\n假如你创建了一个新的Person实例,它的residence属性由于是是可选型而将初始化为nil,在下面的代码中,john有一个值为nil的residence属性：\n\n```Swift\nlet john = Person()\n```\n\n如果使用叹号（!）强制展开获得这个john的residence属性中的numberOfRooms值，会触发运行时错误，因为这时residence没有可以展开的值：\n\n```Swift\nlet roomCount = john.residence!.numberOfRooms\n// this triggers a runtime error\n```\n\njohn.residence为非nil值的时候，上面的调用会成功，并且把roomCount设置为Int类型的房间数量。正如上面提到的，当residence为nil的时候上面这段代码会触发运行时错误。\n\n可选链式调用提供了另一种访问numberOfRooms的方式，使用问号（?）来替代原来的叹号（!）：\n\n```Swift\nif let roomCount = john.residence?.numberOfRooms {\n    print(\"John's residence has \\(roomCount) room(s).\")\n} else {\n    print(\"Unable to retrieve the number of rooms.\")\n}\n// Prints \"Unable to retrieve the number of rooms.\"\n```\n\n在residence后面添加问号之后，Swift 就会在residence不为nil的情况下访问numberOfRooms。\n因为访问numberOfRooms有可能失败，可选链式调用会返回Int?类型，或称为“可选的 Int”。如上例所示，当residence为nil的时候，可选的Int将会为nil，表明无法访问numberOfRooms。访问成功时，可选的Int值会通过可选绑定展开，并赋值给非可选类型的roomCount常量。\n要注意的是，即使numberOfRooms是非可选的Int时，这一点也成立。只要使用可选链式调用就意味着numberOfRooms会返回一个Int?而不是Int。\n可以将一个Residence的实例赋给john.residence，这样它就不再是nil了：\n\n```Swift\njohn.residence = Residence()\n```\n\njohn.residence现在包含一个实际的Residence实例，而不再是nil。如果你试图使用先前的可选链式调用访问numberOfRooms，它现在将返回值为1的Int?类型的值：\n\n```Swift\nif let roomCount = john.residence?.numberOfRooms {\n    print(\"John's residence has \\(roomCount) room(s).\")\n} else {\n    print(\"Unable to retrieve the number of rooms.\")\n}\n// Prints \"John's residence has 1 room(s).\"\n```\n\n### 为可选链式调用定义模型类\n通过使用可选链式调用可以调用多层属性、方法和下标。这样可以在复杂的模型中向下访问各种子属性，并且判断能否访问子属性的属性、方法或下标。\n下面这段代码定义了四个模型类，这些例子包括多层可选链式调用。为了方便说明，在Person和Residence的基础上增加了Room类和Address类，以及相关的属性、方法以及下标。\n\n```Swift\nclass Person {\n    var residence: Residence?\n}\n\nclass Residence {\n    var rooms = [Room]()\n    var numberOfRooms: Int {\n        return rooms.count\n    }\n    subscript(i: Int) -> Room {\n        get {\n            return rooms[i]\n        }\n        set {\n            rooms[i] = newValue\n        }\n    }\n    func printNumberOfRooms() {\n        print(\"The number of rooms is \\(numberOfRooms)\")\n    }\n    var address: Address?\n}\n```\n\n现在Residence有了一个存储Room实例的数组，numberOfRooms属性被实现为计算型属性，而不是存储型属性。numberOfRooms属性简单地返回rooms数组的count属性的值。\n\nResidence还提供了访问rooms数组的快捷方式，即提供可读写的下标来访问rooms数组中指定位置的元素。\n此外，Residence还提供了printNumberOfRooms方法，这个方法的作用是打印numberOfRooms的值。\n最后，Residence还定义了一个可选属性address，其类型为Address?。Address类的定义在下面会说明。\n\nRoom类是一个简单类，其实例被存储在rooms数组中。该类只包含一个属性name，以及一个用于将该属性设置为适当的房间名的初始化函数：\n\n```Swift\nclass Room {\n    let name: String\n    init(name: String) { self.name = name }\n}\n```\n\n最后一个类是Address，这个类有三个String?类型的可选属性。buildingName以及buildingNumber属性分别表示某个大厦的名称和号码，第三个属性street表示大厦所在街道的名称：\n\n```Swift\nclass Address {\n    var buildingName: String?\n    var buildingNumber: String?\n    var street: String?\n    func buildingIdentifier() -> String? {\n        if buildingNumber != nil && street != nil {\n            return \"\\(buildingNumber) \\(street)\"\n        } else if buildingName != nil {\n            return buildingName\n        } else {\n            return nil\n        }\n    }\n}\n```\n\nAddress类提供了buildingIdentifier()方法，返回值为String?。 如果buildingName有值则返回buildingName。或者，如果buildingNumber和street均有值则返回buildingNumber。否则，返回nil。\n\n### 通过可选链式调用访问属性\n可以通过可选链式调用在一个可选值上访问它的属性，并判断访问是否成功。\n下面的代码创建了一个Person实例，然后像之前一样，尝试访问numberOfRooms属性：\n\n```Swift\nlet john = Person()\nif let roomCount = john.residence?.numberOfRooms {\n    print(\"John's residence has \\(roomCount) room(s).\")\n} else {\n    print(\"Unable to retrieve the number of rooms.\")\n}\n// Prints \"Unable to retrieve the number of rooms.\"\n```\n\n因为john.residence为nil，所以这个可选链式调用依旧会像先前一样失败。\n还可以通过可选链式调用来设置属性值：\n\n```Swift\nlet someAddress = Address()\nsomeAddress.buildingNumber = \"29\"\nsomeAddress.street = \"Acacia Road\"\njohn.residence?.address = someAddress\n```\n\n在这个例子中，通过john.residence来设定address属性也会失败，因为john.residence当前为nil。\n\n上面代码中的赋值过程是可选链式调用的一部分，这意味着可选链式调用失败时，等号右侧的代码不会被执行。对于上面的代码来说，很难验证这一点，因为像这样赋值一个常量没有任何副作用。下面的代码完成了同样的事情，但是它使用一个函数来创建Address实例，然后将该实例返回用于赋值。该函数会在返回前打印“Function was called”，这使你能验证等号右侧的代码是否被执行。\n\n```Swift\nfunc createAddress() -> Address {\n    print(\"Function was called.\")\n    \n    let someAddress = Address()\n    someAddress.buildingNumber = \"29\"\n    someAddress.street = \"Acacia Road\"\n    \n    return someAddress\n}\njohn.residence?.address = createAddress()\n```\n\n没有任何打印消息，可以看出createAddress()函数并未被执行。\n\n### 通过可选链式调用调用方法\n可以通过可选链式调用来调用方法，并判断是否调用成功，即使这个方法没有返回值。\nResidence类中的printNumberOfRooms()方法打印当前的numberOfRooms值，如下所示：\n\n```Swift\nfunc printNumberOfRooms() {\n    print(\"The number of rooms is \\(numberOfRooms)\")\n}\n```\n\n这个方法没有返回值。然而，没有返回值的方法具有隐式的返回类型Void。这意味着没有返回值的方法也会返回()，或者说空的元组。\n\n如果在可选值上通过可选链式调用来调用这个方法，该方法的返回类型会是Void?，而不是Void，因为通过可选链式调用得到的返回值都是可选的。这样我们就可以使用if语句来判断能否成功调用printNumberOfRooms()方法，即使方法本身没有定义返回值。通过判断返回值是否为nil可以判断调用是否成功：\n\n```Swift\nif john.residence?.printNumberOfRooms() != nil {\n    print(\"It was possible to print the number of rooms.\")\n} else {\n    print(\"It was not possible to print the number of rooms.\")\n}\n// Prints \"It was not possible to print the number of rooms.\"\n```\n\n同样的，可以据此判断通过可选链式调用为属性赋值是否成功。在上面的通过可选链式调用访问属性的例子中，我们尝试给john.residence中的address属性赋值，即使residence为nil。通过可选链式调用给属性赋值会返回Void?，通过判断返回值是否为nil就可以知道赋值是否成功：\n\n```Swift\nif (john.residence?.address = someAddress) != nil {\n    print(\"It was possible to set the address.\")\n} else {\n    print(\"It was not possible to set the address.\")\n}\n// Prints \"It was not possible to set the address.\"\n```\n\n### 通过可选链式调用访问下标\n通过可选链式调用，我们可以在一个可选值上访问下标，并且判断下标调用是否成功。\n\t通过可选链式调用访问可选值的下标时，应该将问号放在下标方括号的前面而不是后面。可选链式调用的问号一般直接跟在可选表达式的后面。\n\n下面这个例子用下标访问john.residence属性存储的Residence实例的rooms数组中的第一个房间的名称，因为john.residence为nil，所以下标调用失败了：\n\n```Swift\nif let firstRoomName = john.residence?[0].name {\n    print(\"The first room name is \\(firstRoomName).\")\n} else {\n    print(\"Unable to retrieve the first room name.\")\n}\n// Prints \"Unable to retrieve the first room name.\"\n```\n\n在这个例子中，问号直接放在john.residence的后面，并且在方括号的前面，因为john.residence是可选值。\n类似的，可以通过下标，用可选链式调用来赋值：\n\n```Swift\njohn.residence?[0] = Room(name: \"Bathroom\")\n```\n\n这次赋值同样会失败，因为residence目前是nil。\n如果你创建一个Residence实例，并为其rooms数组添加一些Room实例，然后将Residence实例赋值给john.residence，那就可以通过可选链和下标来访问数组中的元素：\n\n```Swift\nlet johnsHouse = Residence()\njohnsHouse.rooms.append(Room(name: \"Living Room\"))\njohnsHouse.rooms.append(Room(name: \"Kitchen\"))\njohn.residence = johnsHouse\n \nif let firstRoomName = john.residence?[0].name {\n    print(\"The first room name is \\(firstRoomName).\")\n} else {\n    print(\"Unable to retrieve the first room name.\")\n}\n// Prints \"The first room name is Living Room.\"\n```\n\n#### 访问可选类型的下标 \n如果下标返回可选类型值，比如 Swift 中Dictionary类型的键的下标，可以在下标的结尾括号后面放一个问号来在其可选返回值上进行可选链式调用：\n\n```Swift\nvar testScores = [\"Dave\": [86, 82, 84], \"Bev\": [79, 94, 81]]\ntestScores[\"Dave\"]?[0] = 91\ntestScores[\"Bev\"]?[0] += 1\ntestScores[\"Brian\"]?[0] = 72\n// the \"Dave\" array is now [91, 82, 84] and the \"Bev\" array is now [80, 94, 81]\n```\n\n上面的例子中定义了一个testScores数组，包含了两个键值对，把String类型的键映射到一个Int值的数组。这个例子用可选链式调用把\"Dave\"数组中第一个元素设为91，把\"Bev\"数组的第一个元素+1，然后尝试把\"Brian\"数组中的第一个元素设为72。前两个调用成功，因为testScores字典中包含\"Dave\"和\"Bev\"这两个键。但是testScores字典中没有\"Brian\"这个键，所以第三个调用失败。\n\n### 连接多层可选链式调用\n可以通过连接多个可选链式调用在更深的模型层级中访问属性、方法以及下标。然而，多层可选链式调用不会增加返回值的可选层级。\n\n * 如果你访问的值不是可选的，可选链式调用将会返回可选值。\n * 如果你访问的值就是可选的，可选链式调用不会让可选返回值变得“更可选”。\n\n因此：\n\n * 通过可选链式调用访问一个Int值，将会返回Int?，无论使用了多少层可选链式调用。\n * 类似的，通过可选链式调用访问Int?值，依旧会返回Int?值，并不会返回Int??。\n\n下面的例子尝试访问john中的residence属性中的address属性中的street属性。这里使用了两层可选链式调用，residence以及address都是可选值：\n\n```Swift\nif let johnsStreet = john.residence?.address?.street {\n    print(\"John's street name is \\(johnsStreet).\")\n} else {\n    print(\"Unable to retrieve the address.\")\n}\n// Prints \"Unable to retrieve the address.\"\n```\n\njohn.residence现在包含一个有效的Residence实例。然而，john.residence.address的值当前为nil。因此，调用john.residence?.address?.street会失败。\n需要注意的是，上面的例子中，street的属性为String?。john.residence?.address?.street的返回值也依然是String?，即使已经使用了两层可选链式调用。\n\n如果为john.residence.address赋值一个Address实例，并且为address中的street属性设置一个有效值，我们就能过通过可选链式调用来访问street属性：\n\n```Swift\nlet johnsAddress = Address()\njohnsAddress.buildingName = \"The Larches\"\njohnsAddress.street = \"Laurel Street\"\njohn.residence?.address = johnsAddress\n \nif let johnsStreet = john.residence?.address?.street {\n    print(\"John's street name is \\(johnsStreet).\")\n} else {\n    print(\"Unable to retrieve the address.\")\n}\n// Prints \"John's street name is Laurel Street.\"\n```\n\n### 在方法的可选返回值上进行可选链式调用\n上面的例子展示了如何在一个可选值上通过可选链式调用来获取它的属性值。我们还可以在一个可选值上通过可选链式调用来调用方法，并且可以根据需要继续在方法的可选返回值上进行可选链式调用。\n\n在下面的例子中，通过可选链式调用来调用Address的buildingIdentifier()方法。这个方法返回String?类型的值。如上所述，通过可选链式调用来调用该方法，最终的返回值依旧会是String?类型：\n\n```Swift\nif let buildingIdentifier = john.residence?.address?.buildingIdentifier() {\n    print(\"John's building identifier is \\(buildingIdentifier).\")\n}\n// Prints \"John's building identifier is The Larches.\"\n```\n\n如果要在该方法的返回值上进行可选链式调用，在方法的圆括号后面加上问号即可：\n\n```Swift\nif let beginsWithThe =\n    john.residence?.address?.buildingIdentifier()?.hasPrefix(\"The\") {\n    if beginsWithThe {\n        print(\"John's building identifier begins with \\\"The\\\".\")\n    } else {\n        print(\"John's building identifier does not begin with \\\"The\\\".\")\n    }\n}\n// Prints \"John's building identifier begins with \"The\".\"\n```\n\n\t在上面的例子中，在方法的圆括号后面加上问号是因为你要在buildingIdentifier()方法的可选返回值上进行可选链式调用，而不是方法本身。\n\n\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html/\"> OptionalChaining </a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","slug":"iOS_Swift_language_note_Optional-Chaining","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4ul003koko861c4cbpa","content":"<p>​    可选链式调用是一种可以在当前值可能为nil的可选值上请求和调用属性、方法及下标的方法。如果可选值有值，那么调用就会成功；如果可选值是nil，那么调用将返回nil。多个调用可以连接在一起形成一个调用链，如果其中任何一个节点为nil，整个调用链都会失败，即返回nil。<br>    Swift 的可选链式调用和 Objective-C 中向nil发送消息有些相像，但是 Swift 的可选链式调用可以应用于任意类型，并且能检查调用是否成功。</p>\n<h3 id=\"使用可选链式调用代替强制展开\"><a href=\"#使用可选链式调用代替强制展开\" class=\"headerlink\" title=\"使用可选链式调用代替强制展开\"></a>使用可选链式调用代替强制展开</h3><p>通过在想调用的属性、方法、或下标的可选值后面放一个问号（?），可以定义一个可选链。这一点很像在可选值后面放一个叹号（!）来强制展开它的值。它们的主要区别在于当可选值为空时可选链式调用只会调用失败，然而强制展开将会触发运行时错误。</p>\n<p>为了反映可选链式调用可以在空值（nil）上调用的事实，不论这个调用的属性、方法及下标返回的值是不是可选值，它的返回结果都是一个可选值。你可以利用这个返回值来判断你的可选链式调用是否调用成功，如果调用有返回值则说明调用成功，返回nil则说明调用失败。</p>\n<p>特别地，可选链式调用的返回结果与原本的返回结果具有相同的类型，但是被包装成了一个可选值。例如，使用可选链式调用访问属性，当可选链式调用成功时，如果属性原本的返回结果是Int类型，则会变为Int?类型。</p>\n<a id=\"more\"></a>\n<p>下面几段代码将解释可选链式调用和强制展开的不同。首先定义两个类Person和Residence：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> residence: <span class=\"type\">Residence</span>?</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Residence</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> numberOfRooms = <span class=\"number\">1</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Residence有一个Int类型的属性numberOfRooms，其默认值为1。Person具有一个可选的residence属性，其类型为Residence?。<br>假如你创建了一个新的Person实例,它的residence属性由于是是可选型而将初始化为nil,在下面的代码中,john有一个值为nil的residence属性：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> john = <span class=\"type\">Person</span>()</div></pre></td></tr></table></figure>\n<p>如果使用叹号（!）强制展开获得这个john的residence属性中的numberOfRooms值，会触发运行时错误，因为这时residence没有可以展开的值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> roomCount = john.residence!.numberOfRooms</div><div class=\"line\"><span class=\"comment\">// this triggers a runtime error</span></div></pre></td></tr></table></figure>\n<p>john.residence为非nil值的时候，上面的调用会成功，并且把roomCount设置为Int类型的房间数量。正如上面提到的，当residence为nil的时候上面这段代码会触发运行时错误。</p>\n<p>可选链式调用提供了另一种访问numberOfRooms的方式，使用问号（?）来替代原来的叹号（!）：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> roomCount = john.residence?.numberOfRooms &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"John's residence has <span class=\"subst\">\\(roomCount)</span> room(s).\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Unable to retrieve the number of rooms.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"Unable to retrieve the number of rooms.\"</span></div></pre></td></tr></table></figure>\n<p>在residence后面添加问号之后，Swift 就会在residence不为nil的情况下访问numberOfRooms。<br>因为访问numberOfRooms有可能失败，可选链式调用会返回Int?类型，或称为“可选的 Int”。如上例所示，当residence为nil的时候，可选的Int将会为nil，表明无法访问numberOfRooms。访问成功时，可选的Int值会通过可选绑定展开，并赋值给非可选类型的roomCount常量。<br>要注意的是，即使numberOfRooms是非可选的Int时，这一点也成立。只要使用可选链式调用就意味着numberOfRooms会返回一个Int?而不是Int。<br>可以将一个Residence的实例赋给john.residence，这样它就不再是nil了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">john.residence = <span class=\"type\">Residence</span>()</div></pre></td></tr></table></figure>\n<p>john.residence现在包含一个实际的Residence实例，而不再是nil。如果你试图使用先前的可选链式调用访问numberOfRooms，它现在将返回值为1的Int?类型的值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> roomCount = john.residence?.numberOfRooms &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"John's residence has <span class=\"subst\">\\(roomCount)</span> room(s).\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Unable to retrieve the number of rooms.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"John's residence has 1 room(s).\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"为可选链式调用定义模型类\"><a href=\"#为可选链式调用定义模型类\" class=\"headerlink\" title=\"为可选链式调用定义模型类\"></a>为可选链式调用定义模型类</h3><p>通过使用可选链式调用可以调用多层属性、方法和下标。这样可以在复杂的模型中向下访问各种子属性，并且判断能否访问子属性的属性、方法或下标。<br>下面这段代码定义了四个模型类，这些例子包括多层可选链式调用。为了方便说明，在Person和Residence的基础上增加了Room类和Address类，以及相关的属性、方法以及下标。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> residence: <span class=\"type\">Residence</span>?</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Residence</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> rooms = [<span class=\"type\">Room</span>]()</div><div class=\"line\">    <span class=\"keyword\">var</span> numberOfRooms: <span class=\"type\">Int</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> rooms.<span class=\"built_in\">count</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">subscript</span>(i: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Room</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">get</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> rooms[i]</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">set</span> &#123;</div><div class=\"line\">            rooms[i] = newValue</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printNumberOfRooms</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"The number of rooms is <span class=\"subst\">\\(numberOfRooms)</span>\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> address: <span class=\"type\">Address</span>?</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在Residence有了一个存储Room实例的数组，numberOfRooms属性被实现为计算型属性，而不是存储型属性。numberOfRooms属性简单地返回rooms数组的count属性的值。</p>\n<p>Residence还提供了访问rooms数组的快捷方式，即提供可读写的下标来访问rooms数组中指定位置的元素。<br>此外，Residence还提供了printNumberOfRooms方法，这个方法的作用是打印numberOfRooms的值。<br>最后，Residence还定义了一个可选属性address，其类型为Address?。Address类的定义在下面会说明。</p>\n<p>Room类是一个简单类，其实例被存储在rooms数组中。该类只包含一个属性name，以及一个用于将该属性设置为适当的房间名的初始化函数：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Room</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> name: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>) &#123; <span class=\"keyword\">self</span>.name = name &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后一个类是Address，这个类有三个String?类型的可选属性。buildingName以及buildingNumber属性分别表示某个大厦的名称和号码，第三个属性street表示大厦所在街道的名称：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Address</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> buildingName: <span class=\"type\">String</span>?</div><div class=\"line\">    <span class=\"keyword\">var</span> buildingNumber: <span class=\"type\">String</span>?</div><div class=\"line\">    <span class=\"keyword\">var</span> street: <span class=\"type\">String</span>?</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildingIdentifier</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">String</span>? &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> buildingNumber != <span class=\"literal\">nil</span> &amp;&amp; street != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"<span class=\"subst\">\\(buildingNumber)</span> <span class=\"subst\">\\(street)</span>\"</span></div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> buildingName != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> buildingName</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Address类提供了buildingIdentifier()方法，返回值为String?。 如果buildingName有值则返回buildingName。或者，如果buildingNumber和street均有值则返回buildingNumber。否则，返回nil。</p>\n<h3 id=\"通过可选链式调用访问属性\"><a href=\"#通过可选链式调用访问属性\" class=\"headerlink\" title=\"通过可选链式调用访问属性\"></a>通过可选链式调用访问属性</h3><p>可以通过可选链式调用在一个可选值上访问它的属性，并判断访问是否成功。<br>下面的代码创建了一个Person实例，然后像之前一样，尝试访问numberOfRooms属性：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> john = <span class=\"type\">Person</span>()</div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> roomCount = john.residence?.numberOfRooms &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"John's residence has <span class=\"subst\">\\(roomCount)</span> room(s).\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Unable to retrieve the number of rooms.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"Unable to retrieve the number of rooms.\"</span></div></pre></td></tr></table></figure>\n<p>因为john.residence为nil，所以这个可选链式调用依旧会像先前一样失败。<br>还可以通过可选链式调用来设置属性值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> someAddress = <span class=\"type\">Address</span>()</div><div class=\"line\">someAddress.buildingNumber = <span class=\"string\">\"29\"</span></div><div class=\"line\">someAddress.street = <span class=\"string\">\"Acacia Road\"</span></div><div class=\"line\">john.residence?.address = someAddress</div></pre></td></tr></table></figure>\n<p>在这个例子中，通过john.residence来设定address属性也会失败，因为john.residence当前为nil。</p>\n<p>上面代码中的赋值过程是可选链式调用的一部分，这意味着可选链式调用失败时，等号右侧的代码不会被执行。对于上面的代码来说，很难验证这一点，因为像这样赋值一个常量没有任何副作用。下面的代码完成了同样的事情，但是它使用一个函数来创建Address实例，然后将该实例返回用于赋值。该函数会在返回前打印“Function was called”，这使你能验证等号右侧的代码是否被执行。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">createAddress</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Address</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Function was called.\"</span>)</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">let</span> someAddress = <span class=\"type\">Address</span>()</div><div class=\"line\">    someAddress.buildingNumber = <span class=\"string\">\"29\"</span></div><div class=\"line\">    someAddress.street = <span class=\"string\">\"Acacia Road\"</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> someAddress</div><div class=\"line\">&#125;</div><div class=\"line\">john.residence?.address = createAddress()</div></pre></td></tr></table></figure>\n<p>没有任何打印消息，可以看出createAddress()函数并未被执行。</p>\n<h3 id=\"通过可选链式调用调用方法\"><a href=\"#通过可选链式调用调用方法\" class=\"headerlink\" title=\"通过可选链式调用调用方法\"></a>通过可选链式调用调用方法</h3><p>可以通过可选链式调用来调用方法，并判断是否调用成功，即使这个方法没有返回值。<br>Residence类中的printNumberOfRooms()方法打印当前的numberOfRooms值，如下所示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printNumberOfRooms</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The number of rooms is <span class=\"subst\">\\(numberOfRooms)</span>\"</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法没有返回值。然而，没有返回值的方法具有隐式的返回类型Void。这意味着没有返回值的方法也会返回()，或者说空的元组。</p>\n<p>如果在可选值上通过可选链式调用来调用这个方法，该方法的返回类型会是Void?，而不是Void，因为通过可选链式调用得到的返回值都是可选的。这样我们就可以使用if语句来判断能否成功调用printNumberOfRooms()方法，即使方法本身没有定义返回值。通过判断返回值是否为nil可以判断调用是否成功：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> john.residence?.printNumberOfRooms() != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"It was possible to print the number of rooms.\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"It was not possible to print the number of rooms.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"It was not possible to print the number of rooms.\"</span></div></pre></td></tr></table></figure>\n<p>同样的，可以据此判断通过可选链式调用为属性赋值是否成功。在上面的通过可选链式调用访问属性的例子中，我们尝试给john.residence中的address属性赋值，即使residence为nil。通过可选链式调用给属性赋值会返回Void?，通过判断返回值是否为nil就可以知道赋值是否成功：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (john.residence?.address = someAddress) != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"It was possible to set the address.\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"It was not possible to set the address.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"It was not possible to set the address.\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"通过可选链式调用访问下标\"><a href=\"#通过可选链式调用访问下标\" class=\"headerlink\" title=\"通过可选链式调用访问下标\"></a>通过可选链式调用访问下标</h3><p>通过可选链式调用，我们可以在一个可选值上访问下标，并且判断下标调用是否成功。<br>    通过可选链式调用访问可选值的下标时，应该将问号放在下标方括号的前面而不是后面。可选链式调用的问号一般直接跟在可选表达式的后面。</p>\n<p>下面这个例子用下标访问john.residence属性存储的Residence实例的rooms数组中的第一个房间的名称，因为john.residence为nil，所以下标调用失败了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> firstRoomName = john.residence?[<span class=\"number\">0</span>].name &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The first room name is <span class=\"subst\">\\(firstRoomName)</span>.\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Unable to retrieve the first room name.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"Unable to retrieve the first room name.\"</span></div></pre></td></tr></table></figure>\n<p>在这个例子中，问号直接放在john.residence的后面，并且在方括号的前面，因为john.residence是可选值。<br>类似的，可以通过下标，用可选链式调用来赋值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">john.residence?[<span class=\"number\">0</span>] = <span class=\"type\">Room</span>(name: <span class=\"string\">\"Bathroom\"</span>)</div></pre></td></tr></table></figure>\n<p>这次赋值同样会失败，因为residence目前是nil。<br>如果你创建一个Residence实例，并为其rooms数组添加一些Room实例，然后将Residence实例赋值给john.residence，那就可以通过可选链和下标来访问数组中的元素：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> johnsHouse = <span class=\"type\">Residence</span>()</div><div class=\"line\">johnsHouse.rooms.append(<span class=\"type\">Room</span>(name: <span class=\"string\">\"Living Room\"</span>))</div><div class=\"line\">johnsHouse.rooms.append(<span class=\"type\">Room</span>(name: <span class=\"string\">\"Kitchen\"</span>))</div><div class=\"line\">john.residence = johnsHouse</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> firstRoomName = john.residence?[<span class=\"number\">0</span>].name &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The first room name is <span class=\"subst\">\\(firstRoomName)</span>.\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Unable to retrieve the first room name.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"The first room name is Living Room.\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"访问可选类型的下标\"><a href=\"#访问可选类型的下标\" class=\"headerlink\" title=\"访问可选类型的下标\"></a>访问可选类型的下标</h4><p>如果下标返回可选类型值，比如 Swift 中Dictionary类型的键的下标，可以在下标的结尾括号后面放一个问号来在其可选返回值上进行可选链式调用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> testScores = [<span class=\"string\">\"Dave\"</span>: [<span class=\"number\">86</span>, <span class=\"number\">82</span>, <span class=\"number\">84</span>], <span class=\"string\">\"Bev\"</span>: [<span class=\"number\">79</span>, <span class=\"number\">94</span>, <span class=\"number\">81</span>]]</div><div class=\"line\">testScores[<span class=\"string\">\"Dave\"</span>]?[<span class=\"number\">0</span>] = <span class=\"number\">91</span></div><div class=\"line\">testScores[<span class=\"string\">\"Bev\"</span>]?[<span class=\"number\">0</span>] += <span class=\"number\">1</span></div><div class=\"line\">testScores[<span class=\"string\">\"Brian\"</span>]?[<span class=\"number\">0</span>] = <span class=\"number\">72</span></div><div class=\"line\"><span class=\"comment\">// the \"Dave\" array is now [91, 82, 84] and the \"Bev\" array is now [80, 94, 81]</span></div></pre></td></tr></table></figure>\n<p>上面的例子中定义了一个testScores数组，包含了两个键值对，把String类型的键映射到一个Int值的数组。这个例子用可选链式调用把”Dave”数组中第一个元素设为91，把”Bev”数组的第一个元素+1，然后尝试把”Brian”数组中的第一个元素设为72。前两个调用成功，因为testScores字典中包含”Dave”和”Bev”这两个键。但是testScores字典中没有”Brian”这个键，所以第三个调用失败。</p>\n<h3 id=\"连接多层可选链式调用\"><a href=\"#连接多层可选链式调用\" class=\"headerlink\" title=\"连接多层可选链式调用\"></a>连接多层可选链式调用</h3><p>可以通过连接多个可选链式调用在更深的模型层级中访问属性、方法以及下标。然而，多层可选链式调用不会增加返回值的可选层级。</p>\n<ul>\n<li>如果你访问的值不是可选的，可选链式调用将会返回可选值。</li>\n<li>如果你访问的值就是可选的，可选链式调用不会让可选返回值变得“更可选”。</li>\n</ul>\n<p>因此：</p>\n<ul>\n<li>通过可选链式调用访问一个Int值，将会返回Int?，无论使用了多少层可选链式调用。</li>\n<li>类似的，通过可选链式调用访问Int?值，依旧会返回Int?值，并不会返回Int??。</li>\n</ul>\n<p>下面的例子尝试访问john中的residence属性中的address属性中的street属性。这里使用了两层可选链式调用，residence以及address都是可选值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> johnsStreet = john.residence?.address?.street &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"John's street name is <span class=\"subst\">\\(johnsStreet)</span>.\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Unable to retrieve the address.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"Unable to retrieve the address.\"</span></div></pre></td></tr></table></figure>\n<p>john.residence现在包含一个有效的Residence实例。然而，john.residence.address的值当前为nil。因此，调用john.residence?.address?.street会失败。<br>需要注意的是，上面的例子中，street的属性为String?。john.residence?.address?.street的返回值也依然是String?，即使已经使用了两层可选链式调用。</p>\n<p>如果为john.residence.address赋值一个Address实例，并且为address中的street属性设置一个有效值，我们就能过通过可选链式调用来访问street属性：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> johnsAddress = <span class=\"type\">Address</span>()</div><div class=\"line\">johnsAddress.buildingName = <span class=\"string\">\"The Larches\"</span></div><div class=\"line\">johnsAddress.street = <span class=\"string\">\"Laurel Street\"</span></div><div class=\"line\">john.residence?.address = johnsAddress</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> johnsStreet = john.residence?.address?.street &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"John's street name is <span class=\"subst\">\\(johnsStreet)</span>.\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Unable to retrieve the address.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"John's street name is Laurel Street.\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"在方法的可选返回值上进行可选链式调用\"><a href=\"#在方法的可选返回值上进行可选链式调用\" class=\"headerlink\" title=\"在方法的可选返回值上进行可选链式调用\"></a>在方法的可选返回值上进行可选链式调用</h3><p>上面的例子展示了如何在一个可选值上通过可选链式调用来获取它的属性值。我们还可以在一个可选值上通过可选链式调用来调用方法，并且可以根据需要继续在方法的可选返回值上进行可选链式调用。</p>\n<p>在下面的例子中，通过可选链式调用来调用Address的buildingIdentifier()方法。这个方法返回String?类型的值。如上所述，通过可选链式调用来调用该方法，最终的返回值依旧会是String?类型：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> buildingIdentifier = john.residence?.address?.buildingIdentifier() &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"John's building identifier is <span class=\"subst\">\\(buildingIdentifier)</span>.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"John's building identifier is The Larches.\"</span></div></pre></td></tr></table></figure>\n<p>如果要在该方法的返回值上进行可选链式调用，在方法的圆括号后面加上问号即可：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> beginsWithThe =</div><div class=\"line\">    john.residence?.address?.buildingIdentifier()?.hasPrefix(<span class=\"string\">\"The\"</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> beginsWithThe &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"John's building identifier begins with \\\"The\\\".\"</span>)</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"John's building identifier does not begin with \\\"The\\\".\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"John's building identifier begins with \"The\".\"</span></div></pre></td></tr></table></figure>\n<pre><code>在上面的例子中，在方法的圆括号后面加上问号是因为你要在buildingIdentifier()方法的可选返回值上进行可选链式调用，而不是方法本身。\n</code></pre><h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html/\" target=\"_blank\" rel=\"external\"> OptionalChaining </a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>​    可选链式调用是一种可以在当前值可能为nil的可选值上请求和调用属性、方法及下标的方法。如果可选值有值，那么调用就会成功；如果可选值是nil，那么调用将返回nil。多个调用可以连接在一起形成一个调用链，如果其中任何一个节点为nil，整个调用链都会失败，即返回nil。<br>    Swift 的可选链式调用和 Objective-C 中向nil发送消息有些相像，但是 Swift 的可选链式调用可以应用于任意类型，并且能检查调用是否成功。</p>\n<h3 id=\"使用可选链式调用代替强制展开\"><a href=\"#使用可选链式调用代替强制展开\" class=\"headerlink\" title=\"使用可选链式调用代替强制展开\"></a>使用可选链式调用代替强制展开</h3><p>通过在想调用的属性、方法、或下标的可选值后面放一个问号（?），可以定义一个可选链。这一点很像在可选值后面放一个叹号（!）来强制展开它的值。它们的主要区别在于当可选值为空时可选链式调用只会调用失败，然而强制展开将会触发运行时错误。</p>\n<p>为了反映可选链式调用可以在空值（nil）上调用的事实，不论这个调用的属性、方法及下标返回的值是不是可选值，它的返回结果都是一个可选值。你可以利用这个返回值来判断你的可选链式调用是否调用成功，如果调用有返回值则说明调用成功，返回nil则说明调用失败。</p>\n<p>特别地，可选链式调用的返回结果与原本的返回结果具有相同的类型，但是被包装成了一个可选值。例如，使用可选链式调用访问属性，当可选链式调用成功时，如果属性原本的返回结果是Int类型，则会变为Int?类型。</p>","more":"<p>下面几段代码将解释可选链式调用和强制展开的不同。首先定义两个类Person和Residence：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> residence: <span class=\"type\">Residence</span>?</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Residence</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> numberOfRooms = <span class=\"number\">1</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Residence有一个Int类型的属性numberOfRooms，其默认值为1。Person具有一个可选的residence属性，其类型为Residence?。<br>假如你创建了一个新的Person实例,它的residence属性由于是是可选型而将初始化为nil,在下面的代码中,john有一个值为nil的residence属性：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> john = <span class=\"type\">Person</span>()</div></pre></td></tr></table></figure>\n<p>如果使用叹号（!）强制展开获得这个john的residence属性中的numberOfRooms值，会触发运行时错误，因为这时residence没有可以展开的值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> roomCount = john.residence!.numberOfRooms</div><div class=\"line\"><span class=\"comment\">// this triggers a runtime error</span></div></pre></td></tr></table></figure>\n<p>john.residence为非nil值的时候，上面的调用会成功，并且把roomCount设置为Int类型的房间数量。正如上面提到的，当residence为nil的时候上面这段代码会触发运行时错误。</p>\n<p>可选链式调用提供了另一种访问numberOfRooms的方式，使用问号（?）来替代原来的叹号（!）：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> roomCount = john.residence?.numberOfRooms &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"John's residence has <span class=\"subst\">\\(roomCount)</span> room(s).\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Unable to retrieve the number of rooms.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"Unable to retrieve the number of rooms.\"</span></div></pre></td></tr></table></figure>\n<p>在residence后面添加问号之后，Swift 就会在residence不为nil的情况下访问numberOfRooms。<br>因为访问numberOfRooms有可能失败，可选链式调用会返回Int?类型，或称为“可选的 Int”。如上例所示，当residence为nil的时候，可选的Int将会为nil，表明无法访问numberOfRooms。访问成功时，可选的Int值会通过可选绑定展开，并赋值给非可选类型的roomCount常量。<br>要注意的是，即使numberOfRooms是非可选的Int时，这一点也成立。只要使用可选链式调用就意味着numberOfRooms会返回一个Int?而不是Int。<br>可以将一个Residence的实例赋给john.residence，这样它就不再是nil了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">john.residence = <span class=\"type\">Residence</span>()</div></pre></td></tr></table></figure>\n<p>john.residence现在包含一个实际的Residence实例，而不再是nil。如果你试图使用先前的可选链式调用访问numberOfRooms，它现在将返回值为1的Int?类型的值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> roomCount = john.residence?.numberOfRooms &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"John's residence has <span class=\"subst\">\\(roomCount)</span> room(s).\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Unable to retrieve the number of rooms.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"John's residence has 1 room(s).\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"为可选链式调用定义模型类\"><a href=\"#为可选链式调用定义模型类\" class=\"headerlink\" title=\"为可选链式调用定义模型类\"></a>为可选链式调用定义模型类</h3><p>通过使用可选链式调用可以调用多层属性、方法和下标。这样可以在复杂的模型中向下访问各种子属性，并且判断能否访问子属性的属性、方法或下标。<br>下面这段代码定义了四个模型类，这些例子包括多层可选链式调用。为了方便说明，在Person和Residence的基础上增加了Room类和Address类，以及相关的属性、方法以及下标。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> residence: <span class=\"type\">Residence</span>?</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Residence</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> rooms = [<span class=\"type\">Room</span>]()</div><div class=\"line\">    <span class=\"keyword\">var</span> numberOfRooms: <span class=\"type\">Int</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> rooms.<span class=\"built_in\">count</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">subscript</span>(i: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Room</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">get</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> rooms[i]</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">set</span> &#123;</div><div class=\"line\">            rooms[i] = newValue</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printNumberOfRooms</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"The number of rooms is <span class=\"subst\">\\(numberOfRooms)</span>\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> address: <span class=\"type\">Address</span>?</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在Residence有了一个存储Room实例的数组，numberOfRooms属性被实现为计算型属性，而不是存储型属性。numberOfRooms属性简单地返回rooms数组的count属性的值。</p>\n<p>Residence还提供了访问rooms数组的快捷方式，即提供可读写的下标来访问rooms数组中指定位置的元素。<br>此外，Residence还提供了printNumberOfRooms方法，这个方法的作用是打印numberOfRooms的值。<br>最后，Residence还定义了一个可选属性address，其类型为Address?。Address类的定义在下面会说明。</p>\n<p>Room类是一个简单类，其实例被存储在rooms数组中。该类只包含一个属性name，以及一个用于将该属性设置为适当的房间名的初始化函数：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Room</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> name: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>) &#123; <span class=\"keyword\">self</span>.name = name &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后一个类是Address，这个类有三个String?类型的可选属性。buildingName以及buildingNumber属性分别表示某个大厦的名称和号码，第三个属性street表示大厦所在街道的名称：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Address</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> buildingName: <span class=\"type\">String</span>?</div><div class=\"line\">    <span class=\"keyword\">var</span> buildingNumber: <span class=\"type\">String</span>?</div><div class=\"line\">    <span class=\"keyword\">var</span> street: <span class=\"type\">String</span>?</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildingIdentifier</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">String</span>? &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> buildingNumber != <span class=\"literal\">nil</span> &amp;&amp; street != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"<span class=\"subst\">\\(buildingNumber)</span> <span class=\"subst\">\\(street)</span>\"</span></div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> buildingName != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> buildingName</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Address类提供了buildingIdentifier()方法，返回值为String?。 如果buildingName有值则返回buildingName。或者，如果buildingNumber和street均有值则返回buildingNumber。否则，返回nil。</p>\n<h3 id=\"通过可选链式调用访问属性\"><a href=\"#通过可选链式调用访问属性\" class=\"headerlink\" title=\"通过可选链式调用访问属性\"></a>通过可选链式调用访问属性</h3><p>可以通过可选链式调用在一个可选值上访问它的属性，并判断访问是否成功。<br>下面的代码创建了一个Person实例，然后像之前一样，尝试访问numberOfRooms属性：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> john = <span class=\"type\">Person</span>()</div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> roomCount = john.residence?.numberOfRooms &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"John's residence has <span class=\"subst\">\\(roomCount)</span> room(s).\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Unable to retrieve the number of rooms.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"Unable to retrieve the number of rooms.\"</span></div></pre></td></tr></table></figure>\n<p>因为john.residence为nil，所以这个可选链式调用依旧会像先前一样失败。<br>还可以通过可选链式调用来设置属性值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> someAddress = <span class=\"type\">Address</span>()</div><div class=\"line\">someAddress.buildingNumber = <span class=\"string\">\"29\"</span></div><div class=\"line\">someAddress.street = <span class=\"string\">\"Acacia Road\"</span></div><div class=\"line\">john.residence?.address = someAddress</div></pre></td></tr></table></figure>\n<p>在这个例子中，通过john.residence来设定address属性也会失败，因为john.residence当前为nil。</p>\n<p>上面代码中的赋值过程是可选链式调用的一部分，这意味着可选链式调用失败时，等号右侧的代码不会被执行。对于上面的代码来说，很难验证这一点，因为像这样赋值一个常量没有任何副作用。下面的代码完成了同样的事情，但是它使用一个函数来创建Address实例，然后将该实例返回用于赋值。该函数会在返回前打印“Function was called”，这使你能验证等号右侧的代码是否被执行。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">createAddress</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Address</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Function was called.\"</span>)</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">let</span> someAddress = <span class=\"type\">Address</span>()</div><div class=\"line\">    someAddress.buildingNumber = <span class=\"string\">\"29\"</span></div><div class=\"line\">    someAddress.street = <span class=\"string\">\"Acacia Road\"</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> someAddress</div><div class=\"line\">&#125;</div><div class=\"line\">john.residence?.address = createAddress()</div></pre></td></tr></table></figure>\n<p>没有任何打印消息，可以看出createAddress()函数并未被执行。</p>\n<h3 id=\"通过可选链式调用调用方法\"><a href=\"#通过可选链式调用调用方法\" class=\"headerlink\" title=\"通过可选链式调用调用方法\"></a>通过可选链式调用调用方法</h3><p>可以通过可选链式调用来调用方法，并判断是否调用成功，即使这个方法没有返回值。<br>Residence类中的printNumberOfRooms()方法打印当前的numberOfRooms值，如下所示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printNumberOfRooms</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The number of rooms is <span class=\"subst\">\\(numberOfRooms)</span>\"</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个方法没有返回值。然而，没有返回值的方法具有隐式的返回类型Void。这意味着没有返回值的方法也会返回()，或者说空的元组。</p>\n<p>如果在可选值上通过可选链式调用来调用这个方法，该方法的返回类型会是Void?，而不是Void，因为通过可选链式调用得到的返回值都是可选的。这样我们就可以使用if语句来判断能否成功调用printNumberOfRooms()方法，即使方法本身没有定义返回值。通过判断返回值是否为nil可以判断调用是否成功：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> john.residence?.printNumberOfRooms() != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"It was possible to print the number of rooms.\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"It was not possible to print the number of rooms.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"It was not possible to print the number of rooms.\"</span></div></pre></td></tr></table></figure>\n<p>同样的，可以据此判断通过可选链式调用为属性赋值是否成功。在上面的通过可选链式调用访问属性的例子中，我们尝试给john.residence中的address属性赋值，即使residence为nil。通过可选链式调用给属性赋值会返回Void?，通过判断返回值是否为nil就可以知道赋值是否成功：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (john.residence?.address = someAddress) != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"It was possible to set the address.\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"It was not possible to set the address.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"It was not possible to set the address.\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"通过可选链式调用访问下标\"><a href=\"#通过可选链式调用访问下标\" class=\"headerlink\" title=\"通过可选链式调用访问下标\"></a>通过可选链式调用访问下标</h3><p>通过可选链式调用，我们可以在一个可选值上访问下标，并且判断下标调用是否成功。<br>    通过可选链式调用访问可选值的下标时，应该将问号放在下标方括号的前面而不是后面。可选链式调用的问号一般直接跟在可选表达式的后面。</p>\n<p>下面这个例子用下标访问john.residence属性存储的Residence实例的rooms数组中的第一个房间的名称，因为john.residence为nil，所以下标调用失败了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> firstRoomName = john.residence?[<span class=\"number\">0</span>].name &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The first room name is <span class=\"subst\">\\(firstRoomName)</span>.\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Unable to retrieve the first room name.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"Unable to retrieve the first room name.\"</span></div></pre></td></tr></table></figure>\n<p>在这个例子中，问号直接放在john.residence的后面，并且在方括号的前面，因为john.residence是可选值。<br>类似的，可以通过下标，用可选链式调用来赋值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">john.residence?[<span class=\"number\">0</span>] = <span class=\"type\">Room</span>(name: <span class=\"string\">\"Bathroom\"</span>)</div></pre></td></tr></table></figure>\n<p>这次赋值同样会失败，因为residence目前是nil。<br>如果你创建一个Residence实例，并为其rooms数组添加一些Room实例，然后将Residence实例赋值给john.residence，那就可以通过可选链和下标来访问数组中的元素：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> johnsHouse = <span class=\"type\">Residence</span>()</div><div class=\"line\">johnsHouse.rooms.append(<span class=\"type\">Room</span>(name: <span class=\"string\">\"Living Room\"</span>))</div><div class=\"line\">johnsHouse.rooms.append(<span class=\"type\">Room</span>(name: <span class=\"string\">\"Kitchen\"</span>))</div><div class=\"line\">john.residence = johnsHouse</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> firstRoomName = john.residence?[<span class=\"number\">0</span>].name &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"The first room name is <span class=\"subst\">\\(firstRoomName)</span>.\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Unable to retrieve the first room name.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"The first room name is Living Room.\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"访问可选类型的下标\"><a href=\"#访问可选类型的下标\" class=\"headerlink\" title=\"访问可选类型的下标\"></a>访问可选类型的下标</h4><p>如果下标返回可选类型值，比如 Swift 中Dictionary类型的键的下标，可以在下标的结尾括号后面放一个问号来在其可选返回值上进行可选链式调用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> testScores = [<span class=\"string\">\"Dave\"</span>: [<span class=\"number\">86</span>, <span class=\"number\">82</span>, <span class=\"number\">84</span>], <span class=\"string\">\"Bev\"</span>: [<span class=\"number\">79</span>, <span class=\"number\">94</span>, <span class=\"number\">81</span>]]</div><div class=\"line\">testScores[<span class=\"string\">\"Dave\"</span>]?[<span class=\"number\">0</span>] = <span class=\"number\">91</span></div><div class=\"line\">testScores[<span class=\"string\">\"Bev\"</span>]?[<span class=\"number\">0</span>] += <span class=\"number\">1</span></div><div class=\"line\">testScores[<span class=\"string\">\"Brian\"</span>]?[<span class=\"number\">0</span>] = <span class=\"number\">72</span></div><div class=\"line\"><span class=\"comment\">// the \"Dave\" array is now [91, 82, 84] and the \"Bev\" array is now [80, 94, 81]</span></div></pre></td></tr></table></figure>\n<p>上面的例子中定义了一个testScores数组，包含了两个键值对，把String类型的键映射到一个Int值的数组。这个例子用可选链式调用把”Dave”数组中第一个元素设为91，把”Bev”数组的第一个元素+1，然后尝试把”Brian”数组中的第一个元素设为72。前两个调用成功，因为testScores字典中包含”Dave”和”Bev”这两个键。但是testScores字典中没有”Brian”这个键，所以第三个调用失败。</p>\n<h3 id=\"连接多层可选链式调用\"><a href=\"#连接多层可选链式调用\" class=\"headerlink\" title=\"连接多层可选链式调用\"></a>连接多层可选链式调用</h3><p>可以通过连接多个可选链式调用在更深的模型层级中访问属性、方法以及下标。然而，多层可选链式调用不会增加返回值的可选层级。</p>\n<ul>\n<li>如果你访问的值不是可选的，可选链式调用将会返回可选值。</li>\n<li>如果你访问的值就是可选的，可选链式调用不会让可选返回值变得“更可选”。</li>\n</ul>\n<p>因此：</p>\n<ul>\n<li>通过可选链式调用访问一个Int值，将会返回Int?，无论使用了多少层可选链式调用。</li>\n<li>类似的，通过可选链式调用访问Int?值，依旧会返回Int?值，并不会返回Int??。</li>\n</ul>\n<p>下面的例子尝试访问john中的residence属性中的address属性中的street属性。这里使用了两层可选链式调用，residence以及address都是可选值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> johnsStreet = john.residence?.address?.street &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"John's street name is <span class=\"subst\">\\(johnsStreet)</span>.\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Unable to retrieve the address.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"Unable to retrieve the address.\"</span></div></pre></td></tr></table></figure>\n<p>john.residence现在包含一个有效的Residence实例。然而，john.residence.address的值当前为nil。因此，调用john.residence?.address?.street会失败。<br>需要注意的是，上面的例子中，street的属性为String?。john.residence?.address?.street的返回值也依然是String?，即使已经使用了两层可选链式调用。</p>\n<p>如果为john.residence.address赋值一个Address实例，并且为address中的street属性设置一个有效值，我们就能过通过可选链式调用来访问street属性：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> johnsAddress = <span class=\"type\">Address</span>()</div><div class=\"line\">johnsAddress.buildingName = <span class=\"string\">\"The Larches\"</span></div><div class=\"line\">johnsAddress.street = <span class=\"string\">\"Laurel Street\"</span></div><div class=\"line\">john.residence?.address = johnsAddress</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> johnsStreet = john.residence?.address?.street &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"John's street name is <span class=\"subst\">\\(johnsStreet)</span>.\"</span>)</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Unable to retrieve the address.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"John's street name is Laurel Street.\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"在方法的可选返回值上进行可选链式调用\"><a href=\"#在方法的可选返回值上进行可选链式调用\" class=\"headerlink\" title=\"在方法的可选返回值上进行可选链式调用\"></a>在方法的可选返回值上进行可选链式调用</h3><p>上面的例子展示了如何在一个可选值上通过可选链式调用来获取它的属性值。我们还可以在一个可选值上通过可选链式调用来调用方法，并且可以根据需要继续在方法的可选返回值上进行可选链式调用。</p>\n<p>在下面的例子中，通过可选链式调用来调用Address的buildingIdentifier()方法。这个方法返回String?类型的值。如上所述，通过可选链式调用来调用该方法，最终的返回值依旧会是String?类型：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> buildingIdentifier = john.residence?.address?.buildingIdentifier() &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"John's building identifier is <span class=\"subst\">\\(buildingIdentifier)</span>.\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"John's building identifier is The Larches.\"</span></div></pre></td></tr></table></figure>\n<p>如果要在该方法的返回值上进行可选链式调用，在方法的圆括号后面加上问号即可：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> beginsWithThe =</div><div class=\"line\">    john.residence?.address?.buildingIdentifier()?.hasPrefix(<span class=\"string\">\"The\"</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> beginsWithThe &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"John's building identifier begins with \\\"The\\\".\"</span>)</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"John's building identifier does not begin with \\\"The\\\".\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"John's building identifier begins with \"The\".\"</span></div></pre></td></tr></table></figure>\n<pre><code>在上面的例子中，在方法的圆括号后面加上问号是因为你要在buildingIdentifier()方法的可选返回值上进行可选链式调用，而不是方法本身。\n</code></pre><h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/OptionalChaining.html/\" target=\"_blank\" rel=\"external\"> OptionalChaining </a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>"},{"layout":"post","title":"Swift Properties","date":"2016-11-24T16:20:11.000Z","author":"liangtong","catalog":true,"_content":"\n\n\n​\t属性将值跟特定的类、结构或枚举关联。存储属性存储常量或变量作为实例的一部分，而计算属性计算（不是存储）一个值。计算属性可以用于类、结构体和枚举，存储属性只能用于类和结构体。\n存储属性和计算属性通常与特定类型的`实例`关联。但是，属性也可以直接作用于`类型`本身，这种属性称为类型属性。\n另外，还可以定义属性观察器来监控属性值的变化，以此来触发一个自定义的操作。属性观察器可以添加到自己定义的存储属性上，也可以添加到从父类继承的属性上。\n\n\n\n### 存储属性\n简单来说，一个存储属性就是存储在特定类或结构体实例里的一个常量(`let`)或变量(`var`)。可以在定义存储属性的时候指定默认值。也可以在构造过程中设置或修改存储属性的值，甚至修改常量存储属性的值。\n\n\n<!-- more -->\n\n\n下面的例子定义了一个名为 FixedLengthRange 的结构体，该结构体用于描述整数的范围，且这个范围值在被创建后不能被修改，因为它是一个常量存储属性。\n\n```Swift\nstruct FixedLengthRange {\n    var firstValue: Int\n    let length: Int\n}\nvar rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)\n// the range represents integer values 0, 1, and 2\nrangeOfThreeItems.firstValue = 6\n// the range now represents integer values 6, 7, and 8\n```\n\n#### 常量结构体的存储属性\n如果创建了一个结构体的实例并将其赋值给一个常量，则无法修改该实例的任何属性，即使有属性被声明为变量也不行：\n\n```Swift\nlet rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)\n// this range represents integer values 0, 1, 2, and 3\nrangeOfFourItems.firstValue = 6\n// this will report an error, even though firstValue is a variable property\n```\n\n这种行为是由于结构体（struct）属于值类型。当值类型的实例被声明为常量的时候，它的所有属性也就成了常量。\n\n属于引用类型的类（class）则不一样。把一个引用类型的实例赋给一个常量后，仍然可以修改该实例的变量属性。\n\n#### 延迟存储属性\n延迟存储属性是指当第一次被调用的时候才会计算其初始值的属性。在属性声明前使用 `lazy` 来标示一个延迟存储属性。\n\t必须将延迟存储属性声明成变量（使用 var 关键字），因为属性的初始值可能在实例构造完成之后才会得到。而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性。\n\n当属性的值依赖于在实例的构造过程结束后才会知道影响值的外部因素时,延迟属性会很有用；或者当获得属性的初始值需要复杂或大量计算时，可以只在需要的时候计算它时，延迟属性也会很有用。\n下面的例子使用了延迟存储属性来避免复杂类中不必要的初始化。例子中定义了 DataImporter 和 DataManager 两个类，下面是部分代码：\n\n```Swift\nclass DataImporter {\n    /*\n     DataImporter is a class to import data from an external file.\n     The class is assumed to take a non-trivial amount of time to initialize.\n     */\n    var fileName = \"data.txt\"\n    // the DataImporter class would provide data importing functionality here\n}\n \nclass DataManager {\n    lazy var importer = DataImporter()\n    var data = [String]()\n    // the DataManager class would provide data management functionality here\n}\n \nlet manager = DataManager()\nmanager.data.append(\"Some data\")\nmanager.data.append(\"Some more data\")\n// the DataImporter instance for the importer property has not yet been created\n```\n\n由于使用了 `lazy` ，importer 属性只有在第一次被访问的时候才被创建。比如访问它的属性 fileName 时：\n\n```Swift\nprint(manager.importer.fileName)\n// the DataImporter instance for the importer property has now been created\n// Prints \"data.txt\"\n```\n\n\t如果一个被标记为 lazy 的属性在没有初始化时就同时被多个线程访问，则无法保证该属性只会被初始化一次。\n\n#### 存储属性和实例化变量\n如果您有过 Objective-C 经验，应该知道 Objective-C 为类实例存储值和引用提供两种方法。除了属性之外，还可以使用实例变量(.m文件中)作为属性值的后端存储。\nSwift 编程语言中把这些理论统一用属性来实现。Swift 中的属性没有对应的实例变量，属性的全部信息——包括命名、类型和内存管理特征——都在唯一一个地方（类型定义中）定义。\n\n### 计算属性\n除存储属性外，类、结构体和枚举可以定义计算属性。计算属性不直接存储值，而是提供一个 getter 和一个可选的 setter，来间接获取和设置其他属性或变量的值。\n\n```Swift\nstruct Point {\n    var x = 0.0, y = 0.0\n}\nstruct Size {\n    var width = 0.0, height = 0.0\n}\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n    var center: Point {\n        get {\n            let centerX = origin.x + (size.width / 2)\n            let centerY = origin.y + (size.height / 2)\n            return Point(x: centerX, y: centerY)\n        }\n        set(newCenter) {\n            origin.x = newCenter.x - (size.width / 2)\n            origin.y = newCenter.y - (size.height / 2)\n        }\n    }\n}\nvar square = Rect(origin: Point(x: 0.0, y: 0.0),\n                  size: Size(width: 10.0, height: 10.0))\nlet initialSquareCenter = square.center\nsquare.center = Point(x: 15.0, y: 15.0)\nprint(\"square.origin is now at (\\(square.origin.x), \\(square.origin.y))\")\n// Prints \"square.origin is now at (10.0, 10.0)\"\n```\n\n#### 简化的Setter声明\n如果计算属性的 setter 没有定义表示新值的参数名，则可以使用默认名称 `newValue`。下面是使用了简化 setter 声明的 Rect 结构体代码：\n\n```Swift\nstruct AlternativeRect {\n    var origin = Point()\n    var size = Size()\n    var center: Point {\n        get {\n            let centerX = origin.x + (size.width / 2)\n            let centerY = origin.y + (size.height / 2)\n            return Point(x: centerX, y: centerY)\n        }\n        set {\n            origin.x = newValue.x - (size.width / 2)\n            origin.y = newValue.y - (size.height / 2)\n        }\n    }\n}\n```\n\n#### 只读计算属性\n只有 getter 没有 setter 的计算属性就是只读计算属性。只读计算属性总是返回一个值，可以通过点运算符访问，但不能设置新的值。\n\t必须使用 var 关键字定义计算属性，包括只读计算属性，因为它们的值不是固定的。let 关键字只用来声明常量属性，表示初始化后再也无法修改的值。\n\n只读计算属性的声明可以去掉 get 关键字和花括号：\n\n```Swift\nstruct Cuboid {\n    var width = 0.0, height = 0.0, depth = 0.0\n    var volume: Double {\n        return width * height * depth\n    }\n}\nlet fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)\nprint(\"the volume of fourByFiveByTwo is \\(fourByFiveByTwo.volume)\")\n// Prints \"the volume of fourByFiveByTwo is 40.0\"\n```\n\n### 属性观察器\n属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，即使新值和当前值相同的时候也不例外。\n可以为除了延迟存储属性之外的其他存储属性添加属性观察器，也可以通过重写属性的方式为继承的属性（包括存储属性和计算属性）添加属性观察器。你不必为非重写的计算属性添加属性观察器，因为可以通过它的 setter 直接监控和响应值的变化。\n可以为属性添加如下的一个或全部观察器：\n\n* willSet 在新的值被设置之前调用\n* didSet 在新的值被设置之后立即调用\n\nwillSet 观察器会将新的属性值作为常量参数传入，在 willSet 的实现代码中可以为这个参数指定一个名称，如果不指定则参数仍然可用，这时使用默认名称 newValue 表示。\n\n同样，didSet 观察器会将旧的属性值作为参数传入，可以为该参数命名或者使用默认参数名 oldValue。如果在 didSet 方法中再次对该属性赋值，那么新值会覆盖旧的值。\n\t父类的属性在子类的构造器中被赋值时，它在父类中的 willSet 和 didSet 观察器会被调用，随后才会调用子类的观察器。在父类初始化方法调用之前，子类给属性赋值时，观察器不会被调用。\n\n下面是一个 willSet 和 didSet 实际运用的例子，其中定义了一个名为 StepCounter 的类，用来统计一个人步行时的总步数。这个类可以跟计步器或其他日常锻炼的统计装置的输入数据配合使用。\n\n```Swift\nclass StepCounter {\n    var totalSteps: Int = 0 {\n        willSet(newTotalSteps) {\n            print(\"About to set totalSteps to \\(newTotalSteps)\")\n        }\n        didSet {\n            if totalSteps > oldValue  {\n                print(\"Added \\(totalSteps - oldValue) steps\")\n            }\n        }\n    }\n}\nlet stepCounter = StepCounter()\nstepCounter.totalSteps = 200\n// About to set totalSteps to 200\n// Added 200 steps\nstepCounter.totalSteps = 360\n// About to set totalSteps to 360\n// Added 160 steps\nstepCounter.totalSteps = 896\n// About to set totalSteps to 896\n// Added 536 steps\n```\n\n\t如果将属性通过 in-out 方式传入函数，willSet 和 didSet 也会调用。这是因为 in-out 参数采用了拷入拷出模式：即在函数内部使用的是参数的 copy，函数结束后，又对参数重新赋值。\n\n### 全局变量和局部变量\n计算属性和属性观察器所描述的功能也可以用于全局变量和局部变量。全局变量是在函数、方法、闭包或任何类型之外定义的变量。局部变量是在函数、方法或闭包内部定义的变量。\n\t全局的常量或变量都是延迟计算的，跟延迟存储属性相似，不同的地方在于，全局的常量或变量不需要标记lazy修饰符。局部范围的常量或变量从不延迟计算。\n\n### 类型属性\n实例属性属于一个特定类型的实例，每创建一个实例，实例都拥有属于自己的一套属性值，实例之间的属性相互独立。\n也可以为类型本身定义属性，无论创建了多少个该类型的实例，这些属性都只有唯一一份。这种属性就是类型属性。\n\t跟实例的存储型属性不同，必须给存储型类型属性指定默认值，因为类型本身没有构造器，也就无法在初始化过程中使用构造器给类型属性赋值。\n存储型类型属性是延迟初始化的，它们只有在第一次被访问的时候才会被初始化。即使它们被多个线程同时访问，系统也保证只会对其进行一次初始化，并且不需要对其使用 lazy 修饰符。\n\n#### 类属性定义语法\n在 C 或 Objective-C 中，与某个类型关联的静态常量和静态变量，是作为全局（global）静态变量定义的。\n但是在 Swift 中，类型属性是作为类型定义的一部分写在类型最外层的花括号内，因此它的作用范围也就在类型支持的范围内。使用关键字 `static` 来定义类型属性。\n在为类定义计算型类型属性时，可以改用关键字 `class` 来支持子类对父类的实现进行重写。下面的例子演示了存储型和计算型类型属性的语法：\n\n```Swift\nstruct SomeStructure {\n    static var storedTypeProperty = \"Some value.\"\n    static var computedTypeProperty: Int {\n        return 1\n    }\n}\nenum SomeEnumeration {\n    static var storedTypeProperty = \"Some value.\"\n    static var computedTypeProperty: Int {\n        return 6\n    }\n}\nclass SomeClass {\n    static var storedTypeProperty = \"Some value.\"\n    static var computedTypeProperty: Int {\n        return 27\n    }\n//本例子中的计算属性是只读的，可以定义为读写的，跟计算型属性的语法相同。用class修饰的方法，可以被子类重写\n    class var overrideableComputedTypeProperty: Int {\n        return 107\n    }\n}\n```\n\n\t注意：对于为类定义可被重写的计算属性，需要使用关键字 class 来修饰，而不是 static。原文是这样的：\n For computed type properties for class types, you can use the class keyword instead to allow subclasses to override the superclass’s implementation. \n\n\n\n#### 类型属性的获取和设置\n跟实例属性一样，类型属性也是通过点运算符来访问。但是，类型属性是通过类型本身来访问，而不是通过实例。比如：\n\n```Swift\nprint(SomeStructure.storedTypeProperty)\n// Prints \"Some value.\"\nSomeStructure.storedTypeProperty = \"Another value.\"\nprint(SomeStructure.storedTypeProperty)\n// Prints \"Another value.\"\nprint(SomeEnumeration.computedTypeProperty)\n// Prints \"6\"\nprint(SomeClass.computedTypeProperty)\n// Prints \"27\"\n```\n\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html/\">Properties</a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","source":"_posts/iOS_Swift_language_note_Properties.md","raw":"---\nlayout:     post\ntitle:      Swift Properties\ndate:       2016-11-25 00:20:11\nauthor:     liangtong\ncatalog: true\ncategories: iOS\ntags: Swift \n\n---\n\n\n\n​\t属性将值跟特定的类、结构或枚举关联。存储属性存储常量或变量作为实例的一部分，而计算属性计算（不是存储）一个值。计算属性可以用于类、结构体和枚举，存储属性只能用于类和结构体。\n存储属性和计算属性通常与特定类型的`实例`关联。但是，属性也可以直接作用于`类型`本身，这种属性称为类型属性。\n另外，还可以定义属性观察器来监控属性值的变化，以此来触发一个自定义的操作。属性观察器可以添加到自己定义的存储属性上，也可以添加到从父类继承的属性上。\n\n\n\n### 存储属性\n简单来说，一个存储属性就是存储在特定类或结构体实例里的一个常量(`let`)或变量(`var`)。可以在定义存储属性的时候指定默认值。也可以在构造过程中设置或修改存储属性的值，甚至修改常量存储属性的值。\n\n\n<!-- more -->\n\n\n下面的例子定义了一个名为 FixedLengthRange 的结构体，该结构体用于描述整数的范围，且这个范围值在被创建后不能被修改，因为它是一个常量存储属性。\n\n```Swift\nstruct FixedLengthRange {\n    var firstValue: Int\n    let length: Int\n}\nvar rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)\n// the range represents integer values 0, 1, and 2\nrangeOfThreeItems.firstValue = 6\n// the range now represents integer values 6, 7, and 8\n```\n\n#### 常量结构体的存储属性\n如果创建了一个结构体的实例并将其赋值给一个常量，则无法修改该实例的任何属性，即使有属性被声明为变量也不行：\n\n```Swift\nlet rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)\n// this range represents integer values 0, 1, 2, and 3\nrangeOfFourItems.firstValue = 6\n// this will report an error, even though firstValue is a variable property\n```\n\n这种行为是由于结构体（struct）属于值类型。当值类型的实例被声明为常量的时候，它的所有属性也就成了常量。\n\n属于引用类型的类（class）则不一样。把一个引用类型的实例赋给一个常量后，仍然可以修改该实例的变量属性。\n\n#### 延迟存储属性\n延迟存储属性是指当第一次被调用的时候才会计算其初始值的属性。在属性声明前使用 `lazy` 来标示一个延迟存储属性。\n\t必须将延迟存储属性声明成变量（使用 var 关键字），因为属性的初始值可能在实例构造完成之后才会得到。而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性。\n\n当属性的值依赖于在实例的构造过程结束后才会知道影响值的外部因素时,延迟属性会很有用；或者当获得属性的初始值需要复杂或大量计算时，可以只在需要的时候计算它时，延迟属性也会很有用。\n下面的例子使用了延迟存储属性来避免复杂类中不必要的初始化。例子中定义了 DataImporter 和 DataManager 两个类，下面是部分代码：\n\n```Swift\nclass DataImporter {\n    /*\n     DataImporter is a class to import data from an external file.\n     The class is assumed to take a non-trivial amount of time to initialize.\n     */\n    var fileName = \"data.txt\"\n    // the DataImporter class would provide data importing functionality here\n}\n \nclass DataManager {\n    lazy var importer = DataImporter()\n    var data = [String]()\n    // the DataManager class would provide data management functionality here\n}\n \nlet manager = DataManager()\nmanager.data.append(\"Some data\")\nmanager.data.append(\"Some more data\")\n// the DataImporter instance for the importer property has not yet been created\n```\n\n由于使用了 `lazy` ，importer 属性只有在第一次被访问的时候才被创建。比如访问它的属性 fileName 时：\n\n```Swift\nprint(manager.importer.fileName)\n// the DataImporter instance for the importer property has now been created\n// Prints \"data.txt\"\n```\n\n\t如果一个被标记为 lazy 的属性在没有初始化时就同时被多个线程访问，则无法保证该属性只会被初始化一次。\n\n#### 存储属性和实例化变量\n如果您有过 Objective-C 经验，应该知道 Objective-C 为类实例存储值和引用提供两种方法。除了属性之外，还可以使用实例变量(.m文件中)作为属性值的后端存储。\nSwift 编程语言中把这些理论统一用属性来实现。Swift 中的属性没有对应的实例变量，属性的全部信息——包括命名、类型和内存管理特征——都在唯一一个地方（类型定义中）定义。\n\n### 计算属性\n除存储属性外，类、结构体和枚举可以定义计算属性。计算属性不直接存储值，而是提供一个 getter 和一个可选的 setter，来间接获取和设置其他属性或变量的值。\n\n```Swift\nstruct Point {\n    var x = 0.0, y = 0.0\n}\nstruct Size {\n    var width = 0.0, height = 0.0\n}\nstruct Rect {\n    var origin = Point()\n    var size = Size()\n    var center: Point {\n        get {\n            let centerX = origin.x + (size.width / 2)\n            let centerY = origin.y + (size.height / 2)\n            return Point(x: centerX, y: centerY)\n        }\n        set(newCenter) {\n            origin.x = newCenter.x - (size.width / 2)\n            origin.y = newCenter.y - (size.height / 2)\n        }\n    }\n}\nvar square = Rect(origin: Point(x: 0.0, y: 0.0),\n                  size: Size(width: 10.0, height: 10.0))\nlet initialSquareCenter = square.center\nsquare.center = Point(x: 15.0, y: 15.0)\nprint(\"square.origin is now at (\\(square.origin.x), \\(square.origin.y))\")\n// Prints \"square.origin is now at (10.0, 10.0)\"\n```\n\n#### 简化的Setter声明\n如果计算属性的 setter 没有定义表示新值的参数名，则可以使用默认名称 `newValue`。下面是使用了简化 setter 声明的 Rect 结构体代码：\n\n```Swift\nstruct AlternativeRect {\n    var origin = Point()\n    var size = Size()\n    var center: Point {\n        get {\n            let centerX = origin.x + (size.width / 2)\n            let centerY = origin.y + (size.height / 2)\n            return Point(x: centerX, y: centerY)\n        }\n        set {\n            origin.x = newValue.x - (size.width / 2)\n            origin.y = newValue.y - (size.height / 2)\n        }\n    }\n}\n```\n\n#### 只读计算属性\n只有 getter 没有 setter 的计算属性就是只读计算属性。只读计算属性总是返回一个值，可以通过点运算符访问，但不能设置新的值。\n\t必须使用 var 关键字定义计算属性，包括只读计算属性，因为它们的值不是固定的。let 关键字只用来声明常量属性，表示初始化后再也无法修改的值。\n\n只读计算属性的声明可以去掉 get 关键字和花括号：\n\n```Swift\nstruct Cuboid {\n    var width = 0.0, height = 0.0, depth = 0.0\n    var volume: Double {\n        return width * height * depth\n    }\n}\nlet fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)\nprint(\"the volume of fourByFiveByTwo is \\(fourByFiveByTwo.volume)\")\n// Prints \"the volume of fourByFiveByTwo is 40.0\"\n```\n\n### 属性观察器\n属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，即使新值和当前值相同的时候也不例外。\n可以为除了延迟存储属性之外的其他存储属性添加属性观察器，也可以通过重写属性的方式为继承的属性（包括存储属性和计算属性）添加属性观察器。你不必为非重写的计算属性添加属性观察器，因为可以通过它的 setter 直接监控和响应值的变化。\n可以为属性添加如下的一个或全部观察器：\n\n* willSet 在新的值被设置之前调用\n* didSet 在新的值被设置之后立即调用\n\nwillSet 观察器会将新的属性值作为常量参数传入，在 willSet 的实现代码中可以为这个参数指定一个名称，如果不指定则参数仍然可用，这时使用默认名称 newValue 表示。\n\n同样，didSet 观察器会将旧的属性值作为参数传入，可以为该参数命名或者使用默认参数名 oldValue。如果在 didSet 方法中再次对该属性赋值，那么新值会覆盖旧的值。\n\t父类的属性在子类的构造器中被赋值时，它在父类中的 willSet 和 didSet 观察器会被调用，随后才会调用子类的观察器。在父类初始化方法调用之前，子类给属性赋值时，观察器不会被调用。\n\n下面是一个 willSet 和 didSet 实际运用的例子，其中定义了一个名为 StepCounter 的类，用来统计一个人步行时的总步数。这个类可以跟计步器或其他日常锻炼的统计装置的输入数据配合使用。\n\n```Swift\nclass StepCounter {\n    var totalSteps: Int = 0 {\n        willSet(newTotalSteps) {\n            print(\"About to set totalSteps to \\(newTotalSteps)\")\n        }\n        didSet {\n            if totalSteps > oldValue  {\n                print(\"Added \\(totalSteps - oldValue) steps\")\n            }\n        }\n    }\n}\nlet stepCounter = StepCounter()\nstepCounter.totalSteps = 200\n// About to set totalSteps to 200\n// Added 200 steps\nstepCounter.totalSteps = 360\n// About to set totalSteps to 360\n// Added 160 steps\nstepCounter.totalSteps = 896\n// About to set totalSteps to 896\n// Added 536 steps\n```\n\n\t如果将属性通过 in-out 方式传入函数，willSet 和 didSet 也会调用。这是因为 in-out 参数采用了拷入拷出模式：即在函数内部使用的是参数的 copy，函数结束后，又对参数重新赋值。\n\n### 全局变量和局部变量\n计算属性和属性观察器所描述的功能也可以用于全局变量和局部变量。全局变量是在函数、方法、闭包或任何类型之外定义的变量。局部变量是在函数、方法或闭包内部定义的变量。\n\t全局的常量或变量都是延迟计算的，跟延迟存储属性相似，不同的地方在于，全局的常量或变量不需要标记lazy修饰符。局部范围的常量或变量从不延迟计算。\n\n### 类型属性\n实例属性属于一个特定类型的实例，每创建一个实例，实例都拥有属于自己的一套属性值，实例之间的属性相互独立。\n也可以为类型本身定义属性，无论创建了多少个该类型的实例，这些属性都只有唯一一份。这种属性就是类型属性。\n\t跟实例的存储型属性不同，必须给存储型类型属性指定默认值，因为类型本身没有构造器，也就无法在初始化过程中使用构造器给类型属性赋值。\n存储型类型属性是延迟初始化的，它们只有在第一次被访问的时候才会被初始化。即使它们被多个线程同时访问，系统也保证只会对其进行一次初始化，并且不需要对其使用 lazy 修饰符。\n\n#### 类属性定义语法\n在 C 或 Objective-C 中，与某个类型关联的静态常量和静态变量，是作为全局（global）静态变量定义的。\n但是在 Swift 中，类型属性是作为类型定义的一部分写在类型最外层的花括号内，因此它的作用范围也就在类型支持的范围内。使用关键字 `static` 来定义类型属性。\n在为类定义计算型类型属性时，可以改用关键字 `class` 来支持子类对父类的实现进行重写。下面的例子演示了存储型和计算型类型属性的语法：\n\n```Swift\nstruct SomeStructure {\n    static var storedTypeProperty = \"Some value.\"\n    static var computedTypeProperty: Int {\n        return 1\n    }\n}\nenum SomeEnumeration {\n    static var storedTypeProperty = \"Some value.\"\n    static var computedTypeProperty: Int {\n        return 6\n    }\n}\nclass SomeClass {\n    static var storedTypeProperty = \"Some value.\"\n    static var computedTypeProperty: Int {\n        return 27\n    }\n//本例子中的计算属性是只读的，可以定义为读写的，跟计算型属性的语法相同。用class修饰的方法，可以被子类重写\n    class var overrideableComputedTypeProperty: Int {\n        return 107\n    }\n}\n```\n\n\t注意：对于为类定义可被重写的计算属性，需要使用关键字 class 来修饰，而不是 static。原文是这样的：\n For computed type properties for class types, you can use the class keyword instead to allow subclasses to override the superclass’s implementation. \n\n\n\n#### 类型属性的获取和设置\n跟实例属性一样，类型属性也是通过点运算符来访问。但是，类型属性是通过类型本身来访问，而不是通过实例。比如：\n\n```Swift\nprint(SomeStructure.storedTypeProperty)\n// Prints \"Some value.\"\nSomeStructure.storedTypeProperty = \"Another value.\"\nprint(SomeStructure.storedTypeProperty)\n// Prints \"Another value.\"\nprint(SomeEnumeration.computedTypeProperty)\n// Prints \"6\"\nprint(SomeClass.computedTypeProperty)\n// Prints \"27\"\n```\n\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html/\">Properties</a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","slug":"iOS_Swift_language_note_Properties","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4um003noko84wpxmt9p","content":"<p>​    属性将值跟特定的类、结构或枚举关联。存储属性存储常量或变量作为实例的一部分，而计算属性计算（不是存储）一个值。计算属性可以用于类、结构体和枚举，存储属性只能用于类和结构体。<br>存储属性和计算属性通常与特定类型的<code>实例</code>关联。但是，属性也可以直接作用于<code>类型</code>本身，这种属性称为类型属性。<br>另外，还可以定义属性观察器来监控属性值的变化，以此来触发一个自定义的操作。属性观察器可以添加到自己定义的存储属性上，也可以添加到从父类继承的属性上。</p>\n<h3 id=\"存储属性\"><a href=\"#存储属性\" class=\"headerlink\" title=\"存储属性\"></a>存储属性</h3><p>简单来说，一个存储属性就是存储在特定类或结构体实例里的一个常量(<code>let</code>)或变量(<code>var</code>)。可以在定义存储属性的时候指定默认值。也可以在构造过程中设置或修改存储属性的值，甚至修改常量存储属性的值。</p>\n<a id=\"more\"></a>\n<p>下面的例子定义了一个名为 FixedLengthRange 的结构体，该结构体用于描述整数的范围，且这个范围值在被创建后不能被修改，因为它是一个常量存储属性。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">FixedLengthRange</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> firstValue: <span class=\"type\">Int</span></div><div class=\"line\">    <span class=\"keyword\">let</span> length: <span class=\"type\">Int</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> rangeOfThreeItems = <span class=\"type\">FixedLengthRange</span>(firstValue: <span class=\"number\">0</span>, length: <span class=\"number\">3</span>)</div><div class=\"line\"><span class=\"comment\">// the range represents integer values 0, 1, and 2</span></div><div class=\"line\">rangeOfThreeItems.firstValue = <span class=\"number\">6</span></div><div class=\"line\"><span class=\"comment\">// the range now represents integer values 6, 7, and 8</span></div></pre></td></tr></table></figure>\n<h4 id=\"常量结构体的存储属性\"><a href=\"#常量结构体的存储属性\" class=\"headerlink\" title=\"常量结构体的存储属性\"></a>常量结构体的存储属性</h4><p>如果创建了一个结构体的实例并将其赋值给一个常量，则无法修改该实例的任何属性，即使有属性被声明为变量也不行：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> rangeOfFourItems = <span class=\"type\">FixedLengthRange</span>(firstValue: <span class=\"number\">0</span>, length: <span class=\"number\">4</span>)</div><div class=\"line\"><span class=\"comment\">// this range represents integer values 0, 1, 2, and 3</span></div><div class=\"line\">rangeOfFourItems.firstValue = <span class=\"number\">6</span></div><div class=\"line\"><span class=\"comment\">// this will report an error, even though firstValue is a variable property</span></div></pre></td></tr></table></figure>\n<p>这种行为是由于结构体（struct）属于值类型。当值类型的实例被声明为常量的时候，它的所有属性也就成了常量。</p>\n<p>属于引用类型的类（class）则不一样。把一个引用类型的实例赋给一个常量后，仍然可以修改该实例的变量属性。</p>\n<h4 id=\"延迟存储属性\"><a href=\"#延迟存储属性\" class=\"headerlink\" title=\"延迟存储属性\"></a>延迟存储属性</h4><p>延迟存储属性是指当第一次被调用的时候才会计算其初始值的属性。在属性声明前使用 <code>lazy</code> 来标示一个延迟存储属性。<br>    必须将延迟存储属性声明成变量（使用 var 关键字），因为属性的初始值可能在实例构造完成之后才会得到。而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性。</p>\n<p>当属性的值依赖于在实例的构造过程结束后才会知道影响值的外部因素时,延迟属性会很有用；或者当获得属性的初始值需要复杂或大量计算时，可以只在需要的时候计算它时，延迟属性也会很有用。<br>下面的例子使用了延迟存储属性来避免复杂类中不必要的初始化。例子中定义了 DataImporter 和 DataManager 两个类，下面是部分代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataImporter</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">/*</span></div><div class=\"line\"><span class=\"comment\">     DataImporter is a class to import data from an external file.</span></div><div class=\"line\"><span class=\"comment\">     The class is assumed to take a non-trivial amount of time to initialize.</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"keyword\">var</span> fileName = <span class=\"string\">\"data.txt\"</span></div><div class=\"line\">    <span class=\"comment\">// the DataImporter class would provide data importing functionality here</span></div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataManager</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">lazy</span> <span class=\"keyword\">var</span> importer = <span class=\"type\">DataImporter</span>()</div><div class=\"line\">    <span class=\"keyword\">var</span> data = [<span class=\"type\">String</span>]()</div><div class=\"line\">    <span class=\"comment\">// the DataManager class would provide data management functionality here</span></div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">let</span> manager = <span class=\"type\">DataManager</span>()</div><div class=\"line\">manager.data.append(<span class=\"string\">\"Some data\"</span>)</div><div class=\"line\">manager.data.append(<span class=\"string\">\"Some more data\"</span>)</div><div class=\"line\"><span class=\"comment\">// the DataImporter instance for the importer property has not yet been created</span></div></pre></td></tr></table></figure>\n<p>由于使用了 <code>lazy</code> ，importer 属性只有在第一次被访问的时候才被创建。比如访问它的属性 fileName 时：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">print</span>(manager.importer.fileName)</div><div class=\"line\"><span class=\"comment\">// the DataImporter instance for the importer property has now been created</span></div><div class=\"line\"><span class=\"comment\">// Prints \"data.txt\"</span></div></pre></td></tr></table></figure>\n<pre><code>如果一个被标记为 lazy 的属性在没有初始化时就同时被多个线程访问，则无法保证该属性只会被初始化一次。\n</code></pre><h4 id=\"存储属性和实例化变量\"><a href=\"#存储属性和实例化变量\" class=\"headerlink\" title=\"存储属性和实例化变量\"></a>存储属性和实例化变量</h4><p>如果您有过 Objective-C 经验，应该知道 Objective-C 为类实例存储值和引用提供两种方法。除了属性之外，还可以使用实例变量(.m文件中)作为属性值的后端存储。<br>Swift 编程语言中把这些理论统一用属性来实现。Swift 中的属性没有对应的实例变量，属性的全部信息——包括命名、类型和内存管理特征——都在唯一一个地方（类型定义中）定义。</p>\n<h3 id=\"计算属性\"><a href=\"#计算属性\" class=\"headerlink\" title=\"计算属性\"></a>计算属性</h3><p>除存储属性外，类、结构体和枚举可以定义计算属性。计算属性不直接存储值，而是提供一个 getter 和一个可选的 setter，来间接获取和设置其他属性或变量的值。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">0.0</span>, y = <span class=\"number\">0.0</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Size</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> width = <span class=\"number\">0.0</span>, height = <span class=\"number\">0.0</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Rect</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> origin = <span class=\"type\">Point</span>()</div><div class=\"line\">    <span class=\"keyword\">var</span> size = <span class=\"type\">Size</span>()</div><div class=\"line\">    <span class=\"keyword\">var</span> center: <span class=\"type\">Point</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">get</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">let</span> centerX = origin.x + (size.width / <span class=\"number\">2</span>)</div><div class=\"line\">            <span class=\"keyword\">let</span> centerY = origin.y + (size.height / <span class=\"number\">2</span>)</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"type\">Point</span>(x: centerX, y: centerY)</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">set</span>(newCenter) &#123;</div><div class=\"line\">            origin.x = newCenter.x - (size.width / <span class=\"number\">2</span>)</div><div class=\"line\">            origin.y = newCenter.y - (size.height / <span class=\"number\">2</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> square = <span class=\"type\">Rect</span>(origin: <span class=\"type\">Point</span>(x: <span class=\"number\">0.0</span>, y: <span class=\"number\">0.0</span>),</div><div class=\"line\">                  size: <span class=\"type\">Size</span>(width: <span class=\"number\">10.0</span>, height: <span class=\"number\">10.0</span>))</div><div class=\"line\"><span class=\"keyword\">let</span> initialSquareCenter = square.center</div><div class=\"line\">square.center = <span class=\"type\">Point</span>(x: <span class=\"number\">15.0</span>, y: <span class=\"number\">15.0</span>)</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"square.origin is now at (<span class=\"subst\">\\(square.origin.x)</span>, <span class=\"subst\">\\(square.origin.y)</span>)\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"square.origin is now at (10.0, 10.0)\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"简化的Setter声明\"><a href=\"#简化的Setter声明\" class=\"headerlink\" title=\"简化的Setter声明\"></a>简化的Setter声明</h4><p>如果计算属性的 setter 没有定义表示新值的参数名，则可以使用默认名称 <code>newValue</code>。下面是使用了简化 setter 声明的 Rect 结构体代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AlternativeRect</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> origin = <span class=\"type\">Point</span>()</div><div class=\"line\">    <span class=\"keyword\">var</span> size = <span class=\"type\">Size</span>()</div><div class=\"line\">    <span class=\"keyword\">var</span> center: <span class=\"type\">Point</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">get</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">let</span> centerX = origin.x + (size.width / <span class=\"number\">2</span>)</div><div class=\"line\">            <span class=\"keyword\">let</span> centerY = origin.y + (size.height / <span class=\"number\">2</span>)</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"type\">Point</span>(x: centerX, y: centerY)</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">set</span> &#123;</div><div class=\"line\">            origin.x = newValue.x - (size.width / <span class=\"number\">2</span>)</div><div class=\"line\">            origin.y = newValue.y - (size.height / <span class=\"number\">2</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"只读计算属性\"><a href=\"#只读计算属性\" class=\"headerlink\" title=\"只读计算属性\"></a>只读计算属性</h4><p>只有 getter 没有 setter 的计算属性就是只读计算属性。只读计算属性总是返回一个值，可以通过点运算符访问，但不能设置新的值。<br>    必须使用 var 关键字定义计算属性，包括只读计算属性，因为它们的值不是固定的。let 关键字只用来声明常量属性，表示初始化后再也无法修改的值。</p>\n<p>只读计算属性的声明可以去掉 get 关键字和花括号：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Cuboid</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> width = <span class=\"number\">0.0</span>, height = <span class=\"number\">0.0</span>, depth = <span class=\"number\">0.0</span></div><div class=\"line\">    <span class=\"keyword\">var</span> volume: <span class=\"type\">Double</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> width * height * depth</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> fourByFiveByTwo = <span class=\"type\">Cuboid</span>(width: <span class=\"number\">4.0</span>, height: <span class=\"number\">5.0</span>, depth: <span class=\"number\">2.0</span>)</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"the volume of fourByFiveByTwo is <span class=\"subst\">\\(fourByFiveByTwo.volume)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"the volume of fourByFiveByTwo is 40.0\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"属性观察器\"><a href=\"#属性观察器\" class=\"headerlink\" title=\"属性观察器\"></a>属性观察器</h3><p>属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，即使新值和当前值相同的时候也不例外。<br>可以为除了延迟存储属性之外的其他存储属性添加属性观察器，也可以通过重写属性的方式为继承的属性（包括存储属性和计算属性）添加属性观察器。你不必为非重写的计算属性添加属性观察器，因为可以通过它的 setter 直接监控和响应值的变化。<br>可以为属性添加如下的一个或全部观察器：</p>\n<ul>\n<li>willSet 在新的值被设置之前调用</li>\n<li>didSet 在新的值被设置之后立即调用</li>\n</ul>\n<p>willSet 观察器会将新的属性值作为常量参数传入，在 willSet 的实现代码中可以为这个参数指定一个名称，如果不指定则参数仍然可用，这时使用默认名称 newValue 表示。</p>\n<p>同样，didSet 观察器会将旧的属性值作为参数传入，可以为该参数命名或者使用默认参数名 oldValue。如果在 didSet 方法中再次对该属性赋值，那么新值会覆盖旧的值。<br>    父类的属性在子类的构造器中被赋值时，它在父类中的 willSet 和 didSet 观察器会被调用，随后才会调用子类的观察器。在父类初始化方法调用之前，子类给属性赋值时，观察器不会被调用。</p>\n<p>下面是一个 willSet 和 didSet 实际运用的例子，其中定义了一个名为 StepCounter 的类，用来统计一个人步行时的总步数。这个类可以跟计步器或其他日常锻炼的统计装置的输入数据配合使用。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StepCounter</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> totalSteps: <span class=\"type\">Int</span> = <span class=\"number\">0</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">willSet</span>(newTotalSteps) &#123;</div><div class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">\"About to set totalSteps to <span class=\"subst\">\\(newTotalSteps)</span>\"</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">didSet</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> totalSteps &gt; oldValue  &#123;</div><div class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">\"Added <span class=\"subst\">\\(totalSteps - oldValue)</span> steps\"</span>)</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> stepCounter = <span class=\"type\">StepCounter</span>()</div><div class=\"line\">stepCounter.totalSteps = <span class=\"number\">200</span></div><div class=\"line\"><span class=\"comment\">// About to set totalSteps to 200</span></div><div class=\"line\"><span class=\"comment\">// Added 200 steps</span></div><div class=\"line\">stepCounter.totalSteps = <span class=\"number\">360</span></div><div class=\"line\"><span class=\"comment\">// About to set totalSteps to 360</span></div><div class=\"line\"><span class=\"comment\">// Added 160 steps</span></div><div class=\"line\">stepCounter.totalSteps = <span class=\"number\">896</span></div><div class=\"line\"><span class=\"comment\">// About to set totalSteps to 896</span></div><div class=\"line\"><span class=\"comment\">// Added 536 steps</span></div></pre></td></tr></table></figure>\n<pre><code>如果将属性通过 in-out 方式传入函数，willSet 和 didSet 也会调用。这是因为 in-out 参数采用了拷入拷出模式：即在函数内部使用的是参数的 copy，函数结束后，又对参数重新赋值。\n</code></pre><h3 id=\"全局变量和局部变量\"><a href=\"#全局变量和局部变量\" class=\"headerlink\" title=\"全局变量和局部变量\"></a>全局变量和局部变量</h3><p>计算属性和属性观察器所描述的功能也可以用于全局变量和局部变量。全局变量是在函数、方法、闭包或任何类型之外定义的变量。局部变量是在函数、方法或闭包内部定义的变量。<br>    全局的常量或变量都是延迟计算的，跟延迟存储属性相似，不同的地方在于，全局的常量或变量不需要标记lazy修饰符。局部范围的常量或变量从不延迟计算。</p>\n<h3 id=\"类型属性\"><a href=\"#类型属性\" class=\"headerlink\" title=\"类型属性\"></a>类型属性</h3><p>实例属性属于一个特定类型的实例，每创建一个实例，实例都拥有属于自己的一套属性值，实例之间的属性相互独立。<br>也可以为类型本身定义属性，无论创建了多少个该类型的实例，这些属性都只有唯一一份。这种属性就是类型属性。<br>    跟实例的存储型属性不同，必须给存储型类型属性指定默认值，因为类型本身没有构造器，也就无法在初始化过程中使用构造器给类型属性赋值。<br>存储型类型属性是延迟初始化的，它们只有在第一次被访问的时候才会被初始化。即使它们被多个线程同时访问，系统也保证只会对其进行一次初始化，并且不需要对其使用 lazy 修饰符。</p>\n<h4 id=\"类属性定义语法\"><a href=\"#类属性定义语法\" class=\"headerlink\" title=\"类属性定义语法\"></a>类属性定义语法</h4><p>在 C 或 Objective-C 中，与某个类型关联的静态常量和静态变量，是作为全局（global）静态变量定义的。<br>但是在 Swift 中，类型属性是作为类型定义的一部分写在类型最外层的花括号内，因此它的作用范围也就在类型支持的范围内。使用关键字 <code>static</code> 来定义类型属性。<br>在为类定义计算型类型属性时，可以改用关键字 <code>class</code> 来支持子类对父类的实现进行重写。下面的例子演示了存储型和计算型类型属性的语法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SomeStructure</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> storedTypeProperty = <span class=\"string\">\"Some value.\"</span></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> computedTypeProperty: <span class=\"type\">Int</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">SomeEnumeration</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> storedTypeProperty = <span class=\"string\">\"Some value.\"</span></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> computedTypeProperty: <span class=\"type\">Int</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">6</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClass</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> storedTypeProperty = <span class=\"string\">\"Some value.\"</span></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> computedTypeProperty: <span class=\"type\">Int</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">27</span></div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"comment\">//本例子中的计算属性是只读的，可以定义为读写的，跟计算型属性的语法相同。用class修饰的方法，可以被子类重写</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">var</span> <span class=\"title\">overrideableComputedTypeProperty</span>: <span class=\"title\">Int</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">107</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<pre><code>注意：对于为类定义可被重写的计算属性，需要使用关键字 class 来修饰，而不是 static。原文是这样的：\n</code></pre><p> For computed type properties for class types, you can use the class keyword instead to allow subclasses to override the superclass’s implementation. </p>\n<h4 id=\"类型属性的获取和设置\"><a href=\"#类型属性的获取和设置\" class=\"headerlink\" title=\"类型属性的获取和设置\"></a>类型属性的获取和设置</h4><p>跟实例属性一样，类型属性也是通过点运算符来访问。但是，类型属性是通过类型本身来访问，而不是通过实例。比如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"type\">SomeStructure</span>.storedTypeProperty)</div><div class=\"line\"><span class=\"comment\">// Prints \"Some value.\"</span></div><div class=\"line\"><span class=\"type\">SomeStructure</span>.storedTypeProperty = <span class=\"string\">\"Another value.\"</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"type\">SomeStructure</span>.storedTypeProperty)</div><div class=\"line\"><span class=\"comment\">// Prints \"Another value.\"</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"type\">SomeEnumeration</span>.computedTypeProperty)</div><div class=\"line\"><span class=\"comment\">// Prints \"6\"</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"type\">SomeClass</span>.computedTypeProperty)</div><div class=\"line\"><span class=\"comment\">// Prints \"27\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html/\" target=\"_blank\" rel=\"external\">Properties</a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>​    属性将值跟特定的类、结构或枚举关联。存储属性存储常量或变量作为实例的一部分，而计算属性计算（不是存储）一个值。计算属性可以用于类、结构体和枚举，存储属性只能用于类和结构体。<br>存储属性和计算属性通常与特定类型的<code>实例</code>关联。但是，属性也可以直接作用于<code>类型</code>本身，这种属性称为类型属性。<br>另外，还可以定义属性观察器来监控属性值的变化，以此来触发一个自定义的操作。属性观察器可以添加到自己定义的存储属性上，也可以添加到从父类继承的属性上。</p>\n<h3 id=\"存储属性\"><a href=\"#存储属性\" class=\"headerlink\" title=\"存储属性\"></a>存储属性</h3><p>简单来说，一个存储属性就是存储在特定类或结构体实例里的一个常量(<code>let</code>)或变量(<code>var</code>)。可以在定义存储属性的时候指定默认值。也可以在构造过程中设置或修改存储属性的值，甚至修改常量存储属性的值。</p>","more":"<p>下面的例子定义了一个名为 FixedLengthRange 的结构体，该结构体用于描述整数的范围，且这个范围值在被创建后不能被修改，因为它是一个常量存储属性。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">FixedLengthRange</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> firstValue: <span class=\"type\">Int</span></div><div class=\"line\">    <span class=\"keyword\">let</span> length: <span class=\"type\">Int</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> rangeOfThreeItems = <span class=\"type\">FixedLengthRange</span>(firstValue: <span class=\"number\">0</span>, length: <span class=\"number\">3</span>)</div><div class=\"line\"><span class=\"comment\">// the range represents integer values 0, 1, and 2</span></div><div class=\"line\">rangeOfThreeItems.firstValue = <span class=\"number\">6</span></div><div class=\"line\"><span class=\"comment\">// the range now represents integer values 6, 7, and 8</span></div></pre></td></tr></table></figure>\n<h4 id=\"常量结构体的存储属性\"><a href=\"#常量结构体的存储属性\" class=\"headerlink\" title=\"常量结构体的存储属性\"></a>常量结构体的存储属性</h4><p>如果创建了一个结构体的实例并将其赋值给一个常量，则无法修改该实例的任何属性，即使有属性被声明为变量也不行：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> rangeOfFourItems = <span class=\"type\">FixedLengthRange</span>(firstValue: <span class=\"number\">0</span>, length: <span class=\"number\">4</span>)</div><div class=\"line\"><span class=\"comment\">// this range represents integer values 0, 1, 2, and 3</span></div><div class=\"line\">rangeOfFourItems.firstValue = <span class=\"number\">6</span></div><div class=\"line\"><span class=\"comment\">// this will report an error, even though firstValue is a variable property</span></div></pre></td></tr></table></figure>\n<p>这种行为是由于结构体（struct）属于值类型。当值类型的实例被声明为常量的时候，它的所有属性也就成了常量。</p>\n<p>属于引用类型的类（class）则不一样。把一个引用类型的实例赋给一个常量后，仍然可以修改该实例的变量属性。</p>\n<h4 id=\"延迟存储属性\"><a href=\"#延迟存储属性\" class=\"headerlink\" title=\"延迟存储属性\"></a>延迟存储属性</h4><p>延迟存储属性是指当第一次被调用的时候才会计算其初始值的属性。在属性声明前使用 <code>lazy</code> 来标示一个延迟存储属性。<br>    必须将延迟存储属性声明成变量（使用 var 关键字），因为属性的初始值可能在实例构造完成之后才会得到。而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性。</p>\n<p>当属性的值依赖于在实例的构造过程结束后才会知道影响值的外部因素时,延迟属性会很有用；或者当获得属性的初始值需要复杂或大量计算时，可以只在需要的时候计算它时，延迟属性也会很有用。<br>下面的例子使用了延迟存储属性来避免复杂类中不必要的初始化。例子中定义了 DataImporter 和 DataManager 两个类，下面是部分代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataImporter</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">/*</span></div><div class=\"line\"><span class=\"comment\">     DataImporter is a class to import data from an external file.</span></div><div class=\"line\"><span class=\"comment\">     The class is assumed to take a non-trivial amount of time to initialize.</span></div><div class=\"line\"><span class=\"comment\">     */</span></div><div class=\"line\">    <span class=\"keyword\">var</span> fileName = <span class=\"string\">\"data.txt\"</span></div><div class=\"line\">    <span class=\"comment\">// the DataImporter class would provide data importing functionality here</span></div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataManager</span> </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">lazy</span> <span class=\"keyword\">var</span> importer = <span class=\"type\">DataImporter</span>()</div><div class=\"line\">    <span class=\"keyword\">var</span> data = [<span class=\"type\">String</span>]()</div><div class=\"line\">    <span class=\"comment\">// the DataManager class would provide data management functionality here</span></div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">let</span> manager = <span class=\"type\">DataManager</span>()</div><div class=\"line\">manager.data.append(<span class=\"string\">\"Some data\"</span>)</div><div class=\"line\">manager.data.append(<span class=\"string\">\"Some more data\"</span>)</div><div class=\"line\"><span class=\"comment\">// the DataImporter instance for the importer property has not yet been created</span></div></pre></td></tr></table></figure>\n<p>由于使用了 <code>lazy</code> ，importer 属性只有在第一次被访问的时候才被创建。比如访问它的属性 fileName 时：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">print</span>(manager.importer.fileName)</div><div class=\"line\"><span class=\"comment\">// the DataImporter instance for the importer property has now been created</span></div><div class=\"line\"><span class=\"comment\">// Prints \"data.txt\"</span></div></pre></td></tr></table></figure>\n<pre><code>如果一个被标记为 lazy 的属性在没有初始化时就同时被多个线程访问，则无法保证该属性只会被初始化一次。\n</code></pre><h4 id=\"存储属性和实例化变量\"><a href=\"#存储属性和实例化变量\" class=\"headerlink\" title=\"存储属性和实例化变量\"></a>存储属性和实例化变量</h4><p>如果您有过 Objective-C 经验，应该知道 Objective-C 为类实例存储值和引用提供两种方法。除了属性之外，还可以使用实例变量(.m文件中)作为属性值的后端存储。<br>Swift 编程语言中把这些理论统一用属性来实现。Swift 中的属性没有对应的实例变量，属性的全部信息——包括命名、类型和内存管理特征——都在唯一一个地方（类型定义中）定义。</p>\n<h3 id=\"计算属性\"><a href=\"#计算属性\" class=\"headerlink\" title=\"计算属性\"></a>计算属性</h3><p>除存储属性外，类、结构体和枚举可以定义计算属性。计算属性不直接存储值，而是提供一个 getter 和一个可选的 setter，来间接获取和设置其他属性或变量的值。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Point</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">0.0</span>, y = <span class=\"number\">0.0</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Size</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> width = <span class=\"number\">0.0</span>, height = <span class=\"number\">0.0</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Rect</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> origin = <span class=\"type\">Point</span>()</div><div class=\"line\">    <span class=\"keyword\">var</span> size = <span class=\"type\">Size</span>()</div><div class=\"line\">    <span class=\"keyword\">var</span> center: <span class=\"type\">Point</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">get</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">let</span> centerX = origin.x + (size.width / <span class=\"number\">2</span>)</div><div class=\"line\">            <span class=\"keyword\">let</span> centerY = origin.y + (size.height / <span class=\"number\">2</span>)</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"type\">Point</span>(x: centerX, y: centerY)</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">set</span>(newCenter) &#123;</div><div class=\"line\">            origin.x = newCenter.x - (size.width / <span class=\"number\">2</span>)</div><div class=\"line\">            origin.y = newCenter.y - (size.height / <span class=\"number\">2</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> square = <span class=\"type\">Rect</span>(origin: <span class=\"type\">Point</span>(x: <span class=\"number\">0.0</span>, y: <span class=\"number\">0.0</span>),</div><div class=\"line\">                  size: <span class=\"type\">Size</span>(width: <span class=\"number\">10.0</span>, height: <span class=\"number\">10.0</span>))</div><div class=\"line\"><span class=\"keyword\">let</span> initialSquareCenter = square.center</div><div class=\"line\">square.center = <span class=\"type\">Point</span>(x: <span class=\"number\">15.0</span>, y: <span class=\"number\">15.0</span>)</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"square.origin is now at (<span class=\"subst\">\\(square.origin.x)</span>, <span class=\"subst\">\\(square.origin.y)</span>)\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"square.origin is now at (10.0, 10.0)\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"简化的Setter声明\"><a href=\"#简化的Setter声明\" class=\"headerlink\" title=\"简化的Setter声明\"></a>简化的Setter声明</h4><p>如果计算属性的 setter 没有定义表示新值的参数名，则可以使用默认名称 <code>newValue</code>。下面是使用了简化 setter 声明的 Rect 结构体代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">AlternativeRect</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> origin = <span class=\"type\">Point</span>()</div><div class=\"line\">    <span class=\"keyword\">var</span> size = <span class=\"type\">Size</span>()</div><div class=\"line\">    <span class=\"keyword\">var</span> center: <span class=\"type\">Point</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">get</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">let</span> centerX = origin.x + (size.width / <span class=\"number\">2</span>)</div><div class=\"line\">            <span class=\"keyword\">let</span> centerY = origin.y + (size.height / <span class=\"number\">2</span>)</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"type\">Point</span>(x: centerX, y: centerY)</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">set</span> &#123;</div><div class=\"line\">            origin.x = newValue.x - (size.width / <span class=\"number\">2</span>)</div><div class=\"line\">            origin.y = newValue.y - (size.height / <span class=\"number\">2</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"只读计算属性\"><a href=\"#只读计算属性\" class=\"headerlink\" title=\"只读计算属性\"></a>只读计算属性</h4><p>只有 getter 没有 setter 的计算属性就是只读计算属性。只读计算属性总是返回一个值，可以通过点运算符访问，但不能设置新的值。<br>    必须使用 var 关键字定义计算属性，包括只读计算属性，因为它们的值不是固定的。let 关键字只用来声明常量属性，表示初始化后再也无法修改的值。</p>\n<p>只读计算属性的声明可以去掉 get 关键字和花括号：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Cuboid</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> width = <span class=\"number\">0.0</span>, height = <span class=\"number\">0.0</span>, depth = <span class=\"number\">0.0</span></div><div class=\"line\">    <span class=\"keyword\">var</span> volume: <span class=\"type\">Double</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> width * height * depth</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> fourByFiveByTwo = <span class=\"type\">Cuboid</span>(width: <span class=\"number\">4.0</span>, height: <span class=\"number\">5.0</span>, depth: <span class=\"number\">2.0</span>)</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"the volume of fourByFiveByTwo is <span class=\"subst\">\\(fourByFiveByTwo.volume)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"the volume of fourByFiveByTwo is 40.0\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"属性观察器\"><a href=\"#属性观察器\" class=\"headerlink\" title=\"属性观察器\"></a>属性观察器</h3><p>属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，即使新值和当前值相同的时候也不例外。<br>可以为除了延迟存储属性之外的其他存储属性添加属性观察器，也可以通过重写属性的方式为继承的属性（包括存储属性和计算属性）添加属性观察器。你不必为非重写的计算属性添加属性观察器，因为可以通过它的 setter 直接监控和响应值的变化。<br>可以为属性添加如下的一个或全部观察器：</p>\n<ul>\n<li>willSet 在新的值被设置之前调用</li>\n<li>didSet 在新的值被设置之后立即调用</li>\n</ul>\n<p>willSet 观察器会将新的属性值作为常量参数传入，在 willSet 的实现代码中可以为这个参数指定一个名称，如果不指定则参数仍然可用，这时使用默认名称 newValue 表示。</p>\n<p>同样，didSet 观察器会将旧的属性值作为参数传入，可以为该参数命名或者使用默认参数名 oldValue。如果在 didSet 方法中再次对该属性赋值，那么新值会覆盖旧的值。<br>    父类的属性在子类的构造器中被赋值时，它在父类中的 willSet 和 didSet 观察器会被调用，随后才会调用子类的观察器。在父类初始化方法调用之前，子类给属性赋值时，观察器不会被调用。</p>\n<p>下面是一个 willSet 和 didSet 实际运用的例子，其中定义了一个名为 StepCounter 的类，用来统计一个人步行时的总步数。这个类可以跟计步器或其他日常锻炼的统计装置的输入数据配合使用。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StepCounter</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> totalSteps: <span class=\"type\">Int</span> = <span class=\"number\">0</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">willSet</span>(newTotalSteps) &#123;</div><div class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">\"About to set totalSteps to <span class=\"subst\">\\(newTotalSteps)</span>\"</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">didSet</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> totalSteps &gt; oldValue  &#123;</div><div class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">\"Added <span class=\"subst\">\\(totalSteps - oldValue)</span> steps\"</span>)</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> stepCounter = <span class=\"type\">StepCounter</span>()</div><div class=\"line\">stepCounter.totalSteps = <span class=\"number\">200</span></div><div class=\"line\"><span class=\"comment\">// About to set totalSteps to 200</span></div><div class=\"line\"><span class=\"comment\">// Added 200 steps</span></div><div class=\"line\">stepCounter.totalSteps = <span class=\"number\">360</span></div><div class=\"line\"><span class=\"comment\">// About to set totalSteps to 360</span></div><div class=\"line\"><span class=\"comment\">// Added 160 steps</span></div><div class=\"line\">stepCounter.totalSteps = <span class=\"number\">896</span></div><div class=\"line\"><span class=\"comment\">// About to set totalSteps to 896</span></div><div class=\"line\"><span class=\"comment\">// Added 536 steps</span></div></pre></td></tr></table></figure>\n<pre><code>如果将属性通过 in-out 方式传入函数，willSet 和 didSet 也会调用。这是因为 in-out 参数采用了拷入拷出模式：即在函数内部使用的是参数的 copy，函数结束后，又对参数重新赋值。\n</code></pre><h3 id=\"全局变量和局部变量\"><a href=\"#全局变量和局部变量\" class=\"headerlink\" title=\"全局变量和局部变量\"></a>全局变量和局部变量</h3><p>计算属性和属性观察器所描述的功能也可以用于全局变量和局部变量。全局变量是在函数、方法、闭包或任何类型之外定义的变量。局部变量是在函数、方法或闭包内部定义的变量。<br>    全局的常量或变量都是延迟计算的，跟延迟存储属性相似，不同的地方在于，全局的常量或变量不需要标记lazy修饰符。局部范围的常量或变量从不延迟计算。</p>\n<h3 id=\"类型属性\"><a href=\"#类型属性\" class=\"headerlink\" title=\"类型属性\"></a>类型属性</h3><p>实例属性属于一个特定类型的实例，每创建一个实例，实例都拥有属于自己的一套属性值，实例之间的属性相互独立。<br>也可以为类型本身定义属性，无论创建了多少个该类型的实例，这些属性都只有唯一一份。这种属性就是类型属性。<br>    跟实例的存储型属性不同，必须给存储型类型属性指定默认值，因为类型本身没有构造器，也就无法在初始化过程中使用构造器给类型属性赋值。<br>存储型类型属性是延迟初始化的，它们只有在第一次被访问的时候才会被初始化。即使它们被多个线程同时访问，系统也保证只会对其进行一次初始化，并且不需要对其使用 lazy 修饰符。</p>\n<h4 id=\"类属性定义语法\"><a href=\"#类属性定义语法\" class=\"headerlink\" title=\"类属性定义语法\"></a>类属性定义语法</h4><p>在 C 或 Objective-C 中，与某个类型关联的静态常量和静态变量，是作为全局（global）静态变量定义的。<br>但是在 Swift 中，类型属性是作为类型定义的一部分写在类型最外层的花括号内，因此它的作用范围也就在类型支持的范围内。使用关键字 <code>static</code> 来定义类型属性。<br>在为类定义计算型类型属性时，可以改用关键字 <code>class</code> 来支持子类对父类的实现进行重写。下面的例子演示了存储型和计算型类型属性的语法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SomeStructure</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> storedTypeProperty = <span class=\"string\">\"Some value.\"</span></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> computedTypeProperty: <span class=\"type\">Int</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">SomeEnumeration</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> storedTypeProperty = <span class=\"string\">\"Some value.\"</span></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> computedTypeProperty: <span class=\"type\">Int</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">6</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClass</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> storedTypeProperty = <span class=\"string\">\"Some value.\"</span></div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> computedTypeProperty: <span class=\"type\">Int</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">27</span></div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"comment\">//本例子中的计算属性是只读的，可以定义为读写的，跟计算型属性的语法相同。用class修饰的方法，可以被子类重写</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">var</span> <span class=\"title\">overrideableComputedTypeProperty</span>: <span class=\"title\">Int</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">107</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<pre><code>注意：对于为类定义可被重写的计算属性，需要使用关键字 class 来修饰，而不是 static。原文是这样的：\n</code></pre><p> For computed type properties for class types, you can use the class keyword instead to allow subclasses to override the superclass’s implementation. </p>\n<h4 id=\"类型属性的获取和设置\"><a href=\"#类型属性的获取和设置\" class=\"headerlink\" title=\"类型属性的获取和设置\"></a>类型属性的获取和设置</h4><p>跟实例属性一样，类型属性也是通过点运算符来访问。但是，类型属性是通过类型本身来访问，而不是通过实例。比如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"type\">SomeStructure</span>.storedTypeProperty)</div><div class=\"line\"><span class=\"comment\">// Prints \"Some value.\"</span></div><div class=\"line\"><span class=\"type\">SomeStructure</span>.storedTypeProperty = <span class=\"string\">\"Another value.\"</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"type\">SomeStructure</span>.storedTypeProperty)</div><div class=\"line\"><span class=\"comment\">// Prints \"Another value.\"</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"type\">SomeEnumeration</span>.computedTypeProperty)</div><div class=\"line\"><span class=\"comment\">// Prints \"6\"</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"type\">SomeClass</span>.computedTypeProperty)</div><div class=\"line\"><span class=\"comment\">// Prints \"27\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html/\" target=\"_blank\" rel=\"external\">Properties</a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>"},{"layout":"post","title":"Swift String and Characters","date":"2016-11-04T16:20:11.000Z","author":"liangtong","catalog":true,"_content":"\n\n\n​\t字符串`String`是一系列字符集合，Swift提供了一种快速、Unicode的方式的字符串和字符类型。和C语言的字符串字面值语法类似，Swift的字符串的创建和操作是轻量级、可读性的。可以通过`+`操作符连接两个字符串。Swift的字符串中的每个字符都是由`Unicode`编码的字符组成，并支持以各种方式访问这些字符。\n    注：Swift中的String类型通过Foundation框架的NSString类型桥接，Foundation也对String类型对应扩展了NSString中定义的方法。这就意味着如果引用了Foundation，就可以不用转换直接使用NSString中的方法。\n\n\n\n### 字符串的字面值\n​\t可以通过双引号`\"`来定义字符串字面值，Swift会根据字符串字面值将对应类型推断为字符串类型。\n\n```Swift\nlet someString = \"Some string literal value\"\n```\n\n<!-- more -->\n\n### 字符串操作\n\n#### 空字符串\n​\t初始化，检查字符串是否为空。\n\n```Swift\nvar emptyString = \"\"               // empty string literal\nvar anotherEmptyString = String()  // initializer syntax\n\nif emptyString.isEmpty {\nprint(\"Nothing to see here\")\n}\n```\n\n#### 字符串是值类型\n​\t字符串是值类型，创建一个字符串后，如果在函数或者方法中使用，或者该字符串会被赋值给常量或者变量，字符串值会被复制，源字符串数据不会变化。\n\n#### 字符串与字符\n​\t可以使用`for-in`循环，通过使用字符串的`characters`属性来访问字符值，例如\n\n```Swift\nfor character in \"Dog!�\".characters {\nprint(character)\n}\n// D\n// o\n// g\n// !\n// �\n```\n\n​\t可以通过字符来创建字符串，例如：\n\n```Swift\nlet exclamationMark: Character = \"!\"\n\nlet catCharacters: [Character] = [\"C\", \"a\", \"t\", \"!\", \"�\"]\nlet catString = String(catCharacters)\n```\n\n#### 字符串连接\n​\t可以通过操作符`+`、`+=`连接两个字符串，也可以通过使用String的append()方法给字符串追加一个字符值，例如：\n\n```Swift\nvar welcome = \"hello\" + \" there\"\n\nvar instruction = \"look over\"\ninstruction += string2\n\nlet exclamationMark: Character = \"!\"\nwelcome.append(exclamationMark)\n```\n\n### Unicode\n​\t用的不多，不详细介绍\n\n### 字符串访问和修改\n\n​\t不同的字符需要不同的空间来存储，所以为了确定哪个字符的特定位置，需要遍历字符串。正是这个原因，Swift字符串不能通过整型的索引来访问。\n可以通过`startIndex`属性来访问字符串的第一个字符位置，`endIndex`属性对应最后一个字符位置。如果一个字符串的两个属性相同，则说明是一个空字符串。另外String还提供来几个方法来确认位置：` index(before:)`、`index(after:)`、`index(_:offsetBy:)`。如果访问越界，则会出现运行时错误：\n\n```Swift\ngreeting[greeting.endIndex] // Error\n```\n\n字符的插入和移除可以通过方法`insert(_:at:)`和`remove(at:)`进行\n\n### 字符串比较\n​\tSwift提供了3中方式比较文字值：字符串和字符等式、前缀等式、后缀等式\n\n#### 字符串和字符等式\n​\t可以通过操作符：`==`和`!=`，例如：\n\n```Swift\nlet quotation = \"We're a lot alike, you and I.\"\nlet sameQuotation = \"We're a lot alike, you and I.\"\nif quotation == sameQuotation {\nprint(\"These two strings are considered equal\")\n}\n// Prints \"These two strings are considered equal\"\n```\n\n#### 前缀、后缀等式\n​\tSwift提供了方法：`hasPrefix(_:)`和`hasSuffix(_:)`\n\n### 字符串的Unicode表示\n\n​\tSwift提供了不同方式来访问不同版本的Unicode字符，你可以遍历字符串通过`for-in`语句，然后通过访问每个字符的Unicode编码。\n\n> * 通过访问字符串的utf8属性，对于UTF-8格式\n> * 通过访问字符串的utf16属性，对于UTF-16格式\n> * 通过访问字符串的unicodeScalars属性，对于UTF-32格式\n\n举个例子，对于一个字符串，需要访问不同格式的编码：\n\n```Swift\nlet dogString = \"Dog‼🐶\"\n```\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UTF8_2x.png)\n对于UTF-8格式表示，如下：\n\n```Swift\nfor codeUnit in dogString.utf8 {\nprint(\"\\(codeUnit) \", terminator: \"\")\n}\nprint(\"\")\n// 68 111 103 226 128 188 240 159 144 182\n```\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UTF16_2x.png)\n对于UTF-16格式表示，如下：\n\n```Swift\nfor codeUnit in dogString.utf16 {\nprint(\"\\(codeUnit) \", terminator: \"\")\n}\nprint(\"\")\n// Prints \"68 111 103 8252 55357 56374 \"\n```\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UnicodeScalar_2x.png)\n对于Unicode Scalar格式表示，如下：\n\n```Swift\nfor codeUnit in dogString.utf16 {\nfor scalar in dogString.unicodeScalars {\nprint(\"\\(scalar.value) \", terminator: \"\")\n}\nprint(\"\")\n// Prints \"68 111 103 8252 128054 \"\n\nfor scalar in dogString.unicodeScalars {\nprint(\"\\(scalar) \")\n}\n// D\n// o\n// g\n// ‼\n// 🐶\n```\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html/\">Strings and Characters</a> \n\n>\n>\n>\n>\n>\n>\n>​Copyright (c) liangtong. All rights reserved.\n>\n\n\n","source":"_posts/iOS_Swift_language_note_String-and-Characters.md","raw":"---\nlayout:     post\ntitle:      Swift String and Characters\ndate:       2016-11-05 00:20:11\nauthor:     liangtong\ncatalog: true\ncategories: iOS\ntags: Swift \n\n---\n\n\n\n​\t字符串`String`是一系列字符集合，Swift提供了一种快速、Unicode的方式的字符串和字符类型。和C语言的字符串字面值语法类似，Swift的字符串的创建和操作是轻量级、可读性的。可以通过`+`操作符连接两个字符串。Swift的字符串中的每个字符都是由`Unicode`编码的字符组成，并支持以各种方式访问这些字符。\n    注：Swift中的String类型通过Foundation框架的NSString类型桥接，Foundation也对String类型对应扩展了NSString中定义的方法。这就意味着如果引用了Foundation，就可以不用转换直接使用NSString中的方法。\n\n\n\n### 字符串的字面值\n​\t可以通过双引号`\"`来定义字符串字面值，Swift会根据字符串字面值将对应类型推断为字符串类型。\n\n```Swift\nlet someString = \"Some string literal value\"\n```\n\n<!-- more -->\n\n### 字符串操作\n\n#### 空字符串\n​\t初始化，检查字符串是否为空。\n\n```Swift\nvar emptyString = \"\"               // empty string literal\nvar anotherEmptyString = String()  // initializer syntax\n\nif emptyString.isEmpty {\nprint(\"Nothing to see here\")\n}\n```\n\n#### 字符串是值类型\n​\t字符串是值类型，创建一个字符串后，如果在函数或者方法中使用，或者该字符串会被赋值给常量或者变量，字符串值会被复制，源字符串数据不会变化。\n\n#### 字符串与字符\n​\t可以使用`for-in`循环，通过使用字符串的`characters`属性来访问字符值，例如\n\n```Swift\nfor character in \"Dog!�\".characters {\nprint(character)\n}\n// D\n// o\n// g\n// !\n// �\n```\n\n​\t可以通过字符来创建字符串，例如：\n\n```Swift\nlet exclamationMark: Character = \"!\"\n\nlet catCharacters: [Character] = [\"C\", \"a\", \"t\", \"!\", \"�\"]\nlet catString = String(catCharacters)\n```\n\n#### 字符串连接\n​\t可以通过操作符`+`、`+=`连接两个字符串，也可以通过使用String的append()方法给字符串追加一个字符值，例如：\n\n```Swift\nvar welcome = \"hello\" + \" there\"\n\nvar instruction = \"look over\"\ninstruction += string2\n\nlet exclamationMark: Character = \"!\"\nwelcome.append(exclamationMark)\n```\n\n### Unicode\n​\t用的不多，不详细介绍\n\n### 字符串访问和修改\n\n​\t不同的字符需要不同的空间来存储，所以为了确定哪个字符的特定位置，需要遍历字符串。正是这个原因，Swift字符串不能通过整型的索引来访问。\n可以通过`startIndex`属性来访问字符串的第一个字符位置，`endIndex`属性对应最后一个字符位置。如果一个字符串的两个属性相同，则说明是一个空字符串。另外String还提供来几个方法来确认位置：` index(before:)`、`index(after:)`、`index(_:offsetBy:)`。如果访问越界，则会出现运行时错误：\n\n```Swift\ngreeting[greeting.endIndex] // Error\n```\n\n字符的插入和移除可以通过方法`insert(_:at:)`和`remove(at:)`进行\n\n### 字符串比较\n​\tSwift提供了3中方式比较文字值：字符串和字符等式、前缀等式、后缀等式\n\n#### 字符串和字符等式\n​\t可以通过操作符：`==`和`!=`，例如：\n\n```Swift\nlet quotation = \"We're a lot alike, you and I.\"\nlet sameQuotation = \"We're a lot alike, you and I.\"\nif quotation == sameQuotation {\nprint(\"These two strings are considered equal\")\n}\n// Prints \"These two strings are considered equal\"\n```\n\n#### 前缀、后缀等式\n​\tSwift提供了方法：`hasPrefix(_:)`和`hasSuffix(_:)`\n\n### 字符串的Unicode表示\n\n​\tSwift提供了不同方式来访问不同版本的Unicode字符，你可以遍历字符串通过`for-in`语句，然后通过访问每个字符的Unicode编码。\n\n> * 通过访问字符串的utf8属性，对于UTF-8格式\n> * 通过访问字符串的utf16属性，对于UTF-16格式\n> * 通过访问字符串的unicodeScalars属性，对于UTF-32格式\n\n举个例子，对于一个字符串，需要访问不同格式的编码：\n\n```Swift\nlet dogString = \"Dog‼🐶\"\n```\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UTF8_2x.png)\n对于UTF-8格式表示，如下：\n\n```Swift\nfor codeUnit in dogString.utf8 {\nprint(\"\\(codeUnit) \", terminator: \"\")\n}\nprint(\"\")\n// 68 111 103 226 128 188 240 159 144 182\n```\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UTF16_2x.png)\n对于UTF-16格式表示，如下：\n\n```Swift\nfor codeUnit in dogString.utf16 {\nprint(\"\\(codeUnit) \", terminator: \"\")\n}\nprint(\"\")\n// Prints \"68 111 103 8252 55357 56374 \"\n```\n![](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UnicodeScalar_2x.png)\n对于Unicode Scalar格式表示，如下：\n\n```Swift\nfor codeUnit in dogString.utf16 {\nfor scalar in dogString.unicodeScalars {\nprint(\"\\(scalar.value) \", terminator: \"\")\n}\nprint(\"\")\n// Prints \"68 111 103 8252 128054 \"\n\nfor scalar in dogString.unicodeScalars {\nprint(\"\\(scalar) \")\n}\n// D\n// o\n// g\n// ‼\n// 🐶\n```\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html/\">Strings and Characters</a> \n\n>\n>\n>\n>\n>\n>\n>​Copyright (c) liangtong. All rights reserved.\n>\n\n\n","slug":"iOS_Swift_language_note_String-and-Characters","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4uo003qoko8x8lqlm8y","content":"<p>​    字符串<code>String</code>是一系列字符集合，Swift提供了一种快速、Unicode的方式的字符串和字符类型。和C语言的字符串字面值语法类似，Swift的字符串的创建和操作是轻量级、可读性的。可以通过<code>+</code>操作符连接两个字符串。Swift的字符串中的每个字符都是由<code>Unicode</code>编码的字符组成，并支持以各种方式访问这些字符。<br>    注：Swift中的String类型通过Foundation框架的NSString类型桥接，Foundation也对String类型对应扩展了NSString中定义的方法。这就意味着如果引用了Foundation，就可以不用转换直接使用NSString中的方法。</p>\n<h3 id=\"字符串的字面值\"><a href=\"#字符串的字面值\" class=\"headerlink\" title=\"字符串的字面值\"></a>字符串的字面值</h3><p>​    可以通过双引号<code>&quot;</code>来定义字符串字面值，Swift会根据字符串字面值将对应类型推断为字符串类型。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> someString = <span class=\"string\">\"Some string literal value\"</span></div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"字符串操作\"><a href=\"#字符串操作\" class=\"headerlink\" title=\"字符串操作\"></a>字符串操作</h3><h4 id=\"空字符串\"><a href=\"#空字符串\" class=\"headerlink\" title=\"空字符串\"></a>空字符串</h4><p>​    初始化，检查字符串是否为空。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> emptyString = <span class=\"string\">\"\"</span>               <span class=\"comment\">// empty string literal</span></div><div class=\"line\"><span class=\"keyword\">var</span> anotherEmptyString = <span class=\"type\">String</span>()  <span class=\"comment\">// initializer syntax</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> emptyString.isEmpty &#123;</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Nothing to see here\"</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"字符串是值类型\"><a href=\"#字符串是值类型\" class=\"headerlink\" title=\"字符串是值类型\"></a>字符串是值类型</h4><p>​    字符串是值类型，创建一个字符串后，如果在函数或者方法中使用，或者该字符串会被赋值给常量或者变量，字符串值会被复制，源字符串数据不会变化。</p>\n<h4 id=\"字符串与字符\"><a href=\"#字符串与字符\" class=\"headerlink\" title=\"字符串与字符\"></a>字符串与字符</h4><p>​    可以使用<code>for-in</code>循环，通过使用字符串的<code>characters</code>属性来访问字符值，例如</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> character <span class=\"keyword\">in</span> <span class=\"string\">\"Dog!�\"</span>.characters &#123;</div><div class=\"line\"><span class=\"built_in\">print</span>(character)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// D</span></div><div class=\"line\"><span class=\"comment\">// o</span></div><div class=\"line\"><span class=\"comment\">// g</span></div><div class=\"line\"><span class=\"comment\">// !</span></div><div class=\"line\"><span class=\"comment\">// �</span></div></pre></td></tr></table></figure>\n<p>​    可以通过字符来创建字符串，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> exclamationMark: <span class=\"type\">Character</span> = <span class=\"string\">\"!\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> catCharacters: [<span class=\"type\">Character</span>] = [<span class=\"string\">\"C\"</span>, <span class=\"string\">\"a\"</span>, <span class=\"string\">\"t\"</span>, <span class=\"string\">\"!\"</span>, <span class=\"string\">\"�\"</span>]</div><div class=\"line\"><span class=\"keyword\">let</span> catString = <span class=\"type\">String</span>(catCharacters)</div></pre></td></tr></table></figure>\n<h4 id=\"字符串连接\"><a href=\"#字符串连接\" class=\"headerlink\" title=\"字符串连接\"></a>字符串连接</h4><p>​    可以通过操作符<code>+</code>、<code>+=</code>连接两个字符串，也可以通过使用String的append()方法给字符串追加一个字符值，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> welcome = <span class=\"string\">\"hello\"</span> + <span class=\"string\">\" there\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> instruction = <span class=\"string\">\"look over\"</span></div><div class=\"line\">instruction += string2</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> exclamationMark: <span class=\"type\">Character</span> = <span class=\"string\">\"!\"</span></div><div class=\"line\">welcome.append(exclamationMark)</div></pre></td></tr></table></figure>\n<h3 id=\"Unicode\"><a href=\"#Unicode\" class=\"headerlink\" title=\"Unicode\"></a>Unicode</h3><p>​    用的不多，不详细介绍</p>\n<h3 id=\"字符串访问和修改\"><a href=\"#字符串访问和修改\" class=\"headerlink\" title=\"字符串访问和修改\"></a>字符串访问和修改</h3><p>​    不同的字符需要不同的空间来存储，所以为了确定哪个字符的特定位置，需要遍历字符串。正是这个原因，Swift字符串不能通过整型的索引来访问。<br>可以通过<code>startIndex</code>属性来访问字符串的第一个字符位置，<code>endIndex</code>属性对应最后一个字符位置。如果一个字符串的两个属性相同，则说明是一个空字符串。另外String还提供来几个方法来确认位置：<code>index(before:)</code>、<code>index(after:)</code>、<code>index(_:offsetBy:)</code>。如果访问越界，则会出现运行时错误：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">greeting[greeting.endIndex] <span class=\"comment\">// Error</span></div></pre></td></tr></table></figure>\n<p>字符的插入和移除可以通过方法<code>insert(_:at:)</code>和<code>remove(at:)</code>进行</p>\n<h3 id=\"字符串比较\"><a href=\"#字符串比较\" class=\"headerlink\" title=\"字符串比较\"></a>字符串比较</h3><p>​    Swift提供了3中方式比较文字值：字符串和字符等式、前缀等式、后缀等式</p>\n<h4 id=\"字符串和字符等式\"><a href=\"#字符串和字符等式\" class=\"headerlink\" title=\"字符串和字符等式\"></a>字符串和字符等式</h4><p>​    可以通过操作符：<code>==</code>和<code>!=</code>，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> quotation = <span class=\"string\">\"We're a lot alike, you and I.\"</span></div><div class=\"line\"><span class=\"keyword\">let</span> sameQuotation = <span class=\"string\">\"We're a lot alike, you and I.\"</span></div><div class=\"line\"><span class=\"keyword\">if</span> quotation == sameQuotation &#123;</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"These two strings are considered equal\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"These two strings are considered equal\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"前缀、后缀等式\"><a href=\"#前缀、后缀等式\" class=\"headerlink\" title=\"前缀、后缀等式\"></a>前缀、后缀等式</h4><p>​    Swift提供了方法：<code>hasPrefix(_:)</code>和<code>hasSuffix(_:)</code></p>\n<h3 id=\"字符串的Unicode表示\"><a href=\"#字符串的Unicode表示\" class=\"headerlink\" title=\"字符串的Unicode表示\"></a>字符串的Unicode表示</h3><p>​    Swift提供了不同方式来访问不同版本的Unicode字符，你可以遍历字符串通过<code>for-in</code>语句，然后通过访问每个字符的Unicode编码。</p>\n<blockquote>\n<ul>\n<li>通过访问字符串的utf8属性，对于UTF-8格式</li>\n<li>通过访问字符串的utf16属性，对于UTF-16格式</li>\n<li>通过访问字符串的unicodeScalars属性，对于UTF-32格式</li>\n</ul>\n</blockquote>\n<p>举个例子，对于一个字符串，需要访问不同格式的编码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> dogString = <span class=\"string\">\"Dog‼🐶\"</span></div></pre></td></tr></table></figure>\n<p><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UTF8_2x.png\" alt=\"\"><br>对于UTF-8格式表示，如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> codeUnit <span class=\"keyword\">in</span> dogString.utf8 &#123;</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(codeUnit)</span> \"</span>, terminator: <span class=\"string\">\"\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"\"</span>)</div><div class=\"line\"><span class=\"comment\">// 68 111 103 226 128 188 240 159 144 182</span></div></pre></td></tr></table></figure>\n<p><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UTF16_2x.png\" alt=\"\"><br>对于UTF-16格式表示，如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> codeUnit <span class=\"keyword\">in</span> dogString.utf16 &#123;</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(codeUnit)</span> \"</span>, terminator: <span class=\"string\">\"\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"68 111 103 8252 55357 56374 \"</span></div></pre></td></tr></table></figure>\n<p><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UnicodeScalar_2x.png\" alt=\"\"><br>对于Unicode Scalar格式表示，如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> codeUnit <span class=\"keyword\">in</span> dogString.utf16 &#123;</div><div class=\"line\"><span class=\"keyword\">for</span> scalar <span class=\"keyword\">in</span> dogString.unicodeScalars &#123;</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(scalar.value)</span> \"</span>, terminator: <span class=\"string\">\"\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"68 111 103 8252 128054 \"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> scalar <span class=\"keyword\">in</span> dogString.unicodeScalars &#123;</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(scalar)</span> \"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// D</span></div><div class=\"line\"><span class=\"comment\">// o</span></div><div class=\"line\"><span class=\"comment\">// g</span></div><div class=\"line\"><span class=\"comment\">// ‼</span></div><div class=\"line\"><span class=\"comment\">// 🐶</span></div></pre></td></tr></table></figure>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html/\" target=\"_blank\" rel=\"external\">Strings and Characters</a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;</p>\n<blockquote>\n<p>​Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>​    字符串<code>String</code>是一系列字符集合，Swift提供了一种快速、Unicode的方式的字符串和字符类型。和C语言的字符串字面值语法类似，Swift的字符串的创建和操作是轻量级、可读性的。可以通过<code>+</code>操作符连接两个字符串。Swift的字符串中的每个字符都是由<code>Unicode</code>编码的字符组成，并支持以各种方式访问这些字符。<br>    注：Swift中的String类型通过Foundation框架的NSString类型桥接，Foundation也对String类型对应扩展了NSString中定义的方法。这就意味着如果引用了Foundation，就可以不用转换直接使用NSString中的方法。</p>\n<h3 id=\"字符串的字面值\"><a href=\"#字符串的字面值\" class=\"headerlink\" title=\"字符串的字面值\"></a>字符串的字面值</h3><p>​    可以通过双引号<code>&quot;</code>来定义字符串字面值，Swift会根据字符串字面值将对应类型推断为字符串类型。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> someString = <span class=\"string\">\"Some string literal value\"</span></div></pre></td></tr></table></figure>","more":"<h3 id=\"字符串操作\"><a href=\"#字符串操作\" class=\"headerlink\" title=\"字符串操作\"></a>字符串操作</h3><h4 id=\"空字符串\"><a href=\"#空字符串\" class=\"headerlink\" title=\"空字符串\"></a>空字符串</h4><p>​    初始化，检查字符串是否为空。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> emptyString = <span class=\"string\">\"\"</span>               <span class=\"comment\">// empty string literal</span></div><div class=\"line\"><span class=\"keyword\">var</span> anotherEmptyString = <span class=\"type\">String</span>()  <span class=\"comment\">// initializer syntax</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> emptyString.isEmpty &#123;</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Nothing to see here\"</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"字符串是值类型\"><a href=\"#字符串是值类型\" class=\"headerlink\" title=\"字符串是值类型\"></a>字符串是值类型</h4><p>​    字符串是值类型，创建一个字符串后，如果在函数或者方法中使用，或者该字符串会被赋值给常量或者变量，字符串值会被复制，源字符串数据不会变化。</p>\n<h4 id=\"字符串与字符\"><a href=\"#字符串与字符\" class=\"headerlink\" title=\"字符串与字符\"></a>字符串与字符</h4><p>​    可以使用<code>for-in</code>循环，通过使用字符串的<code>characters</code>属性来访问字符值，例如</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> character <span class=\"keyword\">in</span> <span class=\"string\">\"Dog!�\"</span>.characters &#123;</div><div class=\"line\"><span class=\"built_in\">print</span>(character)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// D</span></div><div class=\"line\"><span class=\"comment\">// o</span></div><div class=\"line\"><span class=\"comment\">// g</span></div><div class=\"line\"><span class=\"comment\">// !</span></div><div class=\"line\"><span class=\"comment\">// �</span></div></pre></td></tr></table></figure>\n<p>​    可以通过字符来创建字符串，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> exclamationMark: <span class=\"type\">Character</span> = <span class=\"string\">\"!\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> catCharacters: [<span class=\"type\">Character</span>] = [<span class=\"string\">\"C\"</span>, <span class=\"string\">\"a\"</span>, <span class=\"string\">\"t\"</span>, <span class=\"string\">\"!\"</span>, <span class=\"string\">\"�\"</span>]</div><div class=\"line\"><span class=\"keyword\">let</span> catString = <span class=\"type\">String</span>(catCharacters)</div></pre></td></tr></table></figure>\n<h4 id=\"字符串连接\"><a href=\"#字符串连接\" class=\"headerlink\" title=\"字符串连接\"></a>字符串连接</h4><p>​    可以通过操作符<code>+</code>、<code>+=</code>连接两个字符串，也可以通过使用String的append()方法给字符串追加一个字符值，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> welcome = <span class=\"string\">\"hello\"</span> + <span class=\"string\">\" there\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> instruction = <span class=\"string\">\"look over\"</span></div><div class=\"line\">instruction += string2</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> exclamationMark: <span class=\"type\">Character</span> = <span class=\"string\">\"!\"</span></div><div class=\"line\">welcome.append(exclamationMark)</div></pre></td></tr></table></figure>\n<h3 id=\"Unicode\"><a href=\"#Unicode\" class=\"headerlink\" title=\"Unicode\"></a>Unicode</h3><p>​    用的不多，不详细介绍</p>\n<h3 id=\"字符串访问和修改\"><a href=\"#字符串访问和修改\" class=\"headerlink\" title=\"字符串访问和修改\"></a>字符串访问和修改</h3><p>​    不同的字符需要不同的空间来存储，所以为了确定哪个字符的特定位置，需要遍历字符串。正是这个原因，Swift字符串不能通过整型的索引来访问。<br>可以通过<code>startIndex</code>属性来访问字符串的第一个字符位置，<code>endIndex</code>属性对应最后一个字符位置。如果一个字符串的两个属性相同，则说明是一个空字符串。另外String还提供来几个方法来确认位置：<code>index(before:)</code>、<code>index(after:)</code>、<code>index(_:offsetBy:)</code>。如果访问越界，则会出现运行时错误：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">greeting[greeting.endIndex] <span class=\"comment\">// Error</span></div></pre></td></tr></table></figure>\n<p>字符的插入和移除可以通过方法<code>insert(_:at:)</code>和<code>remove(at:)</code>进行</p>\n<h3 id=\"字符串比较\"><a href=\"#字符串比较\" class=\"headerlink\" title=\"字符串比较\"></a>字符串比较</h3><p>​    Swift提供了3中方式比较文字值：字符串和字符等式、前缀等式、后缀等式</p>\n<h4 id=\"字符串和字符等式\"><a href=\"#字符串和字符等式\" class=\"headerlink\" title=\"字符串和字符等式\"></a>字符串和字符等式</h4><p>​    可以通过操作符：<code>==</code>和<code>!=</code>，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> quotation = <span class=\"string\">\"We're a lot alike, you and I.\"</span></div><div class=\"line\"><span class=\"keyword\">let</span> sameQuotation = <span class=\"string\">\"We're a lot alike, you and I.\"</span></div><div class=\"line\"><span class=\"keyword\">if</span> quotation == sameQuotation &#123;</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"These two strings are considered equal\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Prints \"These two strings are considered equal\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"前缀、后缀等式\"><a href=\"#前缀、后缀等式\" class=\"headerlink\" title=\"前缀、后缀等式\"></a>前缀、后缀等式</h4><p>​    Swift提供了方法：<code>hasPrefix(_:)</code>和<code>hasSuffix(_:)</code></p>\n<h3 id=\"字符串的Unicode表示\"><a href=\"#字符串的Unicode表示\" class=\"headerlink\" title=\"字符串的Unicode表示\"></a>字符串的Unicode表示</h3><p>​    Swift提供了不同方式来访问不同版本的Unicode字符，你可以遍历字符串通过<code>for-in</code>语句，然后通过访问每个字符的Unicode编码。</p>\n<blockquote>\n<ul>\n<li>通过访问字符串的utf8属性，对于UTF-8格式</li>\n<li>通过访问字符串的utf16属性，对于UTF-16格式</li>\n<li>通过访问字符串的unicodeScalars属性，对于UTF-32格式</li>\n</ul>\n</blockquote>\n<p>举个例子，对于一个字符串，需要访问不同格式的编码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> dogString = <span class=\"string\">\"Dog‼🐶\"</span></div></pre></td></tr></table></figure>\n<p><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UTF8_2x.png\" alt=\"\"><br>对于UTF-8格式表示，如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> codeUnit <span class=\"keyword\">in</span> dogString.utf8 &#123;</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(codeUnit)</span> \"</span>, terminator: <span class=\"string\">\"\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"\"</span>)</div><div class=\"line\"><span class=\"comment\">// 68 111 103 226 128 188 240 159 144 182</span></div></pre></td></tr></table></figure>\n<p><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UTF16_2x.png\" alt=\"\"><br>对于UTF-16格式表示，如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> codeUnit <span class=\"keyword\">in</span> dogString.utf16 &#123;</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(codeUnit)</span> \"</span>, terminator: <span class=\"string\">\"\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"68 111 103 8252 55357 56374 \"</span></div></pre></td></tr></table></figure>\n<p><img src=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Art/UnicodeScalar_2x.png\" alt=\"\"><br>对于Unicode Scalar格式表示，如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> codeUnit <span class=\"keyword\">in</span> dogString.utf16 &#123;</div><div class=\"line\"><span class=\"keyword\">for</span> scalar <span class=\"keyword\">in</span> dogString.unicodeScalars &#123;</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(scalar.value)</span> \"</span>, terminator: <span class=\"string\">\"\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"68 111 103 8252 128054 \"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> scalar <span class=\"keyword\">in</span> dogString.unicodeScalars &#123;</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"<span class=\"subst\">\\(scalar)</span> \"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// D</span></div><div class=\"line\"><span class=\"comment\">// o</span></div><div class=\"line\"><span class=\"comment\">// g</span></div><div class=\"line\"><span class=\"comment\">// ‼</span></div><div class=\"line\"><span class=\"comment\">// 🐶</span></div></pre></td></tr></table></figure>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html/\" target=\"_blank\" rel=\"external\">Strings and Characters</a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;</p>\n<blockquote>\n<p>​Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>"},{"layout":"post","title":"Swift Protocols","date":"2016-12-02T11:20:11.000Z","author":"liangtong","catalog":true,"_content":"\n\n\n​\t协议 定义了用来实现某一特定任务或者功能的方法、属性，以及其他需要的东西的一个蓝图。类、结构体或枚举都可以遵循协议，并为协议定义的这些要求提供具体实现。任何类型能够满足某个协议的要求，就可以说该类型遵循这个协议。\n除了遵循协议的类型必须实现的要求外，还可以对协议进行扩展，通过扩展来实现一部分要求或者实现一些附加功能，这样遵循协议的类型就能够使用这些功能。\n\n\n\n### 协议语法\n协议的定义方式与类、结构体和枚举的定义非常相似：\n\n```Swift\nprotocol SomeProtocol {\n    // protocol definition goes here\n}\n```\n\n要让自定义类型遵循某个协议，在定义类型时，需要在类型名称后加上协议名称，中间以冒号（:）分隔。遵循多个协议时，各协议之间用逗号（,）分隔：\n\n```Swift\nstruct SomeStructure: FirstProtocol, AnotherProtocol {\n    // structure definition goes here\n}\n```\n\n拥有父类的类在遵循协议时，应该将父类名放在协议名之前，以逗号分隔：\n\n```Swift\nclass SomeClass: SomeSuperclass, FirstProtocol, AnotherProtocol {\n    // class definition goes here\n}\n```\n\n<!-- more -->\n\n### 属性要求\n协议可以要求遵循协议的类型提供特定名称和类型的实例属性或类型属性。协议不指定属性是存储型属性还是计算型属性，它只指定属性的名称和类型。此外，协议还指定属性是可读的还是可读可写的。\n如果协议要求属性是可读可写的，那么该属性不能是常量属性或只读的计算型属性。如果协议只要求属性是可读的，那么该属性不仅可以是可读的，如果代码需要的话，还可以是可写的。\n\n协议总是用 `var` 关键字来声明变量属性，在类型声明后加上 `{ set get }` 来表示属性是可读可写的，可读属性则用 `{ get }` 来表示：\n\n```Swift\nprotocol SomeProtocol {\n    var mustBeSettable: Int { get set }\n    var doesNotNeedToBeSettable: Int { get }\n}\n```\n\n在协议中定义类型属性时，总是使用 `static` 关键字作为前缀。当类类型遵循协议时，除了 `static` 关键字，还可以使用 `class` 关键字来声明类型属性：\n\n```Swift\nprotocol AnotherProtocol {\n    static var someTypeProperty: Int { get set }\n}\n```\n\n如下所示，这是一个只含有一个实例属性要求的协议：\n\n```Swift\nprotocol FullyNamed {\n    var fullName: String { get }\n}\n```\n\nFullyNamed 协议除了要求遵循协议的类型提供 fullName 属性外，并没有其他特别的要求。这个协议表示，任何遵循 FullyNamed 的类型，都必须有一个可读的 String 类型的实例属性 fullName。\n下面是一个遵循 FullyNamed 协议的简单结构体：\n\n```Swift\nstruct Person: FullyNamed {\n    var fullName: String\n}\nlet john = Person(fullName: \"John Appleseed\")\n// john.fullName is \"John Appleseed\"\n```\n\n这个例子中定义了一个叫做 Person 的结构体，用来表示一个具有名字的人。从第一行代码可以看出，它遵循了 FullyNamed 协议。\nPerson 结构体的每一个实例都有一个 String 类型的存储型属性 fullName。这正好满足了 FullyNamed 协议的要求，也就意味着 Person 结构体正确地符合了协议。（如果协议要求未被完全满足，在编译时会报错。）\n下面是一个更为复杂的类，它适配并遵循了 FullyNamed 协议：\n\n```Swift\nclass Starship: FullyNamed {\n    var prefix: String?\n    var name: String\n    init(name: String, prefix: String? = nil) {\n        self.name = name\n        self.prefix = prefix\n    }\n    var fullName: String {\n        return (prefix != nil ? prefix! + \" \" : \"\") + name\n    }\n}\nvar ncc1701 = Starship(name: \"Enterprise\", prefix: \"USS\")\n// ncc1701.fullName is \"USS Enterprise\"\n```\n\nStarship 类把 fullName 属性实现为只读的计算型属性。每一个 Starship 类的实例都有一个名为 name 的非可选属性和一个名为 prefix 的可选属性。 当 prefix 存在时，计算型属性 fullName 会将 prefix 插入到 name 之前，从而为星际飞船构建一个全名。\n\n### 方法要求（Method Requirements）\n协议可以要求遵循协议的类型实现某些指定的实例方法或类方法。这些方法作为协议的一部分，像普通方法一样放在协议的定义中，但是不需要大括号和方法体。可以在协议中定义具有可变参数的方法，和普通方法的定义方式相同。但是，不支持为协议中的方法的参数提供默认值。\n正如属性要求中所述，在协议中定义类方法的时候，总是使用 `static` 关键字作为前缀。当类类型遵循协议时，除了 `static` 关键字，还可以使用 `class` 关键字作为前缀：\n\n```Swift\nprotocol SomeProtocol {\n    static func someTypeMethod()\n}\n```\n\n下面的例子定义了一个只含有一个实例方法的协议：\n\n```Swift\nprotocol RandomNumberGenerator {\n    func random() -> Double\n}\n```\n\nRandomNumberGenerator 协议要求遵循协议的类型必须拥有一个名为 random， 返回值类型为 Double 的实例方法。\nRandomNumberGenerator 协议并不关心每一个随机数是怎样生成的，它只要求必须提供一个随机数生成器。\n\n如下所示，下边是一个遵循并符合 RandomNumberGenerator 协议的类。该类实现了一个叫做 线性同余生成器（linear congruential generator） 的伪随机数算法。\n\n```Swift\nclass LinearCongruentialGenerator: RandomNumberGenerator {\n    var lastRandom = 42.0\n    let m = 139968.0\n    let a = 3877.0\n    let c = 29573.0\n    func random() -> Double {\n        lastRandom = ((lastRandom * a + c).truncatingRemainder(dividingBy:m))\n        return lastRandom / m\n    }\n}\nlet generator = LinearCongruentialGenerator()\nprint(\"Here's a random number: \\(generator.random())\")\n// Prints \"Here's a random number: 0.37464991998171\"\nprint(\"And another one: \\(generator.random())\")\n// Prints \"And another one: 0.729023776863283\"\n```\n\n### Mutating 方法要求\n有时需要在方法中改变方法所属的实例。例如，在值类型（即结构体和枚举）的实例方法中，将 mutating 关键字作为方法的前缀，写在 `func` 关键字之前，表示可以在该方法中修改它所属的实例以及实例的任意属性的值。\n如果你在协议中定义了一个实例方法，该方法会改变遵循该协议的类型的实例，那么在定义协议时需要在方法前加 mutating 关键字。这使得结构体和枚举能够遵循此协议并满足此方法要求。\n\t实现协议中的 mutating 方法时，若是类类型，则不用写 mutating 关键字。而对于结构体和枚举，则必须写 mutating 关键字。\n\n如下所示，Togglable 协议只要求实现一个名为 toggle 的实例方法。根据名称的暗示，toggle() 方法将改变实例属性，从而切换遵循该协议类型的实例的状态。\ntoggle() 方法在定义的时候，使用 mutating 关键字标记，这表明当它被调用时，该方法将会改变遵循协议的类型的实例：\n\n```Swift\nprotocol Togglable {\n    mutating func toggle()\n}\n```\n\n当使用枚举或结构体来实现 Togglable 协议时，需要提供一个带有 mutating 前缀的 toggle() 方法。\n下面定义了一个名为 OnOffSwitch 的枚举。这个枚举在两种状态之间进行切换，用枚举成员 On 和 Off 表示。枚举的 toggle() 方法被标记为 mutating，以满足 Togglable 协议的要求：\n\n```Swift\nenum OnOffSwitch: Togglable {\n    case off, on\n    mutating func toggle() {\n        switch self {\n        case .off:\n            self = .on\n        case .on:\n            self = .off\n        }\n    }\n}\nvar lightSwitch = OnOffSwitch.off\nlightSwitch.toggle()\n// lightSwitch is now equal to .on\n```\n\n\n### 构造器要求\n协议可以要求遵循协议的类型实现指定的构造器。你可以像编写普通构造器那样，在协议的定义里写下构造器的声明，但不需要写花括号和构造器的实体：\n\n```Swift\nprotocol SomeProtocol {\n    init(someParameter: Int)\n}\n```\n\n#### 协议中的构造器在类中的实现\n你可以在遵循协议的类中实现构造器，无论是作为指定构造器，还是作为便利构造器。无论哪种情况，你都必须为构造器实现标上 `required` 修饰符：\n\n```Swift\nclass SomeClass: SomeProtocol {\n    required init(someParameter: Int) {\n        // initializer implementation goes here\n    }\n}\n```\n\n使用 required 修饰符可以确保所有子类也必须提供此构造器实现，从而也能符合协议。\n\t如果类已经被标记为 final，那么不需要在协议构造器的实现中使用 required 修饰符，因为 final 类不能有子类。\n\n\n如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求，那么该构造器的实现需要同时标注 `required` 和 `override` 修饰符：\n\n```Swift\nprotocol SomeProtocol {\n    init()\n}\n \nclass SomeSuperClass {\n    init() {\n        // initializer implementation goes here\n    }\n}\n \nclass SomeSubClass: SomeSuperClass, SomeProtocol {\n    // \"required\" from SomeProtocol conformance; \"override\" from SomeSuperClass\n    required override init() {\n        // initializer implementation goes here\n    }\n}\n```\n\n#### 可失败构造器要求\n协议还可以为遵循协议的类型定义可失败构造器要求\n遵循协议的类型可以通过可失败构造器（init?）或非可失败构造器（init）来满足协议中定义的可失败构造器要求。协议中定义的非可失败构造器要求可以通过非可失败构造器（init）或隐式解包可失败构造器（init!）来满足。\n\n### 协议作为类型\n尽管协议本身并未实现任何功能，但是协议可以被当做一个成熟的类型来使用。\n协议可以像其他普通类型一样使用，使用场景包括：\n\n * 作为函数、方法或构造器中的参数类型或返回值类型\n * 作为常量、变量或属性的类型\n * 作为数组、字典或其他容器中的元素类型\n\n\t协议是一种类型，因此协议类型的名称应与其他类型（例如 Int，Double，String）的写法相同，使用大写字母开头的驼峰式写法，例如（FullyNamed 和 RandomNumberGenerator）。\n\n下面是将协议作为类型使用的例子：\n\n```Swift\nclass Dice {\n    let sides: Int\n    let generator: RandomNumberGenerator\n    init(sides: Int, generator: RandomNumberGenerator) {\n        self.sides = sides\n        self.generator = generator\n    }\n    func roll() -> Int {\n        return Int(generator.random() * Double(sides)) + 1\n    }\n}\n```\n\n例子中定义了一个 Dice 类，用来代表桌游中拥有 N 个面的骰子。Dice 的实例含有 sides 和 generator 两个属性，前者是整型，用来表示骰子有几个面，后者为骰子提供一个随机数生成器，从而生成随机点数。\ngenerator 属性的类型为 RandomNumberGenerator，因此任何遵循了 RandomNumberGenerator 协议的类型的实例都可以赋值给 generator，除此之外并无其他要求。\nDice 类还有一个构造器，用来设置初始状态。构造器有一个名为 generator，类型为 RandomNumberGenerator 的形参。在调用构造方法创建 Dice 的实例时，可以传入任何遵循 RandomNumberGenerator 协议的实例给 generator。\nDice 类提供了一个名为 roll 的实例方法，用来模拟骰子的面值。它先调用 generator 的 random() 方法来生成一个 [0.0,1.0) 区间内的随机数，然后使用这个随机数生成正确的骰子面值。因为 generator 遵循了 RandomNumberGenerator 协议，可以确保它有个 random() 方法可供调用。\n\n下面的例子展示了如何使用 LinearCongruentialGenerator 的实例作为随机数生成器来创建一个六面骰子：\n\n```Swift\nvar d6 = Dice(sides: 6, generator: LinearCongruentialGenerator())\nfor _ in 1...5 {\n    print(\"Random dice roll is \\(d6.roll())\")\n}\n// Random dice roll is 3\n// Random dice roll is 5\n// Random dice roll is 4\n// Random dice roll is 5\n// Random dice roll is 4\n```\n\n### 委托（代理）模式\n委托是一种设计模式，它允许类或结构体将一些需要它们负责的功能委托给其他类型的实例。委托模式的实现很简单：定义协议来封装那些需要被委托的功能，这样就能确保遵循协议的类型能提供这些功能。委托模式可以用来响应特定的动作，或者接收外部数据源提供的数据，而无需关心外部数据源的类型。\n下面的例子定义了两个基于骰子游戏的协议：\n\n```Swift\nprotocol DiceGame {\n    var dice: Dice { get }\n    func play()\n}\nprotocol DiceGameDelegate {\n    func gameDidStart(_ game: DiceGame)\n    func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int)\n    func gameDidEnd(_ game: DiceGame)\n}\n```\n\nDiceGame 协议可以被任意涉及骰子的游戏遵循。DiceGameDelegate 协议可以被任意类型遵循，用来追踪 DiceGame 的游戏过程。\n\n如下所示，SnakesAndLadders 是 控制流 章节引入的蛇梯棋游戏的新版本。新版本使用 Dice 实例作为骰子，并且实现了 DiceGame 和 DiceGameDelegate 协议，后者用来记录游戏的过程：\n\n```Swift\nclass SnakesAndLadders: DiceGame {\n    let finalSquare = 25\n    let dice = Dice(sides: 6, generator: LinearCongruentialGenerator())\n    var square = 0\n    var board: [Int]\n    init() {\n        board = Array(repeating: 0, count: finalSquare + 1)\n        board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02\n        board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08\n    }\n    var delegate: DiceGameDelegate?\n    func play() {\n        square = 0\n        delegate?.gameDidStart(self)\n        gameLoop: while square != finalSquare {\n            let diceRoll = dice.roll()\n            delegate?.game(self, didStartNewTurnWithDiceRoll: diceRoll)\n            switch square + diceRoll {\n            case finalSquare:\n                break gameLoop\n            case let newSquare where newSquare > finalSquare:\n                continue gameLoop\n            default:\n                square += diceRoll\n                square += board[square]\n            }\n        }\n        delegate?.gameDidEnd(self)\n    }\n}\n```\n\n这个版本的游戏封装到了 SnakesAndLadders 类中，该类遵循了 DiceGame 协议，并且提供了相应的可读的 dice 属性和 play() 方法。（ dice 属性在构造之后就不再改变，且协议只要求 dice 为可读的，因此将 dice 声明为常量属性。）\n游戏使用 SnakesAndLadders 类的 init() 构造器来初始化游戏。所有的游戏逻辑被转移到了协议中的 play() 方法，play() 方法使用协议要求的 dice 属性提供骰子摇出的值。\n注意，delegate 并不是游戏的必备条件，因此 delegate 被定义为 DiceGameDelegate 类型的可选属性。因为 delegate 是可选值，因此会被自动赋予初始值 nil。随后，可以在游戏中为 delegate 设置适当的值。\n\nDicegameDelegate 协议提供了三个方法用来追踪游戏过程。这三个方法被放置于游戏的逻辑中，即 play() 方法内。分别在游戏开始时，新一轮开始时，以及游戏结束时被调用。\n\n因为 delegate 是一个 DiceGameDelegate 类型的可选属性，因此在 play() 方法中通过可选链式调用来调用它的方法。若 delegate 属性为 nil，则调用方法会优雅地失败，并不会产生错误。若 delegate 不为 nil，则方法能够被调用，并传递 SnakesAndLadders 实例作为参数。\n\n如下示例定义了 DiceGameTracker 类，它遵循了 DiceGameDelegate 协议：\n\n```Swift\nclass DiceGameTracker: DiceGameDelegate {\n    var numberOfTurns = 0\n    func gameDidStart(_ game: DiceGame) {\n        numberOfTurns = 0\n        if game is SnakesAndLadders {\n            print(\"Started a new game of Snakes and Ladders\")\n        }\n        print(\"The game is using a \\(game.dice.sides)-sided dice\")\n    }\n    func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) {\n        numberOfTurns += 1\n        print(\"Rolled a \\(diceRoll)\")\n    }\n    func gameDidEnd(_ game: DiceGame) {\n        print(\"The game lasted for \\(numberOfTurns) turns\")\n    }\n}\n```\n\nDiceGameTracker 实现了 DiceGameDelegate 协议要求的三个方法，用来记录游戏已经进行的轮数。当游戏开始时，numberOfTurns 属性被赋值为 0，然后在每新一轮中递增，游戏结束后，打印游戏的总轮数。\nDiceGameTracker 的运行情况如下所示：\n\n```Swift\nlet tracker = DiceGameTracker()\nlet game = SnakesAndLadders()\ngame.delegate = tracker\ngame.play()\n// Started a new game of Snakes and Ladders\n// The game is using a 6-sided dice\n// Rolled a 3\n// Rolled a 5\n// Rolled a 4\n// Rolled a 5\n// The game lasted for 4 turns\n```\n\n### 通过扩展遵循协议\n即便无法修改源代码，依然可以通过扩展令已有类型遵循并符合协议。扩展可以为已有类型添加属性、方法、下标以及构造器，因此可以符合协议中的相应要求。\n\t通过扩展令已有类型遵循并符合协议时，该类型的所有实例也会随之获得协议中定义的各项功能。\n\n例如下面这个 TextRepresentable 协议，任何想要通过文本表示一些内容的类型都可以实现该协议。这些想要表示的内容可以是实例本身的描述，也可以是实例当前状态的文本描述：\n\n```Swift\nprotocol TextRepresentable {\n    var textualDescription: String { get }\n}\n```\n\n可以通过扩展，令先前提到的 Dice 类遵循并符合 TextRepresentable 协议：\n\n```Swift\nextension Dice: TextRepresentable {\n    var textualDescription: String {\n        return \"A \\(sides)-sided dice\"\n    }\n}\n```\n\n通过扩展遵循并符合协议，和在原始定义中遵循并符合协议的效果完全相同。协议名称写在类型名之后，以冒号隔开，然后在扩展的大括号内实现协议要求的内容。\n现在所有 Dice 的实例都可以看做 TextRepresentable 类型：\n\n```Swift\nlet d12 = Dice(sides: 12, generator: LinearCongruentialGenerator())\nprint(d12.textualDescription)\n// Prints \"A 12-sided dice\"\n```\n\n同样，SnakesAndLadders 类也可以通过扩展遵循并符合 TextRepresentable 协议：\n\n```Swift\nextension SnakesAndLadders: TextRepresentable {\n    var textualDescription: String {\n        return \"A game of Snakes and Ladders with \\(finalSquare) squares\"\n    }\n}\nprint(game.textualDescription)\n// Prints \"A game of Snakes and Ladders with 25 squares\"\n```\n\n#### 通过扩展遵循协议\n当一个类型已经符合了某个协议中的所有要求，却还没有声明遵循该协议时，可以通过空扩展体的扩展来遵循该协议：\n\n```Swift\nstruct Hamster {\n    var name: String\n    var textualDescription: String {\n        return \"A hamster named \\(name)\"\n    }\n}\nextension Hamster: TextRepresentable {}\n```\n\n从现在起，Hamster 的实例可以作为 TextRepresentable 类型使用：\n\n```Swift\nlet simonTheHamster = Hamster(name: \"Simon\")\nlet somethingTextRepresentable: TextRepresentable = simonTheHamster\nprint(somethingTextRepresentable.textualDescription)\n// Prints \"A hamster named Simon\"\n```\n\n\t即使满足了协议的所有要求，类型也不会自动遵循协议，必须显式地遵循协议。\n\n\n### 协议类型的集合\n协议类型可以在数组或者字典这样的集合中使用，在协议类型提到了这样的用法。下面的例子创建了一个元素类型为 TextRepresentable 的数组：\n\n```Swift\nlet things: [TextRepresentable] = [game, d12, simonTheHamster]\n```\n\n如下所示，可以遍历 things 数组，并打印每个元素的文本表示：\n\n```Swift\nfor thing in things {\n    print(thing.textualDescription)\n}\n// A game of Snakes and Ladders with 25 squares\n// A 12-sided dice\n// A hamster named Simon\n```\n\nthing 是 TextRepresentable 类型而不是 Dice，DiceGame，Hamster 等类型，即使实例在幕后确实是这些类型中的一种。由于 thing 是 TextRepresentable 类型，任何 TextRepresentable 的实例都有一个 textualDescription 属性，所以在每次循环中可以安全地访问 thing.textualDescription。\n\n### 协议的继承\n协议能够继承一个或多个其他协议，可以在继承的协议的基础上增加新的要求。协议的继承语法与类的继承相似，多个被继承的协议间用逗号分隔：\n\n```Swift\nprotocol InheritingProtocol: SomeProtocol, AnotherProtocol {\n    // protocol definition goes here\n}\n```\n\n如下所示，PrettyTextRepresentable 协议继承了 TextRepresentable 协议：\n\n```Swift\nprotocol PrettyTextRepresentable: TextRepresentable {\n    var prettyTextualDescription: String { get }\n}\n```\n\n例子中定义了一个新的协议 PrettyTextRepresentable，它继承自 TextRepresentable 协议。任何遵循 PrettyTextRepresentable 协议的类型在满足该协议的要求时，也必须满足 TextRepresentable 协议的要求。在这个例子中，PrettyTextRepresentable 协议额外要求遵循协议的类型提供一个返回值为 String 类型的 prettyTextualDescription 属性。\n\n如下所示，扩展 SnakesAndLadders，使其遵循并符合 PrettyTextRepresentable 协议：\n\n```Swift\nextension SnakesAndLadders: PrettyTextRepresentable {\n    var prettyTextualDescription: String {\n        var output = textualDescription + \":\\n\"\n        for index in 1...finalSquare {\n            switch board[index] {\n            case let ladder where ladder > 0:\n                output += \"▲ \"\n            case let snake where snake < 0:\n                output += \"▼ \"\n            default:\n                output += \"○ \"\n            }\n        }\n        return output\n    }\n}\n```\n\n上述扩展令 SnakesAndLadders 遵循了 PrettyTextRepresentable 协议，并提供了协议要求的 prettyTextualDescription 属性。每个 PrettyTextRepresentable 类型同时也是 TextRepresentable 类型，所以在 prettyTextualDescription 的实现中，可以访问 textualDescription 属性。\n\n任意 SankesAndLadders 的实例都可以使用 prettyTextualDescription 属性来打印一个漂亮的文本描述：\n\n\n```Swift\nprint(game.prettyTextualDescription)\n// A game of Snakes and Ladders with 25 squares:\n// ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○\n```\n\n### 类类型专属协议\n你可以在协议的继承列表中，通过添加 class 关键字来限制协议只能被类类型遵循，而结构体或枚举不能遵循该协议。`class` 关键字必须第一个出现在协议的继承列表中，在其他继承的协议之前：\n\n```Swift\nprotocol SomeClassOnlyProtocol: class, SomeInheritedProtocol {\n    // class-only protocol definition goes here\n}\n```\n\n在以上例子中，协议 SomeClassOnlyProtocol 只能被类类型遵循。如果尝试让结构体或枚举类型遵循该协议，则会导致编译错误。\n\n\t当协议定义的要求需要遵循协议的类型必须是引用语义而非值语义时，应该采用类类型专属协议。\n\n\n### 协议合成\n有时候需要同时遵循多个协议，你可以将多个协议采用 SomeProtocol & AnotherProtocol 这样的格式进行组合，称为 协议合成（protocol composition）。你可以罗列任意多个你想要遵循的协议，以与符号(&)分隔。\n\n下面的例子中，将 Named 和 Aged 两个协议按照上述语法组合成一个协议，作为函数参数的类型：\n\n```Swift\nprotocol Named {\n    var name: String { get }\n}\nprotocol Aged {\n    var age: Int { get }\n}\nstruct Person: Named, Aged {\n    var name: String\n    var age: Int\n}\nfunc wishHappyBirthday(to celebrator: Named & Aged) {\n    print(\"Happy birthday, \\(celebrator.name), you're \\(celebrator.age)!\")\n}\nlet birthdayPerson = Person(name: \"Malcolm\", age: 21)\nwishHappyBirthday(to: birthdayPerson)\n// Prints \"Happy birthday, Malcolm, you're 21!\"\n```\n\nNamed 协议包含 String 类型的 name 属性。Aged 协议包含 Int 类型的 age 属性。Person 结构体遵循了这两个协议。\nwishHappyBirthday(to:) 函数的参数 celebrator 的类型为 Named & Aged。这意味着它不关心参数的具体类型，只要参数符合这两个协议即可。\n上面的例子创建了一个名为 birthdayPerson 的 Person 的实例，作为参数传递给了 wishHappyBirthday(to:) 函数。因为 Person 同时符合这两个协议，所以这个参数合法，函数将打印生日问候语。\n\n\t协议合成并不会生成新的、永久的协议类型，而是将多个协议中的要求合成到一个只在局部作用域有效的临时协议中。\n\n\n### 检查协议一致性\n你可以使用类型转换中描述的 is 和 as 操作符来检查协议一致性，即是否符合某协议，并且可以转换到指定的协议类型。检查和转换到某个协议类型在语法上和类型的检查和转换完全相同：\n\n * is 用来检查实例是否符合某个协议，若符合则返回 true，否则返回 false。\n * as? 返回一个可选值，当实例符合某个协议时，返回类型为协议类型的可选值，否则返回 nil。\n * as! 将实例强制向下转换到某个协议类型，如果强转失败，会引发运行时错误。\n\nThis example defines a protocol called HasArea, with a single property requirement of a gettable Double property called area:\n\n```Swift\nprotocol HasArea {\n    var area: Double { get }\n}\n```\n\nHere are two classes, Circle and Country, both of which conform to the HasArea protocol:\n\n```Swift\nclass Circle: HasArea {\n    let pi = 3.1415927\n    var radius: Double\n    var area: Double { return pi * radius * radius }\n    init(radius: Double) { self.radius = radius }\n}\nclass Country: HasArea {\n    var area: Double\n    init(area: Double) { self.area = area }\n}\n```\n\nCircle 类把 area 属性实现为基于存储型属性 radius 的计算型属性。Country 类则把 area 属性实现为存储型属性。这两个类都正确地符合了 HasArea 协议。\n\n如下所示，Animal 是一个未遵循 HasArea 协议的类：\n\n```Swift\nclass Animal {\n    var legs: Int\n    init(legs: Int) { self.legs = legs }\n}\n```\n\nCircle，Country，Animal 并没有一个共同的基类，尽管如此，它们都是类，它们的实例都可以作为 AnyObject 类型的值，存储在同一个数组中：\n\n```Swift\nlet objects: [AnyObject] = [\n    Circle(radius: 2.0),\n    Country(area: 243_610),\n    Animal(legs: 4)\n]\n```\n\n如下所示，objects 数组可以被迭代，并对迭代出的每一个元素进行检查，看它是否符合 HasArea 协议：\n\n```Swift\nfor object in objects {\n    if let objectWithArea = object as? HasArea {\n        print(\"Area is \\(objectWithArea.area)\")\n    } else {\n        print(\"Something that doesn't have an area\")\n    }\n}\n// Area is 12.5663708\n// Area is 243610.0\n// Something that doesn't have an area\n```\n\n当迭代出的元素符合 HasArea 协议时，将 as? 操作符返回的可选值通过可选绑定，绑定到 objectWithArea 常量上。objectWithArea 是 HasArea 协议类型的实例，因此 area 属性可以被访问和打印。\n\nobjects 数组中的元素的类型并不会因为强转而丢失类型信息，它们仍然是 Circle，Country，Animal 类型。然而，当它们被赋值给 objectWithArea 常量时，只被视为 HasArea 类型，因此只有 area 属性能够被访问。\n\n### 可选的协议要求\n协议可以定义可选要求，遵循协议的类型可以选择是否实现这些要求。在协议中使用 optional 关键字作为前缀来定义可选要求。可选要求用在你需要和 Objective-C 打交道的代码中。协议和可选要求都必须带上@objc属性。标记 @objc 特性的协议只能被继承自 Objective-C 类的类或者 @objc 类遵循，其他类以及结构体和枚举均不能遵循这种协议。\n\n使用可选要求时（例如，可选的方法或者属性），它们的类型会自动变成可选的。比如，一个类型为 (Int) -> String 的方法会变成 ((Int) -> String)?\n\n协议中的可选要求可通过可选链式调用来使用，因为遵循协议的类型可能没有实现这些可选要求。类似 someOptionalMethod?(someArgument) 这样，你可以在可选方法名称后加上 ? 来调用可选方法。\n\n下面的例子定义了一个名为 Counter 的用于整数计数的类，它使用外部的数据源来提供每次的增量。数据源由 CounterDataSource 协议定义，包含两个可选要求：\n\n```Swift\n@objc protocol CounterDataSource {\n    @objc optional func increment(forCount count: Int) -> Int\n    @objc optional var fixedIncrement: Int { get }\n}\n```\n\nCounterDataSource 协议定义了一个可选方法 increment(forCount:) 和一个可选属性 fiexdIncrement，它们使用了不同的方法来从数据源中获取适当的增量值。\n\t严格来讲，CounterDataSource 协议中的方法和属性都是可选的，因此遵循协议的类可以不实现这些要求\n\nCounter 类含有 CounterDataSource? 类型的可选属性 dataSource，如下所示：\n\n```Swift\nclass Counter {\n    var count = 0\n    var dataSource: CounterDataSource?\n    func increment() {\n        if let amount = dataSource?.increment?(forCount: count) {\n            count += amount\n        } else if let amount = dataSource?.fixedIncrement {\n            count += amount\n        }\n    }\n}\n```\n\n下面的例子展示了 CounterDataSource 的简单实现。ThreeSource 类遵循了 CounterDataSource 协议，它实现了可选属性 fixedIncrement，每次会返回 3：\n\n```Swift\nclass ThreeSource: NSObject, CounterDataSource {\n    let fixedIncrement = 3\n}\n```\n\n可以使用 ThreeSource 的实例作为 Counter 实例的数据源：\n\n```Swift\nvar counter = Counter()\ncounter.dataSource = ThreeSource()\nfor _ in 1...4 {\n    counter.increment()\n    print(counter.count)\n}\n// 3\n// 6\n// 9\n// 12\n```\n\n上述代码新建了一个 Counter 实例，并将它的数据源设置为一个 ThreeSource 的实例，然后调用 increment() 方法四次。和预期一样，每次调用都会将 count 的值增加 3.\n\n下面是一个更为复杂的数据源 TowardsZeroSource，它将使得最后的值变为 0：\n\n```Objective-C\n@objc class TowardsZeroSource: NSObject, CounterDataSource {\n    func increment(forCount count: Int) -> Int {\n        if count == 0 {\n            return 0\n        } else if count < 0 {\n            return 1\n        } else {\n            return -1\n        }\n    }\n}\n```\n\n你可以使用 TowardsZeroSource 实例将 Counter 实例来从 -4 增加到 0。一旦增加到 0，数值便不会再有变动：\n\n```Swift\ncounter.count = -4\ncounter.dataSource = TowardsZeroSource()\nfor _ in 1...5 {\n    counter.increment()\n    print(counter.count)\n}\n// -3\n// -2\n// -1\n// 0\n// 0\n```\n\n\n### 协议扩展\n协议可以通过扩展来为遵循协议的类型提供属性、方法以及下标的实现。通过这种方式，你可以基于协议本身来实现这些功能，而无需在每个遵循协议的类型中都重复同样的实现，也无需使用全局函数。\n例如，可以扩展 RandomNumberGenerator 协议来提供 randomBool() 方法。该方法使用协议中定义的 random() 方法来返回一个随机的 Bool 值：\n\n```Swift\nextension RandomNumberGenerator {\n    func randomBool() -> Bool {\n        return random() > 0.5\n    }\n}\n```\n\n通过协议扩展，所有遵循协议的类型，都能自动获得这个扩展所增加的方法实现，无需任何额外修改：\n\n```Swift\nlet generator = LinearCongruentialGenerator()\nprint(\"Here's a random number: \\(generator.random())\")\n// Prints \"Here's a random number: 0.37464991998171\"\nprint(\"And here's a random Boolean: \\(generator.randomBool())\")\n// Prints \"And here's a random Boolean: true\"\n```\n\n#### 提供默认实现\n可以通过协议扩展来为协议要求的属性、方法以及下标提供默认的实现。如果遵循协议的类型为这些要求提供了自己的实现，那么这些自定义实现将会替代扩展中的默认实现被使用。\n\t通过协议扩展为协议要求提供的默认实现和可选的协议要求不同。虽然在这两种情况下，遵循协议的类型都无需自己实现这些要求，但是通过扩展提供的默认实现可以直接调用，而无需使用可选链式调用。\n\n例如，PrettyTextRepresentable 协议继承自 TextRepresentable 协议，可以为其提供一个默认的 prettyTextualDescription 属性，只是简单地返回 textualDescription 属性的值：\n\n```Swift\nextension PrettyTextRepresentable  {\n    var prettyTextualDescription: String {\n        return textualDescription\n    }\n}\n```\n\n\n\n\n#### 为协议扩展添加限制条件\n在扩展协议的时候，可以指定一些限制条件，只有遵循协议的类型满足这些限制条件时，才能获得协议扩展提供的默认实现。这些限制条件写在协议名之后，使用 where 子句来描述\n例如，你可以扩展 CollectionType 协议，但是只适用于集合中的元素遵循了 TextRepresentable 协议的情况：\n\n```Swift\nextension Collection where Iterator.Element: TextRepresentable {\n    var textualDescription: String {\n        let itemsAsText = self.map { $0.textualDescription }\n        return \"[\" + itemsAsText.joined(separator: \", \") + \"]\"\n    }\n}\n```\n\ntextualDescription 属性返回整个集合的文本描述，它将集合中的每个元素的文本描述以逗号分隔的方式连接起来，包在一对方括号中。\n现在我们来看看先前的 Hamster 结构体，它符合 TextRepresentable 协议，同时这里还有个装有 Hamster 的实例的数组：\n\n```Swift\nlet murrayTheHamster = Hamster(name: \"Murray\")\nlet morganTheHamster = Hamster(name: \"Morgan\")\nlet mauriceTheHamster = Hamster(name: \"Maurice\")\nlet hamsters = [murrayTheHamster, morganTheHamster, mauriceTheHamster]\n```\n\n因为 Array 符合 CollectionType 协议，而数组中的元素又符合 TextRepresentable 协议，所以数组可以使用 textualDescription 属性得到数组内容的文本表示：\n\n```Swift\nprint(hamsters.textualDescription)\n// Prints \"[A hamster named Murray, A hamster named Morgan, A hamster named Maurice]\"\n```\n\n\t如果多个协议扩展都为同一个协议要求提供了默认实现，而遵循协议的类型又同时满足这些协议扩展的限制条件，那么将会使用限制条件最多的那个协议扩展提供的默认实现。\n\n\n\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html/\"> Protocols </a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","source":"_posts/iOS_Swift_language_note_Protocols.md","raw":"---\nlayout:     post\ntitle:      Swift Protocols\ndate:       2016-12-02 19:20:11\nauthor:     liangtong\ncatalog: true\ncategories: iOS\ntags: Swift \n\n---\n\n\n\n​\t协议 定义了用来实现某一特定任务或者功能的方法、属性，以及其他需要的东西的一个蓝图。类、结构体或枚举都可以遵循协议，并为协议定义的这些要求提供具体实现。任何类型能够满足某个协议的要求，就可以说该类型遵循这个协议。\n除了遵循协议的类型必须实现的要求外，还可以对协议进行扩展，通过扩展来实现一部分要求或者实现一些附加功能，这样遵循协议的类型就能够使用这些功能。\n\n\n\n### 协议语法\n协议的定义方式与类、结构体和枚举的定义非常相似：\n\n```Swift\nprotocol SomeProtocol {\n    // protocol definition goes here\n}\n```\n\n要让自定义类型遵循某个协议，在定义类型时，需要在类型名称后加上协议名称，中间以冒号（:）分隔。遵循多个协议时，各协议之间用逗号（,）分隔：\n\n```Swift\nstruct SomeStructure: FirstProtocol, AnotherProtocol {\n    // structure definition goes here\n}\n```\n\n拥有父类的类在遵循协议时，应该将父类名放在协议名之前，以逗号分隔：\n\n```Swift\nclass SomeClass: SomeSuperclass, FirstProtocol, AnotherProtocol {\n    // class definition goes here\n}\n```\n\n<!-- more -->\n\n### 属性要求\n协议可以要求遵循协议的类型提供特定名称和类型的实例属性或类型属性。协议不指定属性是存储型属性还是计算型属性，它只指定属性的名称和类型。此外，协议还指定属性是可读的还是可读可写的。\n如果协议要求属性是可读可写的，那么该属性不能是常量属性或只读的计算型属性。如果协议只要求属性是可读的，那么该属性不仅可以是可读的，如果代码需要的话，还可以是可写的。\n\n协议总是用 `var` 关键字来声明变量属性，在类型声明后加上 `{ set get }` 来表示属性是可读可写的，可读属性则用 `{ get }` 来表示：\n\n```Swift\nprotocol SomeProtocol {\n    var mustBeSettable: Int { get set }\n    var doesNotNeedToBeSettable: Int { get }\n}\n```\n\n在协议中定义类型属性时，总是使用 `static` 关键字作为前缀。当类类型遵循协议时，除了 `static` 关键字，还可以使用 `class` 关键字来声明类型属性：\n\n```Swift\nprotocol AnotherProtocol {\n    static var someTypeProperty: Int { get set }\n}\n```\n\n如下所示，这是一个只含有一个实例属性要求的协议：\n\n```Swift\nprotocol FullyNamed {\n    var fullName: String { get }\n}\n```\n\nFullyNamed 协议除了要求遵循协议的类型提供 fullName 属性外，并没有其他特别的要求。这个协议表示，任何遵循 FullyNamed 的类型，都必须有一个可读的 String 类型的实例属性 fullName。\n下面是一个遵循 FullyNamed 协议的简单结构体：\n\n```Swift\nstruct Person: FullyNamed {\n    var fullName: String\n}\nlet john = Person(fullName: \"John Appleseed\")\n// john.fullName is \"John Appleseed\"\n```\n\n这个例子中定义了一个叫做 Person 的结构体，用来表示一个具有名字的人。从第一行代码可以看出，它遵循了 FullyNamed 协议。\nPerson 结构体的每一个实例都有一个 String 类型的存储型属性 fullName。这正好满足了 FullyNamed 协议的要求，也就意味着 Person 结构体正确地符合了协议。（如果协议要求未被完全满足，在编译时会报错。）\n下面是一个更为复杂的类，它适配并遵循了 FullyNamed 协议：\n\n```Swift\nclass Starship: FullyNamed {\n    var prefix: String?\n    var name: String\n    init(name: String, prefix: String? = nil) {\n        self.name = name\n        self.prefix = prefix\n    }\n    var fullName: String {\n        return (prefix != nil ? prefix! + \" \" : \"\") + name\n    }\n}\nvar ncc1701 = Starship(name: \"Enterprise\", prefix: \"USS\")\n// ncc1701.fullName is \"USS Enterprise\"\n```\n\nStarship 类把 fullName 属性实现为只读的计算型属性。每一个 Starship 类的实例都有一个名为 name 的非可选属性和一个名为 prefix 的可选属性。 当 prefix 存在时，计算型属性 fullName 会将 prefix 插入到 name 之前，从而为星际飞船构建一个全名。\n\n### 方法要求（Method Requirements）\n协议可以要求遵循协议的类型实现某些指定的实例方法或类方法。这些方法作为协议的一部分，像普通方法一样放在协议的定义中，但是不需要大括号和方法体。可以在协议中定义具有可变参数的方法，和普通方法的定义方式相同。但是，不支持为协议中的方法的参数提供默认值。\n正如属性要求中所述，在协议中定义类方法的时候，总是使用 `static` 关键字作为前缀。当类类型遵循协议时，除了 `static` 关键字，还可以使用 `class` 关键字作为前缀：\n\n```Swift\nprotocol SomeProtocol {\n    static func someTypeMethod()\n}\n```\n\n下面的例子定义了一个只含有一个实例方法的协议：\n\n```Swift\nprotocol RandomNumberGenerator {\n    func random() -> Double\n}\n```\n\nRandomNumberGenerator 协议要求遵循协议的类型必须拥有一个名为 random， 返回值类型为 Double 的实例方法。\nRandomNumberGenerator 协议并不关心每一个随机数是怎样生成的，它只要求必须提供一个随机数生成器。\n\n如下所示，下边是一个遵循并符合 RandomNumberGenerator 协议的类。该类实现了一个叫做 线性同余生成器（linear congruential generator） 的伪随机数算法。\n\n```Swift\nclass LinearCongruentialGenerator: RandomNumberGenerator {\n    var lastRandom = 42.0\n    let m = 139968.0\n    let a = 3877.0\n    let c = 29573.0\n    func random() -> Double {\n        lastRandom = ((lastRandom * a + c).truncatingRemainder(dividingBy:m))\n        return lastRandom / m\n    }\n}\nlet generator = LinearCongruentialGenerator()\nprint(\"Here's a random number: \\(generator.random())\")\n// Prints \"Here's a random number: 0.37464991998171\"\nprint(\"And another one: \\(generator.random())\")\n// Prints \"And another one: 0.729023776863283\"\n```\n\n### Mutating 方法要求\n有时需要在方法中改变方法所属的实例。例如，在值类型（即结构体和枚举）的实例方法中，将 mutating 关键字作为方法的前缀，写在 `func` 关键字之前，表示可以在该方法中修改它所属的实例以及实例的任意属性的值。\n如果你在协议中定义了一个实例方法，该方法会改变遵循该协议的类型的实例，那么在定义协议时需要在方法前加 mutating 关键字。这使得结构体和枚举能够遵循此协议并满足此方法要求。\n\t实现协议中的 mutating 方法时，若是类类型，则不用写 mutating 关键字。而对于结构体和枚举，则必须写 mutating 关键字。\n\n如下所示，Togglable 协议只要求实现一个名为 toggle 的实例方法。根据名称的暗示，toggle() 方法将改变实例属性，从而切换遵循该协议类型的实例的状态。\ntoggle() 方法在定义的时候，使用 mutating 关键字标记，这表明当它被调用时，该方法将会改变遵循协议的类型的实例：\n\n```Swift\nprotocol Togglable {\n    mutating func toggle()\n}\n```\n\n当使用枚举或结构体来实现 Togglable 协议时，需要提供一个带有 mutating 前缀的 toggle() 方法。\n下面定义了一个名为 OnOffSwitch 的枚举。这个枚举在两种状态之间进行切换，用枚举成员 On 和 Off 表示。枚举的 toggle() 方法被标记为 mutating，以满足 Togglable 协议的要求：\n\n```Swift\nenum OnOffSwitch: Togglable {\n    case off, on\n    mutating func toggle() {\n        switch self {\n        case .off:\n            self = .on\n        case .on:\n            self = .off\n        }\n    }\n}\nvar lightSwitch = OnOffSwitch.off\nlightSwitch.toggle()\n// lightSwitch is now equal to .on\n```\n\n\n### 构造器要求\n协议可以要求遵循协议的类型实现指定的构造器。你可以像编写普通构造器那样，在协议的定义里写下构造器的声明，但不需要写花括号和构造器的实体：\n\n```Swift\nprotocol SomeProtocol {\n    init(someParameter: Int)\n}\n```\n\n#### 协议中的构造器在类中的实现\n你可以在遵循协议的类中实现构造器，无论是作为指定构造器，还是作为便利构造器。无论哪种情况，你都必须为构造器实现标上 `required` 修饰符：\n\n```Swift\nclass SomeClass: SomeProtocol {\n    required init(someParameter: Int) {\n        // initializer implementation goes here\n    }\n}\n```\n\n使用 required 修饰符可以确保所有子类也必须提供此构造器实现，从而也能符合协议。\n\t如果类已经被标记为 final，那么不需要在协议构造器的实现中使用 required 修饰符，因为 final 类不能有子类。\n\n\n如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求，那么该构造器的实现需要同时标注 `required` 和 `override` 修饰符：\n\n```Swift\nprotocol SomeProtocol {\n    init()\n}\n \nclass SomeSuperClass {\n    init() {\n        // initializer implementation goes here\n    }\n}\n \nclass SomeSubClass: SomeSuperClass, SomeProtocol {\n    // \"required\" from SomeProtocol conformance; \"override\" from SomeSuperClass\n    required override init() {\n        // initializer implementation goes here\n    }\n}\n```\n\n#### 可失败构造器要求\n协议还可以为遵循协议的类型定义可失败构造器要求\n遵循协议的类型可以通过可失败构造器（init?）或非可失败构造器（init）来满足协议中定义的可失败构造器要求。协议中定义的非可失败构造器要求可以通过非可失败构造器（init）或隐式解包可失败构造器（init!）来满足。\n\n### 协议作为类型\n尽管协议本身并未实现任何功能，但是协议可以被当做一个成熟的类型来使用。\n协议可以像其他普通类型一样使用，使用场景包括：\n\n * 作为函数、方法或构造器中的参数类型或返回值类型\n * 作为常量、变量或属性的类型\n * 作为数组、字典或其他容器中的元素类型\n\n\t协议是一种类型，因此协议类型的名称应与其他类型（例如 Int，Double，String）的写法相同，使用大写字母开头的驼峰式写法，例如（FullyNamed 和 RandomNumberGenerator）。\n\n下面是将协议作为类型使用的例子：\n\n```Swift\nclass Dice {\n    let sides: Int\n    let generator: RandomNumberGenerator\n    init(sides: Int, generator: RandomNumberGenerator) {\n        self.sides = sides\n        self.generator = generator\n    }\n    func roll() -> Int {\n        return Int(generator.random() * Double(sides)) + 1\n    }\n}\n```\n\n例子中定义了一个 Dice 类，用来代表桌游中拥有 N 个面的骰子。Dice 的实例含有 sides 和 generator 两个属性，前者是整型，用来表示骰子有几个面，后者为骰子提供一个随机数生成器，从而生成随机点数。\ngenerator 属性的类型为 RandomNumberGenerator，因此任何遵循了 RandomNumberGenerator 协议的类型的实例都可以赋值给 generator，除此之外并无其他要求。\nDice 类还有一个构造器，用来设置初始状态。构造器有一个名为 generator，类型为 RandomNumberGenerator 的形参。在调用构造方法创建 Dice 的实例时，可以传入任何遵循 RandomNumberGenerator 协议的实例给 generator。\nDice 类提供了一个名为 roll 的实例方法，用来模拟骰子的面值。它先调用 generator 的 random() 方法来生成一个 [0.0,1.0) 区间内的随机数，然后使用这个随机数生成正确的骰子面值。因为 generator 遵循了 RandomNumberGenerator 协议，可以确保它有个 random() 方法可供调用。\n\n下面的例子展示了如何使用 LinearCongruentialGenerator 的实例作为随机数生成器来创建一个六面骰子：\n\n```Swift\nvar d6 = Dice(sides: 6, generator: LinearCongruentialGenerator())\nfor _ in 1...5 {\n    print(\"Random dice roll is \\(d6.roll())\")\n}\n// Random dice roll is 3\n// Random dice roll is 5\n// Random dice roll is 4\n// Random dice roll is 5\n// Random dice roll is 4\n```\n\n### 委托（代理）模式\n委托是一种设计模式，它允许类或结构体将一些需要它们负责的功能委托给其他类型的实例。委托模式的实现很简单：定义协议来封装那些需要被委托的功能，这样就能确保遵循协议的类型能提供这些功能。委托模式可以用来响应特定的动作，或者接收外部数据源提供的数据，而无需关心外部数据源的类型。\n下面的例子定义了两个基于骰子游戏的协议：\n\n```Swift\nprotocol DiceGame {\n    var dice: Dice { get }\n    func play()\n}\nprotocol DiceGameDelegate {\n    func gameDidStart(_ game: DiceGame)\n    func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int)\n    func gameDidEnd(_ game: DiceGame)\n}\n```\n\nDiceGame 协议可以被任意涉及骰子的游戏遵循。DiceGameDelegate 协议可以被任意类型遵循，用来追踪 DiceGame 的游戏过程。\n\n如下所示，SnakesAndLadders 是 控制流 章节引入的蛇梯棋游戏的新版本。新版本使用 Dice 实例作为骰子，并且实现了 DiceGame 和 DiceGameDelegate 协议，后者用来记录游戏的过程：\n\n```Swift\nclass SnakesAndLadders: DiceGame {\n    let finalSquare = 25\n    let dice = Dice(sides: 6, generator: LinearCongruentialGenerator())\n    var square = 0\n    var board: [Int]\n    init() {\n        board = Array(repeating: 0, count: finalSquare + 1)\n        board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02\n        board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08\n    }\n    var delegate: DiceGameDelegate?\n    func play() {\n        square = 0\n        delegate?.gameDidStart(self)\n        gameLoop: while square != finalSquare {\n            let diceRoll = dice.roll()\n            delegate?.game(self, didStartNewTurnWithDiceRoll: diceRoll)\n            switch square + diceRoll {\n            case finalSquare:\n                break gameLoop\n            case let newSquare where newSquare > finalSquare:\n                continue gameLoop\n            default:\n                square += diceRoll\n                square += board[square]\n            }\n        }\n        delegate?.gameDidEnd(self)\n    }\n}\n```\n\n这个版本的游戏封装到了 SnakesAndLadders 类中，该类遵循了 DiceGame 协议，并且提供了相应的可读的 dice 属性和 play() 方法。（ dice 属性在构造之后就不再改变，且协议只要求 dice 为可读的，因此将 dice 声明为常量属性。）\n游戏使用 SnakesAndLadders 类的 init() 构造器来初始化游戏。所有的游戏逻辑被转移到了协议中的 play() 方法，play() 方法使用协议要求的 dice 属性提供骰子摇出的值。\n注意，delegate 并不是游戏的必备条件，因此 delegate 被定义为 DiceGameDelegate 类型的可选属性。因为 delegate 是可选值，因此会被自动赋予初始值 nil。随后，可以在游戏中为 delegate 设置适当的值。\n\nDicegameDelegate 协议提供了三个方法用来追踪游戏过程。这三个方法被放置于游戏的逻辑中，即 play() 方法内。分别在游戏开始时，新一轮开始时，以及游戏结束时被调用。\n\n因为 delegate 是一个 DiceGameDelegate 类型的可选属性，因此在 play() 方法中通过可选链式调用来调用它的方法。若 delegate 属性为 nil，则调用方法会优雅地失败，并不会产生错误。若 delegate 不为 nil，则方法能够被调用，并传递 SnakesAndLadders 实例作为参数。\n\n如下示例定义了 DiceGameTracker 类，它遵循了 DiceGameDelegate 协议：\n\n```Swift\nclass DiceGameTracker: DiceGameDelegate {\n    var numberOfTurns = 0\n    func gameDidStart(_ game: DiceGame) {\n        numberOfTurns = 0\n        if game is SnakesAndLadders {\n            print(\"Started a new game of Snakes and Ladders\")\n        }\n        print(\"The game is using a \\(game.dice.sides)-sided dice\")\n    }\n    func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) {\n        numberOfTurns += 1\n        print(\"Rolled a \\(diceRoll)\")\n    }\n    func gameDidEnd(_ game: DiceGame) {\n        print(\"The game lasted for \\(numberOfTurns) turns\")\n    }\n}\n```\n\nDiceGameTracker 实现了 DiceGameDelegate 协议要求的三个方法，用来记录游戏已经进行的轮数。当游戏开始时，numberOfTurns 属性被赋值为 0，然后在每新一轮中递增，游戏结束后，打印游戏的总轮数。\nDiceGameTracker 的运行情况如下所示：\n\n```Swift\nlet tracker = DiceGameTracker()\nlet game = SnakesAndLadders()\ngame.delegate = tracker\ngame.play()\n// Started a new game of Snakes and Ladders\n// The game is using a 6-sided dice\n// Rolled a 3\n// Rolled a 5\n// Rolled a 4\n// Rolled a 5\n// The game lasted for 4 turns\n```\n\n### 通过扩展遵循协议\n即便无法修改源代码，依然可以通过扩展令已有类型遵循并符合协议。扩展可以为已有类型添加属性、方法、下标以及构造器，因此可以符合协议中的相应要求。\n\t通过扩展令已有类型遵循并符合协议时，该类型的所有实例也会随之获得协议中定义的各项功能。\n\n例如下面这个 TextRepresentable 协议，任何想要通过文本表示一些内容的类型都可以实现该协议。这些想要表示的内容可以是实例本身的描述，也可以是实例当前状态的文本描述：\n\n```Swift\nprotocol TextRepresentable {\n    var textualDescription: String { get }\n}\n```\n\n可以通过扩展，令先前提到的 Dice 类遵循并符合 TextRepresentable 协议：\n\n```Swift\nextension Dice: TextRepresentable {\n    var textualDescription: String {\n        return \"A \\(sides)-sided dice\"\n    }\n}\n```\n\n通过扩展遵循并符合协议，和在原始定义中遵循并符合协议的效果完全相同。协议名称写在类型名之后，以冒号隔开，然后在扩展的大括号内实现协议要求的内容。\n现在所有 Dice 的实例都可以看做 TextRepresentable 类型：\n\n```Swift\nlet d12 = Dice(sides: 12, generator: LinearCongruentialGenerator())\nprint(d12.textualDescription)\n// Prints \"A 12-sided dice\"\n```\n\n同样，SnakesAndLadders 类也可以通过扩展遵循并符合 TextRepresentable 协议：\n\n```Swift\nextension SnakesAndLadders: TextRepresentable {\n    var textualDescription: String {\n        return \"A game of Snakes and Ladders with \\(finalSquare) squares\"\n    }\n}\nprint(game.textualDescription)\n// Prints \"A game of Snakes and Ladders with 25 squares\"\n```\n\n#### 通过扩展遵循协议\n当一个类型已经符合了某个协议中的所有要求，却还没有声明遵循该协议时，可以通过空扩展体的扩展来遵循该协议：\n\n```Swift\nstruct Hamster {\n    var name: String\n    var textualDescription: String {\n        return \"A hamster named \\(name)\"\n    }\n}\nextension Hamster: TextRepresentable {}\n```\n\n从现在起，Hamster 的实例可以作为 TextRepresentable 类型使用：\n\n```Swift\nlet simonTheHamster = Hamster(name: \"Simon\")\nlet somethingTextRepresentable: TextRepresentable = simonTheHamster\nprint(somethingTextRepresentable.textualDescription)\n// Prints \"A hamster named Simon\"\n```\n\n\t即使满足了协议的所有要求，类型也不会自动遵循协议，必须显式地遵循协议。\n\n\n### 协议类型的集合\n协议类型可以在数组或者字典这样的集合中使用，在协议类型提到了这样的用法。下面的例子创建了一个元素类型为 TextRepresentable 的数组：\n\n```Swift\nlet things: [TextRepresentable] = [game, d12, simonTheHamster]\n```\n\n如下所示，可以遍历 things 数组，并打印每个元素的文本表示：\n\n```Swift\nfor thing in things {\n    print(thing.textualDescription)\n}\n// A game of Snakes and Ladders with 25 squares\n// A 12-sided dice\n// A hamster named Simon\n```\n\nthing 是 TextRepresentable 类型而不是 Dice，DiceGame，Hamster 等类型，即使实例在幕后确实是这些类型中的一种。由于 thing 是 TextRepresentable 类型，任何 TextRepresentable 的实例都有一个 textualDescription 属性，所以在每次循环中可以安全地访问 thing.textualDescription。\n\n### 协议的继承\n协议能够继承一个或多个其他协议，可以在继承的协议的基础上增加新的要求。协议的继承语法与类的继承相似，多个被继承的协议间用逗号分隔：\n\n```Swift\nprotocol InheritingProtocol: SomeProtocol, AnotherProtocol {\n    // protocol definition goes here\n}\n```\n\n如下所示，PrettyTextRepresentable 协议继承了 TextRepresentable 协议：\n\n```Swift\nprotocol PrettyTextRepresentable: TextRepresentable {\n    var prettyTextualDescription: String { get }\n}\n```\n\n例子中定义了一个新的协议 PrettyTextRepresentable，它继承自 TextRepresentable 协议。任何遵循 PrettyTextRepresentable 协议的类型在满足该协议的要求时，也必须满足 TextRepresentable 协议的要求。在这个例子中，PrettyTextRepresentable 协议额外要求遵循协议的类型提供一个返回值为 String 类型的 prettyTextualDescription 属性。\n\n如下所示，扩展 SnakesAndLadders，使其遵循并符合 PrettyTextRepresentable 协议：\n\n```Swift\nextension SnakesAndLadders: PrettyTextRepresentable {\n    var prettyTextualDescription: String {\n        var output = textualDescription + \":\\n\"\n        for index in 1...finalSquare {\n            switch board[index] {\n            case let ladder where ladder > 0:\n                output += \"▲ \"\n            case let snake where snake < 0:\n                output += \"▼ \"\n            default:\n                output += \"○ \"\n            }\n        }\n        return output\n    }\n}\n```\n\n上述扩展令 SnakesAndLadders 遵循了 PrettyTextRepresentable 协议，并提供了协议要求的 prettyTextualDescription 属性。每个 PrettyTextRepresentable 类型同时也是 TextRepresentable 类型，所以在 prettyTextualDescription 的实现中，可以访问 textualDescription 属性。\n\n任意 SankesAndLadders 的实例都可以使用 prettyTextualDescription 属性来打印一个漂亮的文本描述：\n\n\n```Swift\nprint(game.prettyTextualDescription)\n// A game of Snakes and Ladders with 25 squares:\n// ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○\n```\n\n### 类类型专属协议\n你可以在协议的继承列表中，通过添加 class 关键字来限制协议只能被类类型遵循，而结构体或枚举不能遵循该协议。`class` 关键字必须第一个出现在协议的继承列表中，在其他继承的协议之前：\n\n```Swift\nprotocol SomeClassOnlyProtocol: class, SomeInheritedProtocol {\n    // class-only protocol definition goes here\n}\n```\n\n在以上例子中，协议 SomeClassOnlyProtocol 只能被类类型遵循。如果尝试让结构体或枚举类型遵循该协议，则会导致编译错误。\n\n\t当协议定义的要求需要遵循协议的类型必须是引用语义而非值语义时，应该采用类类型专属协议。\n\n\n### 协议合成\n有时候需要同时遵循多个协议，你可以将多个协议采用 SomeProtocol & AnotherProtocol 这样的格式进行组合，称为 协议合成（protocol composition）。你可以罗列任意多个你想要遵循的协议，以与符号(&)分隔。\n\n下面的例子中，将 Named 和 Aged 两个协议按照上述语法组合成一个协议，作为函数参数的类型：\n\n```Swift\nprotocol Named {\n    var name: String { get }\n}\nprotocol Aged {\n    var age: Int { get }\n}\nstruct Person: Named, Aged {\n    var name: String\n    var age: Int\n}\nfunc wishHappyBirthday(to celebrator: Named & Aged) {\n    print(\"Happy birthday, \\(celebrator.name), you're \\(celebrator.age)!\")\n}\nlet birthdayPerson = Person(name: \"Malcolm\", age: 21)\nwishHappyBirthday(to: birthdayPerson)\n// Prints \"Happy birthday, Malcolm, you're 21!\"\n```\n\nNamed 协议包含 String 类型的 name 属性。Aged 协议包含 Int 类型的 age 属性。Person 结构体遵循了这两个协议。\nwishHappyBirthday(to:) 函数的参数 celebrator 的类型为 Named & Aged。这意味着它不关心参数的具体类型，只要参数符合这两个协议即可。\n上面的例子创建了一个名为 birthdayPerson 的 Person 的实例，作为参数传递给了 wishHappyBirthday(to:) 函数。因为 Person 同时符合这两个协议，所以这个参数合法，函数将打印生日问候语。\n\n\t协议合成并不会生成新的、永久的协议类型，而是将多个协议中的要求合成到一个只在局部作用域有效的临时协议中。\n\n\n### 检查协议一致性\n你可以使用类型转换中描述的 is 和 as 操作符来检查协议一致性，即是否符合某协议，并且可以转换到指定的协议类型。检查和转换到某个协议类型在语法上和类型的检查和转换完全相同：\n\n * is 用来检查实例是否符合某个协议，若符合则返回 true，否则返回 false。\n * as? 返回一个可选值，当实例符合某个协议时，返回类型为协议类型的可选值，否则返回 nil。\n * as! 将实例强制向下转换到某个协议类型，如果强转失败，会引发运行时错误。\n\nThis example defines a protocol called HasArea, with a single property requirement of a gettable Double property called area:\n\n```Swift\nprotocol HasArea {\n    var area: Double { get }\n}\n```\n\nHere are two classes, Circle and Country, both of which conform to the HasArea protocol:\n\n```Swift\nclass Circle: HasArea {\n    let pi = 3.1415927\n    var radius: Double\n    var area: Double { return pi * radius * radius }\n    init(radius: Double) { self.radius = radius }\n}\nclass Country: HasArea {\n    var area: Double\n    init(area: Double) { self.area = area }\n}\n```\n\nCircle 类把 area 属性实现为基于存储型属性 radius 的计算型属性。Country 类则把 area 属性实现为存储型属性。这两个类都正确地符合了 HasArea 协议。\n\n如下所示，Animal 是一个未遵循 HasArea 协议的类：\n\n```Swift\nclass Animal {\n    var legs: Int\n    init(legs: Int) { self.legs = legs }\n}\n```\n\nCircle，Country，Animal 并没有一个共同的基类，尽管如此，它们都是类，它们的实例都可以作为 AnyObject 类型的值，存储在同一个数组中：\n\n```Swift\nlet objects: [AnyObject] = [\n    Circle(radius: 2.0),\n    Country(area: 243_610),\n    Animal(legs: 4)\n]\n```\n\n如下所示，objects 数组可以被迭代，并对迭代出的每一个元素进行检查，看它是否符合 HasArea 协议：\n\n```Swift\nfor object in objects {\n    if let objectWithArea = object as? HasArea {\n        print(\"Area is \\(objectWithArea.area)\")\n    } else {\n        print(\"Something that doesn't have an area\")\n    }\n}\n// Area is 12.5663708\n// Area is 243610.0\n// Something that doesn't have an area\n```\n\n当迭代出的元素符合 HasArea 协议时，将 as? 操作符返回的可选值通过可选绑定，绑定到 objectWithArea 常量上。objectWithArea 是 HasArea 协议类型的实例，因此 area 属性可以被访问和打印。\n\nobjects 数组中的元素的类型并不会因为强转而丢失类型信息，它们仍然是 Circle，Country，Animal 类型。然而，当它们被赋值给 objectWithArea 常量时，只被视为 HasArea 类型，因此只有 area 属性能够被访问。\n\n### 可选的协议要求\n协议可以定义可选要求，遵循协议的类型可以选择是否实现这些要求。在协议中使用 optional 关键字作为前缀来定义可选要求。可选要求用在你需要和 Objective-C 打交道的代码中。协议和可选要求都必须带上@objc属性。标记 @objc 特性的协议只能被继承自 Objective-C 类的类或者 @objc 类遵循，其他类以及结构体和枚举均不能遵循这种协议。\n\n使用可选要求时（例如，可选的方法或者属性），它们的类型会自动变成可选的。比如，一个类型为 (Int) -> String 的方法会变成 ((Int) -> String)?\n\n协议中的可选要求可通过可选链式调用来使用，因为遵循协议的类型可能没有实现这些可选要求。类似 someOptionalMethod?(someArgument) 这样，你可以在可选方法名称后加上 ? 来调用可选方法。\n\n下面的例子定义了一个名为 Counter 的用于整数计数的类，它使用外部的数据源来提供每次的增量。数据源由 CounterDataSource 协议定义，包含两个可选要求：\n\n```Swift\n@objc protocol CounterDataSource {\n    @objc optional func increment(forCount count: Int) -> Int\n    @objc optional var fixedIncrement: Int { get }\n}\n```\n\nCounterDataSource 协议定义了一个可选方法 increment(forCount:) 和一个可选属性 fiexdIncrement，它们使用了不同的方法来从数据源中获取适当的增量值。\n\t严格来讲，CounterDataSource 协议中的方法和属性都是可选的，因此遵循协议的类可以不实现这些要求\n\nCounter 类含有 CounterDataSource? 类型的可选属性 dataSource，如下所示：\n\n```Swift\nclass Counter {\n    var count = 0\n    var dataSource: CounterDataSource?\n    func increment() {\n        if let amount = dataSource?.increment?(forCount: count) {\n            count += amount\n        } else if let amount = dataSource?.fixedIncrement {\n            count += amount\n        }\n    }\n}\n```\n\n下面的例子展示了 CounterDataSource 的简单实现。ThreeSource 类遵循了 CounterDataSource 协议，它实现了可选属性 fixedIncrement，每次会返回 3：\n\n```Swift\nclass ThreeSource: NSObject, CounterDataSource {\n    let fixedIncrement = 3\n}\n```\n\n可以使用 ThreeSource 的实例作为 Counter 实例的数据源：\n\n```Swift\nvar counter = Counter()\ncounter.dataSource = ThreeSource()\nfor _ in 1...4 {\n    counter.increment()\n    print(counter.count)\n}\n// 3\n// 6\n// 9\n// 12\n```\n\n上述代码新建了一个 Counter 实例，并将它的数据源设置为一个 ThreeSource 的实例，然后调用 increment() 方法四次。和预期一样，每次调用都会将 count 的值增加 3.\n\n下面是一个更为复杂的数据源 TowardsZeroSource，它将使得最后的值变为 0：\n\n```Objective-C\n@objc class TowardsZeroSource: NSObject, CounterDataSource {\n    func increment(forCount count: Int) -> Int {\n        if count == 0 {\n            return 0\n        } else if count < 0 {\n            return 1\n        } else {\n            return -1\n        }\n    }\n}\n```\n\n你可以使用 TowardsZeroSource 实例将 Counter 实例来从 -4 增加到 0。一旦增加到 0，数值便不会再有变动：\n\n```Swift\ncounter.count = -4\ncounter.dataSource = TowardsZeroSource()\nfor _ in 1...5 {\n    counter.increment()\n    print(counter.count)\n}\n// -3\n// -2\n// -1\n// 0\n// 0\n```\n\n\n### 协议扩展\n协议可以通过扩展来为遵循协议的类型提供属性、方法以及下标的实现。通过这种方式，你可以基于协议本身来实现这些功能，而无需在每个遵循协议的类型中都重复同样的实现，也无需使用全局函数。\n例如，可以扩展 RandomNumberGenerator 协议来提供 randomBool() 方法。该方法使用协议中定义的 random() 方法来返回一个随机的 Bool 值：\n\n```Swift\nextension RandomNumberGenerator {\n    func randomBool() -> Bool {\n        return random() > 0.5\n    }\n}\n```\n\n通过协议扩展，所有遵循协议的类型，都能自动获得这个扩展所增加的方法实现，无需任何额外修改：\n\n```Swift\nlet generator = LinearCongruentialGenerator()\nprint(\"Here's a random number: \\(generator.random())\")\n// Prints \"Here's a random number: 0.37464991998171\"\nprint(\"And here's a random Boolean: \\(generator.randomBool())\")\n// Prints \"And here's a random Boolean: true\"\n```\n\n#### 提供默认实现\n可以通过协议扩展来为协议要求的属性、方法以及下标提供默认的实现。如果遵循协议的类型为这些要求提供了自己的实现，那么这些自定义实现将会替代扩展中的默认实现被使用。\n\t通过协议扩展为协议要求提供的默认实现和可选的协议要求不同。虽然在这两种情况下，遵循协议的类型都无需自己实现这些要求，但是通过扩展提供的默认实现可以直接调用，而无需使用可选链式调用。\n\n例如，PrettyTextRepresentable 协议继承自 TextRepresentable 协议，可以为其提供一个默认的 prettyTextualDescription 属性，只是简单地返回 textualDescription 属性的值：\n\n```Swift\nextension PrettyTextRepresentable  {\n    var prettyTextualDescription: String {\n        return textualDescription\n    }\n}\n```\n\n\n\n\n#### 为协议扩展添加限制条件\n在扩展协议的时候，可以指定一些限制条件，只有遵循协议的类型满足这些限制条件时，才能获得协议扩展提供的默认实现。这些限制条件写在协议名之后，使用 where 子句来描述\n例如，你可以扩展 CollectionType 协议，但是只适用于集合中的元素遵循了 TextRepresentable 协议的情况：\n\n```Swift\nextension Collection where Iterator.Element: TextRepresentable {\n    var textualDescription: String {\n        let itemsAsText = self.map { $0.textualDescription }\n        return \"[\" + itemsAsText.joined(separator: \", \") + \"]\"\n    }\n}\n```\n\ntextualDescription 属性返回整个集合的文本描述，它将集合中的每个元素的文本描述以逗号分隔的方式连接起来，包在一对方括号中。\n现在我们来看看先前的 Hamster 结构体，它符合 TextRepresentable 协议，同时这里还有个装有 Hamster 的实例的数组：\n\n```Swift\nlet murrayTheHamster = Hamster(name: \"Murray\")\nlet morganTheHamster = Hamster(name: \"Morgan\")\nlet mauriceTheHamster = Hamster(name: \"Maurice\")\nlet hamsters = [murrayTheHamster, morganTheHamster, mauriceTheHamster]\n```\n\n因为 Array 符合 CollectionType 协议，而数组中的元素又符合 TextRepresentable 协议，所以数组可以使用 textualDescription 属性得到数组内容的文本表示：\n\n```Swift\nprint(hamsters.textualDescription)\n// Prints \"[A hamster named Murray, A hamster named Morgan, A hamster named Maurice]\"\n```\n\n\t如果多个协议扩展都为同一个协议要求提供了默认实现，而遵循协议的类型又同时满足这些协议扩展的限制条件，那么将会使用限制条件最多的那个协议扩展提供的默认实现。\n\n\n\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html/\"> Protocols </a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","slug":"iOS_Swift_language_note_Protocols","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4uo003toko89beqqv4g","content":"<p>​    协议 定义了用来实现某一特定任务或者功能的方法、属性，以及其他需要的东西的一个蓝图。类、结构体或枚举都可以遵循协议，并为协议定义的这些要求提供具体实现。任何类型能够满足某个协议的要求，就可以说该类型遵循这个协议。<br>除了遵循协议的类型必须实现的要求外，还可以对协议进行扩展，通过扩展来实现一部分要求或者实现一些附加功能，这样遵循协议的类型就能够使用这些功能。</p>\n<h3 id=\"协议语法\"><a href=\"#协议语法\" class=\"headerlink\" title=\"协议语法\"></a>协议语法</h3><p>协议的定义方式与类、结构体和枚举的定义非常相似：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">SomeProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// protocol definition goes here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>要让自定义类型遵循某个协议，在定义类型时，需要在类型名称后加上协议名称，中间以冒号（:）分隔。遵循多个协议时，各协议之间用逗号（,）分隔：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SomeStructure</span>: <span class=\"title\">FirstProtocol</span>, <span class=\"title\">AnotherProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// structure definition goes here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>拥有父类的类在遵循协议时，应该将父类名放在协议名之前，以逗号分隔：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClass</span>: <span class=\"title\">SomeSuperclass</span>, <span class=\"title\">FirstProtocol</span>, <span class=\"title\">AnotherProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// class definition goes here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"属性要求\"><a href=\"#属性要求\" class=\"headerlink\" title=\"属性要求\"></a>属性要求</h3><p>协议可以要求遵循协议的类型提供特定名称和类型的实例属性或类型属性。协议不指定属性是存储型属性还是计算型属性，它只指定属性的名称和类型。此外，协议还指定属性是可读的还是可读可写的。<br>如果协议要求属性是可读可写的，那么该属性不能是常量属性或只读的计算型属性。如果协议只要求属性是可读的，那么该属性不仅可以是可读的，如果代码需要的话，还可以是可写的。</p>\n<p>协议总是用 <code>var</code> 关键字来声明变量属性，在类型声明后加上 <code>{ set get }</code> 来表示属性是可读可写的，可读属性则用 <code>{ get }</code> 来表示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">SomeProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> mustBeSettable: <span class=\"type\">Int</span> &#123; <span class=\"keyword\">get</span> <span class=\"keyword\">set</span> &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> doesNotNeedToBeSettable: <span class=\"type\">Int</span> &#123; <span class=\"keyword\">get</span> &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在协议中定义类型属性时，总是使用 <code>static</code> 关键字作为前缀。当类类型遵循协议时，除了 <code>static</code> 关键字，还可以使用 <code>class</code> 关键字来声明类型属性：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">AnotherProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> someTypeProperty: <span class=\"type\">Int</span> &#123; <span class=\"keyword\">get</span> <span class=\"keyword\">set</span> &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如下所示，这是一个只含有一个实例属性要求的协议：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">FullyNamed</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> fullName: <span class=\"type\">String</span> &#123; <span class=\"keyword\">get</span> &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>FullyNamed 协议除了要求遵循协议的类型提供 fullName 属性外，并没有其他特别的要求。这个协议表示，任何遵循 FullyNamed 的类型，都必须有一个可读的 String 类型的实例属性 fullName。<br>下面是一个遵循 FullyNamed 协议的简单结构体：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span>: <span class=\"title\">FullyNamed</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> fullName: <span class=\"type\">String</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> john = <span class=\"type\">Person</span>(fullName: <span class=\"string\">\"John Appleseed\"</span>)</div><div class=\"line\"><span class=\"comment\">// john.fullName is \"John Appleseed\"</span></div></pre></td></tr></table></figure>\n<p>这个例子中定义了一个叫做 Person 的结构体，用来表示一个具有名字的人。从第一行代码可以看出，它遵循了 FullyNamed 协议。<br>Person 结构体的每一个实例都有一个 String 类型的存储型属性 fullName。这正好满足了 FullyNamed 协议的要求，也就意味着 Person 结构体正确地符合了协议。（如果协议要求未被完全满足，在编译时会报错。）<br>下面是一个更为复杂的类，它适配并遵循了 FullyNamed 协议：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Starship</span>: <span class=\"title\">FullyNamed</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">prefix</span>: <span class=\"type\">String</span>?</div><div class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>, <span class=\"keyword\">prefix</span>: <span class=\"type\">String</span>? = <span class=\"literal\">nil</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.name = name</div><div class=\"line\">        <span class=\"keyword\">self</span>.<span class=\"keyword\">prefix</span> = <span class=\"keyword\">prefix</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> fullName: <span class=\"type\">String</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">prefix</span> != <span class=\"literal\">nil</span> ? <span class=\"keyword\">prefix</span>! + <span class=\"string\">\" \"</span> : <span class=\"string\">\"\"</span>) + name</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> ncc1701 = <span class=\"type\">Starship</span>(name: <span class=\"string\">\"Enterprise\"</span>, <span class=\"keyword\">prefix</span>: <span class=\"string\">\"USS\"</span>)</div><div class=\"line\"><span class=\"comment\">// ncc1701.fullName is \"USS Enterprise\"</span></div></pre></td></tr></table></figure>\n<p>Starship 类把 fullName 属性实现为只读的计算型属性。每一个 Starship 类的实例都有一个名为 name 的非可选属性和一个名为 prefix 的可选属性。 当 prefix 存在时，计算型属性 fullName 会将 prefix 插入到 name 之前，从而为星际飞船构建一个全名。</p>\n<h3 id=\"方法要求（Method-Requirements）\"><a href=\"#方法要求（Method-Requirements）\" class=\"headerlink\" title=\"方法要求（Method Requirements）\"></a>方法要求（Method Requirements）</h3><p>协议可以要求遵循协议的类型实现某些指定的实例方法或类方法。这些方法作为协议的一部分，像普通方法一样放在协议的定义中，但是不需要大括号和方法体。可以在协议中定义具有可变参数的方法，和普通方法的定义方式相同。但是，不支持为协议中的方法的参数提供默认值。<br>正如属性要求中所述，在协议中定义类方法的时候，总是使用 <code>static</code> 关键字作为前缀。当类类型遵循协议时，除了 <code>static</code> 关键字，还可以使用 <code>class</code> 关键字作为前缀：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">SomeProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someTypeMethod</span><span class=\"params\">()</span></span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下面的例子定义了一个只含有一个实例方法的协议：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">RandomNumberGenerator</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">random</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Double</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>RandomNumberGenerator 协议要求遵循协议的类型必须拥有一个名为 random， 返回值类型为 Double 的实例方法。<br>RandomNumberGenerator 协议并不关心每一个随机数是怎样生成的，它只要求必须提供一个随机数生成器。</p>\n<p>如下所示，下边是一个遵循并符合 RandomNumberGenerator 协议的类。该类实现了一个叫做 线性同余生成器（linear congruential generator） 的伪随机数算法。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinearCongruentialGenerator</span>: <span class=\"title\">RandomNumberGenerator</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> lastRandom = <span class=\"number\">42.0</span></div><div class=\"line\">    <span class=\"keyword\">let</span> m = <span class=\"number\">139968.0</span></div><div class=\"line\">    <span class=\"keyword\">let</span> a = <span class=\"number\">3877.0</span></div><div class=\"line\">    <span class=\"keyword\">let</span> <span class=\"built_in\">c</span> = <span class=\"number\">29573.0</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">random</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Double</span> &#123;</div><div class=\"line\">        lastRandom = ((lastRandom * a + <span class=\"built_in\">c</span>).truncatingRemainder(dividingBy:m))</div><div class=\"line\">        <span class=\"keyword\">return</span> lastRandom / m</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> generator = <span class=\"type\">LinearCongruentialGenerator</span>()</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Here's a random number: <span class=\"subst\">\\(generator.random()</span>)\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"Here's a random number: 0.37464991998171\"</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"And another one: <span class=\"subst\">\\(generator.random()</span>)\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"And another one: 0.729023776863283\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"Mutating-方法要求\"><a href=\"#Mutating-方法要求\" class=\"headerlink\" title=\"Mutating 方法要求\"></a>Mutating 方法要求</h3><p>有时需要在方法中改变方法所属的实例。例如，在值类型（即结构体和枚举）的实例方法中，将 mutating 关键字作为方法的前缀，写在 <code>func</code> 关键字之前，表示可以在该方法中修改它所属的实例以及实例的任意属性的值。<br>如果你在协议中定义了一个实例方法，该方法会改变遵循该协议的类型的实例，那么在定义协议时需要在方法前加 mutating 关键字。这使得结构体和枚举能够遵循此协议并满足此方法要求。<br>    实现协议中的 mutating 方法时，若是类类型，则不用写 mutating 关键字。而对于结构体和枚举，则必须写 mutating 关键字。</p>\n<p>如下所示，Togglable 协议只要求实现一个名为 toggle 的实例方法。根据名称的暗示，toggle() 方法将改变实例属性，从而切换遵循该协议类型的实例的状态。<br>toggle() 方法在定义的时候，使用 mutating 关键字标记，这表明当它被调用时，该方法将会改变遵循协议的类型的实例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">Togglable</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">toggle</span><span class=\"params\">()</span></span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当使用枚举或结构体来实现 Togglable 协议时，需要提供一个带有 mutating 前缀的 toggle() 方法。<br>下面定义了一个名为 OnOffSwitch 的枚举。这个枚举在两种状态之间进行切换，用枚举成员 On 和 Off 表示。枚举的 toggle() 方法被标记为 mutating，以满足 Togglable 协议的要求：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">OnOffSwitch</span>: <span class=\"title\">Togglable</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> off, on</div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">toggle</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> <span class=\"keyword\">self</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> .off:</div><div class=\"line\">            <span class=\"keyword\">self</span> = .on</div><div class=\"line\">        <span class=\"keyword\">case</span> .on:</div><div class=\"line\">            <span class=\"keyword\">self</span> = .off</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> lightSwitch = <span class=\"type\">OnOffSwitch</span>.off</div><div class=\"line\">lightSwitch.toggle()</div><div class=\"line\"><span class=\"comment\">// lightSwitch is now equal to .on</span></div></pre></td></tr></table></figure>\n<h3 id=\"构造器要求\"><a href=\"#构造器要求\" class=\"headerlink\" title=\"构造器要求\"></a>构造器要求</h3><p>协议可以要求遵循协议的类型实现指定的构造器。你可以像编写普通构造器那样，在协议的定义里写下构造器的声明，但不需要写花括号和构造器的实体：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">SomeProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">init</span>(someParameter: <span class=\"type\">Int</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"协议中的构造器在类中的实现\"><a href=\"#协议中的构造器在类中的实现\" class=\"headerlink\" title=\"协议中的构造器在类中的实现\"></a>协议中的构造器在类中的实现</h4><p>你可以在遵循协议的类中实现构造器，无论是作为指定构造器，还是作为便利构造器。无论哪种情况，你都必须为构造器实现标上 <code>required</code> 修饰符：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClass</span>: <span class=\"title\">SomeProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">required</span> <span class=\"keyword\">init</span>(someParameter: <span class=\"type\">Int</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">// initializer implementation goes here</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用 required 修饰符可以确保所有子类也必须提供此构造器实现，从而也能符合协议。<br>    如果类已经被标记为 final，那么不需要在协议构造器的实现中使用 required 修饰符，因为 final 类不能有子类。</p>\n<p>如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求，那么该构造器的实现需要同时标注 <code>required</code> 和 <code>override</code> 修饰符：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">SomeProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">init</span>()</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeSuperClass</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">init</span>() &#123;</div><div class=\"line\">        <span class=\"comment\">// initializer implementation goes here</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeSubClass</span>: <span class=\"title\">SomeSuperClass</span>, <span class=\"title\">SomeProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// \"required\" from SomeProtocol conformance; \"override\" from SomeSuperClass</span></div><div class=\"line\">    <span class=\"keyword\">required</span> <span class=\"keyword\">override</span> <span class=\"keyword\">init</span>() &#123;</div><div class=\"line\">        <span class=\"comment\">// initializer implementation goes here</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"可失败构造器要求\"><a href=\"#可失败构造器要求\" class=\"headerlink\" title=\"可失败构造器要求\"></a>可失败构造器要求</h4><p>协议还可以为遵循协议的类型定义可失败构造器要求<br>遵循协议的类型可以通过可失败构造器（init?）或非可失败构造器（init）来满足协议中定义的可失败构造器要求。协议中定义的非可失败构造器要求可以通过非可失败构造器（init）或隐式解包可失败构造器（init!）来满足。</p>\n<h3 id=\"协议作为类型\"><a href=\"#协议作为类型\" class=\"headerlink\" title=\"协议作为类型\"></a>协议作为类型</h3><p>尽管协议本身并未实现任何功能，但是协议可以被当做一个成熟的类型来使用。<br>协议可以像其他普通类型一样使用，使用场景包括：</p>\n<ul>\n<li>作为函数、方法或构造器中的参数类型或返回值类型</li>\n<li>作为常量、变量或属性的类型</li>\n<li><p>作为数组、字典或其他容器中的元素类型</p>\n<p> 协议是一种类型，因此协议类型的名称应与其他类型（例如 Int，Double，String）的写法相同，使用大写字母开头的驼峰式写法，例如（FullyNamed 和 RandomNumberGenerator）。</p>\n</li>\n</ul>\n<p>下面是将协议作为类型使用的例子：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dice</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> sides: <span class=\"type\">Int</span></div><div class=\"line\">    <span class=\"keyword\">let</span> generator: <span class=\"type\">RandomNumberGenerator</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(sides: <span class=\"type\">Int</span>, generator: <span class=\"type\">RandomNumberGenerator</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.sides = sides</div><div class=\"line\">        <span class=\"keyword\">self</span>.generator = generator</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">roll</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Int</span>(generator.random() * <span class=\"type\">Double</span>(sides)) + <span class=\"number\">1</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>例子中定义了一个 Dice 类，用来代表桌游中拥有 N 个面的骰子。Dice 的实例含有 sides 和 generator 两个属性，前者是整型，用来表示骰子有几个面，后者为骰子提供一个随机数生成器，从而生成随机点数。<br>generator 属性的类型为 RandomNumberGenerator，因此任何遵循了 RandomNumberGenerator 协议的类型的实例都可以赋值给 generator，除此之外并无其他要求。<br>Dice 类还有一个构造器，用来设置初始状态。构造器有一个名为 generator，类型为 RandomNumberGenerator 的形参。在调用构造方法创建 Dice 的实例时，可以传入任何遵循 RandomNumberGenerator 协议的实例给 generator。<br>Dice 类提供了一个名为 roll 的实例方法，用来模拟骰子的面值。它先调用 generator 的 random() 方法来生成一个 [0.0,1.0) 区间内的随机数，然后使用这个随机数生成正确的骰子面值。因为 generator 遵循了 RandomNumberGenerator 协议，可以确保它有个 random() 方法可供调用。</p>\n<p>下面的例子展示了如何使用 LinearCongruentialGenerator 的实例作为随机数生成器来创建一个六面骰子：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> d6 = <span class=\"type\">Dice</span>(sides: <span class=\"number\">6</span>, generator: <span class=\"type\">LinearCongruentialGenerator</span>())</div><div class=\"line\"><span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">1</span>...<span class=\"number\">5</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Random dice roll is <span class=\"subst\">\\(d6.roll()</span>)\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Random dice roll is 3</span></div><div class=\"line\"><span class=\"comment\">// Random dice roll is 5</span></div><div class=\"line\"><span class=\"comment\">// Random dice roll is 4</span></div><div class=\"line\"><span class=\"comment\">// Random dice roll is 5</span></div><div class=\"line\"><span class=\"comment\">// Random dice roll is 4</span></div></pre></td></tr></table></figure>\n<h3 id=\"委托（代理）模式\"><a href=\"#委托（代理）模式\" class=\"headerlink\" title=\"委托（代理）模式\"></a>委托（代理）模式</h3><p>委托是一种设计模式，它允许类或结构体将一些需要它们负责的功能委托给其他类型的实例。委托模式的实现很简单：定义协议来封装那些需要被委托的功能，这样就能确保遵循协议的类型能提供这些功能。委托模式可以用来响应特定的动作，或者接收外部数据源提供的数据，而无需关心外部数据源的类型。<br>下面的例子定义了两个基于骰子游戏的协议：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">DiceGame</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> dice: <span class=\"type\">Dice</span> &#123; <span class=\"keyword\">get</span> &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">play</span><span class=\"params\">()</span></span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">DiceGameDelegate</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gameDidStart</span><span class=\"params\">(<span class=\"number\">_</span> game: DiceGame)</span></span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">game</span><span class=\"params\">(<span class=\"number\">_</span> game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int)</span></span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gameDidEnd</span><span class=\"params\">(<span class=\"number\">_</span> game: DiceGame)</span></span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>DiceGame 协议可以被任意涉及骰子的游戏遵循。DiceGameDelegate 协议可以被任意类型遵循，用来追踪 DiceGame 的游戏过程。</p>\n<p>如下所示，SnakesAndLadders 是 控制流 章节引入的蛇梯棋游戏的新版本。新版本使用 Dice 实例作为骰子，并且实现了 DiceGame 和 DiceGameDelegate 协议，后者用来记录游戏的过程：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SnakesAndLadders</span>: <span class=\"title\">DiceGame</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> finalSquare = <span class=\"number\">25</span></div><div class=\"line\">    <span class=\"keyword\">let</span> dice = <span class=\"type\">Dice</span>(sides: <span class=\"number\">6</span>, generator: <span class=\"type\">LinearCongruentialGenerator</span>())</div><div class=\"line\">    <span class=\"keyword\">var</span> square = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">var</span> board: [<span class=\"type\">Int</span>]</div><div class=\"line\">    <span class=\"keyword\">init</span>() &#123;</div><div class=\"line\">        board = <span class=\"type\">Array</span>(repeating: <span class=\"number\">0</span>, <span class=\"built_in\">count</span>: finalSquare + <span class=\"number\">1</span>)</div><div class=\"line\">        board[<span class=\"number\">03</span>] = +<span class=\"number\">08</span>; board[<span class=\"number\">06</span>] = +<span class=\"number\">11</span>; board[<span class=\"number\">09</span>] = +<span class=\"number\">09</span>; board[<span class=\"number\">10</span>] = +<span class=\"number\">02</span></div><div class=\"line\">        board[<span class=\"number\">14</span>] = -<span class=\"number\">10</span>; board[<span class=\"number\">19</span>] = -<span class=\"number\">11</span>; board[<span class=\"number\">22</span>] = -<span class=\"number\">02</span>; board[<span class=\"number\">24</span>] = -<span class=\"number\">08</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> delegate: <span class=\"type\">DiceGameDelegate</span>?</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">play</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        square = <span class=\"number\">0</span></div><div class=\"line\">        delegate?.gameDidStart(<span class=\"keyword\">self</span>)</div><div class=\"line\">        gameLoop: <span class=\"keyword\">while</span> square != finalSquare &#123;</div><div class=\"line\">            <span class=\"keyword\">let</span> diceRoll = dice.roll()</div><div class=\"line\">            delegate?.game(<span class=\"keyword\">self</span>, didStartNewTurnWithDiceRoll: diceRoll)</div><div class=\"line\">            <span class=\"keyword\">switch</span> square + diceRoll &#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> finalSquare:</div><div class=\"line\">                <span class=\"keyword\">break</span> gameLoop</div><div class=\"line\">            <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> newSquare <span class=\"keyword\">where</span> newSquare &gt; finalSquare:</div><div class=\"line\">                <span class=\"keyword\">continue</span> gameLoop</div><div class=\"line\">            <span class=\"keyword\">default</span>:</div><div class=\"line\">                square += diceRoll</div><div class=\"line\">                square += board[square]</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        delegate?.gameDidEnd(<span class=\"keyword\">self</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个版本的游戏封装到了 SnakesAndLadders 类中，该类遵循了 DiceGame 协议，并且提供了相应的可读的 dice 属性和 play() 方法。（ dice 属性在构造之后就不再改变，且协议只要求 dice 为可读的，因此将 dice 声明为常量属性。）<br>游戏使用 SnakesAndLadders 类的 init() 构造器来初始化游戏。所有的游戏逻辑被转移到了协议中的 play() 方法，play() 方法使用协议要求的 dice 属性提供骰子摇出的值。<br>注意，delegate 并不是游戏的必备条件，因此 delegate 被定义为 DiceGameDelegate 类型的可选属性。因为 delegate 是可选值，因此会被自动赋予初始值 nil。随后，可以在游戏中为 delegate 设置适当的值。</p>\n<p>DicegameDelegate 协议提供了三个方法用来追踪游戏过程。这三个方法被放置于游戏的逻辑中，即 play() 方法内。分别在游戏开始时，新一轮开始时，以及游戏结束时被调用。</p>\n<p>因为 delegate 是一个 DiceGameDelegate 类型的可选属性，因此在 play() 方法中通过可选链式调用来调用它的方法。若 delegate 属性为 nil，则调用方法会优雅地失败，并不会产生错误。若 delegate 不为 nil，则方法能够被调用，并传递 SnakesAndLadders 实例作为参数。</p>\n<p>如下示例定义了 DiceGameTracker 类，它遵循了 DiceGameDelegate 协议：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DiceGameTracker</span>: <span class=\"title\">DiceGameDelegate</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> numberOfTurns = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gameDidStart</span><span class=\"params\">(<span class=\"number\">_</span> game: DiceGame)</span></span> &#123;</div><div class=\"line\">        numberOfTurns = <span class=\"number\">0</span></div><div class=\"line\">        <span class=\"keyword\">if</span> game <span class=\"keyword\">is</span> <span class=\"type\">SnakesAndLadders</span> &#123;</div><div class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">\"Started a new game of Snakes and Ladders\"</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"The game is using a <span class=\"subst\">\\(game.dice.sides)</span>-sided dice\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">game</span><span class=\"params\">(<span class=\"number\">_</span> game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int)</span></span> &#123;</div><div class=\"line\">        numberOfTurns += <span class=\"number\">1</span></div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Rolled a <span class=\"subst\">\\(diceRoll)</span>\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gameDidEnd</span><span class=\"params\">(<span class=\"number\">_</span> game: DiceGame)</span></span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"The game lasted for <span class=\"subst\">\\(numberOfTurns)</span> turns\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>DiceGameTracker 实现了 DiceGameDelegate 协议要求的三个方法，用来记录游戏已经进行的轮数。当游戏开始时，numberOfTurns 属性被赋值为 0，然后在每新一轮中递增，游戏结束后，打印游戏的总轮数。<br>DiceGameTracker 的运行情况如下所示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> tracker = <span class=\"type\">DiceGameTracker</span>()</div><div class=\"line\"><span class=\"keyword\">let</span> game = <span class=\"type\">SnakesAndLadders</span>()</div><div class=\"line\">game.delegate = tracker</div><div class=\"line\">game.play()</div><div class=\"line\"><span class=\"comment\">// Started a new game of Snakes and Ladders</span></div><div class=\"line\"><span class=\"comment\">// The game is using a 6-sided dice</span></div><div class=\"line\"><span class=\"comment\">// Rolled a 3</span></div><div class=\"line\"><span class=\"comment\">// Rolled a 5</span></div><div class=\"line\"><span class=\"comment\">// Rolled a 4</span></div><div class=\"line\"><span class=\"comment\">// Rolled a 5</span></div><div class=\"line\"><span class=\"comment\">// The game lasted for 4 turns</span></div></pre></td></tr></table></figure>\n<h3 id=\"通过扩展遵循协议\"><a href=\"#通过扩展遵循协议\" class=\"headerlink\" title=\"通过扩展遵循协议\"></a>通过扩展遵循协议</h3><p>即便无法修改源代码，依然可以通过扩展令已有类型遵循并符合协议。扩展可以为已有类型添加属性、方法、下标以及构造器，因此可以符合协议中的相应要求。<br>    通过扩展令已有类型遵循并符合协议时，该类型的所有实例也会随之获得协议中定义的各项功能。</p>\n<p>例如下面这个 TextRepresentable 协议，任何想要通过文本表示一些内容的类型都可以实现该协议。这些想要表示的内容可以是实例本身的描述，也可以是实例当前状态的文本描述：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">TextRepresentable</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> textualDescription: <span class=\"type\">String</span> &#123; <span class=\"keyword\">get</span> &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以通过扩展，令先前提到的 Dice 类遵循并符合 TextRepresentable 协议：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Dice</span>: <span class=\"title\">TextRepresentable</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> textualDescription: <span class=\"type\">String</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"A <span class=\"subst\">\\(sides)</span>-sided dice\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过扩展遵循并符合协议，和在原始定义中遵循并符合协议的效果完全相同。协议名称写在类型名之后，以冒号隔开，然后在扩展的大括号内实现协议要求的内容。<br>现在所有 Dice 的实例都可以看做 TextRepresentable 类型：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> d12 = <span class=\"type\">Dice</span>(sides: <span class=\"number\">12</span>, generator: <span class=\"type\">LinearCongruentialGenerator</span>())</div><div class=\"line\"><span class=\"built_in\">print</span>(d12.textualDescription)</div><div class=\"line\"><span class=\"comment\">// Prints \"A 12-sided dice\"</span></div></pre></td></tr></table></figure>\n<p>同样，SnakesAndLadders 类也可以通过扩展遵循并符合 TextRepresentable 协议：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">SnakesAndLadders</span>: <span class=\"title\">TextRepresentable</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> textualDescription: <span class=\"type\">String</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"A game of Snakes and Ladders with <span class=\"subst\">\\(finalSquare)</span> squares\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">print</span>(game.textualDescription)</div><div class=\"line\"><span class=\"comment\">// Prints \"A game of Snakes and Ladders with 25 squares\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"通过扩展遵循协议-1\"><a href=\"#通过扩展遵循协议-1\" class=\"headerlink\" title=\"通过扩展遵循协议\"></a>通过扩展遵循协议</h4><p>当一个类型已经符合了某个协议中的所有要求，却还没有声明遵循该协议时，可以通过空扩展体的扩展来遵循该协议：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Hamster</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">var</span> textualDescription: <span class=\"type\">String</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"A hamster named <span class=\"subst\">\\(name)</span>\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Hamster</span>: <span class=\"title\">TextRepresentable</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n<p>从现在起，Hamster 的实例可以作为 TextRepresentable 类型使用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> simonTheHamster = <span class=\"type\">Hamster</span>(name: <span class=\"string\">\"Simon\"</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> somethingTextRepresentable: <span class=\"type\">TextRepresentable</span> = simonTheHamster</div><div class=\"line\"><span class=\"built_in\">print</span>(somethingTextRepresentable.textualDescription)</div><div class=\"line\"><span class=\"comment\">// Prints \"A hamster named Simon\"</span></div></pre></td></tr></table></figure>\n<pre><code>即使满足了协议的所有要求，类型也不会自动遵循协议，必须显式地遵循协议。\n</code></pre><h3 id=\"协议类型的集合\"><a href=\"#协议类型的集合\" class=\"headerlink\" title=\"协议类型的集合\"></a>协议类型的集合</h3><p>协议类型可以在数组或者字典这样的集合中使用，在协议类型提到了这样的用法。下面的例子创建了一个元素类型为 TextRepresentable 的数组：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> things: [<span class=\"type\">TextRepresentable</span>] = [game, d12, simonTheHamster]</div></pre></td></tr></table></figure>\n<p>如下所示，可以遍历 things 数组，并打印每个元素的文本表示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> thing <span class=\"keyword\">in</span> things &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(thing.textualDescription)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// A game of Snakes and Ladders with 25 squares</span></div><div class=\"line\"><span class=\"comment\">// A 12-sided dice</span></div><div class=\"line\"><span class=\"comment\">// A hamster named Simon</span></div></pre></td></tr></table></figure>\n<p>thing 是 TextRepresentable 类型而不是 Dice，DiceGame，Hamster 等类型，即使实例在幕后确实是这些类型中的一种。由于 thing 是 TextRepresentable 类型，任何 TextRepresentable 的实例都有一个 textualDescription 属性，所以在每次循环中可以安全地访问 thing.textualDescription。</p>\n<h3 id=\"协议的继承\"><a href=\"#协议的继承\" class=\"headerlink\" title=\"协议的继承\"></a>协议的继承</h3><p>协议能够继承一个或多个其他协议，可以在继承的协议的基础上增加新的要求。协议的继承语法与类的继承相似，多个被继承的协议间用逗号分隔：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">InheritingProtocol</span>: <span class=\"title\">SomeProtocol</span>, <span class=\"title\">AnotherProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// protocol definition goes here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如下所示，PrettyTextRepresentable 协议继承了 TextRepresentable 协议：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">PrettyTextRepresentable</span>: <span class=\"title\">TextRepresentable</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> prettyTextualDescription: <span class=\"type\">String</span> &#123; <span class=\"keyword\">get</span> &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>例子中定义了一个新的协议 PrettyTextRepresentable，它继承自 TextRepresentable 协议。任何遵循 PrettyTextRepresentable 协议的类型在满足该协议的要求时，也必须满足 TextRepresentable 协议的要求。在这个例子中，PrettyTextRepresentable 协议额外要求遵循协议的类型提供一个返回值为 String 类型的 prettyTextualDescription 属性。</p>\n<p>如下所示，扩展 SnakesAndLadders，使其遵循并符合 PrettyTextRepresentable 协议：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">SnakesAndLadders</span>: <span class=\"title\">PrettyTextRepresentable</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> prettyTextualDescription: <span class=\"type\">String</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> output = textualDescription + <span class=\"string\">\":\\n\"</span></div><div class=\"line\">        <span class=\"keyword\">for</span> index <span class=\"keyword\">in</span> <span class=\"number\">1</span>...finalSquare &#123;</div><div class=\"line\">            <span class=\"keyword\">switch</span> board[index] &#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> ladder <span class=\"keyword\">where</span> ladder &gt; <span class=\"number\">0</span>:</div><div class=\"line\">                output += <span class=\"string\">\"▲ \"</span></div><div class=\"line\">            <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> snake <span class=\"keyword\">where</span> snake &lt; <span class=\"number\">0</span>:</div><div class=\"line\">                output += <span class=\"string\">\"▼ \"</span></div><div class=\"line\">            <span class=\"keyword\">default</span>:</div><div class=\"line\">                output += <span class=\"string\">\"○ \"</span></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> output</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述扩展令 SnakesAndLadders 遵循了 PrettyTextRepresentable 协议，并提供了协议要求的 prettyTextualDescription 属性。每个 PrettyTextRepresentable 类型同时也是 TextRepresentable 类型，所以在 prettyTextualDescription 的实现中，可以访问 textualDescription 属性。</p>\n<p>任意 SankesAndLadders 的实例都可以使用 prettyTextualDescription 属性来打印一个漂亮的文本描述：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">print</span>(game.prettyTextualDescription)</div><div class=\"line\"><span class=\"comment\">// A game of Snakes and Ladders with 25 squares:</span></div><div class=\"line\"><span class=\"comment\">// ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○</span></div></pre></td></tr></table></figure>\n<h3 id=\"类类型专属协议\"><a href=\"#类类型专属协议\" class=\"headerlink\" title=\"类类型专属协议\"></a>类类型专属协议</h3><p>你可以在协议的继承列表中，通过添加 class 关键字来限制协议只能被类类型遵循，而结构体或枚举不能遵循该协议。<code>class</code> 关键字必须第一个出现在协议的继承列表中，在其他继承的协议之前：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">SomeClassOnlyProtocol</span>: <span class=\"title\">class</span>, <span class=\"title\">SomeInheritedProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// class-only protocol definition goes here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在以上例子中，协议 SomeClassOnlyProtocol 只能被类类型遵循。如果尝试让结构体或枚举类型遵循该协议，则会导致编译错误。</p>\n<pre><code>当协议定义的要求需要遵循协议的类型必须是引用语义而非值语义时，应该采用类类型专属协议。\n</code></pre><h3 id=\"协议合成\"><a href=\"#协议合成\" class=\"headerlink\" title=\"协议合成\"></a>协议合成</h3><p>有时候需要同时遵循多个协议，你可以将多个协议采用 SomeProtocol &amp; AnotherProtocol 这样的格式进行组合，称为 协议合成（protocol composition）。你可以罗列任意多个你想要遵循的协议，以与符号(&amp;)分隔。</p>\n<p>下面的例子中，将 Named 和 Aged 两个协议按照上述语法组合成一个协议，作为函数参数的类型：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">Named</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span> &#123; <span class=\"keyword\">get</span> &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">Aged</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> age: <span class=\"type\">Int</span> &#123; <span class=\"keyword\">get</span> &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span>: <span class=\"title\">Named</span>, <span class=\"title\">Aged</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">var</span> age: <span class=\"type\">Int</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">wishHappyBirthday</span><span class=\"params\">(to celebrator: Named &amp; Aged)</span></span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Happy birthday, <span class=\"subst\">\\(celebrator.name)</span>, you're <span class=\"subst\">\\(celebrator.age)</span>!\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> birthdayPerson = <span class=\"type\">Person</span>(name: <span class=\"string\">\"Malcolm\"</span>, age: <span class=\"number\">21</span>)</div><div class=\"line\">wishHappyBirthday(to: birthdayPerson)</div><div class=\"line\"><span class=\"comment\">// Prints \"Happy birthday, Malcolm, you're 21!\"</span></div></pre></td></tr></table></figure>\n<p>Named 协议包含 String 类型的 name 属性。Aged 协议包含 Int 类型的 age 属性。Person 结构体遵循了这两个协议。<br>wishHappyBirthday(to:) 函数的参数 celebrator 的类型为 Named &amp; Aged。这意味着它不关心参数的具体类型，只要参数符合这两个协议即可。<br>上面的例子创建了一个名为 birthdayPerson 的 Person 的实例，作为参数传递给了 wishHappyBirthday(to:) 函数。因为 Person 同时符合这两个协议，所以这个参数合法，函数将打印生日问候语。</p>\n<pre><code>协议合成并不会生成新的、永久的协议类型，而是将多个协议中的要求合成到一个只在局部作用域有效的临时协议中。\n</code></pre><h3 id=\"检查协议一致性\"><a href=\"#检查协议一致性\" class=\"headerlink\" title=\"检查协议一致性\"></a>检查协议一致性</h3><p>你可以使用类型转换中描述的 is 和 as 操作符来检查协议一致性，即是否符合某协议，并且可以转换到指定的协议类型。检查和转换到某个协议类型在语法上和类型的检查和转换完全相同：</p>\n<ul>\n<li>is 用来检查实例是否符合某个协议，若符合则返回 true，否则返回 false。</li>\n<li>as? 返回一个可选值，当实例符合某个协议时，返回类型为协议类型的可选值，否则返回 nil。</li>\n<li>as! 将实例强制向下转换到某个协议类型，如果强转失败，会引发运行时错误。</li>\n</ul>\n<p>This example defines a protocol called HasArea, with a single property requirement of a gettable Double property called area:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">HasArea</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> area: <span class=\"type\">Double</span> &#123; <span class=\"keyword\">get</span> &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Here are two classes, Circle and Country, both of which conform to the HasArea protocol:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Circle</span>: <span class=\"title\">HasArea</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> pi = <span class=\"number\">3.1415927</span></div><div class=\"line\">    <span class=\"keyword\">var</span> radius: <span class=\"type\">Double</span></div><div class=\"line\">    <span class=\"keyword\">var</span> area: <span class=\"type\">Double</span> &#123; <span class=\"keyword\">return</span> pi * radius * radius &#125;</div><div class=\"line\">    <span class=\"keyword\">init</span>(radius: <span class=\"type\">Double</span>) &#123; <span class=\"keyword\">self</span>.radius = radius &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Country</span>: <span class=\"title\">HasArea</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> area: <span class=\"type\">Double</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(area: <span class=\"type\">Double</span>) &#123; <span class=\"keyword\">self</span>.area = area &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Circle 类把 area 属性实现为基于存储型属性 radius 的计算型属性。Country 类则把 area 属性实现为存储型属性。这两个类都正确地符合了 HasArea 协议。</p>\n<p>如下所示，Animal 是一个未遵循 HasArea 协议的类：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> legs: <span class=\"type\">Int</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(legs: <span class=\"type\">Int</span>) &#123; <span class=\"keyword\">self</span>.legs = legs &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Circle，Country，Animal 并没有一个共同的基类，尽管如此，它们都是类，它们的实例都可以作为 AnyObject 类型的值，存储在同一个数组中：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> objects: [<span class=\"type\">AnyObject</span>] = [</div><div class=\"line\">    <span class=\"type\">Circle</span>(radius: <span class=\"number\">2.0</span>),</div><div class=\"line\">    <span class=\"type\">Country</span>(area: <span class=\"number\">243_610</span>),</div><div class=\"line\">    <span class=\"type\">Animal</span>(legs: <span class=\"number\">4</span>)</div><div class=\"line\">]</div></pre></td></tr></table></figure>\n<p>如下所示，objects 数组可以被迭代，并对迭代出的每一个元素进行检查，看它是否符合 HasArea 协议：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> object <span class=\"keyword\">in</span> objects &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> objectWithArea = object <span class=\"keyword\">as</span>? <span class=\"type\">HasArea</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Area is <span class=\"subst\">\\(objectWithArea.area)</span>\"</span>)</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Something that doesn't have an area\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Area is 12.5663708</span></div><div class=\"line\"><span class=\"comment\">// Area is 243610.0</span></div><div class=\"line\"><span class=\"comment\">// Something that doesn't have an area</span></div></pre></td></tr></table></figure>\n<p>当迭代出的元素符合 HasArea 协议时，将 as? 操作符返回的可选值通过可选绑定，绑定到 objectWithArea 常量上。objectWithArea 是 HasArea 协议类型的实例，因此 area 属性可以被访问和打印。</p>\n<p>objects 数组中的元素的类型并不会因为强转而丢失类型信息，它们仍然是 Circle，Country，Animal 类型。然而，当它们被赋值给 objectWithArea 常量时，只被视为 HasArea 类型，因此只有 area 属性能够被访问。</p>\n<h3 id=\"可选的协议要求\"><a href=\"#可选的协议要求\" class=\"headerlink\" title=\"可选的协议要求\"></a>可选的协议要求</h3><p>协议可以定义可选要求，遵循协议的类型可以选择是否实现这些要求。在协议中使用 optional 关键字作为前缀来定义可选要求。可选要求用在你需要和 Objective-C 打交道的代码中。协议和可选要求都必须带上@objc属性。标记 @objc 特性的协议只能被继承自 Objective-C 类的类或者 @objc 类遵循，其他类以及结构体和枚举均不能遵循这种协议。</p>\n<p>使用可选要求时（例如，可选的方法或者属性），它们的类型会自动变成可选的。比如，一个类型为 (Int) -&gt; String 的方法会变成 ((Int) -&gt; String)?</p>\n<p>协议中的可选要求可通过可选链式调用来使用，因为遵循协议的类型可能没有实现这些可选要求。类似 someOptionalMethod?(someArgument) 这样，你可以在可选方法名称后加上 ? 来调用可选方法。</p>\n<p>下面的例子定义了一个名为 Counter 的用于整数计数的类，它使用外部的数据源来提供每次的增量。数据源由 CounterDataSource 协议定义，包含两个可选要求：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@objc</span> <span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">CounterDataSource</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@objc</span> <span class=\"keyword\">optional</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">increment</span><span class=\"params\">(forCount <span class=\"built_in\">count</span>: Int)</span></span> -&gt; <span class=\"type\">Int</span></div><div class=\"line\">    <span class=\"meta\">@objc</span> <span class=\"keyword\">optional</span> <span class=\"keyword\">var</span> fixedIncrement: <span class=\"type\">Int</span> &#123; <span class=\"keyword\">get</span> &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>CounterDataSource 协议定义了一个可选方法 increment(forCount:) 和一个可选属性 fiexdIncrement，它们使用了不同的方法来从数据源中获取适当的增量值。<br>    严格来讲，CounterDataSource 协议中的方法和属性都是可选的，因此遵循协议的类可以不实现这些要求</p>\n<p>Counter 类含有 CounterDataSource? 类型的可选属性 dataSource，如下所示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">count</span> = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">var</span> dataSource: <span class=\"type\">CounterDataSource</span>?</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">increment</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> amount = dataSource?.increment?(forCount: <span class=\"built_in\">count</span>) &#123;</div><div class=\"line\">            <span class=\"built_in\">count</span> += amount</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> amount = dataSource?.fixedIncrement &#123;</div><div class=\"line\">            <span class=\"built_in\">count</span> += amount</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下面的例子展示了 CounterDataSource 的简单实现。ThreeSource 类遵循了 CounterDataSource 协议，它实现了可选属性 fixedIncrement，每次会返回 3：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreeSource</span>: <span class=\"title\">NSObject</span>, <span class=\"title\">CounterDataSource</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> fixedIncrement = <span class=\"number\">3</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以使用 ThreeSource 的实例作为 Counter 实例的数据源：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> counter = <span class=\"type\">Counter</span>()</div><div class=\"line\">counter.dataSource = <span class=\"type\">ThreeSource</span>()</div><div class=\"line\"><span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">1</span>...<span class=\"number\">4</span> &#123;</div><div class=\"line\">    counter.increment()</div><div class=\"line\">    <span class=\"built_in\">print</span>(counter.<span class=\"built_in\">count</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 3</span></div><div class=\"line\"><span class=\"comment\">// 6</span></div><div class=\"line\"><span class=\"comment\">// 9</span></div><div class=\"line\"><span class=\"comment\">// 12</span></div></pre></td></tr></table></figure>\n<p>上述代码新建了一个 Counter 实例，并将它的数据源设置为一个 ThreeSource 的实例，然后调用 increment() 方法四次。和预期一样，每次调用都会将 count 的值增加 3.</p>\n<p>下面是一个更为复杂的数据源 TowardsZeroSource，它将使得最后的值变为 0：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">@objc class TowardsZeroSource: NSObject, CounterDataSource &#123;</div><div class=\"line\">    func increment(forCount count: Int) -&gt; Int &#123;</div><div class=\"line\">        if count == 0 &#123;</div><div class=\"line\">            return 0</div><div class=\"line\">        &#125; else if count &lt; 0 &#123;</div><div class=\"line\">            return 1</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            return -1</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你可以使用 TowardsZeroSource 实例将 Counter 实例来从 -4 增加到 0。一旦增加到 0，数值便不会再有变动：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">counter.<span class=\"built_in\">count</span> = -<span class=\"number\">4</span></div><div class=\"line\">counter.dataSource = <span class=\"type\">TowardsZeroSource</span>()</div><div class=\"line\"><span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">1</span>...<span class=\"number\">5</span> &#123;</div><div class=\"line\">    counter.increment()</div><div class=\"line\">    <span class=\"built_in\">print</span>(counter.<span class=\"built_in\">count</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// -3</span></div><div class=\"line\"><span class=\"comment\">// -2</span></div><div class=\"line\"><span class=\"comment\">// -1</span></div><div class=\"line\"><span class=\"comment\">// 0</span></div><div class=\"line\"><span class=\"comment\">// 0</span></div></pre></td></tr></table></figure>\n<h3 id=\"协议扩展\"><a href=\"#协议扩展\" class=\"headerlink\" title=\"协议扩展\"></a>协议扩展</h3><p>协议可以通过扩展来为遵循协议的类型提供属性、方法以及下标的实现。通过这种方式，你可以基于协议本身来实现这些功能，而无需在每个遵循协议的类型中都重复同样的实现，也无需使用全局函数。<br>例如，可以扩展 RandomNumberGenerator 协议来提供 randomBool() 方法。该方法使用协议中定义的 random() 方法来返回一个随机的 Bool 值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">RandomNumberGenerator</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">randomBool</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> random() &gt; <span class=\"number\">0.5</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过协议扩展，所有遵循协议的类型，都能自动获得这个扩展所增加的方法实现，无需任何额外修改：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> generator = <span class=\"type\">LinearCongruentialGenerator</span>()</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Here's a random number: <span class=\"subst\">\\(generator.random()</span>)\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"Here's a random number: 0.37464991998171\"</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"And here's a random Boolean: <span class=\"subst\">\\(generator.randomBool()</span>)\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"And here's a random Boolean: true\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"提供默认实现\"><a href=\"#提供默认实现\" class=\"headerlink\" title=\"提供默认实现\"></a>提供默认实现</h4><p>可以通过协议扩展来为协议要求的属性、方法以及下标提供默认的实现。如果遵循协议的类型为这些要求提供了自己的实现，那么这些自定义实现将会替代扩展中的默认实现被使用。<br>    通过协议扩展为协议要求提供的默认实现和可选的协议要求不同。虽然在这两种情况下，遵循协议的类型都无需自己实现这些要求，但是通过扩展提供的默认实现可以直接调用，而无需使用可选链式调用。</p>\n<p>例如，PrettyTextRepresentable 协议继承自 TextRepresentable 协议，可以为其提供一个默认的 prettyTextualDescription 属性，只是简单地返回 textualDescription 属性的值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">PrettyTextRepresentable</span>  </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> prettyTextualDescription: <span class=\"type\">String</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> textualDescription</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"为协议扩展添加限制条件\"><a href=\"#为协议扩展添加限制条件\" class=\"headerlink\" title=\"为协议扩展添加限制条件\"></a>为协议扩展添加限制条件</h4><p>在扩展协议的时候，可以指定一些限制条件，只有遵循协议的类型满足这些限制条件时，才能获得协议扩展提供的默认实现。这些限制条件写在协议名之后，使用 where 子句来描述<br>例如，你可以扩展 CollectionType 协议，但是只适用于集合中的元素遵循了 TextRepresentable 协议的情况：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Collection</span> <span class=\"title\">where</span> <span class=\"title\">Iterator</span>.<span class=\"title\">Element</span>: <span class=\"title\">TextRepresentable</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> textualDescription: <span class=\"type\">String</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> itemsAsText = <span class=\"keyword\">self</span>.<span class=\"built_in\">map</span> &#123; $<span class=\"number\">0</span>.textualDescription &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"[\"</span> + itemsAsText.joined(separator: <span class=\"string\">\", \"</span>) + <span class=\"string\">\"]\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>textualDescription 属性返回整个集合的文本描述，它将集合中的每个元素的文本描述以逗号分隔的方式连接起来，包在一对方括号中。<br>现在我们来看看先前的 Hamster 结构体，它符合 TextRepresentable 协议，同时这里还有个装有 Hamster 的实例的数组：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> murrayTheHamster = <span class=\"type\">Hamster</span>(name: <span class=\"string\">\"Murray\"</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> morganTheHamster = <span class=\"type\">Hamster</span>(name: <span class=\"string\">\"Morgan\"</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> mauriceTheHamster = <span class=\"type\">Hamster</span>(name: <span class=\"string\">\"Maurice\"</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> hamsters = [murrayTheHamster, morganTheHamster, mauriceTheHamster]</div></pre></td></tr></table></figure>\n<p>因为 Array 符合 CollectionType 协议，而数组中的元素又符合 TextRepresentable 协议，所以数组可以使用 textualDescription 属性得到数组内容的文本表示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">print</span>(hamsters.textualDescription)</div><div class=\"line\"><span class=\"comment\">// Prints \"[A hamster named Murray, A hamster named Morgan, A hamster named Maurice]\"</span></div></pre></td></tr></table></figure>\n<pre><code>如果多个协议扩展都为同一个协议要求提供了默认实现，而遵循协议的类型又同时满足这些协议扩展的限制条件，那么将会使用限制条件最多的那个协议扩展提供的默认实现。\n</code></pre><h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html/\" target=\"_blank\" rel=\"external\"> Protocols </a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>​    协议 定义了用来实现某一特定任务或者功能的方法、属性，以及其他需要的东西的一个蓝图。类、结构体或枚举都可以遵循协议，并为协议定义的这些要求提供具体实现。任何类型能够满足某个协议的要求，就可以说该类型遵循这个协议。<br>除了遵循协议的类型必须实现的要求外，还可以对协议进行扩展，通过扩展来实现一部分要求或者实现一些附加功能，这样遵循协议的类型就能够使用这些功能。</p>\n<h3 id=\"协议语法\"><a href=\"#协议语法\" class=\"headerlink\" title=\"协议语法\"></a>协议语法</h3><p>协议的定义方式与类、结构体和枚举的定义非常相似：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">SomeProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// protocol definition goes here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>要让自定义类型遵循某个协议，在定义类型时，需要在类型名称后加上协议名称，中间以冒号（:）分隔。遵循多个协议时，各协议之间用逗号（,）分隔：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SomeStructure</span>: <span class=\"title\">FirstProtocol</span>, <span class=\"title\">AnotherProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// structure definition goes here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>拥有父类的类在遵循协议时，应该将父类名放在协议名之前，以逗号分隔：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClass</span>: <span class=\"title\">SomeSuperclass</span>, <span class=\"title\">FirstProtocol</span>, <span class=\"title\">AnotherProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// class definition goes here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","more":"<h3 id=\"属性要求\"><a href=\"#属性要求\" class=\"headerlink\" title=\"属性要求\"></a>属性要求</h3><p>协议可以要求遵循协议的类型提供特定名称和类型的实例属性或类型属性。协议不指定属性是存储型属性还是计算型属性，它只指定属性的名称和类型。此外，协议还指定属性是可读的还是可读可写的。<br>如果协议要求属性是可读可写的，那么该属性不能是常量属性或只读的计算型属性。如果协议只要求属性是可读的，那么该属性不仅可以是可读的，如果代码需要的话，还可以是可写的。</p>\n<p>协议总是用 <code>var</code> 关键字来声明变量属性，在类型声明后加上 <code>{ set get }</code> 来表示属性是可读可写的，可读属性则用 <code>{ get }</code> 来表示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">SomeProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> mustBeSettable: <span class=\"type\">Int</span> &#123; <span class=\"keyword\">get</span> <span class=\"keyword\">set</span> &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> doesNotNeedToBeSettable: <span class=\"type\">Int</span> &#123; <span class=\"keyword\">get</span> &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在协议中定义类型属性时，总是使用 <code>static</code> 关键字作为前缀。当类类型遵循协议时，除了 <code>static</code> 关键字，还可以使用 <code>class</code> 关键字来声明类型属性：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">AnotherProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">var</span> someTypeProperty: <span class=\"type\">Int</span> &#123; <span class=\"keyword\">get</span> <span class=\"keyword\">set</span> &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如下所示，这是一个只含有一个实例属性要求的协议：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">FullyNamed</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> fullName: <span class=\"type\">String</span> &#123; <span class=\"keyword\">get</span> &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>FullyNamed 协议除了要求遵循协议的类型提供 fullName 属性外，并没有其他特别的要求。这个协议表示，任何遵循 FullyNamed 的类型，都必须有一个可读的 String 类型的实例属性 fullName。<br>下面是一个遵循 FullyNamed 协议的简单结构体：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span>: <span class=\"title\">FullyNamed</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> fullName: <span class=\"type\">String</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> john = <span class=\"type\">Person</span>(fullName: <span class=\"string\">\"John Appleseed\"</span>)</div><div class=\"line\"><span class=\"comment\">// john.fullName is \"John Appleseed\"</span></div></pre></td></tr></table></figure>\n<p>这个例子中定义了一个叫做 Person 的结构体，用来表示一个具有名字的人。从第一行代码可以看出，它遵循了 FullyNamed 协议。<br>Person 结构体的每一个实例都有一个 String 类型的存储型属性 fullName。这正好满足了 FullyNamed 协议的要求，也就意味着 Person 结构体正确地符合了协议。（如果协议要求未被完全满足，在编译时会报错。）<br>下面是一个更为复杂的类，它适配并遵循了 FullyNamed 协议：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Starship</span>: <span class=\"title\">FullyNamed</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">prefix</span>: <span class=\"type\">String</span>?</div><div class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>, <span class=\"keyword\">prefix</span>: <span class=\"type\">String</span>? = <span class=\"literal\">nil</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.name = name</div><div class=\"line\">        <span class=\"keyword\">self</span>.<span class=\"keyword\">prefix</span> = <span class=\"keyword\">prefix</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> fullName: <span class=\"type\">String</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"keyword\">prefix</span> != <span class=\"literal\">nil</span> ? <span class=\"keyword\">prefix</span>! + <span class=\"string\">\" \"</span> : <span class=\"string\">\"\"</span>) + name</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> ncc1701 = <span class=\"type\">Starship</span>(name: <span class=\"string\">\"Enterprise\"</span>, <span class=\"keyword\">prefix</span>: <span class=\"string\">\"USS\"</span>)</div><div class=\"line\"><span class=\"comment\">// ncc1701.fullName is \"USS Enterprise\"</span></div></pre></td></tr></table></figure>\n<p>Starship 类把 fullName 属性实现为只读的计算型属性。每一个 Starship 类的实例都有一个名为 name 的非可选属性和一个名为 prefix 的可选属性。 当 prefix 存在时，计算型属性 fullName 会将 prefix 插入到 name 之前，从而为星际飞船构建一个全名。</p>\n<h3 id=\"方法要求（Method-Requirements）\"><a href=\"#方法要求（Method-Requirements）\" class=\"headerlink\" title=\"方法要求（Method Requirements）\"></a>方法要求（Method Requirements）</h3><p>协议可以要求遵循协议的类型实现某些指定的实例方法或类方法。这些方法作为协议的一部分，像普通方法一样放在协议的定义中，但是不需要大括号和方法体。可以在协议中定义具有可变参数的方法，和普通方法的定义方式相同。但是，不支持为协议中的方法的参数提供默认值。<br>正如属性要求中所述，在协议中定义类方法的时候，总是使用 <code>static</code> 关键字作为前缀。当类类型遵循协议时，除了 <code>static</code> 关键字，还可以使用 <code>class</code> 关键字作为前缀：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">SomeProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">someTypeMethod</span><span class=\"params\">()</span></span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下面的例子定义了一个只含有一个实例方法的协议：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">RandomNumberGenerator</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">random</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Double</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>RandomNumberGenerator 协议要求遵循协议的类型必须拥有一个名为 random， 返回值类型为 Double 的实例方法。<br>RandomNumberGenerator 协议并不关心每一个随机数是怎样生成的，它只要求必须提供一个随机数生成器。</p>\n<p>如下所示，下边是一个遵循并符合 RandomNumberGenerator 协议的类。该类实现了一个叫做 线性同余生成器（linear congruential generator） 的伪随机数算法。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LinearCongruentialGenerator</span>: <span class=\"title\">RandomNumberGenerator</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> lastRandom = <span class=\"number\">42.0</span></div><div class=\"line\">    <span class=\"keyword\">let</span> m = <span class=\"number\">139968.0</span></div><div class=\"line\">    <span class=\"keyword\">let</span> a = <span class=\"number\">3877.0</span></div><div class=\"line\">    <span class=\"keyword\">let</span> <span class=\"built_in\">c</span> = <span class=\"number\">29573.0</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">random</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Double</span> &#123;</div><div class=\"line\">        lastRandom = ((lastRandom * a + <span class=\"built_in\">c</span>).truncatingRemainder(dividingBy:m))</div><div class=\"line\">        <span class=\"keyword\">return</span> lastRandom / m</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> generator = <span class=\"type\">LinearCongruentialGenerator</span>()</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Here's a random number: <span class=\"subst\">\\(generator.random()</span>)\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"Here's a random number: 0.37464991998171\"</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"And another one: <span class=\"subst\">\\(generator.random()</span>)\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"And another one: 0.729023776863283\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"Mutating-方法要求\"><a href=\"#Mutating-方法要求\" class=\"headerlink\" title=\"Mutating 方法要求\"></a>Mutating 方法要求</h3><p>有时需要在方法中改变方法所属的实例。例如，在值类型（即结构体和枚举）的实例方法中，将 mutating 关键字作为方法的前缀，写在 <code>func</code> 关键字之前，表示可以在该方法中修改它所属的实例以及实例的任意属性的值。<br>如果你在协议中定义了一个实例方法，该方法会改变遵循该协议的类型的实例，那么在定义协议时需要在方法前加 mutating 关键字。这使得结构体和枚举能够遵循此协议并满足此方法要求。<br>    实现协议中的 mutating 方法时，若是类类型，则不用写 mutating 关键字。而对于结构体和枚举，则必须写 mutating 关键字。</p>\n<p>如下所示，Togglable 协议只要求实现一个名为 toggle 的实例方法。根据名称的暗示，toggle() 方法将改变实例属性，从而切换遵循该协议类型的实例的状态。<br>toggle() 方法在定义的时候，使用 mutating 关键字标记，这表明当它被调用时，该方法将会改变遵循协议的类型的实例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">Togglable</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">toggle</span><span class=\"params\">()</span></span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当使用枚举或结构体来实现 Togglable 协议时，需要提供一个带有 mutating 前缀的 toggle() 方法。<br>下面定义了一个名为 OnOffSwitch 的枚举。这个枚举在两种状态之间进行切换，用枚举成员 On 和 Off 表示。枚举的 toggle() 方法被标记为 mutating，以满足 Togglable 协议的要求：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">OnOffSwitch</span>: <span class=\"title\">Togglable</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> off, on</div><div class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">toggle</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> <span class=\"keyword\">self</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> .off:</div><div class=\"line\">            <span class=\"keyword\">self</span> = .on</div><div class=\"line\">        <span class=\"keyword\">case</span> .on:</div><div class=\"line\">            <span class=\"keyword\">self</span> = .off</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> lightSwitch = <span class=\"type\">OnOffSwitch</span>.off</div><div class=\"line\">lightSwitch.toggle()</div><div class=\"line\"><span class=\"comment\">// lightSwitch is now equal to .on</span></div></pre></td></tr></table></figure>\n<h3 id=\"构造器要求\"><a href=\"#构造器要求\" class=\"headerlink\" title=\"构造器要求\"></a>构造器要求</h3><p>协议可以要求遵循协议的类型实现指定的构造器。你可以像编写普通构造器那样，在协议的定义里写下构造器的声明，但不需要写花括号和构造器的实体：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">SomeProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">init</span>(someParameter: <span class=\"type\">Int</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"协议中的构造器在类中的实现\"><a href=\"#协议中的构造器在类中的实现\" class=\"headerlink\" title=\"协议中的构造器在类中的实现\"></a>协议中的构造器在类中的实现</h4><p>你可以在遵循协议的类中实现构造器，无论是作为指定构造器，还是作为便利构造器。无论哪种情况，你都必须为构造器实现标上 <code>required</code> 修饰符：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeClass</span>: <span class=\"title\">SomeProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">required</span> <span class=\"keyword\">init</span>(someParameter: <span class=\"type\">Int</span>) &#123;</div><div class=\"line\">        <span class=\"comment\">// initializer implementation goes here</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用 required 修饰符可以确保所有子类也必须提供此构造器实现，从而也能符合协议。<br>    如果类已经被标记为 final，那么不需要在协议构造器的实现中使用 required 修饰符，因为 final 类不能有子类。</p>\n<p>如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求，那么该构造器的实现需要同时标注 <code>required</code> 和 <code>override</code> 修饰符：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">SomeProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">init</span>()</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeSuperClass</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">init</span>() &#123;</div><div class=\"line\">        <span class=\"comment\">// initializer implementation goes here</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeSubClass</span>: <span class=\"title\">SomeSuperClass</span>, <span class=\"title\">SomeProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// \"required\" from SomeProtocol conformance; \"override\" from SomeSuperClass</span></div><div class=\"line\">    <span class=\"keyword\">required</span> <span class=\"keyword\">override</span> <span class=\"keyword\">init</span>() &#123;</div><div class=\"line\">        <span class=\"comment\">// initializer implementation goes here</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"可失败构造器要求\"><a href=\"#可失败构造器要求\" class=\"headerlink\" title=\"可失败构造器要求\"></a>可失败构造器要求</h4><p>协议还可以为遵循协议的类型定义可失败构造器要求<br>遵循协议的类型可以通过可失败构造器（init?）或非可失败构造器（init）来满足协议中定义的可失败构造器要求。协议中定义的非可失败构造器要求可以通过非可失败构造器（init）或隐式解包可失败构造器（init!）来满足。</p>\n<h3 id=\"协议作为类型\"><a href=\"#协议作为类型\" class=\"headerlink\" title=\"协议作为类型\"></a>协议作为类型</h3><p>尽管协议本身并未实现任何功能，但是协议可以被当做一个成熟的类型来使用。<br>协议可以像其他普通类型一样使用，使用场景包括：</p>\n<ul>\n<li>作为函数、方法或构造器中的参数类型或返回值类型</li>\n<li>作为常量、变量或属性的类型</li>\n<li><p>作为数组、字典或其他容器中的元素类型</p>\n<p> 协议是一种类型，因此协议类型的名称应与其他类型（例如 Int，Double，String）的写法相同，使用大写字母开头的驼峰式写法，例如（FullyNamed 和 RandomNumberGenerator）。</p>\n</li>\n</ul>\n<p>下面是将协议作为类型使用的例子：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dice</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> sides: <span class=\"type\">Int</span></div><div class=\"line\">    <span class=\"keyword\">let</span> generator: <span class=\"type\">RandomNumberGenerator</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(sides: <span class=\"type\">Int</span>, generator: <span class=\"type\">RandomNumberGenerator</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.sides = sides</div><div class=\"line\">        <span class=\"keyword\">self</span>.generator = generator</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">roll</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Int</span>(generator.random() * <span class=\"type\">Double</span>(sides)) + <span class=\"number\">1</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>例子中定义了一个 Dice 类，用来代表桌游中拥有 N 个面的骰子。Dice 的实例含有 sides 和 generator 两个属性，前者是整型，用来表示骰子有几个面，后者为骰子提供一个随机数生成器，从而生成随机点数。<br>generator 属性的类型为 RandomNumberGenerator，因此任何遵循了 RandomNumberGenerator 协议的类型的实例都可以赋值给 generator，除此之外并无其他要求。<br>Dice 类还有一个构造器，用来设置初始状态。构造器有一个名为 generator，类型为 RandomNumberGenerator 的形参。在调用构造方法创建 Dice 的实例时，可以传入任何遵循 RandomNumberGenerator 协议的实例给 generator。<br>Dice 类提供了一个名为 roll 的实例方法，用来模拟骰子的面值。它先调用 generator 的 random() 方法来生成一个 [0.0,1.0) 区间内的随机数，然后使用这个随机数生成正确的骰子面值。因为 generator 遵循了 RandomNumberGenerator 协议，可以确保它有个 random() 方法可供调用。</p>\n<p>下面的例子展示了如何使用 LinearCongruentialGenerator 的实例作为随机数生成器来创建一个六面骰子：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> d6 = <span class=\"type\">Dice</span>(sides: <span class=\"number\">6</span>, generator: <span class=\"type\">LinearCongruentialGenerator</span>())</div><div class=\"line\"><span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">1</span>...<span class=\"number\">5</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Random dice roll is <span class=\"subst\">\\(d6.roll()</span>)\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Random dice roll is 3</span></div><div class=\"line\"><span class=\"comment\">// Random dice roll is 5</span></div><div class=\"line\"><span class=\"comment\">// Random dice roll is 4</span></div><div class=\"line\"><span class=\"comment\">// Random dice roll is 5</span></div><div class=\"line\"><span class=\"comment\">// Random dice roll is 4</span></div></pre></td></tr></table></figure>\n<h3 id=\"委托（代理）模式\"><a href=\"#委托（代理）模式\" class=\"headerlink\" title=\"委托（代理）模式\"></a>委托（代理）模式</h3><p>委托是一种设计模式，它允许类或结构体将一些需要它们负责的功能委托给其他类型的实例。委托模式的实现很简单：定义协议来封装那些需要被委托的功能，这样就能确保遵循协议的类型能提供这些功能。委托模式可以用来响应特定的动作，或者接收外部数据源提供的数据，而无需关心外部数据源的类型。<br>下面的例子定义了两个基于骰子游戏的协议：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">DiceGame</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> dice: <span class=\"type\">Dice</span> &#123; <span class=\"keyword\">get</span> &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">play</span><span class=\"params\">()</span></span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">DiceGameDelegate</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gameDidStart</span><span class=\"params\">(<span class=\"number\">_</span> game: DiceGame)</span></span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">game</span><span class=\"params\">(<span class=\"number\">_</span> game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int)</span></span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gameDidEnd</span><span class=\"params\">(<span class=\"number\">_</span> game: DiceGame)</span></span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>DiceGame 协议可以被任意涉及骰子的游戏遵循。DiceGameDelegate 协议可以被任意类型遵循，用来追踪 DiceGame 的游戏过程。</p>\n<p>如下所示，SnakesAndLadders 是 控制流 章节引入的蛇梯棋游戏的新版本。新版本使用 Dice 实例作为骰子，并且实现了 DiceGame 和 DiceGameDelegate 协议，后者用来记录游戏的过程：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SnakesAndLadders</span>: <span class=\"title\">DiceGame</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> finalSquare = <span class=\"number\">25</span></div><div class=\"line\">    <span class=\"keyword\">let</span> dice = <span class=\"type\">Dice</span>(sides: <span class=\"number\">6</span>, generator: <span class=\"type\">LinearCongruentialGenerator</span>())</div><div class=\"line\">    <span class=\"keyword\">var</span> square = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">var</span> board: [<span class=\"type\">Int</span>]</div><div class=\"line\">    <span class=\"keyword\">init</span>() &#123;</div><div class=\"line\">        board = <span class=\"type\">Array</span>(repeating: <span class=\"number\">0</span>, <span class=\"built_in\">count</span>: finalSquare + <span class=\"number\">1</span>)</div><div class=\"line\">        board[<span class=\"number\">03</span>] = +<span class=\"number\">08</span>; board[<span class=\"number\">06</span>] = +<span class=\"number\">11</span>; board[<span class=\"number\">09</span>] = +<span class=\"number\">09</span>; board[<span class=\"number\">10</span>] = +<span class=\"number\">02</span></div><div class=\"line\">        board[<span class=\"number\">14</span>] = -<span class=\"number\">10</span>; board[<span class=\"number\">19</span>] = -<span class=\"number\">11</span>; board[<span class=\"number\">22</span>] = -<span class=\"number\">02</span>; board[<span class=\"number\">24</span>] = -<span class=\"number\">08</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> delegate: <span class=\"type\">DiceGameDelegate</span>?</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">play</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        square = <span class=\"number\">0</span></div><div class=\"line\">        delegate?.gameDidStart(<span class=\"keyword\">self</span>)</div><div class=\"line\">        gameLoop: <span class=\"keyword\">while</span> square != finalSquare &#123;</div><div class=\"line\">            <span class=\"keyword\">let</span> diceRoll = dice.roll()</div><div class=\"line\">            delegate?.game(<span class=\"keyword\">self</span>, didStartNewTurnWithDiceRoll: diceRoll)</div><div class=\"line\">            <span class=\"keyword\">switch</span> square + diceRoll &#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> finalSquare:</div><div class=\"line\">                <span class=\"keyword\">break</span> gameLoop</div><div class=\"line\">            <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> newSquare <span class=\"keyword\">where</span> newSquare &gt; finalSquare:</div><div class=\"line\">                <span class=\"keyword\">continue</span> gameLoop</div><div class=\"line\">            <span class=\"keyword\">default</span>:</div><div class=\"line\">                square += diceRoll</div><div class=\"line\">                square += board[square]</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        delegate?.gameDidEnd(<span class=\"keyword\">self</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个版本的游戏封装到了 SnakesAndLadders 类中，该类遵循了 DiceGame 协议，并且提供了相应的可读的 dice 属性和 play() 方法。（ dice 属性在构造之后就不再改变，且协议只要求 dice 为可读的，因此将 dice 声明为常量属性。）<br>游戏使用 SnakesAndLadders 类的 init() 构造器来初始化游戏。所有的游戏逻辑被转移到了协议中的 play() 方法，play() 方法使用协议要求的 dice 属性提供骰子摇出的值。<br>注意，delegate 并不是游戏的必备条件，因此 delegate 被定义为 DiceGameDelegate 类型的可选属性。因为 delegate 是可选值，因此会被自动赋予初始值 nil。随后，可以在游戏中为 delegate 设置适当的值。</p>\n<p>DicegameDelegate 协议提供了三个方法用来追踪游戏过程。这三个方法被放置于游戏的逻辑中，即 play() 方法内。分别在游戏开始时，新一轮开始时，以及游戏结束时被调用。</p>\n<p>因为 delegate 是一个 DiceGameDelegate 类型的可选属性，因此在 play() 方法中通过可选链式调用来调用它的方法。若 delegate 属性为 nil，则调用方法会优雅地失败，并不会产生错误。若 delegate 不为 nil，则方法能够被调用，并传递 SnakesAndLadders 实例作为参数。</p>\n<p>如下示例定义了 DiceGameTracker 类，它遵循了 DiceGameDelegate 协议：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DiceGameTracker</span>: <span class=\"title\">DiceGameDelegate</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> numberOfTurns = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gameDidStart</span><span class=\"params\">(<span class=\"number\">_</span> game: DiceGame)</span></span> &#123;</div><div class=\"line\">        numberOfTurns = <span class=\"number\">0</span></div><div class=\"line\">        <span class=\"keyword\">if</span> game <span class=\"keyword\">is</span> <span class=\"type\">SnakesAndLadders</span> &#123;</div><div class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">\"Started a new game of Snakes and Ladders\"</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"The game is using a <span class=\"subst\">\\(game.dice.sides)</span>-sided dice\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">game</span><span class=\"params\">(<span class=\"number\">_</span> game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int)</span></span> &#123;</div><div class=\"line\">        numberOfTurns += <span class=\"number\">1</span></div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Rolled a <span class=\"subst\">\\(diceRoll)</span>\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gameDidEnd</span><span class=\"params\">(<span class=\"number\">_</span> game: DiceGame)</span></span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"The game lasted for <span class=\"subst\">\\(numberOfTurns)</span> turns\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>DiceGameTracker 实现了 DiceGameDelegate 协议要求的三个方法，用来记录游戏已经进行的轮数。当游戏开始时，numberOfTurns 属性被赋值为 0，然后在每新一轮中递增，游戏结束后，打印游戏的总轮数。<br>DiceGameTracker 的运行情况如下所示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> tracker = <span class=\"type\">DiceGameTracker</span>()</div><div class=\"line\"><span class=\"keyword\">let</span> game = <span class=\"type\">SnakesAndLadders</span>()</div><div class=\"line\">game.delegate = tracker</div><div class=\"line\">game.play()</div><div class=\"line\"><span class=\"comment\">// Started a new game of Snakes and Ladders</span></div><div class=\"line\"><span class=\"comment\">// The game is using a 6-sided dice</span></div><div class=\"line\"><span class=\"comment\">// Rolled a 3</span></div><div class=\"line\"><span class=\"comment\">// Rolled a 5</span></div><div class=\"line\"><span class=\"comment\">// Rolled a 4</span></div><div class=\"line\"><span class=\"comment\">// Rolled a 5</span></div><div class=\"line\"><span class=\"comment\">// The game lasted for 4 turns</span></div></pre></td></tr></table></figure>\n<h3 id=\"通过扩展遵循协议\"><a href=\"#通过扩展遵循协议\" class=\"headerlink\" title=\"通过扩展遵循协议\"></a>通过扩展遵循协议</h3><p>即便无法修改源代码，依然可以通过扩展令已有类型遵循并符合协议。扩展可以为已有类型添加属性、方法、下标以及构造器，因此可以符合协议中的相应要求。<br>    通过扩展令已有类型遵循并符合协议时，该类型的所有实例也会随之获得协议中定义的各项功能。</p>\n<p>例如下面这个 TextRepresentable 协议，任何想要通过文本表示一些内容的类型都可以实现该协议。这些想要表示的内容可以是实例本身的描述，也可以是实例当前状态的文本描述：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">TextRepresentable</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> textualDescription: <span class=\"type\">String</span> &#123; <span class=\"keyword\">get</span> &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以通过扩展，令先前提到的 Dice 类遵循并符合 TextRepresentable 协议：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Dice</span>: <span class=\"title\">TextRepresentable</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> textualDescription: <span class=\"type\">String</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"A <span class=\"subst\">\\(sides)</span>-sided dice\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过扩展遵循并符合协议，和在原始定义中遵循并符合协议的效果完全相同。协议名称写在类型名之后，以冒号隔开，然后在扩展的大括号内实现协议要求的内容。<br>现在所有 Dice 的实例都可以看做 TextRepresentable 类型：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> d12 = <span class=\"type\">Dice</span>(sides: <span class=\"number\">12</span>, generator: <span class=\"type\">LinearCongruentialGenerator</span>())</div><div class=\"line\"><span class=\"built_in\">print</span>(d12.textualDescription)</div><div class=\"line\"><span class=\"comment\">// Prints \"A 12-sided dice\"</span></div></pre></td></tr></table></figure>\n<p>同样，SnakesAndLadders 类也可以通过扩展遵循并符合 TextRepresentable 协议：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">SnakesAndLadders</span>: <span class=\"title\">TextRepresentable</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> textualDescription: <span class=\"type\">String</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"A game of Snakes and Ladders with <span class=\"subst\">\\(finalSquare)</span> squares\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">print</span>(game.textualDescription)</div><div class=\"line\"><span class=\"comment\">// Prints \"A game of Snakes and Ladders with 25 squares\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"通过扩展遵循协议-1\"><a href=\"#通过扩展遵循协议-1\" class=\"headerlink\" title=\"通过扩展遵循协议\"></a>通过扩展遵循协议</h4><p>当一个类型已经符合了某个协议中的所有要求，却还没有声明遵循该协议时，可以通过空扩展体的扩展来遵循该协议：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Hamster</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">var</span> textualDescription: <span class=\"type\">String</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"A hamster named <span class=\"subst\">\\(name)</span>\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Hamster</span>: <span class=\"title\">TextRepresentable</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>\n<p>从现在起，Hamster 的实例可以作为 TextRepresentable 类型使用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> simonTheHamster = <span class=\"type\">Hamster</span>(name: <span class=\"string\">\"Simon\"</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> somethingTextRepresentable: <span class=\"type\">TextRepresentable</span> = simonTheHamster</div><div class=\"line\"><span class=\"built_in\">print</span>(somethingTextRepresentable.textualDescription)</div><div class=\"line\"><span class=\"comment\">// Prints \"A hamster named Simon\"</span></div></pre></td></tr></table></figure>\n<pre><code>即使满足了协议的所有要求，类型也不会自动遵循协议，必须显式地遵循协议。\n</code></pre><h3 id=\"协议类型的集合\"><a href=\"#协议类型的集合\" class=\"headerlink\" title=\"协议类型的集合\"></a>协议类型的集合</h3><p>协议类型可以在数组或者字典这样的集合中使用，在协议类型提到了这样的用法。下面的例子创建了一个元素类型为 TextRepresentable 的数组：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> things: [<span class=\"type\">TextRepresentable</span>] = [game, d12, simonTheHamster]</div></pre></td></tr></table></figure>\n<p>如下所示，可以遍历 things 数组，并打印每个元素的文本表示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> thing <span class=\"keyword\">in</span> things &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(thing.textualDescription)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// A game of Snakes and Ladders with 25 squares</span></div><div class=\"line\"><span class=\"comment\">// A 12-sided dice</span></div><div class=\"line\"><span class=\"comment\">// A hamster named Simon</span></div></pre></td></tr></table></figure>\n<p>thing 是 TextRepresentable 类型而不是 Dice，DiceGame，Hamster 等类型，即使实例在幕后确实是这些类型中的一种。由于 thing 是 TextRepresentable 类型，任何 TextRepresentable 的实例都有一个 textualDescription 属性，所以在每次循环中可以安全地访问 thing.textualDescription。</p>\n<h3 id=\"协议的继承\"><a href=\"#协议的继承\" class=\"headerlink\" title=\"协议的继承\"></a>协议的继承</h3><p>协议能够继承一个或多个其他协议，可以在继承的协议的基础上增加新的要求。协议的继承语法与类的继承相似，多个被继承的协议间用逗号分隔：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">InheritingProtocol</span>: <span class=\"title\">SomeProtocol</span>, <span class=\"title\">AnotherProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// protocol definition goes here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如下所示，PrettyTextRepresentable 协议继承了 TextRepresentable 协议：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">PrettyTextRepresentable</span>: <span class=\"title\">TextRepresentable</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> prettyTextualDescription: <span class=\"type\">String</span> &#123; <span class=\"keyword\">get</span> &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>例子中定义了一个新的协议 PrettyTextRepresentable，它继承自 TextRepresentable 协议。任何遵循 PrettyTextRepresentable 协议的类型在满足该协议的要求时，也必须满足 TextRepresentable 协议的要求。在这个例子中，PrettyTextRepresentable 协议额外要求遵循协议的类型提供一个返回值为 String 类型的 prettyTextualDescription 属性。</p>\n<p>如下所示，扩展 SnakesAndLadders，使其遵循并符合 PrettyTextRepresentable 协议：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">SnakesAndLadders</span>: <span class=\"title\">PrettyTextRepresentable</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> prettyTextualDescription: <span class=\"type\">String</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> output = textualDescription + <span class=\"string\">\":\\n\"</span></div><div class=\"line\">        <span class=\"keyword\">for</span> index <span class=\"keyword\">in</span> <span class=\"number\">1</span>...finalSquare &#123;</div><div class=\"line\">            <span class=\"keyword\">switch</span> board[index] &#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> ladder <span class=\"keyword\">where</span> ladder &gt; <span class=\"number\">0</span>:</div><div class=\"line\">                output += <span class=\"string\">\"▲ \"</span></div><div class=\"line\">            <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> snake <span class=\"keyword\">where</span> snake &lt; <span class=\"number\">0</span>:</div><div class=\"line\">                output += <span class=\"string\">\"▼ \"</span></div><div class=\"line\">            <span class=\"keyword\">default</span>:</div><div class=\"line\">                output += <span class=\"string\">\"○ \"</span></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> output</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上述扩展令 SnakesAndLadders 遵循了 PrettyTextRepresentable 协议，并提供了协议要求的 prettyTextualDescription 属性。每个 PrettyTextRepresentable 类型同时也是 TextRepresentable 类型，所以在 prettyTextualDescription 的实现中，可以访问 textualDescription 属性。</p>\n<p>任意 SankesAndLadders 的实例都可以使用 prettyTextualDescription 属性来打印一个漂亮的文本描述：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">print</span>(game.prettyTextualDescription)</div><div class=\"line\"><span class=\"comment\">// A game of Snakes and Ladders with 25 squares:</span></div><div class=\"line\"><span class=\"comment\">// ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○</span></div></pre></td></tr></table></figure>\n<h3 id=\"类类型专属协议\"><a href=\"#类类型专属协议\" class=\"headerlink\" title=\"类类型专属协议\"></a>类类型专属协议</h3><p>你可以在协议的继承列表中，通过添加 class 关键字来限制协议只能被类类型遵循，而结构体或枚举不能遵循该协议。<code>class</code> 关键字必须第一个出现在协议的继承列表中，在其他继承的协议之前：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">SomeClassOnlyProtocol</span>: <span class=\"title\">class</span>, <span class=\"title\">SomeInheritedProtocol</span> </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// class-only protocol definition goes here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>在以上例子中，协议 SomeClassOnlyProtocol 只能被类类型遵循。如果尝试让结构体或枚举类型遵循该协议，则会导致编译错误。</p>\n<pre><code>当协议定义的要求需要遵循协议的类型必须是引用语义而非值语义时，应该采用类类型专属协议。\n</code></pre><h3 id=\"协议合成\"><a href=\"#协议合成\" class=\"headerlink\" title=\"协议合成\"></a>协议合成</h3><p>有时候需要同时遵循多个协议，你可以将多个协议采用 SomeProtocol &amp; AnotherProtocol 这样的格式进行组合，称为 协议合成（protocol composition）。你可以罗列任意多个你想要遵循的协议，以与符号(&amp;)分隔。</p>\n<p>下面的例子中，将 Named 和 Aged 两个协议按照上述语法组合成一个协议，作为函数参数的类型：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">Named</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span> &#123; <span class=\"keyword\">get</span> &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">Aged</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> age: <span class=\"type\">Int</span> &#123; <span class=\"keyword\">get</span> &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span>: <span class=\"title\">Named</span>, <span class=\"title\">Aged</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">var</span> age: <span class=\"type\">Int</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">wishHappyBirthday</span><span class=\"params\">(to celebrator: Named &amp; Aged)</span></span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"Happy birthday, <span class=\"subst\">\\(celebrator.name)</span>, you're <span class=\"subst\">\\(celebrator.age)</span>!\"</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> birthdayPerson = <span class=\"type\">Person</span>(name: <span class=\"string\">\"Malcolm\"</span>, age: <span class=\"number\">21</span>)</div><div class=\"line\">wishHappyBirthday(to: birthdayPerson)</div><div class=\"line\"><span class=\"comment\">// Prints \"Happy birthday, Malcolm, you're 21!\"</span></div></pre></td></tr></table></figure>\n<p>Named 协议包含 String 类型的 name 属性。Aged 协议包含 Int 类型的 age 属性。Person 结构体遵循了这两个协议。<br>wishHappyBirthday(to:) 函数的参数 celebrator 的类型为 Named &amp; Aged。这意味着它不关心参数的具体类型，只要参数符合这两个协议即可。<br>上面的例子创建了一个名为 birthdayPerson 的 Person 的实例，作为参数传递给了 wishHappyBirthday(to:) 函数。因为 Person 同时符合这两个协议，所以这个参数合法，函数将打印生日问候语。</p>\n<pre><code>协议合成并不会生成新的、永久的协议类型，而是将多个协议中的要求合成到一个只在局部作用域有效的临时协议中。\n</code></pre><h3 id=\"检查协议一致性\"><a href=\"#检查协议一致性\" class=\"headerlink\" title=\"检查协议一致性\"></a>检查协议一致性</h3><p>你可以使用类型转换中描述的 is 和 as 操作符来检查协议一致性，即是否符合某协议，并且可以转换到指定的协议类型。检查和转换到某个协议类型在语法上和类型的检查和转换完全相同：</p>\n<ul>\n<li>is 用来检查实例是否符合某个协议，若符合则返回 true，否则返回 false。</li>\n<li>as? 返回一个可选值，当实例符合某个协议时，返回类型为协议类型的可选值，否则返回 nil。</li>\n<li>as! 将实例强制向下转换到某个协议类型，如果强转失败，会引发运行时错误。</li>\n</ul>\n<p>This example defines a protocol called HasArea, with a single property requirement of a gettable Double property called area:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">HasArea</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> area: <span class=\"type\">Double</span> &#123; <span class=\"keyword\">get</span> &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Here are two classes, Circle and Country, both of which conform to the HasArea protocol:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Circle</span>: <span class=\"title\">HasArea</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> pi = <span class=\"number\">3.1415927</span></div><div class=\"line\">    <span class=\"keyword\">var</span> radius: <span class=\"type\">Double</span></div><div class=\"line\">    <span class=\"keyword\">var</span> area: <span class=\"type\">Double</span> &#123; <span class=\"keyword\">return</span> pi * radius * radius &#125;</div><div class=\"line\">    <span class=\"keyword\">init</span>(radius: <span class=\"type\">Double</span>) &#123; <span class=\"keyword\">self</span>.radius = radius &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Country</span>: <span class=\"title\">HasArea</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> area: <span class=\"type\">Double</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(area: <span class=\"type\">Double</span>) &#123; <span class=\"keyword\">self</span>.area = area &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Circle 类把 area 属性实现为基于存储型属性 radius 的计算型属性。Country 类则把 area 属性实现为存储型属性。这两个类都正确地符合了 HasArea 协议。</p>\n<p>如下所示，Animal 是一个未遵循 HasArea 协议的类：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> legs: <span class=\"type\">Int</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(legs: <span class=\"type\">Int</span>) &#123; <span class=\"keyword\">self</span>.legs = legs &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Circle，Country，Animal 并没有一个共同的基类，尽管如此，它们都是类，它们的实例都可以作为 AnyObject 类型的值，存储在同一个数组中：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> objects: [<span class=\"type\">AnyObject</span>] = [</div><div class=\"line\">    <span class=\"type\">Circle</span>(radius: <span class=\"number\">2.0</span>),</div><div class=\"line\">    <span class=\"type\">Country</span>(area: <span class=\"number\">243_610</span>),</div><div class=\"line\">    <span class=\"type\">Animal</span>(legs: <span class=\"number\">4</span>)</div><div class=\"line\">]</div></pre></td></tr></table></figure>\n<p>如下所示，objects 数组可以被迭代，并对迭代出的每一个元素进行检查，看它是否符合 HasArea 协议：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> object <span class=\"keyword\">in</span> objects &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> objectWithArea = object <span class=\"keyword\">as</span>? <span class=\"type\">HasArea</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Area is <span class=\"subst\">\\(objectWithArea.area)</span>\"</span>)</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Something that doesn't have an area\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// Area is 12.5663708</span></div><div class=\"line\"><span class=\"comment\">// Area is 243610.0</span></div><div class=\"line\"><span class=\"comment\">// Something that doesn't have an area</span></div></pre></td></tr></table></figure>\n<p>当迭代出的元素符合 HasArea 协议时，将 as? 操作符返回的可选值通过可选绑定，绑定到 objectWithArea 常量上。objectWithArea 是 HasArea 协议类型的实例，因此 area 属性可以被访问和打印。</p>\n<p>objects 数组中的元素的类型并不会因为强转而丢失类型信息，它们仍然是 Circle，Country，Animal 类型。然而，当它们被赋值给 objectWithArea 常量时，只被视为 HasArea 类型，因此只有 area 属性能够被访问。</p>\n<h3 id=\"可选的协议要求\"><a href=\"#可选的协议要求\" class=\"headerlink\" title=\"可选的协议要求\"></a>可选的协议要求</h3><p>协议可以定义可选要求，遵循协议的类型可以选择是否实现这些要求。在协议中使用 optional 关键字作为前缀来定义可选要求。可选要求用在你需要和 Objective-C 打交道的代码中。协议和可选要求都必须带上@objc属性。标记 @objc 特性的协议只能被继承自 Objective-C 类的类或者 @objc 类遵循，其他类以及结构体和枚举均不能遵循这种协议。</p>\n<p>使用可选要求时（例如，可选的方法或者属性），它们的类型会自动变成可选的。比如，一个类型为 (Int) -&gt; String 的方法会变成 ((Int) -&gt; String)?</p>\n<p>协议中的可选要求可通过可选链式调用来使用，因为遵循协议的类型可能没有实现这些可选要求。类似 someOptionalMethod?(someArgument) 这样，你可以在可选方法名称后加上 ? 来调用可选方法。</p>\n<p>下面的例子定义了一个名为 Counter 的用于整数计数的类，它使用外部的数据源来提供每次的增量。数据源由 CounterDataSource 协议定义，包含两个可选要求：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@objc</span> <span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">CounterDataSource</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@objc</span> <span class=\"keyword\">optional</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">increment</span><span class=\"params\">(forCount <span class=\"built_in\">count</span>: Int)</span></span> -&gt; <span class=\"type\">Int</span></div><div class=\"line\">    <span class=\"meta\">@objc</span> <span class=\"keyword\">optional</span> <span class=\"keyword\">var</span> fixedIncrement: <span class=\"type\">Int</span> &#123; <span class=\"keyword\">get</span> &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>CounterDataSource 协议定义了一个可选方法 increment(forCount:) 和一个可选属性 fiexdIncrement，它们使用了不同的方法来从数据源中获取适当的增量值。<br>    严格来讲，CounterDataSource 协议中的方法和属性都是可选的，因此遵循协议的类可以不实现这些要求</p>\n<p>Counter 类含有 CounterDataSource? 类型的可选属性 dataSource，如下所示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">count</span> = <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">var</span> dataSource: <span class=\"type\">CounterDataSource</span>?</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">increment</span><span class=\"params\">()</span></span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> amount = dataSource?.increment?(forCount: <span class=\"built_in\">count</span>) &#123;</div><div class=\"line\">            <span class=\"built_in\">count</span> += amount</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> amount = dataSource?.fixedIncrement &#123;</div><div class=\"line\">            <span class=\"built_in\">count</span> += amount</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下面的例子展示了 CounterDataSource 的简单实现。ThreeSource 类遵循了 CounterDataSource 协议，它实现了可选属性 fixedIncrement，每次会返回 3：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreeSource</span>: <span class=\"title\">NSObject</span>, <span class=\"title\">CounterDataSource</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> fixedIncrement = <span class=\"number\">3</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以使用 ThreeSource 的实例作为 Counter 实例的数据源：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> counter = <span class=\"type\">Counter</span>()</div><div class=\"line\">counter.dataSource = <span class=\"type\">ThreeSource</span>()</div><div class=\"line\"><span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">1</span>...<span class=\"number\">4</span> &#123;</div><div class=\"line\">    counter.increment()</div><div class=\"line\">    <span class=\"built_in\">print</span>(counter.<span class=\"built_in\">count</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// 3</span></div><div class=\"line\"><span class=\"comment\">// 6</span></div><div class=\"line\"><span class=\"comment\">// 9</span></div><div class=\"line\"><span class=\"comment\">// 12</span></div></pre></td></tr></table></figure>\n<p>上述代码新建了一个 Counter 实例，并将它的数据源设置为一个 ThreeSource 的实例，然后调用 increment() 方法四次。和预期一样，每次调用都会将 count 的值增加 3.</p>\n<p>下面是一个更为复杂的数据源 TowardsZeroSource，它将使得最后的值变为 0：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">@objc class TowardsZeroSource: NSObject, CounterDataSource &#123;</div><div class=\"line\">    func increment(forCount count: Int) -&gt; Int &#123;</div><div class=\"line\">        if count == 0 &#123;</div><div class=\"line\">            return 0</div><div class=\"line\">        &#125; else if count &lt; 0 &#123;</div><div class=\"line\">            return 1</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            return -1</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你可以使用 TowardsZeroSource 实例将 Counter 实例来从 -4 增加到 0。一旦增加到 0，数值便不会再有变动：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">counter.<span class=\"built_in\">count</span> = -<span class=\"number\">4</span></div><div class=\"line\">counter.dataSource = <span class=\"type\">TowardsZeroSource</span>()</div><div class=\"line\"><span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">1</span>...<span class=\"number\">5</span> &#123;</div><div class=\"line\">    counter.increment()</div><div class=\"line\">    <span class=\"built_in\">print</span>(counter.<span class=\"built_in\">count</span>)</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// -3</span></div><div class=\"line\"><span class=\"comment\">// -2</span></div><div class=\"line\"><span class=\"comment\">// -1</span></div><div class=\"line\"><span class=\"comment\">// 0</span></div><div class=\"line\"><span class=\"comment\">// 0</span></div></pre></td></tr></table></figure>\n<h3 id=\"协议扩展\"><a href=\"#协议扩展\" class=\"headerlink\" title=\"协议扩展\"></a>协议扩展</h3><p>协议可以通过扩展来为遵循协议的类型提供属性、方法以及下标的实现。通过这种方式，你可以基于协议本身来实现这些功能，而无需在每个遵循协议的类型中都重复同样的实现，也无需使用全局函数。<br>例如，可以扩展 RandomNumberGenerator 协议来提供 randomBool() 方法。该方法使用协议中定义的 random() 方法来返回一个随机的 Bool 值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">RandomNumberGenerator</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">randomBool</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> random() &gt; <span class=\"number\">0.5</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过协议扩展，所有遵循协议的类型，都能自动获得这个扩展所增加的方法实现，无需任何额外修改：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> generator = <span class=\"type\">LinearCongruentialGenerator</span>()</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Here's a random number: <span class=\"subst\">\\(generator.random()</span>)\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"Here's a random number: 0.37464991998171\"</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"And here's a random Boolean: <span class=\"subst\">\\(generator.randomBool()</span>)\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"And here's a random Boolean: true\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"提供默认实现\"><a href=\"#提供默认实现\" class=\"headerlink\" title=\"提供默认实现\"></a>提供默认实现</h4><p>可以通过协议扩展来为协议要求的属性、方法以及下标提供默认的实现。如果遵循协议的类型为这些要求提供了自己的实现，那么这些自定义实现将会替代扩展中的默认实现被使用。<br>    通过协议扩展为协议要求提供的默认实现和可选的协议要求不同。虽然在这两种情况下，遵循协议的类型都无需自己实现这些要求，但是通过扩展提供的默认实现可以直接调用，而无需使用可选链式调用。</p>\n<p>例如，PrettyTextRepresentable 协议继承自 TextRepresentable 协议，可以为其提供一个默认的 prettyTextualDescription 属性，只是简单地返回 textualDescription 属性的值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">PrettyTextRepresentable</span>  </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> prettyTextualDescription: <span class=\"type\">String</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> textualDescription</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"为协议扩展添加限制条件\"><a href=\"#为协议扩展添加限制条件\" class=\"headerlink\" title=\"为协议扩展添加限制条件\"></a>为协议扩展添加限制条件</h4><p>在扩展协议的时候，可以指定一些限制条件，只有遵循协议的类型满足这些限制条件时，才能获得协议扩展提供的默认实现。这些限制条件写在协议名之后，使用 where 子句来描述<br>例如，你可以扩展 CollectionType 协议，但是只适用于集合中的元素遵循了 TextRepresentable 协议的情况：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Collection</span> <span class=\"title\">where</span> <span class=\"title\">Iterator</span>.<span class=\"title\">Element</span>: <span class=\"title\">TextRepresentable</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> textualDescription: <span class=\"type\">String</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> itemsAsText = <span class=\"keyword\">self</span>.<span class=\"built_in\">map</span> &#123; $<span class=\"number\">0</span>.textualDescription &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"[\"</span> + itemsAsText.joined(separator: <span class=\"string\">\", \"</span>) + <span class=\"string\">\"]\"</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>textualDescription 属性返回整个集合的文本描述，它将集合中的每个元素的文本描述以逗号分隔的方式连接起来，包在一对方括号中。<br>现在我们来看看先前的 Hamster 结构体，它符合 TextRepresentable 协议，同时这里还有个装有 Hamster 的实例的数组：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> murrayTheHamster = <span class=\"type\">Hamster</span>(name: <span class=\"string\">\"Murray\"</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> morganTheHamster = <span class=\"type\">Hamster</span>(name: <span class=\"string\">\"Morgan\"</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> mauriceTheHamster = <span class=\"type\">Hamster</span>(name: <span class=\"string\">\"Maurice\"</span>)</div><div class=\"line\"><span class=\"keyword\">let</span> hamsters = [murrayTheHamster, morganTheHamster, mauriceTheHamster]</div></pre></td></tr></table></figure>\n<p>因为 Array 符合 CollectionType 协议，而数组中的元素又符合 TextRepresentable 协议，所以数组可以使用 textualDescription 属性得到数组内容的文本表示：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">print</span>(hamsters.textualDescription)</div><div class=\"line\"><span class=\"comment\">// Prints \"[A hamster named Murray, A hamster named Morgan, A hamster named Maurice]\"</span></div></pre></td></tr></table></figure>\n<pre><code>如果多个协议扩展都为同一个协议要求提供了默认实现，而遵循协议的类型又同时满足这些协议扩展的限制条件，那么将会使用限制条件最多的那个协议扩展提供的默认实现。\n</code></pre><h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html/\" target=\"_blank\" rel=\"external\"> Protocols </a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>"},{"layout":"post","title":"Objective-C 知识普及","date":"2016-10-30T10:00:00.000Z","catalog":true,"_content":"\n\n讲述闭包、协议、常用传值方式，交流时会结合参与的项目进行\n\n\n\n### 闭包\n\n​\t一种带有局部变量的匿名函数。语法结构：`^` `返回值类型` `参数列表` `表达式`\n\n比如：\n\n```objective-c\n^int(int count){return count+1;}\n```\n\n<!-- more -->\n\nblock的声明及使用\n\n```Objective-C\n//声明\nint(^blk) (int) = ^(int count){return count+1;};\n\n//使用 - 作为参数\nvoid function(int(^blk)(int))\n\n//使用 - 作为返回值\nint (^func())(int) {\nreturn ^(int count){return count+1;}\n}\n\n```\n\n使用 `typedef` 简化\n\n```objective-c\ntypedef int (^blk_t) (int);\n\n//原来的写法\nvoid func(int (^blk)(int))\n//新的写法\nvoid func(blk_t blk)\n\n//原来的写法\nint (^func()(int))\n//新的写法\nblk_t func()\n```\n\nObjective-C代码中常用的写法举例\n\n```objective-c\n//点击课程更多按钮菜单的回调\n@property (nonatomic,copy) void(^courseMoreActionBlock)(EMoocCourseMoreActionType actionType, NSString* courseId);\n\n///#begin\n/**\n *\t@brief\t用户提交登录请求\n *\n *\t@param \tuserName \t登录名字\n *  @param  password    登录密码\n *\t@param \tcomplete \t回调函数\n */\n///#end\n+(void)loginWithName:(NSString*)userName\n            password:(NSString*)password\n            progress:(void (^)(NSProgress *progress))progress\n            complete:(void (^)(id data,NSInteger stateCode))complete;\n\n```\n\n##### 注意点\n\nblock 只读block外的属性，不可修改。\n__block可破坏闭包，其修饰的属性可以在block内修改。\n使用block的时候，特别要注意循环引用的问题\n\n\n\n### 协议\n\n​\t类似Java中的interface。在ObjC中使用@protocol定义一组方法规范，实现此协议的类必须实现对应的方法。\n例如常用的UITableViewDelegate协议格式：\n\n```Objective-C\n@protocol UITableViewDelegate<NSObject, UIScrollViewDelegate>//可以扩展多个协议\n\n@required //必须实现的方法\n- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;\n\n@optional //可选实现的方法\n- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;\n\n@end\n```\n\n##### 注意点\n\n* 协议方法的实现。\n  * @required //必须实现的方法(或者属性)\n  * @optional //可选实现的方法(或者属性)\n* 调用delegate（实现协议的委托对象）方法时，如果是可选方法，一定要通过@selector进行判断\n\n\n### 常用传值方式\n​\t\t这里说的传值方式，不包括View<->ViewController之间的Outlet、Target、Action等\n\n##### 闭包\n一言不合就上代码：注意`__weak`和`__strong`的使用\n\n```Objective-C\n//闭包作为属性的例子\n@property (nonatomic,copy) void(^didTapCallBack)(id tapedItem);\n//使用\n__weak __typeof(self) weakSelf = self;\nobj1.didTapCallBack = ^(NSDictionary* tapedItem){\n\t__strong __typeof(weakSelf)strongSelf = weakSelf;\n   \t[strongSelf performSegueWithIdentifier:@\"showNextSegue” sender: tapedItem];\n};\n\n\n//闭包作为参数使用的例子：\n-(void)functionNameWithParamName1:(id)paramName1\n                    completeBlock:(NSDictionary* (^)(NSString* blockParam))completeBlock\n//使用\n[obj2 functionNameWithParamName1:@“” completeBlock:^NSDictionary*(NSString* blockParam) {\n   \tif (blockParam){\n\t\treturn @[];\n   \t}else{\n\t\treturn nil;\n\t}\n}];\n\n\n\n```\n\n##### 协议\n​\t很常用的形式，比如UITableView、UIScrollView等UIKit框架中都是使用Protocol。\n\n* 代码写起来清晰易懂\n\n* 相对闭包来说代码量变大，第三者不容易理解\n\n  ​\n\n##### 共有方法(属性)\n\n​\t这块没啥说的，就是直接在`.h`文件中写属性，方法，对象直接调用（设置）即可\n\n##### KVO\n​\t比较常用，一般Model、ViewModel层通过发广播的形式进行消息发送(数据传输)。\n\n\n>\n>\n>\n>\n\n\n\n","source":"_posts/iOS_develop_ObjC_basic.md","raw":"---\nlayout:     post\ntitle:      Objective-C 知识普及\ndate:       2016-10-30 18:00:00\ncatalog: true\ncategories: iOS\ntags: 随笔 \n\n---\n\n\n讲述闭包、协议、常用传值方式，交流时会结合参与的项目进行\n\n\n\n### 闭包\n\n​\t一种带有局部变量的匿名函数。语法结构：`^` `返回值类型` `参数列表` `表达式`\n\n比如：\n\n```objective-c\n^int(int count){return count+1;}\n```\n\n<!-- more -->\n\nblock的声明及使用\n\n```Objective-C\n//声明\nint(^blk) (int) = ^(int count){return count+1;};\n\n//使用 - 作为参数\nvoid function(int(^blk)(int))\n\n//使用 - 作为返回值\nint (^func())(int) {\nreturn ^(int count){return count+1;}\n}\n\n```\n\n使用 `typedef` 简化\n\n```objective-c\ntypedef int (^blk_t) (int);\n\n//原来的写法\nvoid func(int (^blk)(int))\n//新的写法\nvoid func(blk_t blk)\n\n//原来的写法\nint (^func()(int))\n//新的写法\nblk_t func()\n```\n\nObjective-C代码中常用的写法举例\n\n```objective-c\n//点击课程更多按钮菜单的回调\n@property (nonatomic,copy) void(^courseMoreActionBlock)(EMoocCourseMoreActionType actionType, NSString* courseId);\n\n///#begin\n/**\n *\t@brief\t用户提交登录请求\n *\n *\t@param \tuserName \t登录名字\n *  @param  password    登录密码\n *\t@param \tcomplete \t回调函数\n */\n///#end\n+(void)loginWithName:(NSString*)userName\n            password:(NSString*)password\n            progress:(void (^)(NSProgress *progress))progress\n            complete:(void (^)(id data,NSInteger stateCode))complete;\n\n```\n\n##### 注意点\n\nblock 只读block外的属性，不可修改。\n__block可破坏闭包，其修饰的属性可以在block内修改。\n使用block的时候，特别要注意循环引用的问题\n\n\n\n### 协议\n\n​\t类似Java中的interface。在ObjC中使用@protocol定义一组方法规范，实现此协议的类必须实现对应的方法。\n例如常用的UITableViewDelegate协议格式：\n\n```Objective-C\n@protocol UITableViewDelegate<NSObject, UIScrollViewDelegate>//可以扩展多个协议\n\n@required //必须实现的方法\n- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;\n\n@optional //可选实现的方法\n- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;\n\n@end\n```\n\n##### 注意点\n\n* 协议方法的实现。\n  * @required //必须实现的方法(或者属性)\n  * @optional //可选实现的方法(或者属性)\n* 调用delegate（实现协议的委托对象）方法时，如果是可选方法，一定要通过@selector进行判断\n\n\n### 常用传值方式\n​\t\t这里说的传值方式，不包括View<->ViewController之间的Outlet、Target、Action等\n\n##### 闭包\n一言不合就上代码：注意`__weak`和`__strong`的使用\n\n```Objective-C\n//闭包作为属性的例子\n@property (nonatomic,copy) void(^didTapCallBack)(id tapedItem);\n//使用\n__weak __typeof(self) weakSelf = self;\nobj1.didTapCallBack = ^(NSDictionary* tapedItem){\n\t__strong __typeof(weakSelf)strongSelf = weakSelf;\n   \t[strongSelf performSegueWithIdentifier:@\"showNextSegue” sender: tapedItem];\n};\n\n\n//闭包作为参数使用的例子：\n-(void)functionNameWithParamName1:(id)paramName1\n                    completeBlock:(NSDictionary* (^)(NSString* blockParam))completeBlock\n//使用\n[obj2 functionNameWithParamName1:@“” completeBlock:^NSDictionary*(NSString* blockParam) {\n   \tif (blockParam){\n\t\treturn @[];\n   \t}else{\n\t\treturn nil;\n\t}\n}];\n\n\n\n```\n\n##### 协议\n​\t很常用的形式，比如UITableView、UIScrollView等UIKit框架中都是使用Protocol。\n\n* 代码写起来清晰易懂\n\n* 相对闭包来说代码量变大，第三者不容易理解\n\n  ​\n\n##### 共有方法(属性)\n\n​\t这块没啥说的，就是直接在`.h`文件中写属性，方法，对象直接调用（设置）即可\n\n##### KVO\n​\t比较常用，一般Model、ViewModel层通过发广播的形式进行消息发送(数据传输)。\n\n\n>\n>\n>\n>\n\n\n\n","slug":"iOS_develop_ObjC_basic","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4up003woko8us417d9t","content":"<p>讲述闭包、协议、常用传值方式，交流时会结合参与的项目进行</p>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><p>​    一种带有局部变量的匿名函数。语法结构：<code>^</code> <code>返回值类型</code> <code>参数列表</code> <code>表达式</code></p>\n<p>比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">^int(int count)&#123;return count+1;&#125;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>block的声明及使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">//声明</div><div class=\"line\">int(^blk) (int) = ^(int count)&#123;return count+1;&#125;;</div><div class=\"line\"></div><div class=\"line\">//使用 - 作为参数</div><div class=\"line\">void function(int(^blk)(int))</div><div class=\"line\"></div><div class=\"line\">//使用 - 作为返回值</div><div class=\"line\">int (^func())(int) &#123;</div><div class=\"line\">return ^(int count)&#123;return count+1;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用 <code>typedef</code> 简化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef int (^blk_t) (int);</div><div class=\"line\"></div><div class=\"line\">//原来的写法</div><div class=\"line\">void func(int (^blk)(int))</div><div class=\"line\">//新的写法</div><div class=\"line\">void func(blk_t blk)</div><div class=\"line\"></div><div class=\"line\">//原来的写法</div><div class=\"line\">int (^func()(int))</div><div class=\"line\">//新的写法</div><div class=\"line\">blk_t func()</div></pre></td></tr></table></figure>\n<p>Objective-C代码中常用的写法举例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">//点击课程更多按钮菜单的回调</div><div class=\"line\">@property (nonatomic,copy) void(^courseMoreActionBlock)(EMoocCourseMoreActionType actionType, NSString* courseId);</div><div class=\"line\"></div><div class=\"line\">///#begin</div><div class=\"line\">/**</div><div class=\"line\"> *\t@brief\t用户提交登录请求</div><div class=\"line\"> *</div><div class=\"line\"> *\t@param \tuserName \t登录名字</div><div class=\"line\"> *  @param  password    登录密码</div><div class=\"line\"> *\t@param \tcomplete \t回调函数</div><div class=\"line\"> */</div><div class=\"line\">///#end</div><div class=\"line\">+(void)loginWithName:(NSString*)userName</div><div class=\"line\">            password:(NSString*)password</div><div class=\"line\">            progress:(void (^)(NSProgress *progress))progress</div><div class=\"line\">            complete:(void (^)(id data,NSInteger stateCode))complete;</div></pre></td></tr></table></figure>\n<h5 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h5><p>block 只读block外的属性，不可修改。<br>__block可破坏闭包，其修饰的属性可以在block内修改。<br>使用block的时候，特别要注意循环引用的问题</p>\n<h3 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h3><p>​    类似Java中的interface。在ObjC中使用@protocol定义一组方法规范，实现此协议的类必须实现对应的方法。<br>例如常用的UITableViewDelegate协议格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">@protocol UITableViewDelegate&lt;NSObject, UIScrollViewDelegate&gt;//可以扩展多个协议</div><div class=\"line\"></div><div class=\"line\">@required //必须实现的方法</div><div class=\"line\">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;</div><div class=\"line\"></div><div class=\"line\">@optional //可选实现的方法</div><div class=\"line\">- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<h5 id=\"注意点-1\"><a href=\"#注意点-1\" class=\"headerlink\" title=\"注意点\"></a>注意点</h5><ul>\n<li>协议方法的实现。<ul>\n<li>@required //必须实现的方法(或者属性)</li>\n<li>@optional //可选实现的方法(或者属性)</li>\n</ul>\n</li>\n<li>调用delegate（实现协议的委托对象）方法时，如果是可选方法，一定要通过@selector进行判断</li>\n</ul>\n<h3 id=\"常用传值方式\"><a href=\"#常用传值方式\" class=\"headerlink\" title=\"常用传值方式\"></a>常用传值方式</h3><p>​        这里说的传值方式，不包括View&lt;-&gt;ViewController之间的Outlet、Target、Action等</p>\n<h5 id=\"闭包-1\"><a href=\"#闭包-1\" class=\"headerlink\" title=\"闭包\"></a>闭包</h5><p>一言不合就上代码：注意<code>__weak</code>和<code>__strong</code>的使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">//闭包作为属性的例子</div><div class=\"line\">@property (nonatomic,copy) void(^didTapCallBack)(id tapedItem);</div><div class=\"line\">//使用</div><div class=\"line\">__weak __typeof(self) weakSelf = self;</div><div class=\"line\">obj1.didTapCallBack = ^(NSDictionary* tapedItem)&#123;</div><div class=\"line\">\t__strong __typeof(weakSelf)strongSelf = weakSelf;</div><div class=\"line\">   \t[strongSelf performSegueWithIdentifier:@&quot;showNextSegue” sender: tapedItem];</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//闭包作为参数使用的例子：</div><div class=\"line\">-(void)functionNameWithParamName1:(id)paramName1</div><div class=\"line\">                    completeBlock:(NSDictionary* (^)(NSString* blockParam))completeBlock</div><div class=\"line\">//使用</div><div class=\"line\">[obj2 functionNameWithParamName1:@“” completeBlock:^NSDictionary*(NSString* blockParam) &#123;</div><div class=\"line\">   \tif (blockParam)&#123;</div><div class=\"line\">\t\treturn @[];</div><div class=\"line\">   \t&#125;else&#123;</div><div class=\"line\">\t\treturn nil;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<h5 id=\"协议-1\"><a href=\"#协议-1\" class=\"headerlink\" title=\"协议\"></a>协议</h5><p>​    很常用的形式，比如UITableView、UIScrollView等UIKit框架中都是使用Protocol。</p>\n<ul>\n<li><p>代码写起来清晰易懂</p>\n</li>\n<li><p>相对闭包来说代码量变大，第三者不容易理解</p>\n<p>​</p>\n</li>\n</ul>\n<h5 id=\"共有方法-属性\"><a href=\"#共有方法-属性\" class=\"headerlink\" title=\"共有方法(属性)\"></a>共有方法(属性)</h5><p>​    这块没啥说的，就是直接在<code>.h</code>文件中写属性，方法，对象直接调用（设置）即可</p>\n<h5 id=\"KVO\"><a href=\"#KVO\" class=\"headerlink\" title=\"KVO\"></a>KVO</h5><p>​    比较常用，一般Model、ViewModel层通过发广播的形式进行消息发送(数据传输)。</p>\n<p>&gt;<br>&gt;<br>&gt;<br>&gt;</p>\n","site":{"data":{}},"excerpt":"<p>讲述闭包、协议、常用传值方式，交流时会结合参与的项目进行</p>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><p>​    一种带有局部变量的匿名函数。语法结构：<code>^</code> <code>返回值类型</code> <code>参数列表</code> <code>表达式</code></p>\n<p>比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">^int(int count)&#123;return count+1;&#125;</div></pre></td></tr></table></figure>","more":"<p>block的声明及使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">//声明</div><div class=\"line\">int(^blk) (int) = ^(int count)&#123;return count+1;&#125;;</div><div class=\"line\"></div><div class=\"line\">//使用 - 作为参数</div><div class=\"line\">void function(int(^blk)(int))</div><div class=\"line\"></div><div class=\"line\">//使用 - 作为返回值</div><div class=\"line\">int (^func())(int) &#123;</div><div class=\"line\">return ^(int count)&#123;return count+1;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>使用 <code>typedef</code> 简化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">typedef int (^blk_t) (int);</div><div class=\"line\"></div><div class=\"line\">//原来的写法</div><div class=\"line\">void func(int (^blk)(int))</div><div class=\"line\">//新的写法</div><div class=\"line\">void func(blk_t blk)</div><div class=\"line\"></div><div class=\"line\">//原来的写法</div><div class=\"line\">int (^func()(int))</div><div class=\"line\">//新的写法</div><div class=\"line\">blk_t func()</div></pre></td></tr></table></figure>\n<p>Objective-C代码中常用的写法举例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">//点击课程更多按钮菜单的回调</div><div class=\"line\">@property (nonatomic,copy) void(^courseMoreActionBlock)(EMoocCourseMoreActionType actionType, NSString* courseId);</div><div class=\"line\"></div><div class=\"line\">///#begin</div><div class=\"line\">/**</div><div class=\"line\"> *\t@brief\t用户提交登录请求</div><div class=\"line\"> *</div><div class=\"line\"> *\t@param \tuserName \t登录名字</div><div class=\"line\"> *  @param  password    登录密码</div><div class=\"line\"> *\t@param \tcomplete \t回调函数</div><div class=\"line\"> */</div><div class=\"line\">///#end</div><div class=\"line\">+(void)loginWithName:(NSString*)userName</div><div class=\"line\">            password:(NSString*)password</div><div class=\"line\">            progress:(void (^)(NSProgress *progress))progress</div><div class=\"line\">            complete:(void (^)(id data,NSInteger stateCode))complete;</div></pre></td></tr></table></figure>\n<h5 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h5><p>block 只读block外的属性，不可修改。<br>__block可破坏闭包，其修饰的属性可以在block内修改。<br>使用block的时候，特别要注意循环引用的问题</p>\n<h3 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h3><p>​    类似Java中的interface。在ObjC中使用@protocol定义一组方法规范，实现此协议的类必须实现对应的方法。<br>例如常用的UITableViewDelegate协议格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">@protocol UITableViewDelegate&lt;NSObject, UIScrollViewDelegate&gt;//可以扩展多个协议</div><div class=\"line\"></div><div class=\"line\">@required //必须实现的方法</div><div class=\"line\">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;</div><div class=\"line\"></div><div class=\"line\">@optional //可选实现的方法</div><div class=\"line\">- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<h5 id=\"注意点-1\"><a href=\"#注意点-1\" class=\"headerlink\" title=\"注意点\"></a>注意点</h5><ul>\n<li>协议方法的实现。<ul>\n<li>@required //必须实现的方法(或者属性)</li>\n<li>@optional //可选实现的方法(或者属性)</li>\n</ul>\n</li>\n<li>调用delegate（实现协议的委托对象）方法时，如果是可选方法，一定要通过@selector进行判断</li>\n</ul>\n<h3 id=\"常用传值方式\"><a href=\"#常用传值方式\" class=\"headerlink\" title=\"常用传值方式\"></a>常用传值方式</h3><p>​        这里说的传值方式，不包括View&lt;-&gt;ViewController之间的Outlet、Target、Action等</p>\n<h5 id=\"闭包-1\"><a href=\"#闭包-1\" class=\"headerlink\" title=\"闭包\"></a>闭包</h5><p>一言不合就上代码：注意<code>__weak</code>和<code>__strong</code>的使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">//闭包作为属性的例子</div><div class=\"line\">@property (nonatomic,copy) void(^didTapCallBack)(id tapedItem);</div><div class=\"line\">//使用</div><div class=\"line\">__weak __typeof(self) weakSelf = self;</div><div class=\"line\">obj1.didTapCallBack = ^(NSDictionary* tapedItem)&#123;</div><div class=\"line\">\t__strong __typeof(weakSelf)strongSelf = weakSelf;</div><div class=\"line\">   \t[strongSelf performSegueWithIdentifier:@&quot;showNextSegue” sender: tapedItem];</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//闭包作为参数使用的例子：</div><div class=\"line\">-(void)functionNameWithParamName1:(id)paramName1</div><div class=\"line\">                    completeBlock:(NSDictionary* (^)(NSString* blockParam))completeBlock</div><div class=\"line\">//使用</div><div class=\"line\">[obj2 functionNameWithParamName1:@“” completeBlock:^NSDictionary*(NSString* blockParam) &#123;</div><div class=\"line\">   \tif (blockParam)&#123;</div><div class=\"line\">\t\treturn @[];</div><div class=\"line\">   \t&#125;else&#123;</div><div class=\"line\">\t\treturn nil;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;];</div></pre></td></tr></table></figure>\n<h5 id=\"协议-1\"><a href=\"#协议-1\" class=\"headerlink\" title=\"协议\"></a>协议</h5><p>​    很常用的形式，比如UITableView、UIScrollView等UIKit框架中都是使用Protocol。</p>\n<ul>\n<li><p>代码写起来清晰易懂</p>\n</li>\n<li><p>相对闭包来说代码量变大，第三者不容易理解</p>\n<p>​</p>\n</li>\n</ul>\n<h5 id=\"共有方法-属性\"><a href=\"#共有方法-属性\" class=\"headerlink\" title=\"共有方法(属性)\"></a>共有方法(属性)</h5><p>​    这块没啥说的，就是直接在<code>.h</code>文件中写属性，方法，对象直接调用（设置）即可</p>\n<h5 id=\"KVO\"><a href=\"#KVO\" class=\"headerlink\" title=\"KVO\"></a>KVO</h5><p>​    比较常用，一般Model、ViewModel层通过发广播的形式进行消息发送(数据传输)。</p>\n<p>&gt;<br>&gt;<br>&gt;<br>&gt;</p>"},{"layout":"post","title":"最低支持iOS9系统对应状态栏、导航栏UI设置","date":"2017-11-27T07:51:43.000Z","author":"liangtong","catalog":true,"_content":"\n\n\n​        iOS9之后，APP在修改状态栏前端等颜色时，弃用了部分接口。比如：\n\n```Objective-C\n// Setting the statusBarStyle does nothing if your application is using the default UIViewController-based status bar system.\n@property(readwrite, nonatomic) UIStatusBarStyle statusBarStyle NS_DEPRECATED_IOS(2_0, 9_0, \"Use -[UIViewController preferredStatusBarStyle]\") __TVOS_PROHIBITED;\n```\n\n本文介绍最低支持iOS9系统对应的状态栏前段UI设置。\n\n### 状态栏字体颜色\n\n#### 程序启动Launch画面\n\n对应状态栏字体颜色，可以通过在plist文件中添加属性 **UIStatusBarStyle** （或者 **Status bar style**）来设置字体颜色为黑色 **UIStatusBarStyleDefault** ，或者白色 **UIStatusBarStyleLightContent**\n\n#### 功能页面\n\n程序启动后，可以通过重写 **UIViewController** 中的方法 **preferredStatusBarStyle** 来实现。例如在程序的Base NavigationController中：\n\n```Objective-C\n- (UIStatusBarStyle)preferredStatusBarStyle{\n    return UIStatusBarStyleLightContent;\n}\n```\n\n### 导航栏字体颜色\n\n可以在程序启动时，通过以下代码设置。例如以下代码将导航栏字体颜色设置为白色：\n\n```Objective-C\n    //NavigationBar 字体颜色\n    [[UINavigationBar appearance] setTitleTextAttributes:[NSDictionary dictionaryWithObject:[UIColor whiteColor] forKey:NSForegroundColorAttributeName]];\n```\n\n### 背景颜色\n\n在程序启动时，可以通过代码进行设置\n\n```Objective-C\n    UIColor* statusBarBackgroundColor;//状态栏颜色\n    [[UINavigationBar appearance] setBarTintColor:statusBarBackgroundColor];\n```\n\n\n","source":"_posts/iOS_develop_note_status_bar_style.md","raw":"---\nlayout:     post\ntitle:      最低支持iOS9系统对应状态栏、导航栏UI设置\ndate:       2017-11-27 15:51:43\nauthor:     liangtong\ncatalog: true\ncategories: iOS\ntags: Note\n\n---\n\n\n\n​        iOS9之后，APP在修改状态栏前端等颜色时，弃用了部分接口。比如：\n\n```Objective-C\n// Setting the statusBarStyle does nothing if your application is using the default UIViewController-based status bar system.\n@property(readwrite, nonatomic) UIStatusBarStyle statusBarStyle NS_DEPRECATED_IOS(2_0, 9_0, \"Use -[UIViewController preferredStatusBarStyle]\") __TVOS_PROHIBITED;\n```\n\n本文介绍最低支持iOS9系统对应的状态栏前段UI设置。\n\n### 状态栏字体颜色\n\n#### 程序启动Launch画面\n\n对应状态栏字体颜色，可以通过在plist文件中添加属性 **UIStatusBarStyle** （或者 **Status bar style**）来设置字体颜色为黑色 **UIStatusBarStyleDefault** ，或者白色 **UIStatusBarStyleLightContent**\n\n#### 功能页面\n\n程序启动后，可以通过重写 **UIViewController** 中的方法 **preferredStatusBarStyle** 来实现。例如在程序的Base NavigationController中：\n\n```Objective-C\n- (UIStatusBarStyle)preferredStatusBarStyle{\n    return UIStatusBarStyleLightContent;\n}\n```\n\n### 导航栏字体颜色\n\n可以在程序启动时，通过以下代码设置。例如以下代码将导航栏字体颜色设置为白色：\n\n```Objective-C\n    //NavigationBar 字体颜色\n    [[UINavigationBar appearance] setTitleTextAttributes:[NSDictionary dictionaryWithObject:[UIColor whiteColor] forKey:NSForegroundColorAttributeName]];\n```\n\n### 背景颜色\n\n在程序启动时，可以通过代码进行设置\n\n```Objective-C\n    UIColor* statusBarBackgroundColor;//状态栏颜色\n    [[UINavigationBar appearance] setBarTintColor:statusBarBackgroundColor];\n```\n\n\n","slug":"iOS_develop_note_status_bar_style","published":1,"updated":"2017-11-27T08:28:49.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4ur003zoko8l4tszzot","content":"<p>​        iOS9之后，APP在修改状态栏前端等颜色时，弃用了部分接口。比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Setting the statusBarStyle does nothing if your application is using the default UIViewController-based status bar system.</div><div class=\"line\">@property(readwrite, nonatomic) UIStatusBarStyle statusBarStyle NS_DEPRECATED_IOS(2_0, 9_0, &quot;Use -[UIViewController preferredStatusBarStyle]&quot;) __TVOS_PROHIBITED;</div></pre></td></tr></table></figure>\n<p>本文介绍最低支持iOS9系统对应的状态栏前段UI设置。</p>\n<h3 id=\"状态栏字体颜色\"><a href=\"#状态栏字体颜色\" class=\"headerlink\" title=\"状态栏字体颜色\"></a>状态栏字体颜色</h3><h4 id=\"程序启动Launch画面\"><a href=\"#程序启动Launch画面\" class=\"headerlink\" title=\"程序启动Launch画面\"></a>程序启动Launch画面</h4><p>对应状态栏字体颜色，可以通过在plist文件中添加属性 <strong>UIStatusBarStyle</strong> （或者 <strong>Status bar style</strong>）来设置字体颜色为黑色 <strong>UIStatusBarStyleDefault</strong> ，或者白色 <strong>UIStatusBarStyleLightContent</strong></p>\n<h4 id=\"功能页面\"><a href=\"#功能页面\" class=\"headerlink\" title=\"功能页面\"></a>功能页面</h4><p>程序启动后，可以通过重写 <strong>UIViewController</strong> 中的方法 <strong>preferredStatusBarStyle</strong> 来实现。例如在程序的Base NavigationController中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (UIStatusBarStyle)preferredStatusBarStyle&#123;</div><div class=\"line\">    return UIStatusBarStyleLightContent;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"导航栏字体颜色\"><a href=\"#导航栏字体颜色\" class=\"headerlink\" title=\"导航栏字体颜色\"></a>导航栏字体颜色</h3><p>可以在程序启动时，通过以下代码设置。例如以下代码将导航栏字体颜色设置为白色：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">//NavigationBar 字体颜色</div><div class=\"line\">[[UINavigationBar appearance] setTitleTextAttributes:[NSDictionary dictionaryWithObject:[UIColor whiteColor] forKey:NSForegroundColorAttributeName]];</div></pre></td></tr></table></figure>\n<h3 id=\"背景颜色\"><a href=\"#背景颜色\" class=\"headerlink\" title=\"背景颜色\"></a>背景颜色</h3><p>在程序启动时，可以通过代码进行设置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIColor* statusBarBackgroundColor;//状态栏颜色</div><div class=\"line\">[[UINavigationBar appearance] setBarTintColor:statusBarBackgroundColor];</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>​        iOS9之后，APP在修改状态栏前端等颜色时，弃用了部分接口。比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Setting the statusBarStyle does nothing if your application is using the default UIViewController-based status bar system.</div><div class=\"line\">@property(readwrite, nonatomic) UIStatusBarStyle statusBarStyle NS_DEPRECATED_IOS(2_0, 9_0, &quot;Use -[UIViewController preferredStatusBarStyle]&quot;) __TVOS_PROHIBITED;</div></pre></td></tr></table></figure>\n<p>本文介绍最低支持iOS9系统对应的状态栏前段UI设置。</p>\n<h3 id=\"状态栏字体颜色\"><a href=\"#状态栏字体颜色\" class=\"headerlink\" title=\"状态栏字体颜色\"></a>状态栏字体颜色</h3><h4 id=\"程序启动Launch画面\"><a href=\"#程序启动Launch画面\" class=\"headerlink\" title=\"程序启动Launch画面\"></a>程序启动Launch画面</h4><p>对应状态栏字体颜色，可以通过在plist文件中添加属性 <strong>UIStatusBarStyle</strong> （或者 <strong>Status bar style</strong>）来设置字体颜色为黑色 <strong>UIStatusBarStyleDefault</strong> ，或者白色 <strong>UIStatusBarStyleLightContent</strong></p>\n<h4 id=\"功能页面\"><a href=\"#功能页面\" class=\"headerlink\" title=\"功能页面\"></a>功能页面</h4><p>程序启动后，可以通过重写 <strong>UIViewController</strong> 中的方法 <strong>preferredStatusBarStyle</strong> 来实现。例如在程序的Base NavigationController中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (UIStatusBarStyle)preferredStatusBarStyle&#123;</div><div class=\"line\">    return UIStatusBarStyleLightContent;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"导航栏字体颜色\"><a href=\"#导航栏字体颜色\" class=\"headerlink\" title=\"导航栏字体颜色\"></a>导航栏字体颜色</h3><p>可以在程序启动时，通过以下代码设置。例如以下代码将导航栏字体颜色设置为白色：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">//NavigationBar 字体颜色</div><div class=\"line\">[[UINavigationBar appearance] setTitleTextAttributes:[NSDictionary dictionaryWithObject:[UIColor whiteColor] forKey:NSForegroundColorAttributeName]];</div></pre></td></tr></table></figure>\n<h3 id=\"背景颜色\"><a href=\"#背景颜色\" class=\"headerlink\" title=\"背景颜色\"></a>背景颜色</h3><p>在程序启动时，可以通过代码进行设置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIColor* statusBarBackgroundColor;//状态栏颜色</div><div class=\"line\">[[UINavigationBar appearance] setBarTintColor:statusBarBackgroundColor];</div></pre></td></tr></table></figure>\n"},{"layout":"post","title":"Swift Subscripts","date":"2016-11-25T16:20:11.000Z","author":"liangtong","catalog":true,"_content":"\n\n\n​\t下标可以定义在类、结构体和枚举中，为访问集合，列表或序列中元素提供便捷。可以使用下标的索引，设置和获取值，而不需要再调用对应的存取方法。举例来说，用下标访问一个Array实例中的元素可以写作someArray[index]，访问Dictionary实例中的元素可以写作someDictionary[key]。\n\n\n\n### 语法\n下标允许你通过在实例化对象后边的中括号中添加一个或多个索引值来查询或修改实例。语法类似于实例方法语法和计算型属性语法。通过关键字 `subscript` 定义，并指定一个或多个输入参数和返回类型；与实例方法不同的是。下标语法可以设定为读写( `read-write` )或只读( `read-only` )。这种行为由 getter 和 setter 实现，有点类似计算型属性：\n\n```Swift\nsubscript(index: Int) -> Int {\n    get {\n        // return an appropriate subscript value here\n    }\n    set(newValue) {\n        // perform a suitable setting action here\n    }\n}\n```\n\nnewValue的类型和下标的返回类型相同。如同计算型属性，可以不指定 setter 的参数（newValue）。如果不指定参数，setter 会提供一个名为newValue的默认参数。如同只读计算型属性，可以省略只读下标的get关键字：\n\n<!-- more -->\n\n```Swift\nsubscript(index: Int) -> Int {\n    // return an appropriate subscript value here\n}\n```\n\n下面代码演示了只读下标的实现：\n\n```Swift\nstruct TimesTable {\n    let multiplier: Int\n    subscript(index: Int) -> Int {\n        return multiplier * index\n    }\n}\nlet threeTimesTable = TimesTable(multiplier: 3)\nprint(\"six times three is \\(threeTimesTable[6])\")\n// Prints \"six times three is 18\"\n```\n\n### 用法\n下标的含义通常取决于使用场景，通常在集合、列表和序列中快速访问用。你也可以根据自己的特定类型实现下标功能。\n例如Swift中的字典Dictionary使用下标语法对实例中储存的值进行存取操作。\n\n```Swift\nvar numberOfLegs = [\"spider\": 8, \"ant\": 6, \"cat\": 4]\nnumberOfLegs[\"bird\"] = 2\n```\n\n\tSwift 的Dictionary类型的下标接受并返回可选类型的值。因为不是每个键都有个对应的值，同时这也提供了一种通过键删除对应值的方式，只需将键对应的值赋值为nil即可。\n\n\n### 选项\n下标可以接受任意数量的入参，并且这些入参可以是任意类型。下标的返回值也可以是任意类型。下标可以使用变量参数和可变参数，但不能使用输入输出参数，也不能给参数设置默认值。\n一个类或结构体可以根据自身需要提供多个下标实现\n\n```Swift\nstruct Matrix {\n    let rows: Int, columns: Int\n    var grid: [Double]\n    init(rows: Int, columns: Int) {\n        self.rows = rows\n        self.columns = columns\n        grid = Array(repeating: 0.0, count: rows * columns)\n    }\n    func indexIsValid(row: Int, column: Int) -> Bool {\n        return row >= 0 && row < rows && column >= 0 && column < columns\n    }\n    subscript(row: Int, column: Int) -> Double {\n        get {\n            assert(indexIsValid(row: row, column: column), \"Index out of range\")\n            return grid[(row * columns) + column]\n        }\n        set {\n            assert(indexIsValid(row: row, column: column), \"Index out of range\")\n            grid[(row * columns) + column] = newValue\n        }\n    }\n}\n```\n\n你可以通过传入合适的row和column的数量来构造一个新的Matrix实例：\n\n```Swift\nvar matrix = Matrix(rows: 2, columns: 2)\n```\n\n将row和column的值传入下标来为矩阵设值，下标的入参使用逗号分隔：\n\n```Swift\nmatrix[0, 1] = 1.5\nmatrix[1, 0] = 3.2\n```\n\n访问\n\n```Swift\nlet rightTopValue = matrix[0, 1]\n// 1.5\n\nlet someValue = matrix[2, 2]\n// this triggers an assert, because [2, 2] is outside of the matrix bounds\n```\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Subscripts.html/\">Subscripts</a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","source":"_posts/iOS_Swift_language_note_Subscripts.md","raw":"---\nlayout:     post\ntitle:      Swift Subscripts\ndate:       2016-11-26 00:20:11\nauthor:     liangtong\ncatalog: true\ncategories: iOS\ntags: Swift \n\n---\n\n\n\n​\t下标可以定义在类、结构体和枚举中，为访问集合，列表或序列中元素提供便捷。可以使用下标的索引，设置和获取值，而不需要再调用对应的存取方法。举例来说，用下标访问一个Array实例中的元素可以写作someArray[index]，访问Dictionary实例中的元素可以写作someDictionary[key]。\n\n\n\n### 语法\n下标允许你通过在实例化对象后边的中括号中添加一个或多个索引值来查询或修改实例。语法类似于实例方法语法和计算型属性语法。通过关键字 `subscript` 定义，并指定一个或多个输入参数和返回类型；与实例方法不同的是。下标语法可以设定为读写( `read-write` )或只读( `read-only` )。这种行为由 getter 和 setter 实现，有点类似计算型属性：\n\n```Swift\nsubscript(index: Int) -> Int {\n    get {\n        // return an appropriate subscript value here\n    }\n    set(newValue) {\n        // perform a suitable setting action here\n    }\n}\n```\n\nnewValue的类型和下标的返回类型相同。如同计算型属性，可以不指定 setter 的参数（newValue）。如果不指定参数，setter 会提供一个名为newValue的默认参数。如同只读计算型属性，可以省略只读下标的get关键字：\n\n<!-- more -->\n\n```Swift\nsubscript(index: Int) -> Int {\n    // return an appropriate subscript value here\n}\n```\n\n下面代码演示了只读下标的实现：\n\n```Swift\nstruct TimesTable {\n    let multiplier: Int\n    subscript(index: Int) -> Int {\n        return multiplier * index\n    }\n}\nlet threeTimesTable = TimesTable(multiplier: 3)\nprint(\"six times three is \\(threeTimesTable[6])\")\n// Prints \"six times three is 18\"\n```\n\n### 用法\n下标的含义通常取决于使用场景，通常在集合、列表和序列中快速访问用。你也可以根据自己的特定类型实现下标功能。\n例如Swift中的字典Dictionary使用下标语法对实例中储存的值进行存取操作。\n\n```Swift\nvar numberOfLegs = [\"spider\": 8, \"ant\": 6, \"cat\": 4]\nnumberOfLegs[\"bird\"] = 2\n```\n\n\tSwift 的Dictionary类型的下标接受并返回可选类型的值。因为不是每个键都有个对应的值，同时这也提供了一种通过键删除对应值的方式，只需将键对应的值赋值为nil即可。\n\n\n### 选项\n下标可以接受任意数量的入参，并且这些入参可以是任意类型。下标的返回值也可以是任意类型。下标可以使用变量参数和可变参数，但不能使用输入输出参数，也不能给参数设置默认值。\n一个类或结构体可以根据自身需要提供多个下标实现\n\n```Swift\nstruct Matrix {\n    let rows: Int, columns: Int\n    var grid: [Double]\n    init(rows: Int, columns: Int) {\n        self.rows = rows\n        self.columns = columns\n        grid = Array(repeating: 0.0, count: rows * columns)\n    }\n    func indexIsValid(row: Int, column: Int) -> Bool {\n        return row >= 0 && row < rows && column >= 0 && column < columns\n    }\n    subscript(row: Int, column: Int) -> Double {\n        get {\n            assert(indexIsValid(row: row, column: column), \"Index out of range\")\n            return grid[(row * columns) + column]\n        }\n        set {\n            assert(indexIsValid(row: row, column: column), \"Index out of range\")\n            grid[(row * columns) + column] = newValue\n        }\n    }\n}\n```\n\n你可以通过传入合适的row和column的数量来构造一个新的Matrix实例：\n\n```Swift\nvar matrix = Matrix(rows: 2, columns: 2)\n```\n\n将row和column的值传入下标来为矩阵设值，下标的入参使用逗号分隔：\n\n```Swift\nmatrix[0, 1] = 1.5\nmatrix[1, 0] = 3.2\n```\n\n访问\n\n```Swift\nlet rightTopValue = matrix[0, 1]\n// 1.5\n\nlet someValue = matrix[2, 2]\n// this triggers an assert, because [2, 2] is outside of the matrix bounds\n```\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Subscripts.html/\">Subscripts</a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","slug":"iOS_Swift_language_note_Subscripts","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4us0043oko8vftgamk0","content":"<p>​    下标可以定义在类、结构体和枚举中，为访问集合，列表或序列中元素提供便捷。可以使用下标的索引，设置和获取值，而不需要再调用对应的存取方法。举例来说，用下标访问一个Array实例中的元素可以写作someArray[index]，访问Dictionary实例中的元素可以写作someDictionary[key]。</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>下标允许你通过在实例化对象后边的中括号中添加一个或多个索引值来查询或修改实例。语法类似于实例方法语法和计算型属性语法。通过关键字 <code>subscript</code> 定义，并指定一个或多个输入参数和返回类型；与实例方法不同的是。下标语法可以设定为读写( <code>read-write</code> )或只读( <code>read-only</code> )。这种行为由 getter 和 setter 实现，有点类似计算型属性：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">subscript</span>(index: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">get</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// return an appropriate subscript value here</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">set</span>(newValue) &#123;</div><div class=\"line\">        <span class=\"comment\">// perform a suitable setting action here</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>newValue的类型和下标的返回类型相同。如同计算型属性，可以不指定 setter 的参数（newValue）。如果不指定参数，setter 会提供一个名为newValue的默认参数。如同只读计算型属性，可以省略只读下标的get关键字：</p>\n<a id=\"more\"></a>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">subscript</span>(index: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// return an appropriate subscript value here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下面代码演示了只读下标的实现：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TimesTable</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> multiplier: <span class=\"type\">Int</span></div><div class=\"line\">    <span class=\"keyword\">subscript</span>(index: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> multiplier * index</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> threeTimesTable = <span class=\"type\">TimesTable</span>(multiplier: <span class=\"number\">3</span>)</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"six times three is <span class=\"subst\">\\(threeTimesTable[<span class=\"number\">6</span>])</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"six times three is 18\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><p>下标的含义通常取决于使用场景，通常在集合、列表和序列中快速访问用。你也可以根据自己的特定类型实现下标功能。<br>例如Swift中的字典Dictionary使用下标语法对实例中储存的值进行存取操作。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> numberOfLegs = [<span class=\"string\">\"spider\"</span>: <span class=\"number\">8</span>, <span class=\"string\">\"ant\"</span>: <span class=\"number\">6</span>, <span class=\"string\">\"cat\"</span>: <span class=\"number\">4</span>]</div><div class=\"line\">numberOfLegs[<span class=\"string\">\"bird\"</span>] = <span class=\"number\">2</span></div></pre></td></tr></table></figure>\n<pre><code>Swift 的Dictionary类型的下标接受并返回可选类型的值。因为不是每个键都有个对应的值，同时这也提供了一种通过键删除对应值的方式，只需将键对应的值赋值为nil即可。\n</code></pre><h3 id=\"选项\"><a href=\"#选项\" class=\"headerlink\" title=\"选项\"></a>选项</h3><p>下标可以接受任意数量的入参，并且这些入参可以是任意类型。下标的返回值也可以是任意类型。下标可以使用变量参数和可变参数，但不能使用输入输出参数，也不能给参数设置默认值。<br>一个类或结构体可以根据自身需要提供多个下标实现</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Matrix</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> rows: <span class=\"type\">Int</span>, columns: <span class=\"type\">Int</span></div><div class=\"line\">    <span class=\"keyword\">var</span> grid: [<span class=\"type\">Double</span>]</div><div class=\"line\">    <span class=\"keyword\">init</span>(rows: <span class=\"type\">Int</span>, columns: <span class=\"type\">Int</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.rows = rows</div><div class=\"line\">        <span class=\"keyword\">self</span>.columns = columns</div><div class=\"line\">        grid = <span class=\"type\">Array</span>(repeating: <span class=\"number\">0.0</span>, <span class=\"built_in\">count</span>: rows * columns)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">indexIsValid</span><span class=\"params\">(row: Int, column: Int)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> row &gt;= <span class=\"number\">0</span> &amp;&amp; row &lt; rows &amp;&amp; column &gt;= <span class=\"number\">0</span> &amp;&amp; column &lt; columns</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">subscript</span>(row: <span class=\"type\">Int</span>, column: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Double</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">get</span> &#123;</div><div class=\"line\">            <span class=\"built_in\">assert</span>(indexIsValid(row: row, column: column), <span class=\"string\">\"Index out of range\"</span>)</div><div class=\"line\">            <span class=\"keyword\">return</span> grid[(row * columns) + column]</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">set</span> &#123;</div><div class=\"line\">            <span class=\"built_in\">assert</span>(indexIsValid(row: row, column: column), <span class=\"string\">\"Index out of range\"</span>)</div><div class=\"line\">            grid[(row * columns) + column] = newValue</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你可以通过传入合适的row和column的数量来构造一个新的Matrix实例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> matrix = <span class=\"type\">Matrix</span>(rows: <span class=\"number\">2</span>, columns: <span class=\"number\">2</span>)</div></pre></td></tr></table></figure>\n<p>将row和column的值传入下标来为矩阵设值，下标的入参使用逗号分隔：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">matrix[<span class=\"number\">0</span>, <span class=\"number\">1</span>] = <span class=\"number\">1.5</span></div><div class=\"line\">matrix[<span class=\"number\">1</span>, <span class=\"number\">0</span>] = <span class=\"number\">3.2</span></div></pre></td></tr></table></figure>\n<p>访问</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> rightTopValue = matrix[<span class=\"number\">0</span>, <span class=\"number\">1</span>]</div><div class=\"line\"><span class=\"comment\">// 1.5</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> someValue = matrix[<span class=\"number\">2</span>, <span class=\"number\">2</span>]</div><div class=\"line\"><span class=\"comment\">// this triggers an assert, because [2, 2] is outside of the matrix bounds</span></div></pre></td></tr></table></figure>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Subscripts.html/\" target=\"_blank\" rel=\"external\">Subscripts</a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>​    下标可以定义在类、结构体和枚举中，为访问集合，列表或序列中元素提供便捷。可以使用下标的索引，设置和获取值，而不需要再调用对应的存取方法。举例来说，用下标访问一个Array实例中的元素可以写作someArray[index]，访问Dictionary实例中的元素可以写作someDictionary[key]。</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>下标允许你通过在实例化对象后边的中括号中添加一个或多个索引值来查询或修改实例。语法类似于实例方法语法和计算型属性语法。通过关键字 <code>subscript</code> 定义，并指定一个或多个输入参数和返回类型；与实例方法不同的是。下标语法可以设定为读写( <code>read-write</code> )或只读( <code>read-only</code> )。这种行为由 getter 和 setter 实现，有点类似计算型属性：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">subscript</span>(index: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">get</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// return an appropriate subscript value here</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">set</span>(newValue) &#123;</div><div class=\"line\">        <span class=\"comment\">// perform a suitable setting action here</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>newValue的类型和下标的返回类型相同。如同计算型属性，可以不指定 setter 的参数（newValue）。如果不指定参数，setter 会提供一个名为newValue的默认参数。如同只读计算型属性，可以省略只读下标的get关键字：</p>","more":"<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">subscript</span>(index: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// return an appropriate subscript value here</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下面代码演示了只读下标的实现：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TimesTable</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> multiplier: <span class=\"type\">Int</span></div><div class=\"line\">    <span class=\"keyword\">subscript</span>(index: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> multiplier * index</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">let</span> threeTimesTable = <span class=\"type\">TimesTable</span>(multiplier: <span class=\"number\">3</span>)</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"six times three is <span class=\"subst\">\\(threeTimesTable[<span class=\"number\">6</span>])</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"six times three is 18\"</span></div></pre></td></tr></table></figure>\n<h3 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h3><p>下标的含义通常取决于使用场景，通常在集合、列表和序列中快速访问用。你也可以根据自己的特定类型实现下标功能。<br>例如Swift中的字典Dictionary使用下标语法对实例中储存的值进行存取操作。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> numberOfLegs = [<span class=\"string\">\"spider\"</span>: <span class=\"number\">8</span>, <span class=\"string\">\"ant\"</span>: <span class=\"number\">6</span>, <span class=\"string\">\"cat\"</span>: <span class=\"number\">4</span>]</div><div class=\"line\">numberOfLegs[<span class=\"string\">\"bird\"</span>] = <span class=\"number\">2</span></div></pre></td></tr></table></figure>\n<pre><code>Swift 的Dictionary类型的下标接受并返回可选类型的值。因为不是每个键都有个对应的值，同时这也提供了一种通过键删除对应值的方式，只需将键对应的值赋值为nil即可。\n</code></pre><h3 id=\"选项\"><a href=\"#选项\" class=\"headerlink\" title=\"选项\"></a>选项</h3><p>下标可以接受任意数量的入参，并且这些入参可以是任意类型。下标的返回值也可以是任意类型。下标可以使用变量参数和可变参数，但不能使用输入输出参数，也不能给参数设置默认值。<br>一个类或结构体可以根据自身需要提供多个下标实现</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Matrix</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> rows: <span class=\"type\">Int</span>, columns: <span class=\"type\">Int</span></div><div class=\"line\">    <span class=\"keyword\">var</span> grid: [<span class=\"type\">Double</span>]</div><div class=\"line\">    <span class=\"keyword\">init</span>(rows: <span class=\"type\">Int</span>, columns: <span class=\"type\">Int</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.rows = rows</div><div class=\"line\">        <span class=\"keyword\">self</span>.columns = columns</div><div class=\"line\">        grid = <span class=\"type\">Array</span>(repeating: <span class=\"number\">0.0</span>, <span class=\"built_in\">count</span>: rows * columns)</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">indexIsValid</span><span class=\"params\">(row: Int, column: Int)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> row &gt;= <span class=\"number\">0</span> &amp;&amp; row &lt; rows &amp;&amp; column &gt;= <span class=\"number\">0</span> &amp;&amp; column &lt; columns</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">subscript</span>(row: <span class=\"type\">Int</span>, column: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Double</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">get</span> &#123;</div><div class=\"line\">            <span class=\"built_in\">assert</span>(indexIsValid(row: row, column: column), <span class=\"string\">\"Index out of range\"</span>)</div><div class=\"line\">            <span class=\"keyword\">return</span> grid[(row * columns) + column]</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">set</span> &#123;</div><div class=\"line\">            <span class=\"built_in\">assert</span>(indexIsValid(row: row, column: column), <span class=\"string\">\"Index out of range\"</span>)</div><div class=\"line\">            grid[(row * columns) + column] = newValue</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>你可以通过传入合适的row和column的数量来构造一个新的Matrix实例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> matrix = <span class=\"type\">Matrix</span>(rows: <span class=\"number\">2</span>, columns: <span class=\"number\">2</span>)</div></pre></td></tr></table></figure>\n<p>将row和column的值传入下标来为矩阵设值，下标的入参使用逗号分隔：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">matrix[<span class=\"number\">0</span>, <span class=\"number\">1</span>] = <span class=\"number\">1.5</span></div><div class=\"line\">matrix[<span class=\"number\">1</span>, <span class=\"number\">0</span>] = <span class=\"number\">3.2</span></div></pre></td></tr></table></figure>\n<p>访问</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> rightTopValue = matrix[<span class=\"number\">0</span>, <span class=\"number\">1</span>]</div><div class=\"line\"><span class=\"comment\">// 1.5</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> someValue = matrix[<span class=\"number\">2</span>, <span class=\"number\">2</span>]</div><div class=\"line\"><span class=\"comment\">// this triggers an assert, because [2, 2] is outside of the matrix bounds</span></div></pre></td></tr></table></figure>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Subscripts.html/\" target=\"_blank\" rel=\"external\">Subscripts</a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>"},{"layout":"post","title":"Swift The Basics","date":"2016-11-02T14:06:31.000Z","author":"liangtong","catalog":true,"_content":"\n\n​\tSwift的很多地方类似C和Objective-C语言。在Swift中，用`Int`表示整型，用`Double`和`Float`表示浮点类型，用`Bool`表示布尔类型，用`String`表示文本类型。另外还提供有一些集合类型，比如`Array`，`Set`和`Dictionary`。是一种类型安全的语言。\n​\tSwift拥有和C语言类似变量和常量。还有一些高级的类型例如元组`tuples`（同PL/SQL中的类似）、不仅仅用在Class上的可选类型`optional types`(`Optionals say either “there is a value, and it equals x” or “there isn’t a value at all”.`)\n\n\n\n### 常量和变量\n​\t常量和变量在使用前必须声明，使用`var`来声明变量，使用`let`来声明常量，例如\n\n```Swift\nlet maximumNumberOfLoginAttempts = 10\nvar currentLoginAttempt = 0\nvar x = 0.0, y = 0.0, z = 0.0\n```\n\n​\t可以通过`let(var) name: type`来明确常量或变量的类型，例如：\n\n```Swift\nvar welcomeMessage: String\nvar red, green, blue: Double\n```\n\n​\t变量和常量的名称可以包括绝大多数字符（包括Unicode），但不能包含空格、数学符号、箭头以及一些无效的Unicode，且不能以数字开头。变量或者常量一旦被定义，其名称不能就不能被重复使用，或者改变其类型，也不能将变量改变为常量（反之也不可以）。\n\n```Swift\nvar friendlyWelcome = \"Hello!\"\nlet 你好 = \"你好世界\"\n```\n\n<!-- more -->\n\n​\t通过print函数来输出查看结果：\n\n```Swift\nprint(\"The current value of friendlyWelcome is \\(friendlyWelcome)\")\n```\n\n### 注释\n​\t和C语言类似，可以通过`//`进行单行注释；使用`/*`和`*/`进行多行注释，与C语言不同的是，多行注释在Swift中可以嵌套。例如：\n\n```Swift\n// This is a comment.\n\n/* This is also a comment\nbut is written over multiple lines. */\n\n/* This is the start of the first multiline comment.\n/* This is the second, nested multiline comment. */\nThis is the end of the first multiline comment. */\n\n```\n\n### 分号\n​\t和其他大部分语言不同的是，Swift不需要你在每个代码语句后边添加分号(;)，尽管写上也没问题\n\n### 整型\n​\t包括无符号整型`signed`和有符号整型`unsigned`,Swift提供的整型是以8、16、32、64位格式的，例如：`UInt8`、`Int32`。\n​\t可以通过`min`和`max`两个属性值来查看边界值：\n\n```Swift\nlet minValue = UInt8.min  // minValue is equal to 0, and is of type UInt8\nlet maxValue = UInt8.max  // maxValue is equal to 255, and is of type UInt8\n```\n\n​\t默认情况下，不需要在代码中指明特定的整数，对于`Int`，在32位系统中，默认为`Int32`，64位系统中，默认为`Int64`；对于`UInt`，在32位系统中，默认为`UInt32`，64位系统中，默认为`UInt64`\n\n### 浮点类型\n​\tSwift中提供两种有符号的浮点类型：用'Double'表示64位浮点类型数据，'Float'表示32位浮点类型。根据所需精度进行选择。\n\n### 类型安全和类型推断\n​\tSwift是一个类型安全的语言，意味着对类型区分很清晰，类型检查在编译的时候能确保在你的代码中不会出现因失误导致的类型赋值错误。当你没有明确你需要的类型时，Swfit使用类型推断帮助你选择合适的类型，这样Swift会帮你减少很大的代码量。\n\n```Swift\nlet meaningOfLife = 42// meaningOfLife is inferred to be of type Int\n\n//对于浮点类型，类型推断会将其定义为Double\nlet pi = 3.14159// pi is inferred to be of type Double\n```\n\n### 数值常量\n​\t对于整型数值常量来说：十进制没有前缀，二进制以`0b`开头，八进制以`0o`开头，十六进制以`0x`开头\n\n```Swift\nlet decimalInteger = 17\nlet binaryInteger = 0b10001       // 17 in binary notation\nlet octalInteger = 0o21           // 17 in octal notation\nlet hexadecimalInteger = 0x11     // 17 in hexadecimal notation\n```\n\n​\t浮点数值常量可以是十进制或者十六进制。其中十进制的浮点数值常量中使用字符`e`，代表的是10的exp幂；十六进制数值常量中使用字符`p`，，代表的是2的exp幂\n\n>* 1.25e2 means 1.25 x 10^2, or 125.0.\n>* 1.25e-2 means 1.25 x 10^-2, or 0.0125.\n>* 0xFp2 means 15 x 2^2, or 60.0.\n>* 0xFp-2 means 15 x 2^-2, or 3.75.\n\n​\t\n\n​\t附小常识：数值常量可以通过添加额外的0或者下划线`_`来帮助阅读。不会影响具体值，例如：\n\n```Swift\nlet oneMillion = 1_000_000\nlet justOverOneMillion = 1_000_000.000_000_1\nlet paddedDouble = 000123.456\n```\n\n### 数值类型转换\n​\t这部分需要注意值域问题，如果转换导致越界，会出现错误。别的没啥好说的，编译器会告诉你的。如果需要的话，转换过程举例如下（显示调用类型方法，比如Double(6) ）：\n>>Int8 -> Int16 -> Int -> Double\n\n### 类型别名\n​\t使用关键字`typealias`起别名，例如：\n\n```Swift\ntypealias AudioSample = UInt16//起别名\nvar maxAmplitudeFound = AudioSample.min//使用\n```\n\n### 布尔类型\n​\tSwift中的布尔类型为`Bool`，两个值`true`和`false`。布尔值在`if`语句中很常用。与其他语言不同的是，`if`语句中必须为`Bool`值，否则会出现编译错误。\n\n### 元组\n​\t将多个（不同类型的）数据组合成一个数据类型，可以使用任何你喜欢类型创建元组`(Int, Int, Int)`,或者`(String, Bool)`，没有任何限制，一个元组的创建例子如下：\n\n```Swift\nlet http404Error = (404, \"Not Found\")\n// http404Error is of type (Int, String), and equals (404, \"Not Found\")\n```\n\n​\t可以将元组的内容分解成独立的常量或变量来单独访问；当你只需要元组中的部分值时，其它部分可以通过下划线(`_`)忽略；当然也可以通过下标的形式来访问(`下标从0开始`)。例如：\n\n```Swift\nlet (statusCode, statusMessage) = http404Error\nprint(\"The status code is \\(statusCode)\")\n// Prints \"The status code is 404\"\nprint(\"The status message is \\(statusMessage)\")\n// Prints \"The status message is Not Found\"\n\nlet (justTheStatusCode, _) = http404Error\nprint(\"The status code is \\(justTheStatusCode)\")\n// Prints \"The status code is 404\"\n\nprint(\"The status code is \\(http404Error.0)\")\n// Prints \"The status code is 404\"\nprint(\"The status message is \\(http404Error.1)\")\n// Prints \"The status message is Not Found\"\n```\n\n​\t定义元组的时候可以给单独的元素起名字，然后可以通过元素名字来访问具体的值，例如：\n\n```Swift\nlet http200Status = (statusCode: 200, description: \"OK\")\n\nprint(\"The status code is \\(http200Status.statusCode)\")\n// Prints \"The status code is 200\"\nprint(\"The status message is \\(http200Status.description)\")\n// Prints \"The status message is OK\"\n```\n\n>> 当函数有多个返回值时，元组显得非常适用；但元组不适合于复杂的数据结构创建。\n\n###  可选类型\n​\t当一个值可能不存在时，使用可选类型(`optionals`)，可选表示两种可能：要么存在一个值，你可以解包并访问其值；要么不存在。\n\n>> ​\t注：可选的概念在C或者Objective-C中是不存在的，ObjC中一个相似点是一个方法要么返回一个对象，要么返回nil，但是在ObjC中仅适用于对象，不适用于结构体、基本C类型或者枚举类型。但是Swift中的可选适用于所有类型。\n\n```Swift\nlet possibleNumber = \"123\"\nlet convertedNumber = Int(possibleNumber)\n// convertedNumber is inferred to be of type \"Int?\", or \"optional Int\"\n```\n\n#### nil\n​\t可以将nil赋值给一个可选类型变量。对于可选类型变量，如果声明的时候没有提供初始值，则默认被设置为nil。\n\n>> ​\t注：nil不能被可选类型以外的变量或者常量适用，如果代码中一个变量需要处理不存在的情况，通常将其定义为可选类型。Swift中的nil和ObjC中的nil不同：ObjC中的nil是一个指向不存在的对象的指针；Swift中的nil不是指针，它是一个特定类型不存在的值，适用于所有Swift类型\n\n```Swift\nvar serverResponseCode: Int? = 404\n// serverResponseCode contains an actual Int value of 404\nserverResponseCode = nil\n// serverResponseCode now contains no value\n\nvar surveyAnswer: String?\n// surveyAnswer is automatically set to nil\n```\n\n#### if语句和强制解包\n​\t可以通过使用If语句来确定一个可选类型是一个值或者是nil(使用操作符`==`或`!=`)。如果一个可选类型存在一个值，就可以通过在参数名后边添加`!`来强制解包该可选类型值。\n\n>> 注：[重要] 使用`!`的时候一定要确保可选类型的值是存在的，否则会出现运行时错误，导致程序闪退。\n\n\n```Swift\nif convertedNumber != nil {\n    print(\"convertedNumber has an integer value of \\(convertedNumber!).\")\n}\n```\n\n#### 可选绑定\n​\t在if和while语句中，可以通过使用可选绑定来检查可选值。if语句中使用可选绑定格式如下\n\n```Swift\nif let constantName = someOptional {//if var constantName\n    non-nil-statements\n} else {\n    nil-statement\n}\n```\n\n#### 可选类型的隐式解包\n​\t通常情况下，对于一个可选类型，如果在设置初始值后能够`确定包含一个值`，就没有必要每次通过可选绑定来进行检查、解包。这时可以通过在可选类型名后边添加`!`来隐式解包\n\n```Swift\nlet possibleString: String? = \"An optional string.\"\nlet forcedString: String = possibleString! // requires an exclamation mark\n \nlet assumedString: String! = \"An implicitly unwrapped optional string.\"\nlet implicitString: String = assumedString // no need for an exclamation mark\n```\n\n### 错误处理\n在程序执行过程中，可以通过错误处理来响应程序运行期间遇到的错误。当一个函数遇到错误的时候，可以抛出，函数调用者捕捉该错误并做相应的相应处理。函数通过关键字`throws`来表明会抛出错误。当调用该类型的函数时，使用`try`关键字\n\n```Swift\nfunc canThrowAnError() throws {\n    // this function may or may not throw an error\n}\n\ndo {\n    try canThrowAnError()\n    // no error was thrown\n} catch {//默认error，当然你也可以使用多个catch，并明确具体的错误类型 比如：catch SandwichError.outOfCleanDishes\n    // an error was thrown\n}\n\n\n```\n\n\n### 断言\n​\t在一些特定的情况下，代码没有必要继续执行。这时候可以通过触发断言来终止代码的执行，并告知原因。\n\n​\t通常情况下，断言的使用时机：\n>* 在Debug的时候使用；\n\n>* 使用下标访问数据时；\n\n>* 函数入口参数检查时；\n\n>* 可选类型要求非nil时；\n\n\n\n\n### 参照文档\n\n`https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html`\n\n>\n>\n>\n>\n>\n>\n>​Copyright (c) liangtong. All rights reserved.\n>\n\n\n","source":"_posts/iOS_Swift_language_note_The-Basics.md","raw":"---\nlayout:     post\ntitle:      Swift The Basics\ndate:       2016-11-02 22:06:31\nauthor:     liangtong\ncatalog: true\ncategories: iOS\ntags: Swift \n\n---\n\n\n​\tSwift的很多地方类似C和Objective-C语言。在Swift中，用`Int`表示整型，用`Double`和`Float`表示浮点类型，用`Bool`表示布尔类型，用`String`表示文本类型。另外还提供有一些集合类型，比如`Array`，`Set`和`Dictionary`。是一种类型安全的语言。\n​\tSwift拥有和C语言类似变量和常量。还有一些高级的类型例如元组`tuples`（同PL/SQL中的类似）、不仅仅用在Class上的可选类型`optional types`(`Optionals say either “there is a value, and it equals x” or “there isn’t a value at all”.`)\n\n\n\n### 常量和变量\n​\t常量和变量在使用前必须声明，使用`var`来声明变量，使用`let`来声明常量，例如\n\n```Swift\nlet maximumNumberOfLoginAttempts = 10\nvar currentLoginAttempt = 0\nvar x = 0.0, y = 0.0, z = 0.0\n```\n\n​\t可以通过`let(var) name: type`来明确常量或变量的类型，例如：\n\n```Swift\nvar welcomeMessage: String\nvar red, green, blue: Double\n```\n\n​\t变量和常量的名称可以包括绝大多数字符（包括Unicode），但不能包含空格、数学符号、箭头以及一些无效的Unicode，且不能以数字开头。变量或者常量一旦被定义，其名称不能就不能被重复使用，或者改变其类型，也不能将变量改变为常量（反之也不可以）。\n\n```Swift\nvar friendlyWelcome = \"Hello!\"\nlet 你好 = \"你好世界\"\n```\n\n<!-- more -->\n\n​\t通过print函数来输出查看结果：\n\n```Swift\nprint(\"The current value of friendlyWelcome is \\(friendlyWelcome)\")\n```\n\n### 注释\n​\t和C语言类似，可以通过`//`进行单行注释；使用`/*`和`*/`进行多行注释，与C语言不同的是，多行注释在Swift中可以嵌套。例如：\n\n```Swift\n// This is a comment.\n\n/* This is also a comment\nbut is written over multiple lines. */\n\n/* This is the start of the first multiline comment.\n/* This is the second, nested multiline comment. */\nThis is the end of the first multiline comment. */\n\n```\n\n### 分号\n​\t和其他大部分语言不同的是，Swift不需要你在每个代码语句后边添加分号(;)，尽管写上也没问题\n\n### 整型\n​\t包括无符号整型`signed`和有符号整型`unsigned`,Swift提供的整型是以8、16、32、64位格式的，例如：`UInt8`、`Int32`。\n​\t可以通过`min`和`max`两个属性值来查看边界值：\n\n```Swift\nlet minValue = UInt8.min  // minValue is equal to 0, and is of type UInt8\nlet maxValue = UInt8.max  // maxValue is equal to 255, and is of type UInt8\n```\n\n​\t默认情况下，不需要在代码中指明特定的整数，对于`Int`，在32位系统中，默认为`Int32`，64位系统中，默认为`Int64`；对于`UInt`，在32位系统中，默认为`UInt32`，64位系统中，默认为`UInt64`\n\n### 浮点类型\n​\tSwift中提供两种有符号的浮点类型：用'Double'表示64位浮点类型数据，'Float'表示32位浮点类型。根据所需精度进行选择。\n\n### 类型安全和类型推断\n​\tSwift是一个类型安全的语言，意味着对类型区分很清晰，类型检查在编译的时候能确保在你的代码中不会出现因失误导致的类型赋值错误。当你没有明确你需要的类型时，Swfit使用类型推断帮助你选择合适的类型，这样Swift会帮你减少很大的代码量。\n\n```Swift\nlet meaningOfLife = 42// meaningOfLife is inferred to be of type Int\n\n//对于浮点类型，类型推断会将其定义为Double\nlet pi = 3.14159// pi is inferred to be of type Double\n```\n\n### 数值常量\n​\t对于整型数值常量来说：十进制没有前缀，二进制以`0b`开头，八进制以`0o`开头，十六进制以`0x`开头\n\n```Swift\nlet decimalInteger = 17\nlet binaryInteger = 0b10001       // 17 in binary notation\nlet octalInteger = 0o21           // 17 in octal notation\nlet hexadecimalInteger = 0x11     // 17 in hexadecimal notation\n```\n\n​\t浮点数值常量可以是十进制或者十六进制。其中十进制的浮点数值常量中使用字符`e`，代表的是10的exp幂；十六进制数值常量中使用字符`p`，，代表的是2的exp幂\n\n>* 1.25e2 means 1.25 x 10^2, or 125.0.\n>* 1.25e-2 means 1.25 x 10^-2, or 0.0125.\n>* 0xFp2 means 15 x 2^2, or 60.0.\n>* 0xFp-2 means 15 x 2^-2, or 3.75.\n\n​\t\n\n​\t附小常识：数值常量可以通过添加额外的0或者下划线`_`来帮助阅读。不会影响具体值，例如：\n\n```Swift\nlet oneMillion = 1_000_000\nlet justOverOneMillion = 1_000_000.000_000_1\nlet paddedDouble = 000123.456\n```\n\n### 数值类型转换\n​\t这部分需要注意值域问题，如果转换导致越界，会出现错误。别的没啥好说的，编译器会告诉你的。如果需要的话，转换过程举例如下（显示调用类型方法，比如Double(6) ）：\n>>Int8 -> Int16 -> Int -> Double\n\n### 类型别名\n​\t使用关键字`typealias`起别名，例如：\n\n```Swift\ntypealias AudioSample = UInt16//起别名\nvar maxAmplitudeFound = AudioSample.min//使用\n```\n\n### 布尔类型\n​\tSwift中的布尔类型为`Bool`，两个值`true`和`false`。布尔值在`if`语句中很常用。与其他语言不同的是，`if`语句中必须为`Bool`值，否则会出现编译错误。\n\n### 元组\n​\t将多个（不同类型的）数据组合成一个数据类型，可以使用任何你喜欢类型创建元组`(Int, Int, Int)`,或者`(String, Bool)`，没有任何限制，一个元组的创建例子如下：\n\n```Swift\nlet http404Error = (404, \"Not Found\")\n// http404Error is of type (Int, String), and equals (404, \"Not Found\")\n```\n\n​\t可以将元组的内容分解成独立的常量或变量来单独访问；当你只需要元组中的部分值时，其它部分可以通过下划线(`_`)忽略；当然也可以通过下标的形式来访问(`下标从0开始`)。例如：\n\n```Swift\nlet (statusCode, statusMessage) = http404Error\nprint(\"The status code is \\(statusCode)\")\n// Prints \"The status code is 404\"\nprint(\"The status message is \\(statusMessage)\")\n// Prints \"The status message is Not Found\"\n\nlet (justTheStatusCode, _) = http404Error\nprint(\"The status code is \\(justTheStatusCode)\")\n// Prints \"The status code is 404\"\n\nprint(\"The status code is \\(http404Error.0)\")\n// Prints \"The status code is 404\"\nprint(\"The status message is \\(http404Error.1)\")\n// Prints \"The status message is Not Found\"\n```\n\n​\t定义元组的时候可以给单独的元素起名字，然后可以通过元素名字来访问具体的值，例如：\n\n```Swift\nlet http200Status = (statusCode: 200, description: \"OK\")\n\nprint(\"The status code is \\(http200Status.statusCode)\")\n// Prints \"The status code is 200\"\nprint(\"The status message is \\(http200Status.description)\")\n// Prints \"The status message is OK\"\n```\n\n>> 当函数有多个返回值时，元组显得非常适用；但元组不适合于复杂的数据结构创建。\n\n###  可选类型\n​\t当一个值可能不存在时，使用可选类型(`optionals`)，可选表示两种可能：要么存在一个值，你可以解包并访问其值；要么不存在。\n\n>> ​\t注：可选的概念在C或者Objective-C中是不存在的，ObjC中一个相似点是一个方法要么返回一个对象，要么返回nil，但是在ObjC中仅适用于对象，不适用于结构体、基本C类型或者枚举类型。但是Swift中的可选适用于所有类型。\n\n```Swift\nlet possibleNumber = \"123\"\nlet convertedNumber = Int(possibleNumber)\n// convertedNumber is inferred to be of type \"Int?\", or \"optional Int\"\n```\n\n#### nil\n​\t可以将nil赋值给一个可选类型变量。对于可选类型变量，如果声明的时候没有提供初始值，则默认被设置为nil。\n\n>> ​\t注：nil不能被可选类型以外的变量或者常量适用，如果代码中一个变量需要处理不存在的情况，通常将其定义为可选类型。Swift中的nil和ObjC中的nil不同：ObjC中的nil是一个指向不存在的对象的指针；Swift中的nil不是指针，它是一个特定类型不存在的值，适用于所有Swift类型\n\n```Swift\nvar serverResponseCode: Int? = 404\n// serverResponseCode contains an actual Int value of 404\nserverResponseCode = nil\n// serverResponseCode now contains no value\n\nvar surveyAnswer: String?\n// surveyAnswer is automatically set to nil\n```\n\n#### if语句和强制解包\n​\t可以通过使用If语句来确定一个可选类型是一个值或者是nil(使用操作符`==`或`!=`)。如果一个可选类型存在一个值，就可以通过在参数名后边添加`!`来强制解包该可选类型值。\n\n>> 注：[重要] 使用`!`的时候一定要确保可选类型的值是存在的，否则会出现运行时错误，导致程序闪退。\n\n\n```Swift\nif convertedNumber != nil {\n    print(\"convertedNumber has an integer value of \\(convertedNumber!).\")\n}\n```\n\n#### 可选绑定\n​\t在if和while语句中，可以通过使用可选绑定来检查可选值。if语句中使用可选绑定格式如下\n\n```Swift\nif let constantName = someOptional {//if var constantName\n    non-nil-statements\n} else {\n    nil-statement\n}\n```\n\n#### 可选类型的隐式解包\n​\t通常情况下，对于一个可选类型，如果在设置初始值后能够`确定包含一个值`，就没有必要每次通过可选绑定来进行检查、解包。这时可以通过在可选类型名后边添加`!`来隐式解包\n\n```Swift\nlet possibleString: String? = \"An optional string.\"\nlet forcedString: String = possibleString! // requires an exclamation mark\n \nlet assumedString: String! = \"An implicitly unwrapped optional string.\"\nlet implicitString: String = assumedString // no need for an exclamation mark\n```\n\n### 错误处理\n在程序执行过程中，可以通过错误处理来响应程序运行期间遇到的错误。当一个函数遇到错误的时候，可以抛出，函数调用者捕捉该错误并做相应的相应处理。函数通过关键字`throws`来表明会抛出错误。当调用该类型的函数时，使用`try`关键字\n\n```Swift\nfunc canThrowAnError() throws {\n    // this function may or may not throw an error\n}\n\ndo {\n    try canThrowAnError()\n    // no error was thrown\n} catch {//默认error，当然你也可以使用多个catch，并明确具体的错误类型 比如：catch SandwichError.outOfCleanDishes\n    // an error was thrown\n}\n\n\n```\n\n\n### 断言\n​\t在一些特定的情况下，代码没有必要继续执行。这时候可以通过触发断言来终止代码的执行，并告知原因。\n\n​\t通常情况下，断言的使用时机：\n>* 在Debug的时候使用；\n\n>* 使用下标访问数据时；\n\n>* 函数入口参数检查时；\n\n>* 可选类型要求非nil时；\n\n\n\n\n### 参照文档\n\n`https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html`\n\n>\n>\n>\n>\n>\n>\n>​Copyright (c) liangtong. All rights reserved.\n>\n\n\n","slug":"iOS_Swift_language_note_The-Basics","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4ut0046oko8grgmvle1","content":"<p>​    Swift的很多地方类似C和Objective-C语言。在Swift中，用<code>Int</code>表示整型，用<code>Double</code>和<code>Float</code>表示浮点类型，用<code>Bool</code>表示布尔类型，用<code>String</code>表示文本类型。另外还提供有一些集合类型，比如<code>Array</code>，<code>Set</code>和<code>Dictionary</code>。是一种类型安全的语言。<br>​    Swift拥有和C语言类似变量和常量。还有一些高级的类型例如元组<code>tuples</code>（同PL/SQL中的类似）、不仅仅用在Class上的可选类型<code>optional types</code>(<code>Optionals say either “there is a value, and it equals x” or “there isn’t a value at all”.</code>)</p>\n<h3 id=\"常量和变量\"><a href=\"#常量和变量\" class=\"headerlink\" title=\"常量和变量\"></a>常量和变量</h3><p>​    常量和变量在使用前必须声明，使用<code>var</code>来声明变量，使用<code>let</code>来声明常量，例如</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> maximumNumberOfLoginAttempts = <span class=\"number\">10</span></div><div class=\"line\"><span class=\"keyword\">var</span> currentLoginAttempt = <span class=\"number\">0</span></div><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">0.0</span>, y = <span class=\"number\">0.0</span>, z = <span class=\"number\">0.0</span></div></pre></td></tr></table></figure>\n<p>​    可以通过<code>let(var) name: type</code>来明确常量或变量的类型，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> welcomeMessage: <span class=\"type\">String</span></div><div class=\"line\"><span class=\"keyword\">var</span> red, green, blue: <span class=\"type\">Double</span></div></pre></td></tr></table></figure>\n<p>​    变量和常量的名称可以包括绝大多数字符（包括Unicode），但不能包含空格、数学符号、箭头以及一些无效的Unicode，且不能以数字开头。变量或者常量一旦被定义，其名称不能就不能被重复使用，或者改变其类型，也不能将变量改变为常量（反之也不可以）。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> friendlyWelcome = <span class=\"string\">\"Hello!\"</span></div><div class=\"line\"><span class=\"keyword\">let</span> 你好 = <span class=\"string\">\"你好世界\"</span></div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>​    通过print函数来输出查看结果：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The current value of friendlyWelcome is <span class=\"subst\">\\(friendlyWelcome)</span>\"</span>)</div></pre></td></tr></table></figure>\n<h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><p>​    和C语言类似，可以通过<code>//</code>进行单行注释；使用<code>/*</code>和<code>*/</code>进行多行注释，与C语言不同的是，多行注释在Swift中可以嵌套。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// This is a comment.</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* This is also a comment</span></div><div class=\"line\"><span class=\"comment\">but is written over multiple lines. */</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* This is the start of the first multiline comment.</span></div><div class=\"line\"><span class=\"comment\"><span class=\"comment\">/* This is the second, nested multiline comment. */</span></span></div><div class=\"line\"><span class=\"comment\">This is the end of the first multiline comment. */</span></div></pre></td></tr></table></figure>\n<h3 id=\"分号\"><a href=\"#分号\" class=\"headerlink\" title=\"分号\"></a>分号</h3><p>​    和其他大部分语言不同的是，Swift不需要你在每个代码语句后边添加分号(;)，尽管写上也没问题</p>\n<h3 id=\"整型\"><a href=\"#整型\" class=\"headerlink\" title=\"整型\"></a>整型</h3><p>​    包括无符号整型<code>signed</code>和有符号整型<code>unsigned</code>,Swift提供的整型是以8、16、32、64位格式的，例如：<code>UInt8</code>、<code>Int32</code>。<br>​    可以通过<code>min</code>和<code>max</code>两个属性值来查看边界值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> minValue = <span class=\"type\">UInt8</span>.<span class=\"built_in\">min</span>  <span class=\"comment\">// minValue is equal to 0, and is of type UInt8</span></div><div class=\"line\"><span class=\"keyword\">let</span> maxValue = <span class=\"type\">UInt8</span>.<span class=\"built_in\">max</span>  <span class=\"comment\">// maxValue is equal to 255, and is of type UInt8</span></div></pre></td></tr></table></figure>\n<p>​    默认情况下，不需要在代码中指明特定的整数，对于<code>Int</code>，在32位系统中，默认为<code>Int32</code>，64位系统中，默认为<code>Int64</code>；对于<code>UInt</code>，在32位系统中，默认为<code>UInt32</code>，64位系统中，默认为<code>UInt64</code></p>\n<h3 id=\"浮点类型\"><a href=\"#浮点类型\" class=\"headerlink\" title=\"浮点类型\"></a>浮点类型</h3><p>​    Swift中提供两种有符号的浮点类型：用’Double’表示64位浮点类型数据，’Float’表示32位浮点类型。根据所需精度进行选择。</p>\n<h3 id=\"类型安全和类型推断\"><a href=\"#类型安全和类型推断\" class=\"headerlink\" title=\"类型安全和类型推断\"></a>类型安全和类型推断</h3><p>​    Swift是一个类型安全的语言，意味着对类型区分很清晰，类型检查在编译的时候能确保在你的代码中不会出现因失误导致的类型赋值错误。当你没有明确你需要的类型时，Swfit使用类型推断帮助你选择合适的类型，这样Swift会帮你减少很大的代码量。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> meaningOfLife = <span class=\"number\">42</span><span class=\"comment\">// meaningOfLife is inferred to be of type Int</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//对于浮点类型，类型推断会将其定义为Double</span></div><div class=\"line\"><span class=\"keyword\">let</span> pi = <span class=\"number\">3.14159</span><span class=\"comment\">// pi is inferred to be of type Double</span></div></pre></td></tr></table></figure>\n<h3 id=\"数值常量\"><a href=\"#数值常量\" class=\"headerlink\" title=\"数值常量\"></a>数值常量</h3><p>​    对于整型数值常量来说：十进制没有前缀，二进制以<code>0b</code>开头，八进制以<code>0o</code>开头，十六进制以<code>0x</code>开头</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> decimalInteger = <span class=\"number\">17</span></div><div class=\"line\"><span class=\"keyword\">let</span> binaryInteger = <span class=\"number\">0b10001</span>       <span class=\"comment\">// 17 in binary notation</span></div><div class=\"line\"><span class=\"keyword\">let</span> octalInteger = <span class=\"number\">0o21</span>           <span class=\"comment\">// 17 in octal notation</span></div><div class=\"line\"><span class=\"keyword\">let</span> hexadecimalInteger = <span class=\"number\">0x11</span>     <span class=\"comment\">// 17 in hexadecimal notation</span></div></pre></td></tr></table></figure>\n<p>​    浮点数值常量可以是十进制或者十六进制。其中十进制的浮点数值常量中使用字符<code>e</code>，代表的是10的exp幂；十六进制数值常量中使用字符<code>p</code>，，代表的是2的exp幂</p>\n<blockquote>\n<ul>\n<li>1.25e2 means 1.25 x 10^2, or 125.0.</li>\n<li>1.25e-2 means 1.25 x 10^-2, or 0.0125.</li>\n<li>0xFp2 means 15 x 2^2, or 60.0.</li>\n<li>0xFp-2 means 15 x 2^-2, or 3.75.</li>\n</ul>\n</blockquote>\n<p>​    </p>\n<p>​    附小常识：数值常量可以通过添加额外的0或者下划线<code>_</code>来帮助阅读。不会影响具体值，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> oneMillion = <span class=\"number\">1_000_000</span></div><div class=\"line\"><span class=\"keyword\">let</span> justOverOneMillion = <span class=\"number\">1_000_000.000_000_1</span></div><div class=\"line\"><span class=\"keyword\">let</span> paddedDouble = <span class=\"number\">000123.456</span></div></pre></td></tr></table></figure>\n<h3 id=\"数值类型转换\"><a href=\"#数值类型转换\" class=\"headerlink\" title=\"数值类型转换\"></a>数值类型转换</h3><p>​    这部分需要注意值域问题，如果转换导致越界，会出现错误。别的没啥好说的，编译器会告诉你的。如果需要的话，转换过程举例如下（显示调用类型方法，比如Double(6) ）：</p>\n<blockquote>\n<blockquote>\n<p>Int8 -&gt; Int16 -&gt; Int -&gt; Double</p>\n</blockquote>\n</blockquote>\n<h3 id=\"类型别名\"><a href=\"#类型别名\" class=\"headerlink\" title=\"类型别名\"></a>类型别名</h3><p>​    使用关键字<code>typealias</code>起别名，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typealias</span> <span class=\"type\">AudioSample</span> = <span class=\"type\">UInt16</span><span class=\"comment\">//起别名</span></div><div class=\"line\"><span class=\"keyword\">var</span> maxAmplitudeFound = <span class=\"type\">AudioSample</span>.<span class=\"built_in\">min</span><span class=\"comment\">//使用</span></div></pre></td></tr></table></figure>\n<h3 id=\"布尔类型\"><a href=\"#布尔类型\" class=\"headerlink\" title=\"布尔类型\"></a>布尔类型</h3><p>​    Swift中的布尔类型为<code>Bool</code>，两个值<code>true</code>和<code>false</code>。布尔值在<code>if</code>语句中很常用。与其他语言不同的是，<code>if</code>语句中必须为<code>Bool</code>值，否则会出现编译错误。</p>\n<h3 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h3><p>​    将多个（不同类型的）数据组合成一个数据类型，可以使用任何你喜欢类型创建元组<code>(Int, Int, Int)</code>,或者<code>(String, Bool)</code>，没有任何限制，一个元组的创建例子如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> http404Error = (<span class=\"number\">404</span>, <span class=\"string\">\"Not Found\"</span>)</div><div class=\"line\"><span class=\"comment\">// http404Error is of type (Int, String), and equals (404, \"Not Found\")</span></div></pre></td></tr></table></figure>\n<p>​    可以将元组的内容分解成独立的常量或变量来单独访问；当你只需要元组中的部分值时，其它部分可以通过下划线(<code>_</code>)忽略；当然也可以通过下标的形式来访问(<code>下标从0开始</code>)。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> (statusCode, statusMessage) = http404Error</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The status code is <span class=\"subst\">\\(statusCode)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"The status code is 404\"</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The status message is <span class=\"subst\">\\(statusMessage)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"The status message is Not Found\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> (justTheStatusCode, <span class=\"number\">_</span>) = http404Error</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The status code is <span class=\"subst\">\\(justTheStatusCode)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"The status code is 404\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The status code is <span class=\"subst\">\\(http404Error.<span class=\"number\">0</span>)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"The status code is 404\"</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The status message is <span class=\"subst\">\\(http404Error.<span class=\"number\">1</span>)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"The status message is Not Found\"</span></div></pre></td></tr></table></figure>\n<p>​    定义元组的时候可以给单独的元素起名字，然后可以通过元素名字来访问具体的值，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> http200Status = (statusCode: <span class=\"number\">200</span>, description: <span class=\"string\">\"OK\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The status code is <span class=\"subst\">\\(http200Status.statusCode)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"The status code is 200\"</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The status message is <span class=\"subst\">\\(http200Status.description)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"The status message is OK\"</span></div></pre></td></tr></table></figure>\n<blockquote>\n<blockquote>\n<p>当函数有多个返回值时，元组显得非常适用；但元组不适合于复杂的数据结构创建。</p>\n</blockquote>\n</blockquote>\n<h3 id=\"可选类型\"><a href=\"#可选类型\" class=\"headerlink\" title=\"可选类型\"></a>可选类型</h3><p>​    当一个值可能不存在时，使用可选类型(<code>optionals</code>)，可选表示两种可能：要么存在一个值，你可以解包并访问其值；要么不存在。</p>\n<blockquote>\n<blockquote>\n<p>​    注：可选的概念在C或者Objective-C中是不存在的，ObjC中一个相似点是一个方法要么返回一个对象，要么返回nil，但是在ObjC中仅适用于对象，不适用于结构体、基本C类型或者枚举类型。但是Swift中的可选适用于所有类型。</p>\n</blockquote>\n</blockquote>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> possibleNumber = <span class=\"string\">\"123\"</span></div><div class=\"line\"><span class=\"keyword\">let</span> convertedNumber = <span class=\"type\">Int</span>(possibleNumber)</div><div class=\"line\"><span class=\"comment\">// convertedNumber is inferred to be of type \"Int?\", or \"optional Int\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"nil\"><a href=\"#nil\" class=\"headerlink\" title=\"nil\"></a>nil</h4><p>​    可以将nil赋值给一个可选类型变量。对于可选类型变量，如果声明的时候没有提供初始值，则默认被设置为nil。</p>\n<blockquote>\n<blockquote>\n<p>​    注：nil不能被可选类型以外的变量或者常量适用，如果代码中一个变量需要处理不存在的情况，通常将其定义为可选类型。Swift中的nil和ObjC中的nil不同：ObjC中的nil是一个指向不存在的对象的指针；Swift中的nil不是指针，它是一个特定类型不存在的值，适用于所有Swift类型</p>\n</blockquote>\n</blockquote>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> serverResponseCode: <span class=\"type\">Int</span>? = <span class=\"number\">404</span></div><div class=\"line\"><span class=\"comment\">// serverResponseCode contains an actual Int value of 404</span></div><div class=\"line\">serverResponseCode = <span class=\"literal\">nil</span></div><div class=\"line\"><span class=\"comment\">// serverResponseCode now contains no value</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> surveyAnswer: <span class=\"type\">String</span>?</div><div class=\"line\"><span class=\"comment\">// surveyAnswer is automatically set to nil</span></div></pre></td></tr></table></figure>\n<h4 id=\"if语句和强制解包\"><a href=\"#if语句和强制解包\" class=\"headerlink\" title=\"if语句和强制解包\"></a>if语句和强制解包</h4><p>​    可以通过使用If语句来确定一个可选类型是一个值或者是nil(使用操作符<code>==</code>或<code>!=</code>)。如果一个可选类型存在一个值，就可以通过在参数名后边添加<code>!</code>来强制解包该可选类型值。</p>\n<blockquote>\n<blockquote>\n<p>注：[重要] 使用<code>!</code>的时候一定要确保可选类型的值是存在的，否则会出现运行时错误，导致程序闪退。</p>\n</blockquote>\n</blockquote>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> convertedNumber != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"convertedNumber has an integer value of <span class=\"subst\">\\(convertedNumber!)</span>.\"</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"可选绑定\"><a href=\"#可选绑定\" class=\"headerlink\" title=\"可选绑定\"></a>可选绑定</h4><p>​    在if和while语句中，可以通过使用可选绑定来检查可选值。if语句中使用可选绑定格式如下</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> constantName = someOptional &#123;<span class=\"comment\">//if var constantName</span></div><div class=\"line\">    non-<span class=\"literal\">nil</span>-statements</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"literal\">nil</span>-statement</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"可选类型的隐式解包\"><a href=\"#可选类型的隐式解包\" class=\"headerlink\" title=\"可选类型的隐式解包\"></a>可选类型的隐式解包</h4><p>​    通常情况下，对于一个可选类型，如果在设置初始值后能够<code>确定包含一个值</code>，就没有必要每次通过可选绑定来进行检查、解包。这时可以通过在可选类型名后边添加<code>!</code>来隐式解包</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> possibleString: <span class=\"type\">String</span>? = <span class=\"string\">\"An optional string.\"</span></div><div class=\"line\"><span class=\"keyword\">let</span> forcedString: <span class=\"type\">String</span> = possibleString! <span class=\"comment\">// requires an exclamation mark</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">let</span> assumedString: <span class=\"type\">String</span>! = <span class=\"string\">\"An implicitly unwrapped optional string.\"</span></div><div class=\"line\"><span class=\"keyword\">let</span> implicitString: <span class=\"type\">String</span> = assumedString <span class=\"comment\">// no need for an exclamation mark</span></div></pre></td></tr></table></figure>\n<h3 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h3><p>在程序执行过程中，可以通过错误处理来响应程序运行期间遇到的错误。当一个函数遇到错误的时候，可以抛出，函数调用者捕捉该错误并做相应的相应处理。函数通过关键字<code>throws</code>来表明会抛出错误。当调用该类型的函数时，使用<code>try</code>关键字</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">canThrowAnError</span><span class=\"params\">()</span></span> <span class=\"keyword\">throws</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// this function may or may not throw an error</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">do</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">try</span> canThrowAnError()</div><div class=\"line\">    <span class=\"comment\">// no error was thrown</span></div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> &#123;<span class=\"comment\">//默认error，当然你也可以使用多个catch，并明确具体的错误类型 比如：catch SandwichError.outOfCleanDishes</span></div><div class=\"line\">    <span class=\"comment\">// an error was thrown</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"断言\"><a href=\"#断言\" class=\"headerlink\" title=\"断言\"></a>断言</h3><p>​    在一些特定的情况下，代码没有必要继续执行。这时候可以通过触发断言来终止代码的执行，并告知原因。</p>\n<p>​    通常情况下，断言的使用时机：</p>\n<blockquote>\n<ul>\n<li><p>在Debug的时候使用；</p>\n</li>\n<li><p>使用下标访问数据时；</p>\n</li>\n<li><p>函数入口参数检查时；</p>\n</li>\n<li><p>可选类型要求非nil时；</p>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><p><code>https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html</code></p>\n<p>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;</p>\n<blockquote>\n<p>​Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>​    Swift的很多地方类似C和Objective-C语言。在Swift中，用<code>Int</code>表示整型，用<code>Double</code>和<code>Float</code>表示浮点类型，用<code>Bool</code>表示布尔类型，用<code>String</code>表示文本类型。另外还提供有一些集合类型，比如<code>Array</code>，<code>Set</code>和<code>Dictionary</code>。是一种类型安全的语言。<br>​    Swift拥有和C语言类似变量和常量。还有一些高级的类型例如元组<code>tuples</code>（同PL/SQL中的类似）、不仅仅用在Class上的可选类型<code>optional types</code>(<code>Optionals say either “there is a value, and it equals x” or “there isn’t a value at all”.</code>)</p>\n<h3 id=\"常量和变量\"><a href=\"#常量和变量\" class=\"headerlink\" title=\"常量和变量\"></a>常量和变量</h3><p>​    常量和变量在使用前必须声明，使用<code>var</code>来声明变量，使用<code>let</code>来声明常量，例如</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> maximumNumberOfLoginAttempts = <span class=\"number\">10</span></div><div class=\"line\"><span class=\"keyword\">var</span> currentLoginAttempt = <span class=\"number\">0</span></div><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">0.0</span>, y = <span class=\"number\">0.0</span>, z = <span class=\"number\">0.0</span></div></pre></td></tr></table></figure>\n<p>​    可以通过<code>let(var) name: type</code>来明确常量或变量的类型，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> welcomeMessage: <span class=\"type\">String</span></div><div class=\"line\"><span class=\"keyword\">var</span> red, green, blue: <span class=\"type\">Double</span></div></pre></td></tr></table></figure>\n<p>​    变量和常量的名称可以包括绝大多数字符（包括Unicode），但不能包含空格、数学符号、箭头以及一些无效的Unicode，且不能以数字开头。变量或者常量一旦被定义，其名称不能就不能被重复使用，或者改变其类型，也不能将变量改变为常量（反之也不可以）。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> friendlyWelcome = <span class=\"string\">\"Hello!\"</span></div><div class=\"line\"><span class=\"keyword\">let</span> 你好 = <span class=\"string\">\"你好世界\"</span></div></pre></td></tr></table></figure>","more":"<p>​    通过print函数来输出查看结果：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The current value of friendlyWelcome is <span class=\"subst\">\\(friendlyWelcome)</span>\"</span>)</div></pre></td></tr></table></figure>\n<h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><p>​    和C语言类似，可以通过<code>//</code>进行单行注释；使用<code>/*</code>和<code>*/</code>进行多行注释，与C语言不同的是，多行注释在Swift中可以嵌套。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// This is a comment.</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* This is also a comment</span></div><div class=\"line\"><span class=\"comment\">but is written over multiple lines. */</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* This is the start of the first multiline comment.</span></div><div class=\"line\"><span class=\"comment\"><span class=\"comment\">/* This is the second, nested multiline comment. */</span></span></div><div class=\"line\"><span class=\"comment\">This is the end of the first multiline comment. */</span></div></pre></td></tr></table></figure>\n<h3 id=\"分号\"><a href=\"#分号\" class=\"headerlink\" title=\"分号\"></a>分号</h3><p>​    和其他大部分语言不同的是，Swift不需要你在每个代码语句后边添加分号(;)，尽管写上也没问题</p>\n<h3 id=\"整型\"><a href=\"#整型\" class=\"headerlink\" title=\"整型\"></a>整型</h3><p>​    包括无符号整型<code>signed</code>和有符号整型<code>unsigned</code>,Swift提供的整型是以8、16、32、64位格式的，例如：<code>UInt8</code>、<code>Int32</code>。<br>​    可以通过<code>min</code>和<code>max</code>两个属性值来查看边界值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> minValue = <span class=\"type\">UInt8</span>.<span class=\"built_in\">min</span>  <span class=\"comment\">// minValue is equal to 0, and is of type UInt8</span></div><div class=\"line\"><span class=\"keyword\">let</span> maxValue = <span class=\"type\">UInt8</span>.<span class=\"built_in\">max</span>  <span class=\"comment\">// maxValue is equal to 255, and is of type UInt8</span></div></pre></td></tr></table></figure>\n<p>​    默认情况下，不需要在代码中指明特定的整数，对于<code>Int</code>，在32位系统中，默认为<code>Int32</code>，64位系统中，默认为<code>Int64</code>；对于<code>UInt</code>，在32位系统中，默认为<code>UInt32</code>，64位系统中，默认为<code>UInt64</code></p>\n<h3 id=\"浮点类型\"><a href=\"#浮点类型\" class=\"headerlink\" title=\"浮点类型\"></a>浮点类型</h3><p>​    Swift中提供两种有符号的浮点类型：用’Double’表示64位浮点类型数据，’Float’表示32位浮点类型。根据所需精度进行选择。</p>\n<h3 id=\"类型安全和类型推断\"><a href=\"#类型安全和类型推断\" class=\"headerlink\" title=\"类型安全和类型推断\"></a>类型安全和类型推断</h3><p>​    Swift是一个类型安全的语言，意味着对类型区分很清晰，类型检查在编译的时候能确保在你的代码中不会出现因失误导致的类型赋值错误。当你没有明确你需要的类型时，Swfit使用类型推断帮助你选择合适的类型，这样Swift会帮你减少很大的代码量。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> meaningOfLife = <span class=\"number\">42</span><span class=\"comment\">// meaningOfLife is inferred to be of type Int</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//对于浮点类型，类型推断会将其定义为Double</span></div><div class=\"line\"><span class=\"keyword\">let</span> pi = <span class=\"number\">3.14159</span><span class=\"comment\">// pi is inferred to be of type Double</span></div></pre></td></tr></table></figure>\n<h3 id=\"数值常量\"><a href=\"#数值常量\" class=\"headerlink\" title=\"数值常量\"></a>数值常量</h3><p>​    对于整型数值常量来说：十进制没有前缀，二进制以<code>0b</code>开头，八进制以<code>0o</code>开头，十六进制以<code>0x</code>开头</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> decimalInteger = <span class=\"number\">17</span></div><div class=\"line\"><span class=\"keyword\">let</span> binaryInteger = <span class=\"number\">0b10001</span>       <span class=\"comment\">// 17 in binary notation</span></div><div class=\"line\"><span class=\"keyword\">let</span> octalInteger = <span class=\"number\">0o21</span>           <span class=\"comment\">// 17 in octal notation</span></div><div class=\"line\"><span class=\"keyword\">let</span> hexadecimalInteger = <span class=\"number\">0x11</span>     <span class=\"comment\">// 17 in hexadecimal notation</span></div></pre></td></tr></table></figure>\n<p>​    浮点数值常量可以是十进制或者十六进制。其中十进制的浮点数值常量中使用字符<code>e</code>，代表的是10的exp幂；十六进制数值常量中使用字符<code>p</code>，，代表的是2的exp幂</p>\n<blockquote>\n<ul>\n<li>1.25e2 means 1.25 x 10^2, or 125.0.</li>\n<li>1.25e-2 means 1.25 x 10^-2, or 0.0125.</li>\n<li>0xFp2 means 15 x 2^2, or 60.0.</li>\n<li>0xFp-2 means 15 x 2^-2, or 3.75.</li>\n</ul>\n</blockquote>\n<p>​    </p>\n<p>​    附小常识：数值常量可以通过添加额外的0或者下划线<code>_</code>来帮助阅读。不会影响具体值，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> oneMillion = <span class=\"number\">1_000_000</span></div><div class=\"line\"><span class=\"keyword\">let</span> justOverOneMillion = <span class=\"number\">1_000_000.000_000_1</span></div><div class=\"line\"><span class=\"keyword\">let</span> paddedDouble = <span class=\"number\">000123.456</span></div></pre></td></tr></table></figure>\n<h3 id=\"数值类型转换\"><a href=\"#数值类型转换\" class=\"headerlink\" title=\"数值类型转换\"></a>数值类型转换</h3><p>​    这部分需要注意值域问题，如果转换导致越界，会出现错误。别的没啥好说的，编译器会告诉你的。如果需要的话，转换过程举例如下（显示调用类型方法，比如Double(6) ）：</p>\n<blockquote>\n<blockquote>\n<p>Int8 -&gt; Int16 -&gt; Int -&gt; Double</p>\n</blockquote>\n</blockquote>\n<h3 id=\"类型别名\"><a href=\"#类型别名\" class=\"headerlink\" title=\"类型别名\"></a>类型别名</h3><p>​    使用关键字<code>typealias</code>起别名，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typealias</span> <span class=\"type\">AudioSample</span> = <span class=\"type\">UInt16</span><span class=\"comment\">//起别名</span></div><div class=\"line\"><span class=\"keyword\">var</span> maxAmplitudeFound = <span class=\"type\">AudioSample</span>.<span class=\"built_in\">min</span><span class=\"comment\">//使用</span></div></pre></td></tr></table></figure>\n<h3 id=\"布尔类型\"><a href=\"#布尔类型\" class=\"headerlink\" title=\"布尔类型\"></a>布尔类型</h3><p>​    Swift中的布尔类型为<code>Bool</code>，两个值<code>true</code>和<code>false</code>。布尔值在<code>if</code>语句中很常用。与其他语言不同的是，<code>if</code>语句中必须为<code>Bool</code>值，否则会出现编译错误。</p>\n<h3 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h3><p>​    将多个（不同类型的）数据组合成一个数据类型，可以使用任何你喜欢类型创建元组<code>(Int, Int, Int)</code>,或者<code>(String, Bool)</code>，没有任何限制，一个元组的创建例子如下：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> http404Error = (<span class=\"number\">404</span>, <span class=\"string\">\"Not Found\"</span>)</div><div class=\"line\"><span class=\"comment\">// http404Error is of type (Int, String), and equals (404, \"Not Found\")</span></div></pre></td></tr></table></figure>\n<p>​    可以将元组的内容分解成独立的常量或变量来单独访问；当你只需要元组中的部分值时，其它部分可以通过下划线(<code>_</code>)忽略；当然也可以通过下标的形式来访问(<code>下标从0开始</code>)。例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> (statusCode, statusMessage) = http404Error</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The status code is <span class=\"subst\">\\(statusCode)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"The status code is 404\"</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The status message is <span class=\"subst\">\\(statusMessage)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"The status message is Not Found\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> (justTheStatusCode, <span class=\"number\">_</span>) = http404Error</div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The status code is <span class=\"subst\">\\(justTheStatusCode)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"The status code is 404\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The status code is <span class=\"subst\">\\(http404Error.<span class=\"number\">0</span>)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"The status code is 404\"</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The status message is <span class=\"subst\">\\(http404Error.<span class=\"number\">1</span>)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"The status message is Not Found\"</span></div></pre></td></tr></table></figure>\n<p>​    定义元组的时候可以给单独的元素起名字，然后可以通过元素名字来访问具体的值，例如：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> http200Status = (statusCode: <span class=\"number\">200</span>, description: <span class=\"string\">\"OK\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The status code is <span class=\"subst\">\\(http200Status.statusCode)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"The status code is 200\"</span></div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"The status message is <span class=\"subst\">\\(http200Status.description)</span>\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"The status message is OK\"</span></div></pre></td></tr></table></figure>\n<blockquote>\n<blockquote>\n<p>当函数有多个返回值时，元组显得非常适用；但元组不适合于复杂的数据结构创建。</p>\n</blockquote>\n</blockquote>\n<h3 id=\"可选类型\"><a href=\"#可选类型\" class=\"headerlink\" title=\"可选类型\"></a>可选类型</h3><p>​    当一个值可能不存在时，使用可选类型(<code>optionals</code>)，可选表示两种可能：要么存在一个值，你可以解包并访问其值；要么不存在。</p>\n<blockquote>\n<blockquote>\n<p>​    注：可选的概念在C或者Objective-C中是不存在的，ObjC中一个相似点是一个方法要么返回一个对象，要么返回nil，但是在ObjC中仅适用于对象，不适用于结构体、基本C类型或者枚举类型。但是Swift中的可选适用于所有类型。</p>\n</blockquote>\n</blockquote>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> possibleNumber = <span class=\"string\">\"123\"</span></div><div class=\"line\"><span class=\"keyword\">let</span> convertedNumber = <span class=\"type\">Int</span>(possibleNumber)</div><div class=\"line\"><span class=\"comment\">// convertedNumber is inferred to be of type \"Int?\", or \"optional Int\"</span></div></pre></td></tr></table></figure>\n<h4 id=\"nil\"><a href=\"#nil\" class=\"headerlink\" title=\"nil\"></a>nil</h4><p>​    可以将nil赋值给一个可选类型变量。对于可选类型变量，如果声明的时候没有提供初始值，则默认被设置为nil。</p>\n<blockquote>\n<blockquote>\n<p>​    注：nil不能被可选类型以外的变量或者常量适用，如果代码中一个变量需要处理不存在的情况，通常将其定义为可选类型。Swift中的nil和ObjC中的nil不同：ObjC中的nil是一个指向不存在的对象的指针；Swift中的nil不是指针，它是一个特定类型不存在的值，适用于所有Swift类型</p>\n</blockquote>\n</blockquote>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> serverResponseCode: <span class=\"type\">Int</span>? = <span class=\"number\">404</span></div><div class=\"line\"><span class=\"comment\">// serverResponseCode contains an actual Int value of 404</span></div><div class=\"line\">serverResponseCode = <span class=\"literal\">nil</span></div><div class=\"line\"><span class=\"comment\">// serverResponseCode now contains no value</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> surveyAnswer: <span class=\"type\">String</span>?</div><div class=\"line\"><span class=\"comment\">// surveyAnswer is automatically set to nil</span></div></pre></td></tr></table></figure>\n<h4 id=\"if语句和强制解包\"><a href=\"#if语句和强制解包\" class=\"headerlink\" title=\"if语句和强制解包\"></a>if语句和强制解包</h4><p>​    可以通过使用If语句来确定一个可选类型是一个值或者是nil(使用操作符<code>==</code>或<code>!=</code>)。如果一个可选类型存在一个值，就可以通过在参数名后边添加<code>!</code>来强制解包该可选类型值。</p>\n<blockquote>\n<blockquote>\n<p>注：[重要] 使用<code>!</code>的时候一定要确保可选类型的值是存在的，否则会出现运行时错误，导致程序闪退。</p>\n</blockquote>\n</blockquote>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> convertedNumber != <span class=\"literal\">nil</span> &#123;</div><div class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"convertedNumber has an integer value of <span class=\"subst\">\\(convertedNumber!)</span>.\"</span>)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"可选绑定\"><a href=\"#可选绑定\" class=\"headerlink\" title=\"可选绑定\"></a>可选绑定</h4><p>​    在if和while语句中，可以通过使用可选绑定来检查可选值。if语句中使用可选绑定格式如下</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> constantName = someOptional &#123;<span class=\"comment\">//if var constantName</span></div><div class=\"line\">    non-<span class=\"literal\">nil</span>-statements</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"literal\">nil</span>-statement</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"可选类型的隐式解包\"><a href=\"#可选类型的隐式解包\" class=\"headerlink\" title=\"可选类型的隐式解包\"></a>可选类型的隐式解包</h4><p>​    通常情况下，对于一个可选类型，如果在设置初始值后能够<code>确定包含一个值</code>，就没有必要每次通过可选绑定来进行检查、解包。这时可以通过在可选类型名后边添加<code>!</code>来隐式解包</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> possibleString: <span class=\"type\">String</span>? = <span class=\"string\">\"An optional string.\"</span></div><div class=\"line\"><span class=\"keyword\">let</span> forcedString: <span class=\"type\">String</span> = possibleString! <span class=\"comment\">// requires an exclamation mark</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">let</span> assumedString: <span class=\"type\">String</span>! = <span class=\"string\">\"An implicitly unwrapped optional string.\"</span></div><div class=\"line\"><span class=\"keyword\">let</span> implicitString: <span class=\"type\">String</span> = assumedString <span class=\"comment\">// no need for an exclamation mark</span></div></pre></td></tr></table></figure>\n<h3 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h3><p>在程序执行过程中，可以通过错误处理来响应程序运行期间遇到的错误。当一个函数遇到错误的时候，可以抛出，函数调用者捕捉该错误并做相应的相应处理。函数通过关键字<code>throws</code>来表明会抛出错误。当调用该类型的函数时，使用<code>try</code>关键字</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">canThrowAnError</span><span class=\"params\">()</span></span> <span class=\"keyword\">throws</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// this function may or may not throw an error</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">do</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">try</span> canThrowAnError()</div><div class=\"line\">    <span class=\"comment\">// no error was thrown</span></div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> &#123;<span class=\"comment\">//默认error，当然你也可以使用多个catch，并明确具体的错误类型 比如：catch SandwichError.outOfCleanDishes</span></div><div class=\"line\">    <span class=\"comment\">// an error was thrown</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"断言\"><a href=\"#断言\" class=\"headerlink\" title=\"断言\"></a>断言</h3><p>​    在一些特定的情况下，代码没有必要继续执行。这时候可以通过触发断言来终止代码的执行，并告知原因。</p>\n<p>​    通常情况下，断言的使用时机：</p>\n<blockquote>\n<ul>\n<li><p>在Debug的时候使用；</p>\n</li>\n<li><p>使用下标访问数据时；</p>\n</li>\n<li><p>函数入口参数检查时；</p>\n</li>\n<li><p>可选类型要求非nil时；</p>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><p><code>https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html</code></p>\n<p>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;</p>\n<blockquote>\n<p>​Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>"},{"layout":"post","title":"Swift Type Casting","date":"2016-11-30T15:20:11.000Z","author":"liangtong","catalog":true,"_content":"\n\n\n​\t类型转换 可以判断实例的类型，也可以将实例看做是其父类或者子类的实例。\n​类型转换在 Swift 中使用 is 和 as 操作符实现。这两个操作符提供了一种简单达意的方式去检查值的类型或者转换它的类型。也可以用它来检查一个类型是否实现了某个协议\n\n\n\n<!-- more -->\n\n### 定义一个类层次作为例子\n你可以将类型转换用在类和子类的层次结构上，检查特定类实例的类型并且转换这个类实例的类型成为这个层次结构中的其他类型。下面的三个代码段定义了一个类层次和一个包含了这些类实例的数组，作为类型转换的例子。\n第一个代码片段定义了一个新的基类 MediaItem。这个类为任何出现在数字媒体库的媒体项提供基础功能。特别的，它声明了一个 String 类型的 name 属性，和一个 init(name:) 初始化器。（假定所有的媒体项都有个名称。）\n\n```Swift\nclass MediaItem {\n    var name: String\n    init(name: String) {\n        self.name = name\n    }\n}\n```\n\n下一个代码段定义了 MediaItem 的两个子类。第一个子类 Movie 封装了与电影相关的额外信息，在父类（或者说基类）的基础上增加了一个 director（导演）属性，和相应的初始化器。第二个子类 Song，在父类的基础上增加了一个 artist（艺术家）属性，和相应的初始化器：\n\n```Swift\nclass Movie: MediaItem {\n    var director: String\n    init(name: String, director: String) {\n        self.director = director\n        super.init(name: name)\n    }\n}\n \nclass Song: MediaItem {\n    var artist: String\n    init(name: String, artist: String) {\n        self.artist = artist\n        super.init(name: name)\n    }\n}\n```\n\n最后一个代码段创建了一个数组常量 library，包含两个 Movie 实例和三个 Song 实例。library 的类型是在它被初始化时根据它数组中所包含的内容推断来的。Swift 的类型检测器能够推断出 Movie 和 Song 有共同的父类 MediaItem，所以它推断出 [MediaItem] 类作为 library 的类型：\n\n```Swift\nlet library = [\n    Movie(name: \"Casablanca\", director: \"Michael Curtiz\"),\n    Song(name: \"Blue Suede Shoes\", artist: \"Elvis Presley\"),\n    Movie(name: \"Citizen Kane\", director: \"Orson Welles\"),\n    Song(name: \"The One And Only\", artist: \"Chesney Hawkes\"),\n    Song(name: \"Never Gonna Give You Up\", artist: \"Rick Astley\")\n]\n// the type of \"library\" is inferred to be [MediaItem]\n```\n\n在幕后 library 里存储的媒体项依然是 Movie 和 Song 类型的。但是，若你迭代它，依次取出的实例会是 MediaItem 类型的，而不是 Movie 和 Song 类型。为了让它们作为原本的类型工作，你需要检查它们的类型或者向下转换它们到其它类型，就像下面描述的一样。\n\n### 检查类型\n用类型检查操作符（ `is` ）来检查一个实例是否属于特定子类型。若实例属于那个子类型，类型检查操作符返回 `true` ，否则返回 `false` 。\n\n下面的例子定义了两个变量，movieCount 和 songCount，用来计算数组 library 中 Movie 和 Song 类型的实例数量：\n\n```Swift\nvar movieCount = 0\nvar songCount = 0\n \nfor item in library {\n    if item is Movie {\n        movieCount += 1\n    } else if item is Song {\n        songCount += 1\n    }\n}\n \nprint(\"Media library contains \\(movieCount) movies and \\(songCount) songs\")\n// Prints \"Media library contains 2 movies and 3 songs\"\n```\n\n若当前 MediaItem 是一个 Movie 类型的实例，item is Movie 返回 true，否则返回 false。同样的，item is Song 检查 item 是否为 Song 类型的实例。在循环结束后，movieCount 和 songCount 的值就是被找到的属于各自类型的实例的数量。\n\n### 向下转型\n某类型的一个常量或变量可能在幕后实际上属于一个子类。当确定是这种情况时，你可以尝试向下转到它的子类型，用类型转换操作符（as? 或 as!）。\n因为向下转型可能会失败，类型转型操作符带有两种不同形式。条件形式as? 返回一个你试图向下转成的类型的可选值。强制形式 as! 把试图向下转型和强制解包转换结果结合为一个操作。\n\n当你不确定向下转型可以成功时，用类型转换的条件形式（as?）。条件形式的类型转换总是返回一个可选值，并且若下转是不可能的，可选值将是 nil。这使你能够检查向下转型是否成功。\n只有你可以确定向下转型一定会成功时，才使用强制形式（as!）。当你试图向下转型为一个不正确的类型时，强制形式的类型转换会触发一个运行时错误。\n\n下面的例子，迭代了 library 里的每一个 MediaItem，并打印出适当的描述。要这样做，item 需要真正作为 Movie 或 Song 的类型来使用，而不仅仅是作为 MediaItem。为了能够在描述中使用 Movie 或 Song 的 director 或 artist 属性，这是必要的。\n在这个示例中，数组中的每一个 item 可能是 Movie 或 Song。事前你不知道每个 item 的真实类型，所以这里使用条件形式的类型转换（as?）去检查循环里的每次下转：\n\n```Swift\nfor item in library {\n    if let movie = item as? Movie {\n        print(\"Movie: \\(movie.name), dir. \\(movie.director)\")\n    } else if let song = item as? Song {\n        print(\"Song: \\(song.name), by \\(song.artist)\")\n    }\n}\n \n// Movie: Casablanca, dir. Michael Curtiz\n// Song: Blue Suede Shoes, by Elvis Presley\n// Movie: Citizen Kane, dir. Orson Welles\n// Song: The One And Only, by Chesney Hawkes\n// Song: Never Gonna Give You Up, by Rick Astley\n```\n\n示例首先试图将 item 下转为 Movie。因为 item 是一个 MediaItem 类型的实例，它可能是一个 Movie；同样，它也可能是一个 Song，或者仅仅是基类 MediaItem。因为不确定，as? 形式在试图下转时将返回一个可选值。item as? Movie 的返回值是 Movie? 或者说“可选 Movie”。\n\n当向下转型为 Movie 应用在两个 Song 实例时将会失败。为了处理这种情况，上面的例子使用了可选绑定（optional binding）来检查可选 Movie 真的包含一个值（这个是为了判断下转是否成功。）可选绑定是这样写的“if let movie = item as? Movie”，可以这样解读：\n\n“尝试将 item 转为 Movie 类型。若成功，设置一个新的临时常量 movie 来存储返回的可选 Movie 中的值”\n\n若向下转型成功，然后 movie 的属性将用于打印一个 Movie 实例的描述，包括它的导演的名字 director。相似的原理被用来检测 Song 实例，当 Song 被找到时则打印它的描述（包含 artist 的名字）。\n\t转换没有真的改变实例或它的值。根本的实例保持不变；只是简单地把它作为它被转换成的类型来使用。\n\n### Any 和 AnyObject 的类型转换\nSwift 为不确定类型提供了两种特殊的类型别名：\n\n * 可以表示任何类型，包括函数类型。\n * 可以表示任何类类型的实例。\n\n只有当你确实需要它们的行为和功能时才使用 Any 和 AnyObject。代码中最好使用明确的类型。\n\n这里有个示例，使用 Any 类型来和混合的不同类型一起工作，包括函数类型和非类类型。它创建了一个可以存储 Any 类型的数组 things：\n\n```Swift\nvar things = [Any]()\n \nthings.append(0)\nthings.append(0.0)\nthings.append(42)\nthings.append(3.14159)\nthings.append(\"hello\")\nthings.append((3.0, 5.0))\nthings.append(Movie(name: \"Ghostbusters\", director: \"Ivan Reitman\"))\nthings.append({ (name: String) -> String in \"Hello, \\(name)\" })\n```\n\nthings 数组包含两个 Int 值，两个 Double 值，一个 String 值，一个元组 (Double, Double)，一个Movie实例“Ghostbusters”，以及一个接受 String 值并返回另一个 String 值的闭包表达式。\n你可以在 switch 表达式的 case 中使用 is 和 as 操作符来找出只知道是 Any 或 AnyObject 类型的常量或变量的具体类型。下面的示例迭代 things 数组中的每一项，并用 switch 语句查找每一项的类型。有几个 switch 语句的 case 绑定它们匹配到的值到一个指定类型的常量，从而可以打印这些值：\n\n```Swift\nfor thing in things {\n    switch thing {\n    case 0 as Int:\n        print(\"zero as an Int\")\n    case 0 as Double:\n        print(\"zero as a Double\")\n    case let someInt as Int:\n        print(\"an integer value of \\(someInt)\")\n    case let someDouble as Double where someDouble > 0:\n        print(\"a positive double value of \\(someDouble)\")\n    case is Double:\n        print(\"some other double value that I don't want to print\")\n    case let someString as String:\n        print(\"a string value of \\\"\\(someString)\\\"\")\n    case let (x, y) as (Double, Double):\n        print(\"an (x, y) point at \\(x), \\(y)\")\n    case let movie as Movie:\n        print(\"a movie called \\(movie.name), dir. \\(movie.director)\")\n    case let stringConverter as (String) -> String:\n        print(stringConverter(\"Michael\"))\n    default:\n        print(\"something else\")\n    }\n}\n \n// zero as an Int\n// zero as a Double\n// an integer value of 42\n// a positive double value of 3.14159\n// a string value of \"hello\"\n// an (x, y) point at 3.0, 5.0\n// a movie called Ghostbusters, dir. Ivan Reitman\n// Hello, Michael\n```\n\n\tAny类型可以表示所有类型的值，包括可选类型。Swift 会在你用Any类型来表示一个可选值的时候，给你一个警告。如果你确实想使用Any类型来承载可选值，你可以使用as操作符显示转换为Any，如下所示：\n\n\n```Swift\nlet optionalNumber: Int? = 3\nthings.append(optionalNumber)        // Warning\nthings.append(optionalNumber as Any) // No warning\n```\n\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TypeCasting.html/\"> Type Casting </a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","source":"_posts/iOS_Swift_language_note_Type-Casting.md","raw":"---\nlayout:     post\ntitle:      Swift Type Casting\ndate:       2016-11-30 23:20:11\nauthor:     liangtong\ncatalog: true\ncategories: iOS\ntags: Swift \n\n---\n\n\n\n​\t类型转换 可以判断实例的类型，也可以将实例看做是其父类或者子类的实例。\n​类型转换在 Swift 中使用 is 和 as 操作符实现。这两个操作符提供了一种简单达意的方式去检查值的类型或者转换它的类型。也可以用它来检查一个类型是否实现了某个协议\n\n\n\n<!-- more -->\n\n### 定义一个类层次作为例子\n你可以将类型转换用在类和子类的层次结构上，检查特定类实例的类型并且转换这个类实例的类型成为这个层次结构中的其他类型。下面的三个代码段定义了一个类层次和一个包含了这些类实例的数组，作为类型转换的例子。\n第一个代码片段定义了一个新的基类 MediaItem。这个类为任何出现在数字媒体库的媒体项提供基础功能。特别的，它声明了一个 String 类型的 name 属性，和一个 init(name:) 初始化器。（假定所有的媒体项都有个名称。）\n\n```Swift\nclass MediaItem {\n    var name: String\n    init(name: String) {\n        self.name = name\n    }\n}\n```\n\n下一个代码段定义了 MediaItem 的两个子类。第一个子类 Movie 封装了与电影相关的额外信息，在父类（或者说基类）的基础上增加了一个 director（导演）属性，和相应的初始化器。第二个子类 Song，在父类的基础上增加了一个 artist（艺术家）属性，和相应的初始化器：\n\n```Swift\nclass Movie: MediaItem {\n    var director: String\n    init(name: String, director: String) {\n        self.director = director\n        super.init(name: name)\n    }\n}\n \nclass Song: MediaItem {\n    var artist: String\n    init(name: String, artist: String) {\n        self.artist = artist\n        super.init(name: name)\n    }\n}\n```\n\n最后一个代码段创建了一个数组常量 library，包含两个 Movie 实例和三个 Song 实例。library 的类型是在它被初始化时根据它数组中所包含的内容推断来的。Swift 的类型检测器能够推断出 Movie 和 Song 有共同的父类 MediaItem，所以它推断出 [MediaItem] 类作为 library 的类型：\n\n```Swift\nlet library = [\n    Movie(name: \"Casablanca\", director: \"Michael Curtiz\"),\n    Song(name: \"Blue Suede Shoes\", artist: \"Elvis Presley\"),\n    Movie(name: \"Citizen Kane\", director: \"Orson Welles\"),\n    Song(name: \"The One And Only\", artist: \"Chesney Hawkes\"),\n    Song(name: \"Never Gonna Give You Up\", artist: \"Rick Astley\")\n]\n// the type of \"library\" is inferred to be [MediaItem]\n```\n\n在幕后 library 里存储的媒体项依然是 Movie 和 Song 类型的。但是，若你迭代它，依次取出的实例会是 MediaItem 类型的，而不是 Movie 和 Song 类型。为了让它们作为原本的类型工作，你需要检查它们的类型或者向下转换它们到其它类型，就像下面描述的一样。\n\n### 检查类型\n用类型检查操作符（ `is` ）来检查一个实例是否属于特定子类型。若实例属于那个子类型，类型检查操作符返回 `true` ，否则返回 `false` 。\n\n下面的例子定义了两个变量，movieCount 和 songCount，用来计算数组 library 中 Movie 和 Song 类型的实例数量：\n\n```Swift\nvar movieCount = 0\nvar songCount = 0\n \nfor item in library {\n    if item is Movie {\n        movieCount += 1\n    } else if item is Song {\n        songCount += 1\n    }\n}\n \nprint(\"Media library contains \\(movieCount) movies and \\(songCount) songs\")\n// Prints \"Media library contains 2 movies and 3 songs\"\n```\n\n若当前 MediaItem 是一个 Movie 类型的实例，item is Movie 返回 true，否则返回 false。同样的，item is Song 检查 item 是否为 Song 类型的实例。在循环结束后，movieCount 和 songCount 的值就是被找到的属于各自类型的实例的数量。\n\n### 向下转型\n某类型的一个常量或变量可能在幕后实际上属于一个子类。当确定是这种情况时，你可以尝试向下转到它的子类型，用类型转换操作符（as? 或 as!）。\n因为向下转型可能会失败，类型转型操作符带有两种不同形式。条件形式as? 返回一个你试图向下转成的类型的可选值。强制形式 as! 把试图向下转型和强制解包转换结果结合为一个操作。\n\n当你不确定向下转型可以成功时，用类型转换的条件形式（as?）。条件形式的类型转换总是返回一个可选值，并且若下转是不可能的，可选值将是 nil。这使你能够检查向下转型是否成功。\n只有你可以确定向下转型一定会成功时，才使用强制形式（as!）。当你试图向下转型为一个不正确的类型时，强制形式的类型转换会触发一个运行时错误。\n\n下面的例子，迭代了 library 里的每一个 MediaItem，并打印出适当的描述。要这样做，item 需要真正作为 Movie 或 Song 的类型来使用，而不仅仅是作为 MediaItem。为了能够在描述中使用 Movie 或 Song 的 director 或 artist 属性，这是必要的。\n在这个示例中，数组中的每一个 item 可能是 Movie 或 Song。事前你不知道每个 item 的真实类型，所以这里使用条件形式的类型转换（as?）去检查循环里的每次下转：\n\n```Swift\nfor item in library {\n    if let movie = item as? Movie {\n        print(\"Movie: \\(movie.name), dir. \\(movie.director)\")\n    } else if let song = item as? Song {\n        print(\"Song: \\(song.name), by \\(song.artist)\")\n    }\n}\n \n// Movie: Casablanca, dir. Michael Curtiz\n// Song: Blue Suede Shoes, by Elvis Presley\n// Movie: Citizen Kane, dir. Orson Welles\n// Song: The One And Only, by Chesney Hawkes\n// Song: Never Gonna Give You Up, by Rick Astley\n```\n\n示例首先试图将 item 下转为 Movie。因为 item 是一个 MediaItem 类型的实例，它可能是一个 Movie；同样，它也可能是一个 Song，或者仅仅是基类 MediaItem。因为不确定，as? 形式在试图下转时将返回一个可选值。item as? Movie 的返回值是 Movie? 或者说“可选 Movie”。\n\n当向下转型为 Movie 应用在两个 Song 实例时将会失败。为了处理这种情况，上面的例子使用了可选绑定（optional binding）来检查可选 Movie 真的包含一个值（这个是为了判断下转是否成功。）可选绑定是这样写的“if let movie = item as? Movie”，可以这样解读：\n\n“尝试将 item 转为 Movie 类型。若成功，设置一个新的临时常量 movie 来存储返回的可选 Movie 中的值”\n\n若向下转型成功，然后 movie 的属性将用于打印一个 Movie 实例的描述，包括它的导演的名字 director。相似的原理被用来检测 Song 实例，当 Song 被找到时则打印它的描述（包含 artist 的名字）。\n\t转换没有真的改变实例或它的值。根本的实例保持不变；只是简单地把它作为它被转换成的类型来使用。\n\n### Any 和 AnyObject 的类型转换\nSwift 为不确定类型提供了两种特殊的类型别名：\n\n * 可以表示任何类型，包括函数类型。\n * 可以表示任何类类型的实例。\n\n只有当你确实需要它们的行为和功能时才使用 Any 和 AnyObject。代码中最好使用明确的类型。\n\n这里有个示例，使用 Any 类型来和混合的不同类型一起工作，包括函数类型和非类类型。它创建了一个可以存储 Any 类型的数组 things：\n\n```Swift\nvar things = [Any]()\n \nthings.append(0)\nthings.append(0.0)\nthings.append(42)\nthings.append(3.14159)\nthings.append(\"hello\")\nthings.append((3.0, 5.0))\nthings.append(Movie(name: \"Ghostbusters\", director: \"Ivan Reitman\"))\nthings.append({ (name: String) -> String in \"Hello, \\(name)\" })\n```\n\nthings 数组包含两个 Int 值，两个 Double 值，一个 String 值，一个元组 (Double, Double)，一个Movie实例“Ghostbusters”，以及一个接受 String 值并返回另一个 String 值的闭包表达式。\n你可以在 switch 表达式的 case 中使用 is 和 as 操作符来找出只知道是 Any 或 AnyObject 类型的常量或变量的具体类型。下面的示例迭代 things 数组中的每一项，并用 switch 语句查找每一项的类型。有几个 switch 语句的 case 绑定它们匹配到的值到一个指定类型的常量，从而可以打印这些值：\n\n```Swift\nfor thing in things {\n    switch thing {\n    case 0 as Int:\n        print(\"zero as an Int\")\n    case 0 as Double:\n        print(\"zero as a Double\")\n    case let someInt as Int:\n        print(\"an integer value of \\(someInt)\")\n    case let someDouble as Double where someDouble > 0:\n        print(\"a positive double value of \\(someDouble)\")\n    case is Double:\n        print(\"some other double value that I don't want to print\")\n    case let someString as String:\n        print(\"a string value of \\\"\\(someString)\\\"\")\n    case let (x, y) as (Double, Double):\n        print(\"an (x, y) point at \\(x), \\(y)\")\n    case let movie as Movie:\n        print(\"a movie called \\(movie.name), dir. \\(movie.director)\")\n    case let stringConverter as (String) -> String:\n        print(stringConverter(\"Michael\"))\n    default:\n        print(\"something else\")\n    }\n}\n \n// zero as an Int\n// zero as a Double\n// an integer value of 42\n// a positive double value of 3.14159\n// a string value of \"hello\"\n// an (x, y) point at 3.0, 5.0\n// a movie called Ghostbusters, dir. Ivan Reitman\n// Hello, Michael\n```\n\n\tAny类型可以表示所有类型的值，包括可选类型。Swift 会在你用Any类型来表示一个可选值的时候，给你一个警告。如果你确实想使用Any类型来承载可选值，你可以使用as操作符显示转换为Any，如下所示：\n\n\n```Swift\nlet optionalNumber: Int? = 3\nthings.append(optionalNumber)        // Warning\nthings.append(optionalNumber as Any) // No warning\n```\n\n\n\n### 参照文档\n\n>* <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TypeCasting.html/\"> Type Casting </a> \n\n\n>\n>\n>Copyright (c) liangtong. All rights reserved.\n>\n\n\n","slug":"iOS_Swift_language_note_Type-Casting","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4uw0049oko8uyamqwe4","content":"<p>​    类型转换 可以判断实例的类型，也可以将实例看做是其父类或者子类的实例。<br>​类型转换在 Swift 中使用 is 和 as 操作符实现。这两个操作符提供了一种简单达意的方式去检查值的类型或者转换它的类型。也可以用它来检查一个类型是否实现了某个协议</p>\n<a id=\"more\"></a>\n<h3 id=\"定义一个类层次作为例子\"><a href=\"#定义一个类层次作为例子\" class=\"headerlink\" title=\"定义一个类层次作为例子\"></a>定义一个类层次作为例子</h3><p>你可以将类型转换用在类和子类的层次结构上，检查特定类实例的类型并且转换这个类实例的类型成为这个层次结构中的其他类型。下面的三个代码段定义了一个类层次和一个包含了这些类实例的数组，作为类型转换的例子。<br>第一个代码片段定义了一个新的基类 MediaItem。这个类为任何出现在数字媒体库的媒体项提供基础功能。特别的，它声明了一个 String 类型的 name 属性，和一个 init(name:) 初始化器。（假定所有的媒体项都有个名称。）</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MediaItem</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.name = name</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下一个代码段定义了 MediaItem 的两个子类。第一个子类 Movie 封装了与电影相关的额外信息，在父类（或者说基类）的基础上增加了一个 director（导演）属性，和相应的初始化器。第二个子类 Song，在父类的基础上增加了一个 artist（艺术家）属性，和相应的初始化器：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Movie</span>: <span class=\"title\">MediaItem</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> director: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>, director: <span class=\"type\">String</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.director = director</div><div class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(name: name)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Song</span>: <span class=\"title\">MediaItem</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> artist: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>, artist: <span class=\"type\">String</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.artist = artist</div><div class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(name: name)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后一个代码段创建了一个数组常量 library，包含两个 Movie 实例和三个 Song 实例。library 的类型是在它被初始化时根据它数组中所包含的内容推断来的。Swift 的类型检测器能够推断出 Movie 和 Song 有共同的父类 MediaItem，所以它推断出 [MediaItem] 类作为 library 的类型：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> library = [</div><div class=\"line\">    <span class=\"type\">Movie</span>(name: <span class=\"string\">\"Casablanca\"</span>, director: <span class=\"string\">\"Michael Curtiz\"</span>),</div><div class=\"line\">    <span class=\"type\">Song</span>(name: <span class=\"string\">\"Blue Suede Shoes\"</span>, artist: <span class=\"string\">\"Elvis Presley\"</span>),</div><div class=\"line\">    <span class=\"type\">Movie</span>(name: <span class=\"string\">\"Citizen Kane\"</span>, director: <span class=\"string\">\"Orson Welles\"</span>),</div><div class=\"line\">    <span class=\"type\">Song</span>(name: <span class=\"string\">\"The One And Only\"</span>, artist: <span class=\"string\">\"Chesney Hawkes\"</span>),</div><div class=\"line\">    <span class=\"type\">Song</span>(name: <span class=\"string\">\"Never Gonna Give You Up\"</span>, artist: <span class=\"string\">\"Rick Astley\"</span>)</div><div class=\"line\">]</div><div class=\"line\"><span class=\"comment\">// the type of \"library\" is inferred to be [MediaItem]</span></div></pre></td></tr></table></figure>\n<p>在幕后 library 里存储的媒体项依然是 Movie 和 Song 类型的。但是，若你迭代它，依次取出的实例会是 MediaItem 类型的，而不是 Movie 和 Song 类型。为了让它们作为原本的类型工作，你需要检查它们的类型或者向下转换它们到其它类型，就像下面描述的一样。</p>\n<h3 id=\"检查类型\"><a href=\"#检查类型\" class=\"headerlink\" title=\"检查类型\"></a>检查类型</h3><p>用类型检查操作符（ <code>is</code> ）来检查一个实例是否属于特定子类型。若实例属于那个子类型，类型检查操作符返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n<p>下面的例子定义了两个变量，movieCount 和 songCount，用来计算数组 library 中 Movie 和 Song 类型的实例数量：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> movieCount = <span class=\"number\">0</span></div><div class=\"line\"><span class=\"keyword\">var</span> songCount = <span class=\"number\">0</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> library &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> item <span class=\"keyword\">is</span> <span class=\"type\">Movie</span> &#123;</div><div class=\"line\">        movieCount += <span class=\"number\">1</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> item <span class=\"keyword\">is</span> <span class=\"type\">Song</span> &#123;</div><div class=\"line\">        songCount += <span class=\"number\">1</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Media library contains <span class=\"subst\">\\(movieCount)</span> movies and <span class=\"subst\">\\(songCount)</span> songs\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"Media library contains 2 movies and 3 songs\"</span></div></pre></td></tr></table></figure>\n<p>若当前 MediaItem 是一个 Movie 类型的实例，item is Movie 返回 true，否则返回 false。同样的，item is Song 检查 item 是否为 Song 类型的实例。在循环结束后，movieCount 和 songCount 的值就是被找到的属于各自类型的实例的数量。</p>\n<h3 id=\"向下转型\"><a href=\"#向下转型\" class=\"headerlink\" title=\"向下转型\"></a>向下转型</h3><p>某类型的一个常量或变量可能在幕后实际上属于一个子类。当确定是这种情况时，你可以尝试向下转到它的子类型，用类型转换操作符（as? 或 as!）。<br>因为向下转型可能会失败，类型转型操作符带有两种不同形式。条件形式as? 返回一个你试图向下转成的类型的可选值。强制形式 as! 把试图向下转型和强制解包转换结果结合为一个操作。</p>\n<p>当你不确定向下转型可以成功时，用类型转换的条件形式（as?）。条件形式的类型转换总是返回一个可选值，并且若下转是不可能的，可选值将是 nil。这使你能够检查向下转型是否成功。<br>只有你可以确定向下转型一定会成功时，才使用强制形式（as!）。当你试图向下转型为一个不正确的类型时，强制形式的类型转换会触发一个运行时错误。</p>\n<p>下面的例子，迭代了 library 里的每一个 MediaItem，并打印出适当的描述。要这样做，item 需要真正作为 Movie 或 Song 的类型来使用，而不仅仅是作为 MediaItem。为了能够在描述中使用 Movie 或 Song 的 director 或 artist 属性，这是必要的。<br>在这个示例中，数组中的每一个 item 可能是 Movie 或 Song。事前你不知道每个 item 的真实类型，所以这里使用条件形式的类型转换（as?）去检查循环里的每次下转：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> library &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> movie = item <span class=\"keyword\">as</span>? <span class=\"type\">Movie</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Movie: <span class=\"subst\">\\(movie.name)</span>, dir. <span class=\"subst\">\\(movie.director)</span>\"</span>)</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> song = item <span class=\"keyword\">as</span>? <span class=\"type\">Song</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Song: <span class=\"subst\">\\(song.name)</span>, by <span class=\"subst\">\\(song.artist)</span>\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// Movie: Casablanca, dir. Michael Curtiz</span></div><div class=\"line\"><span class=\"comment\">// Song: Blue Suede Shoes, by Elvis Presley</span></div><div class=\"line\"><span class=\"comment\">// Movie: Citizen Kane, dir. Orson Welles</span></div><div class=\"line\"><span class=\"comment\">// Song: The One And Only, by Chesney Hawkes</span></div><div class=\"line\"><span class=\"comment\">// Song: Never Gonna Give You Up, by Rick Astley</span></div></pre></td></tr></table></figure>\n<p>示例首先试图将 item 下转为 Movie。因为 item 是一个 MediaItem 类型的实例，它可能是一个 Movie；同样，它也可能是一个 Song，或者仅仅是基类 MediaItem。因为不确定，as? 形式在试图下转时将返回一个可选值。item as? Movie 的返回值是 Movie? 或者说“可选 Movie”。</p>\n<p>当向下转型为 Movie 应用在两个 Song 实例时将会失败。为了处理这种情况，上面的例子使用了可选绑定（optional binding）来检查可选 Movie 真的包含一个值（这个是为了判断下转是否成功。）可选绑定是这样写的“if let movie = item as? Movie”，可以这样解读：</p>\n<p>“尝试将 item 转为 Movie 类型。若成功，设置一个新的临时常量 movie 来存储返回的可选 Movie 中的值”</p>\n<p>若向下转型成功，然后 movie 的属性将用于打印一个 Movie 实例的描述，包括它的导演的名字 director。相似的原理被用来检测 Song 实例，当 Song 被找到时则打印它的描述（包含 artist 的名字）。<br>    转换没有真的改变实例或它的值。根本的实例保持不变；只是简单地把它作为它被转换成的类型来使用。</p>\n<h3 id=\"Any-和-AnyObject-的类型转换\"><a href=\"#Any-和-AnyObject-的类型转换\" class=\"headerlink\" title=\"Any 和 AnyObject 的类型转换\"></a>Any 和 AnyObject 的类型转换</h3><p>Swift 为不确定类型提供了两种特殊的类型别名：</p>\n<ul>\n<li>可以表示任何类型，包括函数类型。</li>\n<li>可以表示任何类类型的实例。</li>\n</ul>\n<p>只有当你确实需要它们的行为和功能时才使用 Any 和 AnyObject。代码中最好使用明确的类型。</p>\n<p>这里有个示例，使用 Any 类型来和混合的不同类型一起工作，包括函数类型和非类类型。它创建了一个可以存储 Any 类型的数组 things：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> things = [<span class=\"type\">Any</span>]()</div><div class=\"line\"> </div><div class=\"line\">things.append(<span class=\"number\">0</span>)</div><div class=\"line\">things.append(<span class=\"number\">0.0</span>)</div><div class=\"line\">things.append(<span class=\"number\">42</span>)</div><div class=\"line\">things.append(<span class=\"number\">3.14159</span>)</div><div class=\"line\">things.append(<span class=\"string\">\"hello\"</span>)</div><div class=\"line\">things.append((<span class=\"number\">3.0</span>, <span class=\"number\">5.0</span>))</div><div class=\"line\">things.append(<span class=\"type\">Movie</span>(name: <span class=\"string\">\"Ghostbusters\"</span>, director: <span class=\"string\">\"Ivan Reitman\"</span>))</div><div class=\"line\">things.append(&#123; (name: <span class=\"type\">String</span>) -&gt; <span class=\"type\">String</span> <span class=\"keyword\">in</span> <span class=\"string\">\"Hello, <span class=\"subst\">\\(name)</span>\"</span> &#125;)</div></pre></td></tr></table></figure>\n<p>things 数组包含两个 Int 值，两个 Double 值，一个 String 值，一个元组 (Double, Double)，一个Movie实例“Ghostbusters”，以及一个接受 String 值并返回另一个 String 值的闭包表达式。<br>你可以在 switch 表达式的 case 中使用 is 和 as 操作符来找出只知道是 Any 或 AnyObject 类型的常量或变量的具体类型。下面的示例迭代 things 数组中的每一项，并用 switch 语句查找每一项的类型。有几个 switch 语句的 case 绑定它们匹配到的值到一个指定类型的常量，从而可以打印这些值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> thing <span class=\"keyword\">in</span> things &#123;</div><div class=\"line\">    <span class=\"keyword\">switch</span> thing &#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">0</span> <span class=\"keyword\">as</span> <span class=\"type\">Int</span>:</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"zero as an Int\"</span>)</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">0</span> <span class=\"keyword\">as</span> <span class=\"type\">Double</span>:</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"zero as a Double\"</span>)</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> someInt <span class=\"keyword\">as</span> <span class=\"type\">Int</span>:</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"an integer value of <span class=\"subst\">\\(someInt)</span>\"</span>)</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> someDouble <span class=\"keyword\">as</span> <span class=\"type\">Double</span> <span class=\"keyword\">where</span> someDouble &gt; <span class=\"number\">0</span>:</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"a positive double value of <span class=\"subst\">\\(someDouble)</span>\"</span>)</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"keyword\">is</span> <span class=\"type\">Double</span>:</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"some other double value that I don't want to print\"</span>)</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> someString <span class=\"keyword\">as</span> <span class=\"type\">String</span>:</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"a string value of \\\"<span class=\"subst\">\\(someString)</span>\\\"\"</span>)</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> (x, y) <span class=\"keyword\">as</span> (<span class=\"type\">Double</span>, <span class=\"type\">Double</span>):</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"an (x, y) point at <span class=\"subst\">\\(x)</span>, <span class=\"subst\">\\(y)</span>\"</span>)</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> movie <span class=\"keyword\">as</span> <span class=\"type\">Movie</span>:</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"a movie called <span class=\"subst\">\\(movie.name)</span>, dir. <span class=\"subst\">\\(movie.director)</span>\"</span>)</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> stringConverter <span class=\"keyword\">as</span> (<span class=\"type\">String</span>) -&gt; <span class=\"type\">String</span>:</div><div class=\"line\">        <span class=\"built_in\">print</span>(stringConverter(<span class=\"string\">\"Michael\"</span>))</div><div class=\"line\">    <span class=\"keyword\">default</span>:</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"something else\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// zero as an Int</span></div><div class=\"line\"><span class=\"comment\">// zero as a Double</span></div><div class=\"line\"><span class=\"comment\">// an integer value of 42</span></div><div class=\"line\"><span class=\"comment\">// a positive double value of 3.14159</span></div><div class=\"line\"><span class=\"comment\">// a string value of \"hello\"</span></div><div class=\"line\"><span class=\"comment\">// an (x, y) point at 3.0, 5.0</span></div><div class=\"line\"><span class=\"comment\">// a movie called Ghostbusters, dir. Ivan Reitman</span></div><div class=\"line\"><span class=\"comment\">// Hello, Michael</span></div></pre></td></tr></table></figure>\n<pre><code>Any类型可以表示所有类型的值，包括可选类型。Swift 会在你用Any类型来表示一个可选值的时候，给你一个警告。如果你确实想使用Any类型来承载可选值，你可以使用as操作符显示转换为Any，如下所示：\n</code></pre><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> optionalNumber: <span class=\"type\">Int</span>? = <span class=\"number\">3</span></div><div class=\"line\">things.append(optionalNumber)        <span class=\"comment\">// Warning</span></div><div class=\"line\">things.append(optionalNumber <span class=\"keyword\">as</span> <span class=\"type\">Any</span>) <span class=\"comment\">// No warning</span></div></pre></td></tr></table></figure>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TypeCasting.html/\" target=\"_blank\" rel=\"external\"> Type Casting </a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>​    类型转换 可以判断实例的类型，也可以将实例看做是其父类或者子类的实例。<br>​类型转换在 Swift 中使用 is 和 as 操作符实现。这两个操作符提供了一种简单达意的方式去检查值的类型或者转换它的类型。也可以用它来检查一个类型是否实现了某个协议</p>","more":"<h3 id=\"定义一个类层次作为例子\"><a href=\"#定义一个类层次作为例子\" class=\"headerlink\" title=\"定义一个类层次作为例子\"></a>定义一个类层次作为例子</h3><p>你可以将类型转换用在类和子类的层次结构上，检查特定类实例的类型并且转换这个类实例的类型成为这个层次结构中的其他类型。下面的三个代码段定义了一个类层次和一个包含了这些类实例的数组，作为类型转换的例子。<br>第一个代码片段定义了一个新的基类 MediaItem。这个类为任何出现在数字媒体库的媒体项提供基础功能。特别的，它声明了一个 String 类型的 name 属性，和一个 init(name:) 初始化器。（假定所有的媒体项都有个名称。）</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MediaItem</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.name = name</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>下一个代码段定义了 MediaItem 的两个子类。第一个子类 Movie 封装了与电影相关的额外信息，在父类（或者说基类）的基础上增加了一个 director（导演）属性，和相应的初始化器。第二个子类 Song，在父类的基础上增加了一个 artist（艺术家）属性，和相应的初始化器：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Movie</span>: <span class=\"title\">MediaItem</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> director: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>, director: <span class=\"type\">String</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.director = director</div><div class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(name: name)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Song</span>: <span class=\"title\">MediaItem</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> artist: <span class=\"type\">String</span></div><div class=\"line\">    <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>, artist: <span class=\"type\">String</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">self</span>.artist = artist</div><div class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(name: name)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最后一个代码段创建了一个数组常量 library，包含两个 Movie 实例和三个 Song 实例。library 的类型是在它被初始化时根据它数组中所包含的内容推断来的。Swift 的类型检测器能够推断出 Movie 和 Song 有共同的父类 MediaItem，所以它推断出 [MediaItem] 类作为 library 的类型：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> library = [</div><div class=\"line\">    <span class=\"type\">Movie</span>(name: <span class=\"string\">\"Casablanca\"</span>, director: <span class=\"string\">\"Michael Curtiz\"</span>),</div><div class=\"line\">    <span class=\"type\">Song</span>(name: <span class=\"string\">\"Blue Suede Shoes\"</span>, artist: <span class=\"string\">\"Elvis Presley\"</span>),</div><div class=\"line\">    <span class=\"type\">Movie</span>(name: <span class=\"string\">\"Citizen Kane\"</span>, director: <span class=\"string\">\"Orson Welles\"</span>),</div><div class=\"line\">    <span class=\"type\">Song</span>(name: <span class=\"string\">\"The One And Only\"</span>, artist: <span class=\"string\">\"Chesney Hawkes\"</span>),</div><div class=\"line\">    <span class=\"type\">Song</span>(name: <span class=\"string\">\"Never Gonna Give You Up\"</span>, artist: <span class=\"string\">\"Rick Astley\"</span>)</div><div class=\"line\">]</div><div class=\"line\"><span class=\"comment\">// the type of \"library\" is inferred to be [MediaItem]</span></div></pre></td></tr></table></figure>\n<p>在幕后 library 里存储的媒体项依然是 Movie 和 Song 类型的。但是，若你迭代它，依次取出的实例会是 MediaItem 类型的，而不是 Movie 和 Song 类型。为了让它们作为原本的类型工作，你需要检查它们的类型或者向下转换它们到其它类型，就像下面描述的一样。</p>\n<h3 id=\"检查类型\"><a href=\"#检查类型\" class=\"headerlink\" title=\"检查类型\"></a>检查类型</h3><p>用类型检查操作符（ <code>is</code> ）来检查一个实例是否属于特定子类型。若实例属于那个子类型，类型检查操作符返回 <code>true</code> ，否则返回 <code>false</code> 。</p>\n<p>下面的例子定义了两个变量，movieCount 和 songCount，用来计算数组 library 中 Movie 和 Song 类型的实例数量：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> movieCount = <span class=\"number\">0</span></div><div class=\"line\"><span class=\"keyword\">var</span> songCount = <span class=\"number\">0</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> library &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> item <span class=\"keyword\">is</span> <span class=\"type\">Movie</span> &#123;</div><div class=\"line\">        movieCount += <span class=\"number\">1</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> item <span class=\"keyword\">is</span> <span class=\"type\">Song</span> &#123;</div><div class=\"line\">        songCount += <span class=\"number\">1</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">\"Media library contains <span class=\"subst\">\\(movieCount)</span> movies and <span class=\"subst\">\\(songCount)</span> songs\"</span>)</div><div class=\"line\"><span class=\"comment\">// Prints \"Media library contains 2 movies and 3 songs\"</span></div></pre></td></tr></table></figure>\n<p>若当前 MediaItem 是一个 Movie 类型的实例，item is Movie 返回 true，否则返回 false。同样的，item is Song 检查 item 是否为 Song 类型的实例。在循环结束后，movieCount 和 songCount 的值就是被找到的属于各自类型的实例的数量。</p>\n<h3 id=\"向下转型\"><a href=\"#向下转型\" class=\"headerlink\" title=\"向下转型\"></a>向下转型</h3><p>某类型的一个常量或变量可能在幕后实际上属于一个子类。当确定是这种情况时，你可以尝试向下转到它的子类型，用类型转换操作符（as? 或 as!）。<br>因为向下转型可能会失败，类型转型操作符带有两种不同形式。条件形式as? 返回一个你试图向下转成的类型的可选值。强制形式 as! 把试图向下转型和强制解包转换结果结合为一个操作。</p>\n<p>当你不确定向下转型可以成功时，用类型转换的条件形式（as?）。条件形式的类型转换总是返回一个可选值，并且若下转是不可能的，可选值将是 nil。这使你能够检查向下转型是否成功。<br>只有你可以确定向下转型一定会成功时，才使用强制形式（as!）。当你试图向下转型为一个不正确的类型时，强制形式的类型转换会触发一个运行时错误。</p>\n<p>下面的例子，迭代了 library 里的每一个 MediaItem，并打印出适当的描述。要这样做，item 需要真正作为 Movie 或 Song 的类型来使用，而不仅仅是作为 MediaItem。为了能够在描述中使用 Movie 或 Song 的 director 或 artist 属性，这是必要的。<br>在这个示例中，数组中的每一个 item 可能是 Movie 或 Song。事前你不知道每个 item 的真实类型，所以这里使用条件形式的类型转换（as?）去检查循环里的每次下转：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> library &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> movie = item <span class=\"keyword\">as</span>? <span class=\"type\">Movie</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Movie: <span class=\"subst\">\\(movie.name)</span>, dir. <span class=\"subst\">\\(movie.director)</span>\"</span>)</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> song = item <span class=\"keyword\">as</span>? <span class=\"type\">Song</span> &#123;</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Song: <span class=\"subst\">\\(song.name)</span>, by <span class=\"subst\">\\(song.artist)</span>\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// Movie: Casablanca, dir. Michael Curtiz</span></div><div class=\"line\"><span class=\"comment\">// Song: Blue Suede Shoes, by Elvis Presley</span></div><div class=\"line\"><span class=\"comment\">// Movie: Citizen Kane, dir. Orson Welles</span></div><div class=\"line\"><span class=\"comment\">// Song: The One And Only, by Chesney Hawkes</span></div><div class=\"line\"><span class=\"comment\">// Song: Never Gonna Give You Up, by Rick Astley</span></div></pre></td></tr></table></figure>\n<p>示例首先试图将 item 下转为 Movie。因为 item 是一个 MediaItem 类型的实例，它可能是一个 Movie；同样，它也可能是一个 Song，或者仅仅是基类 MediaItem。因为不确定，as? 形式在试图下转时将返回一个可选值。item as? Movie 的返回值是 Movie? 或者说“可选 Movie”。</p>\n<p>当向下转型为 Movie 应用在两个 Song 实例时将会失败。为了处理这种情况，上面的例子使用了可选绑定（optional binding）来检查可选 Movie 真的包含一个值（这个是为了判断下转是否成功。）可选绑定是这样写的“if let movie = item as? Movie”，可以这样解读：</p>\n<p>“尝试将 item 转为 Movie 类型。若成功，设置一个新的临时常量 movie 来存储返回的可选 Movie 中的值”</p>\n<p>若向下转型成功，然后 movie 的属性将用于打印一个 Movie 实例的描述，包括它的导演的名字 director。相似的原理被用来检测 Song 实例，当 Song 被找到时则打印它的描述（包含 artist 的名字）。<br>    转换没有真的改变实例或它的值。根本的实例保持不变；只是简单地把它作为它被转换成的类型来使用。</p>\n<h3 id=\"Any-和-AnyObject-的类型转换\"><a href=\"#Any-和-AnyObject-的类型转换\" class=\"headerlink\" title=\"Any 和 AnyObject 的类型转换\"></a>Any 和 AnyObject 的类型转换</h3><p>Swift 为不确定类型提供了两种特殊的类型别名：</p>\n<ul>\n<li>可以表示任何类型，包括函数类型。</li>\n<li>可以表示任何类类型的实例。</li>\n</ul>\n<p>只有当你确实需要它们的行为和功能时才使用 Any 和 AnyObject。代码中最好使用明确的类型。</p>\n<p>这里有个示例，使用 Any 类型来和混合的不同类型一起工作，包括函数类型和非类类型。它创建了一个可以存储 Any 类型的数组 things：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> things = [<span class=\"type\">Any</span>]()</div><div class=\"line\"> </div><div class=\"line\">things.append(<span class=\"number\">0</span>)</div><div class=\"line\">things.append(<span class=\"number\">0.0</span>)</div><div class=\"line\">things.append(<span class=\"number\">42</span>)</div><div class=\"line\">things.append(<span class=\"number\">3.14159</span>)</div><div class=\"line\">things.append(<span class=\"string\">\"hello\"</span>)</div><div class=\"line\">things.append((<span class=\"number\">3.0</span>, <span class=\"number\">5.0</span>))</div><div class=\"line\">things.append(<span class=\"type\">Movie</span>(name: <span class=\"string\">\"Ghostbusters\"</span>, director: <span class=\"string\">\"Ivan Reitman\"</span>))</div><div class=\"line\">things.append(&#123; (name: <span class=\"type\">String</span>) -&gt; <span class=\"type\">String</span> <span class=\"keyword\">in</span> <span class=\"string\">\"Hello, <span class=\"subst\">\\(name)</span>\"</span> &#125;)</div></pre></td></tr></table></figure>\n<p>things 数组包含两个 Int 值，两个 Double 值，一个 String 值，一个元组 (Double, Double)，一个Movie实例“Ghostbusters”，以及一个接受 String 值并返回另一个 String 值的闭包表达式。<br>你可以在 switch 表达式的 case 中使用 is 和 as 操作符来找出只知道是 Any 或 AnyObject 类型的常量或变量的具体类型。下面的示例迭代 things 数组中的每一项，并用 switch 语句查找每一项的类型。有几个 switch 语句的 case 绑定它们匹配到的值到一个指定类型的常量，从而可以打印这些值：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> thing <span class=\"keyword\">in</span> things &#123;</div><div class=\"line\">    <span class=\"keyword\">switch</span> thing &#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">0</span> <span class=\"keyword\">as</span> <span class=\"type\">Int</span>:</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"zero as an Int\"</span>)</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">0</span> <span class=\"keyword\">as</span> <span class=\"type\">Double</span>:</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"zero as a Double\"</span>)</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> someInt <span class=\"keyword\">as</span> <span class=\"type\">Int</span>:</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"an integer value of <span class=\"subst\">\\(someInt)</span>\"</span>)</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> someDouble <span class=\"keyword\">as</span> <span class=\"type\">Double</span> <span class=\"keyword\">where</span> someDouble &gt; <span class=\"number\">0</span>:</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"a positive double value of <span class=\"subst\">\\(someDouble)</span>\"</span>)</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"keyword\">is</span> <span class=\"type\">Double</span>:</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"some other double value that I don't want to print\"</span>)</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> someString <span class=\"keyword\">as</span> <span class=\"type\">String</span>:</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"a string value of \\\"<span class=\"subst\">\\(someString)</span>\\\"\"</span>)</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> (x, y) <span class=\"keyword\">as</span> (<span class=\"type\">Double</span>, <span class=\"type\">Double</span>):</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"an (x, y) point at <span class=\"subst\">\\(x)</span>, <span class=\"subst\">\\(y)</span>\"</span>)</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> movie <span class=\"keyword\">as</span> <span class=\"type\">Movie</span>:</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"a movie called <span class=\"subst\">\\(movie.name)</span>, dir. <span class=\"subst\">\\(movie.director)</span>\"</span>)</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"keyword\">let</span> stringConverter <span class=\"keyword\">as</span> (<span class=\"type\">String</span>) -&gt; <span class=\"type\">String</span>:</div><div class=\"line\">        <span class=\"built_in\">print</span>(stringConverter(<span class=\"string\">\"Michael\"</span>))</div><div class=\"line\">    <span class=\"keyword\">default</span>:</div><div class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"something else\"</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// zero as an Int</span></div><div class=\"line\"><span class=\"comment\">// zero as a Double</span></div><div class=\"line\"><span class=\"comment\">// an integer value of 42</span></div><div class=\"line\"><span class=\"comment\">// a positive double value of 3.14159</span></div><div class=\"line\"><span class=\"comment\">// a string value of \"hello\"</span></div><div class=\"line\"><span class=\"comment\">// an (x, y) point at 3.0, 5.0</span></div><div class=\"line\"><span class=\"comment\">// a movie called Ghostbusters, dir. Ivan Reitman</span></div><div class=\"line\"><span class=\"comment\">// Hello, Michael</span></div></pre></td></tr></table></figure>\n<pre><code>Any类型可以表示所有类型的值，包括可选类型。Swift 会在你用Any类型来表示一个可选值的时候，给你一个警告。如果你确实想使用Any类型来承载可选值，你可以使用as操作符显示转换为Any，如下所示：\n</code></pre><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> optionalNumber: <span class=\"type\">Int</span>? = <span class=\"number\">3</span></div><div class=\"line\">things.append(optionalNumber)        <span class=\"comment\">// Warning</span></div><div class=\"line\">things.append(optionalNumber <span class=\"keyword\">as</span> <span class=\"type\">Any</span>) <span class=\"comment\">// No warning</span></div></pre></td></tr></table></figure>\n<h3 id=\"参照文档\"><a href=\"#参照文档\" class=\"headerlink\" title=\"参照文档\"></a>参照文档</h3><blockquote>\n<ul>\n<li><a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TypeCasting.html/\" target=\"_blank\" rel=\"external\"> Type Casting </a> </li>\n</ul>\n</blockquote>\n<p>&gt;<br>&gt;</p>\n<blockquote>\n<p>Copyright (c) liangtong. All rights reserved.</p>\n</blockquote>"},{"layout":"post","title":"iOS移动App开发综述","date":"2016-10-21T15:50:12.000Z","catalog":true,"_content":"\n\n对iOS端移动App使用的开发语言、框架等信息进行介绍\n\n\n\n### 环境及工具\n* OS\n  * macOS , OSX\n* TOOL\n  * XCode： `Version 8.0+` , 早期版本\n\n> 建议：鉴于苹果的习惯，如果没有特殊需求，保持最新的系统和工具版本。\n\n\n<!-- more -->\n\n### 开发语言选择\n​\t\t首先要对开发的应用的功能有一定的了解，结合应用需要的功能及部署系统版本选择合适的开发语言。可以使用的主要开发语言包括：\n\n* Objective-C：\n\n  * 优点：老牌iOS开发语言，很多成熟稳定的开源代码可以使用；可以用来开发各个iOS系统上的应用。\n\n  * 缺点：苹果已经开始主推Swift；语言较复杂，比如虽然引入了ARC概念，但是部分内存管理还是需要自己来搞定；\n\n* Swift：苹果在2014年WWDC上发布的语言（函数式编程Monad，最低支持iOS7.0系统)，建议多使用结构体。\n\n  * 优点：苹果主推的取代Objective-C语言，*开源*、*易学易用*、*借鉴了好多主流开发语言(很多概念比如：泛型，闭包，元组，协议等)，如果熟悉数据库，JavaScript、Objective-C等的话，可以快速入手*\n\n  * 缺点：新语言，对旧系统不支持、多语言混合编译存在一些桥接问题；\n\n* 其它：C/C++​\n\n\n---\n> *  如果想快速开发应用，建议使用Objective-C，毕竟有很多现成的东西；\n> *  长远的看的话，建议使用Swift，新东西还是很让人兴奋的；\n> *  Swift语言选择3.0以上的版本，因为XCode8.0及后续工具不兼容3.0之前的语言版本；\n> *  如果项目中必须引入C++混合编译，建议使用Objective-C，Swift调用C代码还好，调用C++目前来说不可行。\n> *  没啥想法，建议前期使用Objective-C和Swift混合开发，最终全面向Swift过渡。\n\n\n---\n\n### 程序框架选择\n​\t这里主要介绍两个框架MVC和MVVM，以及最终程序开发中使用的MVMCV\n\n##### MVC\n​\tMVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。\n![](http://hi.csdn.net/attachment/201105/19/0_1305768550zP1b.gif)\n\n* View：负责数据展示。\n  * 应用程序中用户可以看见的对象。在iOS应用程序开发中，所有的控件、窗口等都继承自 UIView，UIView及其子类主要负责UI的实现，而UIView所产生的事件都可以采用委托的方式，交给UIViewController实现。\n\n* Controller：处理输入输出。\n  * View和Model之间交互的媒介，控制器对象解释在视图对象中进行的用户操作，并将新的或更改过的数据传达给模型对象。模型对象更改时，一个控制器对象会将新的模型数据传达给视图对象，以便视图对象可以显示它。对于不同的UIView，有相应的UIViewController，例如在iOS上常用的UITableView，它所对应的Controller就是UITableViewController。\n\n* Model：持有数据，比如本地数据库，本地文件。\n  ​\n\n  ​\tiOS应用中，对应UIViewController其实可以理解为ViewContainer（View + Controler）；如果使用MVC框架进行移动App开发的话，ViewController会显得特别臃肿，并且如果更换Controller策略就会显得比较麻烦。对于功能复杂的页面，其ViewController结构将会非常庞大，后期维护代价明显会比较高。\n\n##### MVVM\n​\t\tMVVM代表的是Model View View-Model，她的出现可以理解成是给MVC的视图控制器瘦身。\n![](http://images.cnitblog.com/i/380707/201403/152139487613221.png)\n\n* View：负责数据展示。\n  * 包含实际 UI 本身(不论是 UIView 代码, storyboard 和 xib), 任何视图特定的逻辑, 和对用户输入的反馈. 在 iOS 中这不仅需要 UIView 代码和那些文件, 还包括很多需由 UIViewController 处理的工作。\n\n* View-Model ：处理输入输出。\n  * 它的职责之一就是作为一个表现视图显示自身所需数据的静态模型;但它也有收集, 解释和转换那些数据的责任. 这留给了 view (controller) 一个更加清晰明确的任务: 呈现由 view-model 提供的数据。\n\n* Model：持有数据，比如本地数据库，本地文件。\n  ​\n\n  ​\t说下View-Model：它从必要的资源(数据库, 网络服务调用, 等)中获取原始数据, 运用逻辑, 并处理成 view (controller) 的展示数据. 它(通常通过属性)暴露给视图控制器需要知道的仅关于显示视图工作的信息(理想地你不会暴漏你的 data-model 对象)。 它还负责对上游数据的修改(比如更新模型/数据库, API POST 调用)。\n\n##### MVC与MVVM的对比\n​\t\t经过上边对MVC和MVVM的介绍，相信大家对两种模式简单的映射关系有了一定的了解。通过对比，我们会发现视图控制器是非常大的。\n![](http://cc.cocimg.com/api/uploads/20150525/1432542173109354.png)\n\n##### MVMCV的产生\n​\t\t如果将两者结合，会是什么样子呢\n![](http://cc.cocimg.com/api/uploads/20150525/1432542301497557.gif)\n​\t\t结果就说MVMCV产生了。\n![](http://cc.cocimg.com/api/uploads/20150525/1432542328653234.png)\n\n​\t\tview-model会在视图控制器上以一个属性的方式存在. 视图控制器知道 view-model 和它的公有属性, 但是 view-model 对视图控制器一无所知. 你早就该对这个设计感觉好多了因为我们的关注点在这儿进行更好地分离.最后我们用一个应用构建模块层级图来结束这节介绍：\n![](http://cc.cocimg.com/api/uploads/20150525/1432542362309133.png)\n\n\n### 第三方应用的使用\n* 手动将别人的代码拖拽到自己工程中。\n  * 优点：随时可以修改别人的代码。\n  * 缺点：需要自己维护该代码。\n* 通过pod引用\n  * 优点：大家一起维护，代码质量高；代码更新只要一句`pod update`一切都搞定 \n  * 缺点：如果发现问题，修改可能会比较慢\n\n>建议：如果不涉及UI，尽量使用pod来管理；使用GitHub第三方代码的时候需要注意几点：star、watch数量，还有活跃度。别选那种没人用的，不然后期出了问题你就很可能只能靠自己了\n\n### 发布相关\n* 签名Code Sign\n  * App标识符\n  * 开发证书\n  * 发布证书\n* APNS\n  * 开发证书\n  * 发布证书\n* 其他\n\n### 学习建议\n* 如果有一定的语言基础，不用看「xx从入门到精通」之类的书。因为技术更新很快，书上很多东西都过时或者被弃用了\n* 多看看苹果开发者文档，接口文档介绍的非常详细。\n* 多逛逛GitHub，学习GitHub上一些牛人的思想，编码风格。链接 ： <a href=\"https://github.com/search?l=Objective-C&o=desc&q=stars%3A%3E1&s=stars&type=Repositories\">Objective-C 排行</a>\n\n>\n> \n>\n> \n","source":"_posts/iOS_develop_overview_framework_1.md","raw":"---\nlayout:     post\ntitle:      iOS移动App开发综述\ndate:       2016-10-21 23:50:12\ncatalog: true\ncategories: iOS\ntags: 随笔 \n\n---\n\n\n对iOS端移动App使用的开发语言、框架等信息进行介绍\n\n\n\n### 环境及工具\n* OS\n  * macOS , OSX\n* TOOL\n  * XCode： `Version 8.0+` , 早期版本\n\n> 建议：鉴于苹果的习惯，如果没有特殊需求，保持最新的系统和工具版本。\n\n\n<!-- more -->\n\n### 开发语言选择\n​\t\t首先要对开发的应用的功能有一定的了解，结合应用需要的功能及部署系统版本选择合适的开发语言。可以使用的主要开发语言包括：\n\n* Objective-C：\n\n  * 优点：老牌iOS开发语言，很多成熟稳定的开源代码可以使用；可以用来开发各个iOS系统上的应用。\n\n  * 缺点：苹果已经开始主推Swift；语言较复杂，比如虽然引入了ARC概念，但是部分内存管理还是需要自己来搞定；\n\n* Swift：苹果在2014年WWDC上发布的语言（函数式编程Monad，最低支持iOS7.0系统)，建议多使用结构体。\n\n  * 优点：苹果主推的取代Objective-C语言，*开源*、*易学易用*、*借鉴了好多主流开发语言(很多概念比如：泛型，闭包，元组，协议等)，如果熟悉数据库，JavaScript、Objective-C等的话，可以快速入手*\n\n  * 缺点：新语言，对旧系统不支持、多语言混合编译存在一些桥接问题；\n\n* 其它：C/C++​\n\n\n---\n> *  如果想快速开发应用，建议使用Objective-C，毕竟有很多现成的东西；\n> *  长远的看的话，建议使用Swift，新东西还是很让人兴奋的；\n> *  Swift语言选择3.0以上的版本，因为XCode8.0及后续工具不兼容3.0之前的语言版本；\n> *  如果项目中必须引入C++混合编译，建议使用Objective-C，Swift调用C代码还好，调用C++目前来说不可行。\n> *  没啥想法，建议前期使用Objective-C和Swift混合开发，最终全面向Swift过渡。\n\n\n---\n\n### 程序框架选择\n​\t这里主要介绍两个框架MVC和MVVM，以及最终程序开发中使用的MVMCV\n\n##### MVC\n​\tMVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。\n![](http://hi.csdn.net/attachment/201105/19/0_1305768550zP1b.gif)\n\n* View：负责数据展示。\n  * 应用程序中用户可以看见的对象。在iOS应用程序开发中，所有的控件、窗口等都继承自 UIView，UIView及其子类主要负责UI的实现，而UIView所产生的事件都可以采用委托的方式，交给UIViewController实现。\n\n* Controller：处理输入输出。\n  * View和Model之间交互的媒介，控制器对象解释在视图对象中进行的用户操作，并将新的或更改过的数据传达给模型对象。模型对象更改时，一个控制器对象会将新的模型数据传达给视图对象，以便视图对象可以显示它。对于不同的UIView，有相应的UIViewController，例如在iOS上常用的UITableView，它所对应的Controller就是UITableViewController。\n\n* Model：持有数据，比如本地数据库，本地文件。\n  ​\n\n  ​\tiOS应用中，对应UIViewController其实可以理解为ViewContainer（View + Controler）；如果使用MVC框架进行移动App开发的话，ViewController会显得特别臃肿，并且如果更换Controller策略就会显得比较麻烦。对于功能复杂的页面，其ViewController结构将会非常庞大，后期维护代价明显会比较高。\n\n##### MVVM\n​\t\tMVVM代表的是Model View View-Model，她的出现可以理解成是给MVC的视图控制器瘦身。\n![](http://images.cnitblog.com/i/380707/201403/152139487613221.png)\n\n* View：负责数据展示。\n  * 包含实际 UI 本身(不论是 UIView 代码, storyboard 和 xib), 任何视图特定的逻辑, 和对用户输入的反馈. 在 iOS 中这不仅需要 UIView 代码和那些文件, 还包括很多需由 UIViewController 处理的工作。\n\n* View-Model ：处理输入输出。\n  * 它的职责之一就是作为一个表现视图显示自身所需数据的静态模型;但它也有收集, 解释和转换那些数据的责任. 这留给了 view (controller) 一个更加清晰明确的任务: 呈现由 view-model 提供的数据。\n\n* Model：持有数据，比如本地数据库，本地文件。\n  ​\n\n  ​\t说下View-Model：它从必要的资源(数据库, 网络服务调用, 等)中获取原始数据, 运用逻辑, 并处理成 view (controller) 的展示数据. 它(通常通过属性)暴露给视图控制器需要知道的仅关于显示视图工作的信息(理想地你不会暴漏你的 data-model 对象)。 它还负责对上游数据的修改(比如更新模型/数据库, API POST 调用)。\n\n##### MVC与MVVM的对比\n​\t\t经过上边对MVC和MVVM的介绍，相信大家对两种模式简单的映射关系有了一定的了解。通过对比，我们会发现视图控制器是非常大的。\n![](http://cc.cocimg.com/api/uploads/20150525/1432542173109354.png)\n\n##### MVMCV的产生\n​\t\t如果将两者结合，会是什么样子呢\n![](http://cc.cocimg.com/api/uploads/20150525/1432542301497557.gif)\n​\t\t结果就说MVMCV产生了。\n![](http://cc.cocimg.com/api/uploads/20150525/1432542328653234.png)\n\n​\t\tview-model会在视图控制器上以一个属性的方式存在. 视图控制器知道 view-model 和它的公有属性, 但是 view-model 对视图控制器一无所知. 你早就该对这个设计感觉好多了因为我们的关注点在这儿进行更好地分离.最后我们用一个应用构建模块层级图来结束这节介绍：\n![](http://cc.cocimg.com/api/uploads/20150525/1432542362309133.png)\n\n\n### 第三方应用的使用\n* 手动将别人的代码拖拽到自己工程中。\n  * 优点：随时可以修改别人的代码。\n  * 缺点：需要自己维护该代码。\n* 通过pod引用\n  * 优点：大家一起维护，代码质量高；代码更新只要一句`pod update`一切都搞定 \n  * 缺点：如果发现问题，修改可能会比较慢\n\n>建议：如果不涉及UI，尽量使用pod来管理；使用GitHub第三方代码的时候需要注意几点：star、watch数量，还有活跃度。别选那种没人用的，不然后期出了问题你就很可能只能靠自己了\n\n### 发布相关\n* 签名Code Sign\n  * App标识符\n  * 开发证书\n  * 发布证书\n* APNS\n  * 开发证书\n  * 发布证书\n* 其他\n\n### 学习建议\n* 如果有一定的语言基础，不用看「xx从入门到精通」之类的书。因为技术更新很快，书上很多东西都过时或者被弃用了\n* 多看看苹果开发者文档，接口文档介绍的非常详细。\n* 多逛逛GitHub，学习GitHub上一些牛人的思想，编码风格。链接 ： <a href=\"https://github.com/search?l=Objective-C&o=desc&q=stars%3A%3E1&s=stars&type=Repositories\">Objective-C 排行</a>\n\n>\n> \n>\n> \n","slug":"iOS_develop_overview_framework_1","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4uz004coko8pwzq7cob","content":"<p>对iOS端移动App使用的开发语言、框架等信息进行介绍</p>\n<h3 id=\"环境及工具\"><a href=\"#环境及工具\" class=\"headerlink\" title=\"环境及工具\"></a>环境及工具</h3><ul>\n<li>OS<ul>\n<li>macOS , OSX</li>\n</ul>\n</li>\n<li>TOOL<ul>\n<li>XCode： <code>Version 8.0+</code> , 早期版本</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>建议：鉴于苹果的习惯，如果没有特殊需求，保持最新的系统和工具版本。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"开发语言选择\"><a href=\"#开发语言选择\" class=\"headerlink\" title=\"开发语言选择\"></a>开发语言选择</h3><p>​        首先要对开发的应用的功能有一定的了解，结合应用需要的功能及部署系统版本选择合适的开发语言。可以使用的主要开发语言包括：</p>\n<ul>\n<li><p>Objective-C：</p>\n<ul>\n<li><p>优点：老牌iOS开发语言，很多成熟稳定的开源代码可以使用；可以用来开发各个iOS系统上的应用。</p>\n</li>\n<li><p>缺点：苹果已经开始主推Swift；语言较复杂，比如虽然引入了ARC概念，但是部分内存管理还是需要自己来搞定；</p>\n</li>\n</ul>\n</li>\n<li><p>Swift：苹果在2014年WWDC上发布的语言（函数式编程Monad，最低支持iOS7.0系统)，建议多使用结构体。</p>\n<ul>\n<li><p>优点：苹果主推的取代Objective-C语言，<em>开源</em>、<em>易学易用</em>、<em>借鉴了好多主流开发语言(很多概念比如：泛型，闭包，元组，协议等)，如果熟悉数据库，JavaScript、Objective-C等的话，可以快速入手</em></p>\n</li>\n<li><p>缺点：新语言，对旧系统不支持、多语言混合编译存在一些桥接问题；</p>\n</li>\n</ul>\n</li>\n<li><p>其它：C/C++​</p>\n</li>\n</ul>\n<hr>\n<blockquote>\n<ul>\n<li>如果想快速开发应用，建议使用Objective-C，毕竟有很多现成的东西；</li>\n<li>长远的看的话，建议使用Swift，新东西还是很让人兴奋的；</li>\n<li>Swift语言选择3.0以上的版本，因为XCode8.0及后续工具不兼容3.0之前的语言版本；</li>\n<li>如果项目中必须引入C++混合编译，建议使用Objective-C，Swift调用C代码还好，调用C++目前来说不可行。</li>\n<li>没啥想法，建议前期使用Objective-C和Swift混合开发，最终全面向Swift过渡。</li>\n</ul>\n</blockquote>\n<hr>\n<h3 id=\"程序框架选择\"><a href=\"#程序框架选择\" class=\"headerlink\" title=\"程序框架选择\"></a>程序框架选择</h3><p>​    这里主要介绍两个框架MVC和MVVM，以及最终程序开发中使用的MVMCV</p>\n<h5 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h5><p>​    MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。<br><img src=\"http://hi.csdn.net/attachment/201105/19/0_1305768550zP1b.gif\" alt=\"\"></p>\n<ul>\n<li><p>View：负责数据展示。</p>\n<ul>\n<li>应用程序中用户可以看见的对象。在iOS应用程序开发中，所有的控件、窗口等都继承自 UIView，UIView及其子类主要负责UI的实现，而UIView所产生的事件都可以采用委托的方式，交给UIViewController实现。</li>\n</ul>\n</li>\n<li><p>Controller：处理输入输出。</p>\n<ul>\n<li>View和Model之间交互的媒介，控制器对象解释在视图对象中进行的用户操作，并将新的或更改过的数据传达给模型对象。模型对象更改时，一个控制器对象会将新的模型数据传达给视图对象，以便视图对象可以显示它。对于不同的UIView，有相应的UIViewController，例如在iOS上常用的UITableView，它所对应的Controller就是UITableViewController。</li>\n</ul>\n</li>\n<li><p>Model：持有数据，比如本地数据库，本地文件。<br>​</p>\n<p>​    iOS应用中，对应UIViewController其实可以理解为ViewContainer（View + Controler）；如果使用MVC框架进行移动App开发的话，ViewController会显得特别臃肿，并且如果更换Controller策略就会显得比较麻烦。对于功能复杂的页面，其ViewController结构将会非常庞大，后期维护代价明显会比较高。</p>\n</li>\n</ul>\n<h5 id=\"MVVM\"><a href=\"#MVVM\" class=\"headerlink\" title=\"MVVM\"></a>MVVM</h5><p>​        MVVM代表的是Model View View-Model，她的出现可以理解成是给MVC的视图控制器瘦身。<br><img src=\"http://images.cnitblog.com/i/380707/201403/152139487613221.png\" alt=\"\"></p>\n<ul>\n<li><p>View：负责数据展示。</p>\n<ul>\n<li>包含实际 UI 本身(不论是 UIView 代码, storyboard 和 xib), 任何视图特定的逻辑, 和对用户输入的反馈. 在 iOS 中这不仅需要 UIView 代码和那些文件, 还包括很多需由 UIViewController 处理的工作。</li>\n</ul>\n</li>\n<li><p>View-Model ：处理输入输出。</p>\n<ul>\n<li>它的职责之一就是作为一个表现视图显示自身所需数据的静态模型;但它也有收集, 解释和转换那些数据的责任. 这留给了 view (controller) 一个更加清晰明确的任务: 呈现由 view-model 提供的数据。</li>\n</ul>\n</li>\n<li><p>Model：持有数据，比如本地数据库，本地文件。<br>​</p>\n<p>​    说下View-Model：它从必要的资源(数据库, 网络服务调用, 等)中获取原始数据, 运用逻辑, 并处理成 view (controller) 的展示数据. 它(通常通过属性)暴露给视图控制器需要知道的仅关于显示视图工作的信息(理想地你不会暴漏你的 data-model 对象)。 它还负责对上游数据的修改(比如更新模型/数据库, API POST 调用)。</p>\n</li>\n</ul>\n<h5 id=\"MVC与MVVM的对比\"><a href=\"#MVC与MVVM的对比\" class=\"headerlink\" title=\"MVC与MVVM的对比\"></a>MVC与MVVM的对比</h5><p>​        经过上边对MVC和MVVM的介绍，相信大家对两种模式简单的映射关系有了一定的了解。通过对比，我们会发现视图控制器是非常大的。<br><img src=\"http://cc.cocimg.com/api/uploads/20150525/1432542173109354.png\" alt=\"\"></p>\n<h5 id=\"MVMCV的产生\"><a href=\"#MVMCV的产生\" class=\"headerlink\" title=\"MVMCV的产生\"></a>MVMCV的产生</h5><p>​        如果将两者结合，会是什么样子呢<br><img src=\"http://cc.cocimg.com/api/uploads/20150525/1432542301497557.gif\" alt=\"\"><br>​        结果就说MVMCV产生了。<br><img src=\"http://cc.cocimg.com/api/uploads/20150525/1432542328653234.png\" alt=\"\"></p>\n<p>​        view-model会在视图控制器上以一个属性的方式存在. 视图控制器知道 view-model 和它的公有属性, 但是 view-model 对视图控制器一无所知. 你早就该对这个设计感觉好多了因为我们的关注点在这儿进行更好地分离.最后我们用一个应用构建模块层级图来结束这节介绍：<br><img src=\"http://cc.cocimg.com/api/uploads/20150525/1432542362309133.png\" alt=\"\"></p>\n<h3 id=\"第三方应用的使用\"><a href=\"#第三方应用的使用\" class=\"headerlink\" title=\"第三方应用的使用\"></a>第三方应用的使用</h3><ul>\n<li>手动将别人的代码拖拽到自己工程中。<ul>\n<li>优点：随时可以修改别人的代码。</li>\n<li>缺点：需要自己维护该代码。</li>\n</ul>\n</li>\n<li>通过pod引用<ul>\n<li>优点：大家一起维护，代码质量高；代码更新只要一句<code>pod update</code>一切都搞定 </li>\n<li>缺点：如果发现问题，修改可能会比较慢</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>建议：如果不涉及UI，尽量使用pod来管理；使用GitHub第三方代码的时候需要注意几点：star、watch数量，还有活跃度。别选那种没人用的，不然后期出了问题你就很可能只能靠自己了</p>\n</blockquote>\n<h3 id=\"发布相关\"><a href=\"#发布相关\" class=\"headerlink\" title=\"发布相关\"></a>发布相关</h3><ul>\n<li>签名Code Sign<ul>\n<li>App标识符</li>\n<li>开发证书</li>\n<li>发布证书</li>\n</ul>\n</li>\n<li>APNS<ul>\n<li>开发证书</li>\n<li>发布证书</li>\n</ul>\n</li>\n<li>其他</li>\n</ul>\n<h3 id=\"学习建议\"><a href=\"#学习建议\" class=\"headerlink\" title=\"学习建议\"></a>学习建议</h3><ul>\n<li>如果有一定的语言基础，不用看「xx从入门到精通」之类的书。因为技术更新很快，书上很多东西都过时或者被弃用了</li>\n<li>多看看苹果开发者文档，接口文档介绍的非常详细。</li>\n<li>多逛逛GitHub，学习GitHub上一些牛人的思想，编码风格。链接 ： <a href=\"https://github.com/search?l=Objective-C&o=desc&q=stars%3A%3E1&s=stars&type=Repositories\" target=\"_blank\" rel=\"external\">Objective-C 排行</a></li>\n</ul>\n<p>&gt;</p>\n<blockquote>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>对iOS端移动App使用的开发语言、框架等信息进行介绍</p>\n<h3 id=\"环境及工具\"><a href=\"#环境及工具\" class=\"headerlink\" title=\"环境及工具\"></a>环境及工具</h3><ul>\n<li>OS<ul>\n<li>macOS , OSX</li>\n</ul>\n</li>\n<li>TOOL<ul>\n<li>XCode： <code>Version 8.0+</code> , 早期版本</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>建议：鉴于苹果的习惯，如果没有特殊需求，保持最新的系统和工具版本。</p>\n</blockquote>","more":"<h3 id=\"开发语言选择\"><a href=\"#开发语言选择\" class=\"headerlink\" title=\"开发语言选择\"></a>开发语言选择</h3><p>​        首先要对开发的应用的功能有一定的了解，结合应用需要的功能及部署系统版本选择合适的开发语言。可以使用的主要开发语言包括：</p>\n<ul>\n<li><p>Objective-C：</p>\n<ul>\n<li><p>优点：老牌iOS开发语言，很多成熟稳定的开源代码可以使用；可以用来开发各个iOS系统上的应用。</p>\n</li>\n<li><p>缺点：苹果已经开始主推Swift；语言较复杂，比如虽然引入了ARC概念，但是部分内存管理还是需要自己来搞定；</p>\n</li>\n</ul>\n</li>\n<li><p>Swift：苹果在2014年WWDC上发布的语言（函数式编程Monad，最低支持iOS7.0系统)，建议多使用结构体。</p>\n<ul>\n<li><p>优点：苹果主推的取代Objective-C语言，<em>开源</em>、<em>易学易用</em>、<em>借鉴了好多主流开发语言(很多概念比如：泛型，闭包，元组，协议等)，如果熟悉数据库，JavaScript、Objective-C等的话，可以快速入手</em></p>\n</li>\n<li><p>缺点：新语言，对旧系统不支持、多语言混合编译存在一些桥接问题；</p>\n</li>\n</ul>\n</li>\n<li><p>其它：C/C++​</p>\n</li>\n</ul>\n<hr>\n<blockquote>\n<ul>\n<li>如果想快速开发应用，建议使用Objective-C，毕竟有很多现成的东西；</li>\n<li>长远的看的话，建议使用Swift，新东西还是很让人兴奋的；</li>\n<li>Swift语言选择3.0以上的版本，因为XCode8.0及后续工具不兼容3.0之前的语言版本；</li>\n<li>如果项目中必须引入C++混合编译，建议使用Objective-C，Swift调用C代码还好，调用C++目前来说不可行。</li>\n<li>没啥想法，建议前期使用Objective-C和Swift混合开发，最终全面向Swift过渡。</li>\n</ul>\n</blockquote>\n<hr>\n<h3 id=\"程序框架选择\"><a href=\"#程序框架选择\" class=\"headerlink\" title=\"程序框架选择\"></a>程序框架选择</h3><p>​    这里主要介绍两个框架MVC和MVVM，以及最终程序开发中使用的MVMCV</p>\n<h5 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h5><p>​    MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。<br><img src=\"http://hi.csdn.net/attachment/201105/19/0_1305768550zP1b.gif\" alt=\"\"></p>\n<ul>\n<li><p>View：负责数据展示。</p>\n<ul>\n<li>应用程序中用户可以看见的对象。在iOS应用程序开发中，所有的控件、窗口等都继承自 UIView，UIView及其子类主要负责UI的实现，而UIView所产生的事件都可以采用委托的方式，交给UIViewController实现。</li>\n</ul>\n</li>\n<li><p>Controller：处理输入输出。</p>\n<ul>\n<li>View和Model之间交互的媒介，控制器对象解释在视图对象中进行的用户操作，并将新的或更改过的数据传达给模型对象。模型对象更改时，一个控制器对象会将新的模型数据传达给视图对象，以便视图对象可以显示它。对于不同的UIView，有相应的UIViewController，例如在iOS上常用的UITableView，它所对应的Controller就是UITableViewController。</li>\n</ul>\n</li>\n<li><p>Model：持有数据，比如本地数据库，本地文件。<br>​</p>\n<p>​    iOS应用中，对应UIViewController其实可以理解为ViewContainer（View + Controler）；如果使用MVC框架进行移动App开发的话，ViewController会显得特别臃肿，并且如果更换Controller策略就会显得比较麻烦。对于功能复杂的页面，其ViewController结构将会非常庞大，后期维护代价明显会比较高。</p>\n</li>\n</ul>\n<h5 id=\"MVVM\"><a href=\"#MVVM\" class=\"headerlink\" title=\"MVVM\"></a>MVVM</h5><p>​        MVVM代表的是Model View View-Model，她的出现可以理解成是给MVC的视图控制器瘦身。<br><img src=\"http://images.cnitblog.com/i/380707/201403/152139487613221.png\" alt=\"\"></p>\n<ul>\n<li><p>View：负责数据展示。</p>\n<ul>\n<li>包含实际 UI 本身(不论是 UIView 代码, storyboard 和 xib), 任何视图特定的逻辑, 和对用户输入的反馈. 在 iOS 中这不仅需要 UIView 代码和那些文件, 还包括很多需由 UIViewController 处理的工作。</li>\n</ul>\n</li>\n<li><p>View-Model ：处理输入输出。</p>\n<ul>\n<li>它的职责之一就是作为一个表现视图显示自身所需数据的静态模型;但它也有收集, 解释和转换那些数据的责任. 这留给了 view (controller) 一个更加清晰明确的任务: 呈现由 view-model 提供的数据。</li>\n</ul>\n</li>\n<li><p>Model：持有数据，比如本地数据库，本地文件。<br>​</p>\n<p>​    说下View-Model：它从必要的资源(数据库, 网络服务调用, 等)中获取原始数据, 运用逻辑, 并处理成 view (controller) 的展示数据. 它(通常通过属性)暴露给视图控制器需要知道的仅关于显示视图工作的信息(理想地你不会暴漏你的 data-model 对象)。 它还负责对上游数据的修改(比如更新模型/数据库, API POST 调用)。</p>\n</li>\n</ul>\n<h5 id=\"MVC与MVVM的对比\"><a href=\"#MVC与MVVM的对比\" class=\"headerlink\" title=\"MVC与MVVM的对比\"></a>MVC与MVVM的对比</h5><p>​        经过上边对MVC和MVVM的介绍，相信大家对两种模式简单的映射关系有了一定的了解。通过对比，我们会发现视图控制器是非常大的。<br><img src=\"http://cc.cocimg.com/api/uploads/20150525/1432542173109354.png\" alt=\"\"></p>\n<h5 id=\"MVMCV的产生\"><a href=\"#MVMCV的产生\" class=\"headerlink\" title=\"MVMCV的产生\"></a>MVMCV的产生</h5><p>​        如果将两者结合，会是什么样子呢<br><img src=\"http://cc.cocimg.com/api/uploads/20150525/1432542301497557.gif\" alt=\"\"><br>​        结果就说MVMCV产生了。<br><img src=\"http://cc.cocimg.com/api/uploads/20150525/1432542328653234.png\" alt=\"\"></p>\n<p>​        view-model会在视图控制器上以一个属性的方式存在. 视图控制器知道 view-model 和它的公有属性, 但是 view-model 对视图控制器一无所知. 你早就该对这个设计感觉好多了因为我们的关注点在这儿进行更好地分离.最后我们用一个应用构建模块层级图来结束这节介绍：<br><img src=\"http://cc.cocimg.com/api/uploads/20150525/1432542362309133.png\" alt=\"\"></p>\n<h3 id=\"第三方应用的使用\"><a href=\"#第三方应用的使用\" class=\"headerlink\" title=\"第三方应用的使用\"></a>第三方应用的使用</h3><ul>\n<li>手动将别人的代码拖拽到自己工程中。<ul>\n<li>优点：随时可以修改别人的代码。</li>\n<li>缺点：需要自己维护该代码。</li>\n</ul>\n</li>\n<li>通过pod引用<ul>\n<li>优点：大家一起维护，代码质量高；代码更新只要一句<code>pod update</code>一切都搞定 </li>\n<li>缺点：如果发现问题，修改可能会比较慢</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>建议：如果不涉及UI，尽量使用pod来管理；使用GitHub第三方代码的时候需要注意几点：star、watch数量，还有活跃度。别选那种没人用的，不然后期出了问题你就很可能只能靠自己了</p>\n</blockquote>\n<h3 id=\"发布相关\"><a href=\"#发布相关\" class=\"headerlink\" title=\"发布相关\"></a>发布相关</h3><ul>\n<li>签名Code Sign<ul>\n<li>App标识符</li>\n<li>开发证书</li>\n<li>发布证书</li>\n</ul>\n</li>\n<li>APNS<ul>\n<li>开发证书</li>\n<li>发布证书</li>\n</ul>\n</li>\n<li>其他</li>\n</ul>\n<h3 id=\"学习建议\"><a href=\"#学习建议\" class=\"headerlink\" title=\"学习建议\"></a>学习建议</h3><ul>\n<li>如果有一定的语言基础，不用看「xx从入门到精通」之类的书。因为技术更新很快，书上很多东西都过时或者被弃用了</li>\n<li>多看看苹果开发者文档，接口文档介绍的非常详细。</li>\n<li>多逛逛GitHub，学习GitHub上一些牛人的思想，编码风格。链接 ： <a href=\"https://github.com/search?l=Objective-C&o=desc&q=stars%3A%3E1&s=stars&type=Repositories\" target=\"_blank\" rel=\"external\">Objective-C 排行</a></li>\n</ul>\n<p>&gt;</p>\n<blockquote>\n</blockquote>"},{"layout":"post","title":"浅谈iOS框架","date":"2016-12-21T15:50:12.000Z","author":"liangtong","catalog":true,"_content":"\n\n记录下个人从事iOS开发过程中，使用过的程序框架，谈谈个人的理解。\n\n\n\n### 前言\n​\t回顾最近三年，我主要从事iOS前端开发工作。一个一无所知的摸石头过河，慢慢在前端开发的道路上寻找、探索。之前我是做嵌入式开发的，转做iOS前端开发可以说是一个幸运的意外。因为业务需要，看了两个星期的斯坦福大学大学iOS公开课，就开始了我的踩坑、脱坑之旅。这里就聊一聊近3年来iOS前端开发使用的框架吧。\n\n\n<!-- more -->\n\n### MVC\n​\t第一次接触MVC这个框架，是在大三的一门《J2EE》教材的最后一章，当时还沉浸在JSP+Servlet各种组合中，提到这个的时候，因为是接触的第一个框架，所以印象特别深刻，直到后来实习的时候使用Struct框架做了一个管理系统，才算`真正`的理解。后来在斯坦福iOS视频教程中又一次的遇到她。\n概念不用再赘述，当时主要是使用Xib+ObjC开发。鉴于应用本身的弱Model，当时的整个应用看起来都是ViewController。文件组织特别的乱，结果就是很不好维护。在经历了iOS5～iOS10系统的适配后，在代码复用方面，简直是个噩梦！在这里就主要记录下使用她的过程中遇到的问题吧   \n\n* 基础知识不熟练。   \n* 零基础的代码编写，主要精力放在了逻辑编写上，很少关注代码结构。\n* 很多组件使用不规范。虽然UI上达到了效果。   \n* 第三方库的使用。直接拖拽、修改代码。\n* 系统不熟悉，等。\n\n以上很多因素，最终导致了App的ViewController特别臃肿，且页面间组织关系不好梳理，代码复用等这里真心无力再吐槽了。期间界面组织方式有`StoryBoard+ObjC`、`Xib+ObjC`和`ObjC纯代码`，开发的应用包括《效率助手》、《知识库》、《因泰在线》，使用该框架过程中对其结构进行了调整，和后边的MVVM框架思想类似。\n\n\n### MVVM\n​\t对于这个框架，感觉是先使用后，才了解到其概念的。先使用的主要原因是MVC的Controller太过庞大，且维护起来很不容易。很多逻辑感觉不应该放到控制器中，所以将Controller进行了分割，使用起来确实解决了代码复用问题，程序结构变得清晰起来。使用该框架开发的应用包括《数据采集》、《路桥在线》等。因为在查询框架资料时，使用的和这个不谋而合。所以这个框架使用的周期相对较短。\n\n### 自定义框架\n​\t之前主要从事嵌入式开发，对某个车载导航产品的结构比较熟悉，所以就仿造她自己编写了一套框架，主要为了解决代码分类。层级结构包括：界面展示层HMI、交互层PF、数据传输层HMI-Core、核心功能层FunctionCore、数据持有层Model、共同层Common等，功能模块横向纵向通过Symbol（Event或者Notification）的形式实现，通过反射等机制来协调各功能。\n![](/post/iOS/Other/Introduction-MyFramework-1.png)\n\n### MVVM变种\n​\t这个(自己定的名字)是主要使用的，一个类似MVMCV但严格上来说不属于MVMCV框架的框架。与之的主要区别是View-Model的组织，我目前在VM（View-Model）中放置了部分业务逻辑，少量的业务逻辑还是在C（Controller）中。主要原因是目前iOS前端移动应用由我一人进行承担，部分业务逻辑放在Controller中一定程度上可以加快开发速度（应该是错觉，反正我说了算）。这里主要提一点就是 **pod** 的使用，她解决了很大的APP适配问题。\n\n### MVMCV\n​\t目前使用这个框架开发过聊天功能界面。感觉多人合作的时候这个框架还是非常清晰的；从工作分配到代码编写、问题调查，实在是找不出拒绝她的理由。\n\n### 总结\n​\t虽然目前主要使用MVVM的一种变种形式，将View-Model中的逻辑进行了初步的分类。但后续过程中，我还是会向MVMCV结构变更的，因为现在已经尝到了MVMCV结构的甜头。\n","source":"_posts/iOS_develop_overview_framework_2.md","raw":"---\nlayout:     post\ntitle:      浅谈iOS框架\ndate:       2016-12-21 23:50:12\nauthor:     liangtong\ncatalog: true\ncategories: iOS\ntags: 随笔 \n\n---\n\n\n记录下个人从事iOS开发过程中，使用过的程序框架，谈谈个人的理解。\n\n\n\n### 前言\n​\t回顾最近三年，我主要从事iOS前端开发工作。一个一无所知的摸石头过河，慢慢在前端开发的道路上寻找、探索。之前我是做嵌入式开发的，转做iOS前端开发可以说是一个幸运的意外。因为业务需要，看了两个星期的斯坦福大学大学iOS公开课，就开始了我的踩坑、脱坑之旅。这里就聊一聊近3年来iOS前端开发使用的框架吧。\n\n\n<!-- more -->\n\n### MVC\n​\t第一次接触MVC这个框架，是在大三的一门《J2EE》教材的最后一章，当时还沉浸在JSP+Servlet各种组合中，提到这个的时候，因为是接触的第一个框架，所以印象特别深刻，直到后来实习的时候使用Struct框架做了一个管理系统，才算`真正`的理解。后来在斯坦福iOS视频教程中又一次的遇到她。\n概念不用再赘述，当时主要是使用Xib+ObjC开发。鉴于应用本身的弱Model，当时的整个应用看起来都是ViewController。文件组织特别的乱，结果就是很不好维护。在经历了iOS5～iOS10系统的适配后，在代码复用方面，简直是个噩梦！在这里就主要记录下使用她的过程中遇到的问题吧   \n\n* 基础知识不熟练。   \n* 零基础的代码编写，主要精力放在了逻辑编写上，很少关注代码结构。\n* 很多组件使用不规范。虽然UI上达到了效果。   \n* 第三方库的使用。直接拖拽、修改代码。\n* 系统不熟悉，等。\n\n以上很多因素，最终导致了App的ViewController特别臃肿，且页面间组织关系不好梳理，代码复用等这里真心无力再吐槽了。期间界面组织方式有`StoryBoard+ObjC`、`Xib+ObjC`和`ObjC纯代码`，开发的应用包括《效率助手》、《知识库》、《因泰在线》，使用该框架过程中对其结构进行了调整，和后边的MVVM框架思想类似。\n\n\n### MVVM\n​\t对于这个框架，感觉是先使用后，才了解到其概念的。先使用的主要原因是MVC的Controller太过庞大，且维护起来很不容易。很多逻辑感觉不应该放到控制器中，所以将Controller进行了分割，使用起来确实解决了代码复用问题，程序结构变得清晰起来。使用该框架开发的应用包括《数据采集》、《路桥在线》等。因为在查询框架资料时，使用的和这个不谋而合。所以这个框架使用的周期相对较短。\n\n### 自定义框架\n​\t之前主要从事嵌入式开发，对某个车载导航产品的结构比较熟悉，所以就仿造她自己编写了一套框架，主要为了解决代码分类。层级结构包括：界面展示层HMI、交互层PF、数据传输层HMI-Core、核心功能层FunctionCore、数据持有层Model、共同层Common等，功能模块横向纵向通过Symbol（Event或者Notification）的形式实现，通过反射等机制来协调各功能。\n![](/post/iOS/Other/Introduction-MyFramework-1.png)\n\n### MVVM变种\n​\t这个(自己定的名字)是主要使用的，一个类似MVMCV但严格上来说不属于MVMCV框架的框架。与之的主要区别是View-Model的组织，我目前在VM（View-Model）中放置了部分业务逻辑，少量的业务逻辑还是在C（Controller）中。主要原因是目前iOS前端移动应用由我一人进行承担，部分业务逻辑放在Controller中一定程度上可以加快开发速度（应该是错觉，反正我说了算）。这里主要提一点就是 **pod** 的使用，她解决了很大的APP适配问题。\n\n### MVMCV\n​\t目前使用这个框架开发过聊天功能界面。感觉多人合作的时候这个框架还是非常清晰的；从工作分配到代码编写、问题调查，实在是找不出拒绝她的理由。\n\n### 总结\n​\t虽然目前主要使用MVVM的一种变种形式，将View-Model中的逻辑进行了初步的分类。但后续过程中，我还是会向MVMCV结构变更的，因为现在已经尝到了MVMCV结构的甜头。\n","slug":"iOS_develop_overview_framework_2","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4v1004foko8hfxztlkl","content":"<p>记录下个人从事iOS开发过程中，使用过的程序框架，谈谈个人的理解。</p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>​    回顾最近三年，我主要从事iOS前端开发工作。一个一无所知的摸石头过河，慢慢在前端开发的道路上寻找、探索。之前我是做嵌入式开发的，转做iOS前端开发可以说是一个幸运的意外。因为业务需要，看了两个星期的斯坦福大学大学iOS公开课，就开始了我的踩坑、脱坑之旅。这里就聊一聊近3年来iOS前端开发使用的框架吧。</p>\n<a id=\"more\"></a>\n<h3 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h3><p>​    第一次接触MVC这个框架，是在大三的一门《J2EE》教材的最后一章，当时还沉浸在JSP+Servlet各种组合中，提到这个的时候，因为是接触的第一个框架，所以印象特别深刻，直到后来实习的时候使用Struct框架做了一个管理系统，才算<code>真正</code>的理解。后来在斯坦福iOS视频教程中又一次的遇到她。<br>概念不用再赘述，当时主要是使用Xib+ObjC开发。鉴于应用本身的弱Model，当时的整个应用看起来都是ViewController。文件组织特别的乱，结果就是很不好维护。在经历了iOS5～iOS10系统的适配后，在代码复用方面，简直是个噩梦！在这里就主要记录下使用她的过程中遇到的问题吧   </p>\n<ul>\n<li>基础知识不熟练。   </li>\n<li>零基础的代码编写，主要精力放在了逻辑编写上，很少关注代码结构。</li>\n<li>很多组件使用不规范。虽然UI上达到了效果。   </li>\n<li>第三方库的使用。直接拖拽、修改代码。</li>\n<li>系统不熟悉，等。</li>\n</ul>\n<p>以上很多因素，最终导致了App的ViewController特别臃肿，且页面间组织关系不好梳理，代码复用等这里真心无力再吐槽了。期间界面组织方式有<code>StoryBoard+ObjC</code>、<code>Xib+ObjC</code>和<code>ObjC纯代码</code>，开发的应用包括《效率助手》、《知识库》、《因泰在线》，使用该框架过程中对其结构进行了调整，和后边的MVVM框架思想类似。</p>\n<h3 id=\"MVVM\"><a href=\"#MVVM\" class=\"headerlink\" title=\"MVVM\"></a>MVVM</h3><p>​    对于这个框架，感觉是先使用后，才了解到其概念的。先使用的主要原因是MVC的Controller太过庞大，且维护起来很不容易。很多逻辑感觉不应该放到控制器中，所以将Controller进行了分割，使用起来确实解决了代码复用问题，程序结构变得清晰起来。使用该框架开发的应用包括《数据采集》、《路桥在线》等。因为在查询框架资料时，使用的和这个不谋而合。所以这个框架使用的周期相对较短。</p>\n<h3 id=\"自定义框架\"><a href=\"#自定义框架\" class=\"headerlink\" title=\"自定义框架\"></a>自定义框架</h3><p>​    之前主要从事嵌入式开发，对某个车载导航产品的结构比较熟悉，所以就仿造她自己编写了一套框架，主要为了解决代码分类。层级结构包括：界面展示层HMI、交互层PF、数据传输层HMI-Core、核心功能层FunctionCore、数据持有层Model、共同层Common等，功能模块横向纵向通过Symbol（Event或者Notification）的形式实现，通过反射等机制来协调各功能。<br><img src=\"/post/iOS/Other/Introduction-MyFramework-1.png\" alt=\"\"></p>\n<h3 id=\"MVVM变种\"><a href=\"#MVVM变种\" class=\"headerlink\" title=\"MVVM变种\"></a>MVVM变种</h3><p>​    这个(自己定的名字)是主要使用的，一个类似MVMCV但严格上来说不属于MVMCV框架的框架。与之的主要区别是View-Model的组织，我目前在VM（View-Model）中放置了部分业务逻辑，少量的业务逻辑还是在C（Controller）中。主要原因是目前iOS前端移动应用由我一人进行承担，部分业务逻辑放在Controller中一定程度上可以加快开发速度（应该是错觉，反正我说了算）。这里主要提一点就是 <strong>pod</strong> 的使用，她解决了很大的APP适配问题。</p>\n<h3 id=\"MVMCV\"><a href=\"#MVMCV\" class=\"headerlink\" title=\"MVMCV\"></a>MVMCV</h3><p>​    目前使用这个框架开发过聊天功能界面。感觉多人合作的时候这个框架还是非常清晰的；从工作分配到代码编写、问题调查，实在是找不出拒绝她的理由。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>​    虽然目前主要使用MVVM的一种变种形式，将View-Model中的逻辑进行了初步的分类。但后续过程中，我还是会向MVMCV结构变更的，因为现在已经尝到了MVMCV结构的甜头。</p>\n","site":{"data":{}},"excerpt":"<p>记录下个人从事iOS开发过程中，使用过的程序框架，谈谈个人的理解。</p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>​    回顾最近三年，我主要从事iOS前端开发工作。一个一无所知的摸石头过河，慢慢在前端开发的道路上寻找、探索。之前我是做嵌入式开发的，转做iOS前端开发可以说是一个幸运的意外。因为业务需要，看了两个星期的斯坦福大学大学iOS公开课，就开始了我的踩坑、脱坑之旅。这里就聊一聊近3年来iOS前端开发使用的框架吧。</p>","more":"<h3 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h3><p>​    第一次接触MVC这个框架，是在大三的一门《J2EE》教材的最后一章，当时还沉浸在JSP+Servlet各种组合中，提到这个的时候，因为是接触的第一个框架，所以印象特别深刻，直到后来实习的时候使用Struct框架做了一个管理系统，才算<code>真正</code>的理解。后来在斯坦福iOS视频教程中又一次的遇到她。<br>概念不用再赘述，当时主要是使用Xib+ObjC开发。鉴于应用本身的弱Model，当时的整个应用看起来都是ViewController。文件组织特别的乱，结果就是很不好维护。在经历了iOS5～iOS10系统的适配后，在代码复用方面，简直是个噩梦！在这里就主要记录下使用她的过程中遇到的问题吧   </p>\n<ul>\n<li>基础知识不熟练。   </li>\n<li>零基础的代码编写，主要精力放在了逻辑编写上，很少关注代码结构。</li>\n<li>很多组件使用不规范。虽然UI上达到了效果。   </li>\n<li>第三方库的使用。直接拖拽、修改代码。</li>\n<li>系统不熟悉，等。</li>\n</ul>\n<p>以上很多因素，最终导致了App的ViewController特别臃肿，且页面间组织关系不好梳理，代码复用等这里真心无力再吐槽了。期间界面组织方式有<code>StoryBoard+ObjC</code>、<code>Xib+ObjC</code>和<code>ObjC纯代码</code>，开发的应用包括《效率助手》、《知识库》、《因泰在线》，使用该框架过程中对其结构进行了调整，和后边的MVVM框架思想类似。</p>\n<h3 id=\"MVVM\"><a href=\"#MVVM\" class=\"headerlink\" title=\"MVVM\"></a>MVVM</h3><p>​    对于这个框架，感觉是先使用后，才了解到其概念的。先使用的主要原因是MVC的Controller太过庞大，且维护起来很不容易。很多逻辑感觉不应该放到控制器中，所以将Controller进行了分割，使用起来确实解决了代码复用问题，程序结构变得清晰起来。使用该框架开发的应用包括《数据采集》、《路桥在线》等。因为在查询框架资料时，使用的和这个不谋而合。所以这个框架使用的周期相对较短。</p>\n<h3 id=\"自定义框架\"><a href=\"#自定义框架\" class=\"headerlink\" title=\"自定义框架\"></a>自定义框架</h3><p>​    之前主要从事嵌入式开发，对某个车载导航产品的结构比较熟悉，所以就仿造她自己编写了一套框架，主要为了解决代码分类。层级结构包括：界面展示层HMI、交互层PF、数据传输层HMI-Core、核心功能层FunctionCore、数据持有层Model、共同层Common等，功能模块横向纵向通过Symbol（Event或者Notification）的形式实现，通过反射等机制来协调各功能。<br><img src=\"/post/iOS/Other/Introduction-MyFramework-1.png\" alt=\"\"></p>\n<h3 id=\"MVVM变种\"><a href=\"#MVVM变种\" class=\"headerlink\" title=\"MVVM变种\"></a>MVVM变种</h3><p>​    这个(自己定的名字)是主要使用的，一个类似MVMCV但严格上来说不属于MVMCV框架的框架。与之的主要区别是View-Model的组织，我目前在VM（View-Model）中放置了部分业务逻辑，少量的业务逻辑还是在C（Controller）中。主要原因是目前iOS前端移动应用由我一人进行承担，部分业务逻辑放在Controller中一定程度上可以加快开发速度（应该是错觉，反正我说了算）。这里主要提一点就是 <strong>pod</strong> 的使用，她解决了很大的APP适配问题。</p>\n<h3 id=\"MVMCV\"><a href=\"#MVMCV\" class=\"headerlink\" title=\"MVMCV\"></a>MVMCV</h3><p>​    目前使用这个框架开发过聊天功能界面。感觉多人合作的时候这个框架还是非常清晰的；从工作分配到代码编写、问题调查，实在是找不出拒绝她的理由。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>​    虽然目前主要使用MVVM的一种变种形式，将View-Model中的逻辑进行了初步的分类。但后续过程中，我还是会向MVMCV结构变更的，因为现在已经尝到了MVMCV结构的甜头。</p>"},{"layout":"post","title":"Xcode9中TableViewCell高度自适应","date":"2017-11-01T07:51:43.000Z","author":"liangtong","catalog":true,"_content":"\n\n\n​        前几天升级了Xcode9后，在对一个项目进行调试时突然发现有个使用UITableView的自定义Cell展示异常了，然后控制台报了一大堆的约束警告。\n\n```Objective-C\n    \"<NSLayoutConstraint:0x60c0000977f0 UIView:0x7fbb8c7841d0.bottom == UILabel:0x7fbb8c7870e0.bottom + 8>\",\n    \"<NSLayoutConstraint:0x60c0000979d0 UIView:0x7fbb8c7841d0.top == UITableViewCellContentView:0x7fbb8c781b70.top>\",\n    \"<NSLayoutConstraint:0x60c000097a70 UITableViewCellContentView:0x7fbb8c781b70.bottom == UIView:0x7fbb8c7841d0.bottom + 2>\",\n    \"<NSLayoutConstraint:0x60c000098bf0 UITableViewCellContentView:0x7fbb8c781b70.height == 44>\"\n```\n\n从log上看，觉得应该是tableview的高度设置有问题。于是查看对应 **Controller** 相关代码。\n\n```Objective-C\n    //注册自定义TableViewCell\n    [self.tableView registerNib:[UINib nibWithNibName:@\"GKProjectSearchHeaderFilterView\" bundle:nil] forHeaderFooterViewReuseIdentifier:GKProjectSearchHeaderFilterViewIdentifier];\n    self.tableView.separatorStyle = UITableViewCellSeparatorStyleNone;\n    self.tableView.estimatedRowHeight = 60.0f;\n```\n\n### rowHeight\n\n代码没有问题，无奈点开UITableView文件进行查看，发现还有个 **rowHeight** 属性，印象中之前如果使用 **estimatedRowHeight** 时不设置 **rowHeight** 也没有影响。考虑到log信息，决定添加上该属性设置\n\n```Objective-C\n    self.tableView.rowHeight = UITableViewAutomaticDimension;\n```\n\n界面表现正常！\n\n如果不设置 **rowHeight** 属性时，实现 **UITableViewDelegate** 协议的方法也可以，但是 **从性能方面考虑，不建议使用协议的方式** 。\n\n```Objective-C\n-(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath{\n    return UITableViewAutomaticDimension;\n}\n```\n\n\n### 结论\n\n应该是Xcode9在处理UITableView时，对属性 **rowHeight** 的支持出现了问题。以下摘自UIKit中源码。\n\n```Objective-C\n@property (nonatomic) CGFloat rowHeight;             // default is UITableViewAutomaticDimension\n```\n\n注释中提到该属性的默认值就是UITableViewAutomaticDimension。\n\n\n\n","source":"_posts/iOS_develop_problem_xcode9__tableview.md","raw":"---\nlayout:     post\ntitle:      Xcode9中TableViewCell高度自适应\ndate:       2017-11-01 15:51:43\nauthor:     liangtong\ncatalog: true\ncategories: iOS\ntags: 问题记录\n\n---\n\n\n\n​        前几天升级了Xcode9后，在对一个项目进行调试时突然发现有个使用UITableView的自定义Cell展示异常了，然后控制台报了一大堆的约束警告。\n\n```Objective-C\n    \"<NSLayoutConstraint:0x60c0000977f0 UIView:0x7fbb8c7841d0.bottom == UILabel:0x7fbb8c7870e0.bottom + 8>\",\n    \"<NSLayoutConstraint:0x60c0000979d0 UIView:0x7fbb8c7841d0.top == UITableViewCellContentView:0x7fbb8c781b70.top>\",\n    \"<NSLayoutConstraint:0x60c000097a70 UITableViewCellContentView:0x7fbb8c781b70.bottom == UIView:0x7fbb8c7841d0.bottom + 2>\",\n    \"<NSLayoutConstraint:0x60c000098bf0 UITableViewCellContentView:0x7fbb8c781b70.height == 44>\"\n```\n\n从log上看，觉得应该是tableview的高度设置有问题。于是查看对应 **Controller** 相关代码。\n\n```Objective-C\n    //注册自定义TableViewCell\n    [self.tableView registerNib:[UINib nibWithNibName:@\"GKProjectSearchHeaderFilterView\" bundle:nil] forHeaderFooterViewReuseIdentifier:GKProjectSearchHeaderFilterViewIdentifier];\n    self.tableView.separatorStyle = UITableViewCellSeparatorStyleNone;\n    self.tableView.estimatedRowHeight = 60.0f;\n```\n\n### rowHeight\n\n代码没有问题，无奈点开UITableView文件进行查看，发现还有个 **rowHeight** 属性，印象中之前如果使用 **estimatedRowHeight** 时不设置 **rowHeight** 也没有影响。考虑到log信息，决定添加上该属性设置\n\n```Objective-C\n    self.tableView.rowHeight = UITableViewAutomaticDimension;\n```\n\n界面表现正常！\n\n如果不设置 **rowHeight** 属性时，实现 **UITableViewDelegate** 协议的方法也可以，但是 **从性能方面考虑，不建议使用协议的方式** 。\n\n```Objective-C\n-(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath{\n    return UITableViewAutomaticDimension;\n}\n```\n\n\n### 结论\n\n应该是Xcode9在处理UITableView时，对属性 **rowHeight** 的支持出现了问题。以下摘自UIKit中源码。\n\n```Objective-C\n@property (nonatomic) CGFloat rowHeight;             // default is UITableViewAutomaticDimension\n```\n\n注释中提到该属性的默认值就是UITableViewAutomaticDimension。\n\n\n\n","slug":"iOS_develop_problem_xcode9__tableview","published":1,"updated":"2017-11-23T02:11:43.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4v2004ioko8vjgqbks3","content":"<p>​        前几天升级了Xcode9后，在对一个项目进行调试时突然发现有个使用UITableView的自定义Cell展示异常了，然后控制台报了一大堆的约束警告。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;&lt;NSLayoutConstraint:0x60c0000977f0 UIView:0x7fbb8c7841d0.bottom == UILabel:0x7fbb8c7870e0.bottom + 8&gt;&quot;,</div><div class=\"line\">&quot;&lt;NSLayoutConstraint:0x60c0000979d0 UIView:0x7fbb8c7841d0.top == UITableViewCellContentView:0x7fbb8c781b70.top&gt;&quot;,</div><div class=\"line\">&quot;&lt;NSLayoutConstraint:0x60c000097a70 UITableViewCellContentView:0x7fbb8c781b70.bottom == UIView:0x7fbb8c7841d0.bottom + 2&gt;&quot;,</div><div class=\"line\">&quot;&lt;NSLayoutConstraint:0x60c000098bf0 UITableViewCellContentView:0x7fbb8c781b70.height == 44&gt;&quot;</div></pre></td></tr></table></figure>\n<p>从log上看，觉得应该是tableview的高度设置有问题。于是查看对应 <strong>Controller</strong> 相关代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//注册自定义TableViewCell</div><div class=\"line\">[self.tableView registerNib:[UINib nibWithNibName:@&quot;GKProjectSearchHeaderFilterView&quot; bundle:nil] forHeaderFooterViewReuseIdentifier:GKProjectSearchHeaderFilterViewIdentifier];</div><div class=\"line\">self.tableView.separatorStyle = UITableViewCellSeparatorStyleNone;</div><div class=\"line\">self.tableView.estimatedRowHeight = 60.0f;</div></pre></td></tr></table></figure>\n<h3 id=\"rowHeight\"><a href=\"#rowHeight\" class=\"headerlink\" title=\"rowHeight\"></a>rowHeight</h3><p>代码没有问题，无奈点开UITableView文件进行查看，发现还有个 <strong>rowHeight</strong> 属性，印象中之前如果使用 <strong>estimatedRowHeight</strong> 时不设置 <strong>rowHeight</strong> 也没有影响。考虑到log信息，决定添加上该属性设置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">self.tableView.rowHeight = UITableViewAutomaticDimension;</div></pre></td></tr></table></figure>\n<p>界面表现正常！</p>\n<p>如果不设置 <strong>rowHeight</strong> 属性时，实现 <strong>UITableViewDelegate</strong> 协议的方法也可以，但是 <strong>从性能方面考虑，不建议使用协议的方式</strong> 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123;</div><div class=\"line\">    return UITableViewAutomaticDimension;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>应该是Xcode9在处理UITableView时，对属性 <strong>rowHeight</strong> 的支持出现了问题。以下摘自UIKit中源码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property (nonatomic) CGFloat rowHeight;             // default is UITableViewAutomaticDimension</div></pre></td></tr></table></figure>\n<p>注释中提到该属性的默认值就是UITableViewAutomaticDimension。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>​        前几天升级了Xcode9后，在对一个项目进行调试时突然发现有个使用UITableView的自定义Cell展示异常了，然后控制台报了一大堆的约束警告。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;&lt;NSLayoutConstraint:0x60c0000977f0 UIView:0x7fbb8c7841d0.bottom == UILabel:0x7fbb8c7870e0.bottom + 8&gt;&quot;,</div><div class=\"line\">&quot;&lt;NSLayoutConstraint:0x60c0000979d0 UIView:0x7fbb8c7841d0.top == UITableViewCellContentView:0x7fbb8c781b70.top&gt;&quot;,</div><div class=\"line\">&quot;&lt;NSLayoutConstraint:0x60c000097a70 UITableViewCellContentView:0x7fbb8c781b70.bottom == UIView:0x7fbb8c7841d0.bottom + 2&gt;&quot;,</div><div class=\"line\">&quot;&lt;NSLayoutConstraint:0x60c000098bf0 UITableViewCellContentView:0x7fbb8c781b70.height == 44&gt;&quot;</div></pre></td></tr></table></figure>\n<p>从log上看，觉得应该是tableview的高度设置有问题。于是查看对应 <strong>Controller</strong> 相关代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//注册自定义TableViewCell</div><div class=\"line\">[self.tableView registerNib:[UINib nibWithNibName:@&quot;GKProjectSearchHeaderFilterView&quot; bundle:nil] forHeaderFooterViewReuseIdentifier:GKProjectSearchHeaderFilterViewIdentifier];</div><div class=\"line\">self.tableView.separatorStyle = UITableViewCellSeparatorStyleNone;</div><div class=\"line\">self.tableView.estimatedRowHeight = 60.0f;</div></pre></td></tr></table></figure>\n<h3 id=\"rowHeight\"><a href=\"#rowHeight\" class=\"headerlink\" title=\"rowHeight\"></a>rowHeight</h3><p>代码没有问题，无奈点开UITableView文件进行查看，发现还有个 <strong>rowHeight</strong> 属性，印象中之前如果使用 <strong>estimatedRowHeight</strong> 时不设置 <strong>rowHeight</strong> 也没有影响。考虑到log信息，决定添加上该属性设置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">self.tableView.rowHeight = UITableViewAutomaticDimension;</div></pre></td></tr></table></figure>\n<p>界面表现正常！</p>\n<p>如果不设置 <strong>rowHeight</strong> 属性时，实现 <strong>UITableViewDelegate</strong> 协议的方法也可以，但是 <strong>从性能方面考虑，不建议使用协议的方式</strong> 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123;</div><div class=\"line\">    return UITableViewAutomaticDimension;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>应该是Xcode9在处理UITableView时，对属性 <strong>rowHeight</strong> 的支持出现了问题。以下摘自UIKit中源码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property (nonatomic) CGFloat rowHeight;             // default is UITableViewAutomaticDimension</div></pre></td></tr></table></figure>\n<p>注释中提到该属性的默认值就是UITableViewAutomaticDimension。</p>\n"},{"layout":"post","title":"ViewController Life-Circle","date":"2016-10-25T14:16:32.000Z","catalog":true,"_content":"\n\n对ViewController生命周期进行介绍，同时会说一些曾经遇到过的坑及注意事项\n\n\n\n### 前言\n​\t这部分其实没啥好说的，苹果UIViewController接口文档对各个接口的描述写的很详细。\n​\t在视图的生命周期中，我曾经出问题的地方包括是UI表现异常；通知监听与释放没有成对出现；异步闭包回调引起的循环引用的资源无法释放；`__weak`和`__strong`问题导致的程序闪退等。这里就是把这些坑给记下来，（如果你碰巧）遇到这类问题后不会感到莫名其妙。\n\n<!-- more -->\n\n### UIViewController的生命周期\n\n> 视图出现的时候调用顺序\n\n\t- (void)viewDidLoad; // Called after the view has been loaded.just once\n\t\n\t- (void)viewWillAppear:(BOOL)animated;    // Called when the view is about to made visible. Default does nothing\n\t\n\t// Called just before the view controller's view's layoutSubviews method is invoked. Subclasses can implement as necessary. The default is a nop.\n\t- (void)viewWillLayoutSubviews NS_AVAILABLE_IOS(5_0);\n\t\n\t// Called just after the view controller's view's layoutSubviews method is invoked. Subclasses can implement as necessary. The default is a nop.\n\t- (void)viewDidLayoutSubviews NS_AVAILABLE_IOS(5_0);\n\t\n\t- (void)viewDidAppear:(BOOL)animated;     // Called when the view has been fully transitioned onto the screen. Default does nothing\n\n---\n\n> 视图离开屏幕的时候调用顺序\n\n\t- (void)viewWillDisappear:(BOOL)animated; // Called when the view is dismissed, covered or otherwise hidden. Default does nothing\n\t\n\t- (void)viewDidDisappear:(BOOL)animated;  // Called after the view was dismissed, covered or otherwise hidden. Default does nothing\n\n\n\n\n### 说明及最佳实践\n\n```Objective-C\n- (void)viewDidLoad；  \n```\n\n> 很常用、很重要的方法，只是在APP页面加载的时候调用一次，以后不会再调用了。\n> 通常做一些`初始化设置`，但是UI相关的设置不要放在这里\n> 当然，iOS6之前早期系统上，没有AutoLayout，使用绝对布局在这里更新UI问题不大\n>\n> \n\n\n```Objective-C\n- (void)viewWillAppear:(BOOL)animated；  \n```\n\n> 视图即将出现在屏幕上，会调用该方法。\n> 重写该方法，可以做一些`UI相关设置`，以及KVO监听之类操作\n> 当APP视图间进行切换的时候，也会调用该方法\n>\n> \n\n```Objective-C\n- (void)viewWillLayoutSubviews；  \n```\n\n> 在viewWillAppare后调用，将要对子视图进行布局\n>\n> \n\n\n```Objective-C\n- (void) viewDidLayoutSubviews；  \n```\n\n> 已经布局完成子视图\n>\n> \n\n\n```Objective-C\n- (void)viewDidAppear:(BOOL)animated；  \n```\n\n> 视图出现在屏幕上，会调用该方法。\n> 重写该方法，可以做一些*UI更新设置*\n>\n> \n\n```Objective-C\n - (void)viewWillDisappear:(BOOL)animated；  \n```\n\n> 视图变换，即将离开屏幕时，会调用该方法。\n> 重写该方法，做一些善后的处理工作，比如持久化处理、移除KVO监听之类的\n>\n> \n\n```Objective-C\n - (void)viewDidDisappear:(BOOL)animated；  \n```\n\n> 视图变换，离开屏幕时，会调用该方法。\n> 重写该方法，对已消失的视图做一些操作，比如释放资源\n>\n> \n\n\n### 补充\n\n* UI表示异常的话，多半是在不正确的时机调用了UI相关设置。\n\n* 资源释放，尤其涉及视频、监听相关内容。\n\n* 异步操作，涉及闭包，协议等操作时，要谨慎。\n  * 例如：使用`__weakSelf`和`__strongSelf`打破循环引用\n  * 例如：使用@selector前要判断\n\n* 其他\n\n  ​\n\n### 后记\n\n​\t在这里遇到问题的话，一定要静下心。举个例子，比如你在viewDidLoad方法内有关于某个对象的回调处理。\n\n```Objective-C\n    _obj.testBlock = ^(){\n        //your test block process\n    };\n```\n\n但是实际开发中没有触发。可以从以下几个方向去调查：\n* _obj对应类/结构体中是否会调用（绑定）该闭包；\n* _obj的作用域：是全局的还是堆栈的；\n* 该闭包是否在其他地方进行了设置；\n* 其他。\n\n\n>\n>\n>\n>\n\n\n\n","source":"_posts/iOS_develop_viewController_life_circle.md","raw":"---\nlayout:     post\ntitle:      ViewController Life-Circle\ndate:       2016-10-25 22:16:32\ncatalog: true\ncategories: iOS\ntags: 随笔 \n\n---\n\n\n对ViewController生命周期进行介绍，同时会说一些曾经遇到过的坑及注意事项\n\n\n\n### 前言\n​\t这部分其实没啥好说的，苹果UIViewController接口文档对各个接口的描述写的很详细。\n​\t在视图的生命周期中，我曾经出问题的地方包括是UI表现异常；通知监听与释放没有成对出现；异步闭包回调引起的循环引用的资源无法释放；`__weak`和`__strong`问题导致的程序闪退等。这里就是把这些坑给记下来，（如果你碰巧）遇到这类问题后不会感到莫名其妙。\n\n<!-- more -->\n\n### UIViewController的生命周期\n\n> 视图出现的时候调用顺序\n\n\t- (void)viewDidLoad; // Called after the view has been loaded.just once\n\t\n\t- (void)viewWillAppear:(BOOL)animated;    // Called when the view is about to made visible. Default does nothing\n\t\n\t// Called just before the view controller's view's layoutSubviews method is invoked. Subclasses can implement as necessary. The default is a nop.\n\t- (void)viewWillLayoutSubviews NS_AVAILABLE_IOS(5_0);\n\t\n\t// Called just after the view controller's view's layoutSubviews method is invoked. Subclasses can implement as necessary. The default is a nop.\n\t- (void)viewDidLayoutSubviews NS_AVAILABLE_IOS(5_0);\n\t\n\t- (void)viewDidAppear:(BOOL)animated;     // Called when the view has been fully transitioned onto the screen. Default does nothing\n\n---\n\n> 视图离开屏幕的时候调用顺序\n\n\t- (void)viewWillDisappear:(BOOL)animated; // Called when the view is dismissed, covered or otherwise hidden. Default does nothing\n\t\n\t- (void)viewDidDisappear:(BOOL)animated;  // Called after the view was dismissed, covered or otherwise hidden. Default does nothing\n\n\n\n\n### 说明及最佳实践\n\n```Objective-C\n- (void)viewDidLoad；  \n```\n\n> 很常用、很重要的方法，只是在APP页面加载的时候调用一次，以后不会再调用了。\n> 通常做一些`初始化设置`，但是UI相关的设置不要放在这里\n> 当然，iOS6之前早期系统上，没有AutoLayout，使用绝对布局在这里更新UI问题不大\n>\n> \n\n\n```Objective-C\n- (void)viewWillAppear:(BOOL)animated；  \n```\n\n> 视图即将出现在屏幕上，会调用该方法。\n> 重写该方法，可以做一些`UI相关设置`，以及KVO监听之类操作\n> 当APP视图间进行切换的时候，也会调用该方法\n>\n> \n\n```Objective-C\n- (void)viewWillLayoutSubviews；  \n```\n\n> 在viewWillAppare后调用，将要对子视图进行布局\n>\n> \n\n\n```Objective-C\n- (void) viewDidLayoutSubviews；  \n```\n\n> 已经布局完成子视图\n>\n> \n\n\n```Objective-C\n- (void)viewDidAppear:(BOOL)animated；  \n```\n\n> 视图出现在屏幕上，会调用该方法。\n> 重写该方法，可以做一些*UI更新设置*\n>\n> \n\n```Objective-C\n - (void)viewWillDisappear:(BOOL)animated；  \n```\n\n> 视图变换，即将离开屏幕时，会调用该方法。\n> 重写该方法，做一些善后的处理工作，比如持久化处理、移除KVO监听之类的\n>\n> \n\n```Objective-C\n - (void)viewDidDisappear:(BOOL)animated；  \n```\n\n> 视图变换，离开屏幕时，会调用该方法。\n> 重写该方法，对已消失的视图做一些操作，比如释放资源\n>\n> \n\n\n### 补充\n\n* UI表示异常的话，多半是在不正确的时机调用了UI相关设置。\n\n* 资源释放，尤其涉及视频、监听相关内容。\n\n* 异步操作，涉及闭包，协议等操作时，要谨慎。\n  * 例如：使用`__weakSelf`和`__strongSelf`打破循环引用\n  * 例如：使用@selector前要判断\n\n* 其他\n\n  ​\n\n### 后记\n\n​\t在这里遇到问题的话，一定要静下心。举个例子，比如你在viewDidLoad方法内有关于某个对象的回调处理。\n\n```Objective-C\n    _obj.testBlock = ^(){\n        //your test block process\n    };\n```\n\n但是实际开发中没有触发。可以从以下几个方向去调查：\n* _obj对应类/结构体中是否会调用（绑定）该闭包；\n* _obj的作用域：是全局的还是堆栈的；\n* 该闭包是否在其他地方进行了设置；\n* 其他。\n\n\n>\n>\n>\n>\n\n\n\n","slug":"iOS_develop_viewController_life_circle","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4v3004loko8jsyphqxm","content":"<p>对ViewController生命周期进行介绍，同时会说一些曾经遇到过的坑及注意事项</p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>​    这部分其实没啥好说的，苹果UIViewController接口文档对各个接口的描述写的很详细。<br>​    在视图的生命周期中，我曾经出问题的地方包括是UI表现异常；通知监听与释放没有成对出现；异步闭包回调引起的循环引用的资源无法释放；<code>__weak</code>和<code>__strong</code>问题导致的程序闪退等。这里就是把这些坑给记下来，（如果你碰巧）遇到这类问题后不会感到莫名其妙。</p>\n<a id=\"more\"></a>\n<h3 id=\"UIViewController的生命周期\"><a href=\"#UIViewController的生命周期\" class=\"headerlink\" title=\"UIViewController的生命周期\"></a>UIViewController的生命周期</h3><blockquote>\n<p>视图出现的时候调用顺序</p>\n</blockquote>\n<pre><code>- (void)viewDidLoad; // Called after the view has been loaded.just once\n\n- (void)viewWillAppear:(BOOL)animated;    // Called when the view is about to made visible. Default does nothing\n\n// Called just before the view controller&apos;s view&apos;s layoutSubviews method is invoked. Subclasses can implement as necessary. The default is a nop.\n- (void)viewWillLayoutSubviews NS_AVAILABLE_IOS(5_0);\n\n// Called just after the view controller&apos;s view&apos;s layoutSubviews method is invoked. Subclasses can implement as necessary. The default is a nop.\n- (void)viewDidLayoutSubviews NS_AVAILABLE_IOS(5_0);\n\n- (void)viewDidAppear:(BOOL)animated;     // Called when the view has been fully transitioned onto the screen. Default does nothing\n</code></pre><hr>\n<blockquote>\n<p>视图离开屏幕的时候调用顺序</p>\n</blockquote>\n<pre><code>- (void)viewWillDisappear:(BOOL)animated; // Called when the view is dismissed, covered or otherwise hidden. Default does nothing\n\n- (void)viewDidDisappear:(BOOL)animated;  // Called after the view was dismissed, covered or otherwise hidden. Default does nothing\n</code></pre><h3 id=\"说明及最佳实践\"><a href=\"#说明及最佳实践\" class=\"headerlink\" title=\"说明及最佳实践\"></a>说明及最佳实践</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad；</div></pre></td></tr></table></figure>\n<blockquote>\n<p>很常用、很重要的方法，只是在APP页面加载的时候调用一次，以后不会再调用了。<br>通常做一些<code>初始化设置</code>，但是UI相关的设置不要放在这里<br>当然，iOS6之前早期系统上，没有AutoLayout，使用绝对布局在这里更新UI问题不大</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewWillAppear:(BOOL)animated；</div></pre></td></tr></table></figure>\n<blockquote>\n<p>视图即将出现在屏幕上，会调用该方法。<br>重写该方法，可以做一些<code>UI相关设置</code>，以及KVO监听之类操作<br>当APP视图间进行切换的时候，也会调用该方法</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewWillLayoutSubviews；</div></pre></td></tr></table></figure>\n<blockquote>\n<p>在viewWillAppare后调用，将要对子视图进行布局</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void) viewDidLayoutSubviews；</div></pre></td></tr></table></figure>\n<blockquote>\n<p>已经布局完成子视图</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidAppear:(BOOL)animated；</div></pre></td></tr></table></figure>\n<blockquote>\n<p>视图出现在屏幕上，会调用该方法。<br>重写该方法，可以做一些<em>UI更新设置</em></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewWillDisappear:(BOOL)animated；</div></pre></td></tr></table></figure>\n<blockquote>\n<p>视图变换，即将离开屏幕时，会调用该方法。<br>重写该方法，做一些善后的处理工作，比如持久化处理、移除KVO监听之类的</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidDisappear:(BOOL)animated；</div></pre></td></tr></table></figure>\n<blockquote>\n<p>视图变换，离开屏幕时，会调用该方法。<br>重写该方法，对已消失的视图做一些操作，比如释放资源</p>\n</blockquote>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><ul>\n<li><p>UI表示异常的话，多半是在不正确的时机调用了UI相关设置。</p>\n</li>\n<li><p>资源释放，尤其涉及视频、监听相关内容。</p>\n</li>\n<li><p>异步操作，涉及闭包，协议等操作时，要谨慎。</p>\n<ul>\n<li>例如：使用<code>__weakSelf</code>和<code>__strongSelf</code>打破循环引用</li>\n<li>例如：使用@selector前要判断</li>\n</ul>\n</li>\n<li><p>其他</p>\n<p>​</p>\n</li>\n</ul>\n<h3 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h3><p>​    在这里遇到问题的话，一定要静下心。举个例子，比如你在viewDidLoad方法内有关于某个对象的回调处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">_obj.testBlock = ^()&#123;</div><div class=\"line\">    //your test block process</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>但是实际开发中没有触发。可以从以下几个方向去调查：</p>\n<ul>\n<li>_obj对应类/结构体中是否会调用（绑定）该闭包；</li>\n<li>_obj的作用域：是全局的还是堆栈的；</li>\n<li>该闭包是否在其他地方进行了设置；</li>\n<li>其他。</li>\n</ul>\n<p>&gt;<br>&gt;<br>&gt;<br>&gt;</p>\n","site":{"data":{}},"excerpt":"<p>对ViewController生命周期进行介绍，同时会说一些曾经遇到过的坑及注意事项</p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>​    这部分其实没啥好说的，苹果UIViewController接口文档对各个接口的描述写的很详细。<br>​    在视图的生命周期中，我曾经出问题的地方包括是UI表现异常；通知监听与释放没有成对出现；异步闭包回调引起的循环引用的资源无法释放；<code>__weak</code>和<code>__strong</code>问题导致的程序闪退等。这里就是把这些坑给记下来，（如果你碰巧）遇到这类问题后不会感到莫名其妙。</p>","more":"<h3 id=\"UIViewController的生命周期\"><a href=\"#UIViewController的生命周期\" class=\"headerlink\" title=\"UIViewController的生命周期\"></a>UIViewController的生命周期</h3><blockquote>\n<p>视图出现的时候调用顺序</p>\n</blockquote>\n<pre><code>- (void)viewDidLoad; // Called after the view has been loaded.just once\n\n- (void)viewWillAppear:(BOOL)animated;    // Called when the view is about to made visible. Default does nothing\n\n// Called just before the view controller&apos;s view&apos;s layoutSubviews method is invoked. Subclasses can implement as necessary. The default is a nop.\n- (void)viewWillLayoutSubviews NS_AVAILABLE_IOS(5_0);\n\n// Called just after the view controller&apos;s view&apos;s layoutSubviews method is invoked. Subclasses can implement as necessary. The default is a nop.\n- (void)viewDidLayoutSubviews NS_AVAILABLE_IOS(5_0);\n\n- (void)viewDidAppear:(BOOL)animated;     // Called when the view has been fully transitioned onto the screen. Default does nothing\n</code></pre><hr>\n<blockquote>\n<p>视图离开屏幕的时候调用顺序</p>\n</blockquote>\n<pre><code>- (void)viewWillDisappear:(BOOL)animated; // Called when the view is dismissed, covered or otherwise hidden. Default does nothing\n\n- (void)viewDidDisappear:(BOOL)animated;  // Called after the view was dismissed, covered or otherwise hidden. Default does nothing\n</code></pre><h3 id=\"说明及最佳实践\"><a href=\"#说明及最佳实践\" class=\"headerlink\" title=\"说明及最佳实践\"></a>说明及最佳实践</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidLoad；</div></pre></td></tr></table></figure>\n<blockquote>\n<p>很常用、很重要的方法，只是在APP页面加载的时候调用一次，以后不会再调用了。<br>通常做一些<code>初始化设置</code>，但是UI相关的设置不要放在这里<br>当然，iOS6之前早期系统上，没有AutoLayout，使用绝对布局在这里更新UI问题不大</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewWillAppear:(BOOL)animated；</div></pre></td></tr></table></figure>\n<blockquote>\n<p>视图即将出现在屏幕上，会调用该方法。<br>重写该方法，可以做一些<code>UI相关设置</code>，以及KVO监听之类操作<br>当APP视图间进行切换的时候，也会调用该方法</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewWillLayoutSubviews；</div></pre></td></tr></table></figure>\n<blockquote>\n<p>在viewWillAppare后调用，将要对子视图进行布局</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void) viewDidLayoutSubviews；</div></pre></td></tr></table></figure>\n<blockquote>\n<p>已经布局完成子视图</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidAppear:(BOOL)animated；</div></pre></td></tr></table></figure>\n<blockquote>\n<p>视图出现在屏幕上，会调用该方法。<br>重写该方法，可以做一些<em>UI更新设置</em></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewWillDisappear:(BOOL)animated；</div></pre></td></tr></table></figure>\n<blockquote>\n<p>视图变换，即将离开屏幕时，会调用该方法。<br>重写该方法，做一些善后的处理工作，比如持久化处理、移除KVO监听之类的</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (void)viewDidDisappear:(BOOL)animated；</div></pre></td></tr></table></figure>\n<blockquote>\n<p>视图变换，离开屏幕时，会调用该方法。<br>重写该方法，对已消失的视图做一些操作，比如释放资源</p>\n</blockquote>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><ul>\n<li><p>UI表示异常的话，多半是在不正确的时机调用了UI相关设置。</p>\n</li>\n<li><p>资源释放，尤其涉及视频、监听相关内容。</p>\n</li>\n<li><p>异步操作，涉及闭包，协议等操作时，要谨慎。</p>\n<ul>\n<li>例如：使用<code>__weakSelf</code>和<code>__strongSelf</code>打破循环引用</li>\n<li>例如：使用@selector前要判断</li>\n</ul>\n</li>\n<li><p>其他</p>\n<p>​</p>\n</li>\n</ul>\n<h3 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h3><p>​    在这里遇到问题的话，一定要静下心。举个例子，比如你在viewDidLoad方法内有关于某个对象的回调处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">_obj.testBlock = ^()&#123;</div><div class=\"line\">    //your test block process</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>但是实际开发中没有触发。可以从以下几个方向去调查：</p>\n<ul>\n<li>_obj对应类/结构体中是否会调用（绑定）该闭包；</li>\n<li>_obj的作用域：是全局的还是堆栈的；</li>\n<li>该闭包是否在其他地方进行了设置；</li>\n<li>其他。</li>\n</ul>\n<p>&gt;<br>&gt;<br>&gt;<br>&gt;</p>"},{"layout":"post","title":"GoogleWebRTC实时通讯","date":"2017-11-21T10:11:43.000Z","author":"liangtong","catalog":true,"_content":"\n\nWebRT（Web browsers with Real-Time Communications）是一个由谷歌支持免费、开源的项目。本节主要讲述iOS端音视频实时通话，跨局域网需要搭建NAT穿墙服务器。\n\n\n\n\n#### 引入\n\n移动端可以通过Pod命令，直接使用由Google编译好的framework。\n\n```Objective-C\n    pod 'GoogleWebRTC'\n```\n\n > 谷歌提供的WebRTC.framework支持处理器: x86_64 armv7 arm64，不包含i386\n\n<!-- more -->\n\n\n#### 简介\n\n使用WebRTC点对点音视频聊天主要涉及 **RTCPeerConnection** ，一对一、一对多音视频聊天都会用到。需要首先理解以下几个概念(名词)。\n\n - ICEServers\n - Offer / Answer\n     - SessionDescription\n          - Local SDP / Remote SDP\n      - RTCAudioTrack:音频源\n      - RTCVideoTrack: 视频源\n - ICECandidates\n\n#### 连接\n\n音视频连接的建立，可以通过（不限于）以下方式：\n\n- Socket\n- XMPP\n\n过程可以直接参照下图\n![](/post/message/webrtc_messaging.svg)\n\n\n#### 代码\n\n使用代码参照链接[GitHub](https://github.com/l900416/LTChat)\n","source":"_posts/ios_instance_message_webrtc_message.md","raw":"---\nlayout:     post\ntitle:      GoogleWebRTC实时通讯\ndate:       2017-11-21 18:11:43\nauthor:     liangtong\ncatalog: true\ncategories: 即时通讯\ntags: WebRTC\n\n---\n\n\nWebRT（Web browsers with Real-Time Communications）是一个由谷歌支持免费、开源的项目。本节主要讲述iOS端音视频实时通话，跨局域网需要搭建NAT穿墙服务器。\n\n\n\n\n#### 引入\n\n移动端可以通过Pod命令，直接使用由Google编译好的framework。\n\n```Objective-C\n    pod 'GoogleWebRTC'\n```\n\n > 谷歌提供的WebRTC.framework支持处理器: x86_64 armv7 arm64，不包含i386\n\n<!-- more -->\n\n\n#### 简介\n\n使用WebRTC点对点音视频聊天主要涉及 **RTCPeerConnection** ，一对一、一对多音视频聊天都会用到。需要首先理解以下几个概念(名词)。\n\n - ICEServers\n - Offer / Answer\n     - SessionDescription\n          - Local SDP / Remote SDP\n      - RTCAudioTrack:音频源\n      - RTCVideoTrack: 视频源\n - ICECandidates\n\n#### 连接\n\n音视频连接的建立，可以通过（不限于）以下方式：\n\n- Socket\n- XMPP\n\n过程可以直接参照下图\n![](/post/message/webrtc_messaging.svg)\n\n\n#### 代码\n\n使用代码参照链接[GitHub](https://github.com/l900416/LTChat)\n","slug":"ios_instance_message_webrtc_message","published":1,"updated":"2017-11-21T08:24:07.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4v4004poko8hy5ghqix","content":"<p>WebRT（Web browsers with Real-Time Communications）是一个由谷歌支持免费、开源的项目。本节主要讲述iOS端音视频实时通话，跨局域网需要搭建NAT穿墙服务器。</p>\n<h4 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h4><p>移动端可以通过Pod命令，直接使用由Google编译好的framework。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod &apos;GoogleWebRTC&apos;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>谷歌提供的WebRTC.framework支持处理器: x86_64 armv7 arm64，不包含i386</p>\n</blockquote>\n<a id=\"more\"></a>\n<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>使用WebRTC点对点音视频聊天主要涉及 <strong>RTCPeerConnection</strong> ，一对一、一对多音视频聊天都会用到。需要首先理解以下几个概念(名词)。</p>\n<ul>\n<li>ICEServers</li>\n<li>Offer / Answer<ul>\n<li>SessionDescription<ul>\n<li>Local SDP / Remote SDP<ul>\n<li>RTCAudioTrack:音频源</li>\n<li>RTCVideoTrack: 视频源</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>ICECandidates</li>\n</ul>\n<h4 id=\"连接\"><a href=\"#连接\" class=\"headerlink\" title=\"连接\"></a>连接</h4><p>音视频连接的建立，可以通过（不限于）以下方式：</p>\n<ul>\n<li>Socket</li>\n<li>XMPP</li>\n</ul>\n<p>过程可以直接参照下图<br><img src=\"/post/message/webrtc_messaging.svg\" alt=\"\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p>使用代码参照链接<a href=\"https://github.com/l900416/LTChat\" target=\"_blank\" rel=\"external\">GitHub</a></p>\n","site":{"data":{}},"excerpt":"<p>WebRT（Web browsers with Real-Time Communications）是一个由谷歌支持免费、开源的项目。本节主要讲述iOS端音视频实时通话，跨局域网需要搭建NAT穿墙服务器。</p>\n<h4 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h4><p>移动端可以通过Pod命令，直接使用由Google编译好的framework。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod &apos;GoogleWebRTC&apos;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>谷歌提供的WebRTC.framework支持处理器: x86_64 armv7 arm64，不包含i386</p>\n</blockquote>","more":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>使用WebRTC点对点音视频聊天主要涉及 <strong>RTCPeerConnection</strong> ，一对一、一对多音视频聊天都会用到。需要首先理解以下几个概念(名词)。</p>\n<ul>\n<li>ICEServers</li>\n<li>Offer / Answer<ul>\n<li>SessionDescription<ul>\n<li>Local SDP / Remote SDP<ul>\n<li>RTCAudioTrack:音频源</li>\n<li>RTCVideoTrack: 视频源</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>ICECandidates</li>\n</ul>\n<h4 id=\"连接\"><a href=\"#连接\" class=\"headerlink\" title=\"连接\"></a>连接</h4><p>音视频连接的建立，可以通过（不限于）以下方式：</p>\n<ul>\n<li>Socket</li>\n<li>XMPP</li>\n</ul>\n<p>过程可以直接参照下图<br><img src=\"/post/message/webrtc_messaging.svg\" alt=\"\"></p>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><p>使用代码参照链接<a href=\"https://github.com/l900416/LTChat\" target=\"_blank\" rel=\"external\">GitHub</a></p>"},{"layout":"post","title":"XCode9对应iOS11系统适配","date":"2017-11-22T09:51:43.000Z","author":"liangtong","catalog":true,"_content":"\n\n\n​        为了适配iOS11系统，将XCode工具升级到了9.1版本。本文记录适配过程中遇到的问题。\n\n##### NSLocationAlwaysUsageDescription 变更为 NSLocationAlwaysAndWhenInUseUsageDescription\n\n 使用iBeacon技术，在程序不打开的情况下对区域进行监听时，需要将位置使用方式设置为Always。控制台出现以下log信息：\n\n > This app has attempted to access privacy-sensitive data without a usage description. The app's Info.plist must contain both NSLocationAlwaysAndWhenInUseUsageDescription and NSLocationWhenInUseUsageDescription keys with string values explaining to the user how the app uses this data\n\n\n意思是说在plist中需要设置请求位置服务的描述信息。字段名已经提供，只需要将info.plist中响应的字段修改下就可以了。\n\n\n<----持续更新中---->\n\n","source":"_posts/iOS_develop_problem_xcode9_ios11.md","raw":"---\nlayout:     post\ntitle:      XCode9对应iOS11系统适配\ndate:       2017-11-22 17:51:43\nauthor:     liangtong\ncatalog: true\ncategories: iOS\ntags: 问题记录\n\n---\n\n\n\n​        为了适配iOS11系统，将XCode工具升级到了9.1版本。本文记录适配过程中遇到的问题。\n\n##### NSLocationAlwaysUsageDescription 变更为 NSLocationAlwaysAndWhenInUseUsageDescription\n\n 使用iBeacon技术，在程序不打开的情况下对区域进行监听时，需要将位置使用方式设置为Always。控制台出现以下log信息：\n\n > This app has attempted to access privacy-sensitive data without a usage description. The app's Info.plist must contain both NSLocationAlwaysAndWhenInUseUsageDescription and NSLocationWhenInUseUsageDescription keys with string values explaining to the user how the app uses this data\n\n\n意思是说在plist中需要设置请求位置服务的描述信息。字段名已经提供，只需要将info.plist中响应的字段修改下就可以了。\n\n\n<----持续更新中---->\n\n","slug":"iOS_develop_problem_xcode9_ios11","published":1,"updated":"2017-11-23T01:12:34.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4v6004soko86rihifpg","content":"<p>​        为了适配iOS11系统，将XCode工具升级到了9.1版本。本文记录适配过程中遇到的问题。</p>\n<h5 id=\"NSLocationAlwaysUsageDescription-变更为-NSLocationAlwaysAndWhenInUseUsageDescription\"><a href=\"#NSLocationAlwaysUsageDescription-变更为-NSLocationAlwaysAndWhenInUseUsageDescription\" class=\"headerlink\" title=\"NSLocationAlwaysUsageDescription 变更为 NSLocationAlwaysAndWhenInUseUsageDescription\"></a>NSLocationAlwaysUsageDescription 变更为 NSLocationAlwaysAndWhenInUseUsageDescription</h5><p> 使用iBeacon技术，在程序不打开的情况下对区域进行监听时，需要将位置使用方式设置为Always。控制台出现以下log信息：</p>\n<blockquote>\n<p>This app has attempted to access privacy-sensitive data without a usage description. The app’s Info.plist must contain both NSLocationAlwaysAndWhenInUseUsageDescription and NSLocationWhenInUseUsageDescription keys with string values explaining to the user how the app uses this data</p>\n</blockquote>\n<p>意思是说在plist中需要设置请求位置服务的描述信息。字段名已经提供，只需要将info.plist中响应的字段修改下就可以了。</p>\n<p>&lt;—-持续更新中—-&gt;</p>\n","site":{"data":{}},"excerpt":"","more":"<p>​        为了适配iOS11系统，将XCode工具升级到了9.1版本。本文记录适配过程中遇到的问题。</p>\n<h5 id=\"NSLocationAlwaysUsageDescription-变更为-NSLocationAlwaysAndWhenInUseUsageDescription\"><a href=\"#NSLocationAlwaysUsageDescription-变更为-NSLocationAlwaysAndWhenInUseUsageDescription\" class=\"headerlink\" title=\"NSLocationAlwaysUsageDescription 变更为 NSLocationAlwaysAndWhenInUseUsageDescription\"></a>NSLocationAlwaysUsageDescription 变更为 NSLocationAlwaysAndWhenInUseUsageDescription</h5><p> 使用iBeacon技术，在程序不打开的情况下对区域进行监听时，需要将位置使用方式设置为Always。控制台出现以下log信息：</p>\n<blockquote>\n<p>This app has attempted to access privacy-sensitive data without a usage description. The app’s Info.plist must contain both NSLocationAlwaysAndWhenInUseUsageDescription and NSLocationWhenInUseUsageDescription keys with string values explaining to the user how the app uses this data</p>\n</blockquote>\n<p>意思是说在plist中需要设置请求位置服务的描述信息。字段名已经提供，只需要将info.plist中响应的字段修改下就可以了。</p>\n<p>&lt;—-持续更新中—-&gt;</p>\n"},{"layout":"post","title":"XMPP之用户注册／登录","date":"2017-09-22T09:51:43.000Z","author":"liangtong","catalog":true,"_content":"\n\n[XMPP](https://xmpp.org/)是一个以XML为基础的开源的即时通讯协议。具有开放、标准、可用、分布式、安全、可扩展、多样性等优点。因为最近工作接触，在此进行记录。希望对你有帮助。\n本文为XMPP开发的第一讲，记录XMPP的用户注册／登录。\n\n\n#### 环境配置\n\n使用GitHub上现有的[XMPPFramework](https://github.com/robbiehanson/XMPPFramework)，直接将其依赖加入到工程的Podfile中后，执行 **pod install** 下载：    \n```Objective-C\nplatform :ios, '8.0'\nuse_frameworks!\ntarget 'LTIM' do\n    pod 'XMPPFramework', '~> 3.7.0'\nend\n```\n\n<!-- more -->\n\n#### 登录流程\n\nXMPP的登录主要需要了解 **XMPPStreamDelegate** 协议，用户登录分为以下几个步骤：\n\n + 设置代理并激活\n + 连接服务器\n + 完成注册／认证\n + 发送Presence状态数据\n\n对应需要重点关注 **XMPPStreamDelegate** 协议中的以下方法，其他方法根据需要进行实现即可：\n\n```Objective-C\n#pragma mark - XMPPStreamDelegate\n\n/*证书相关*/\n- (void)xmppStream:(XMPPStream *)sender willSecureWithSettings:(NSMutableDictionary *)settings;\n/*连接服务器之后，回调的方法*/\n- (void)xmppStreamDidConnect:(XMPPStream *)sender;\n/*新用户注册，回调的方法*/\n- (void)xmppStreamDidRegister:(XMPPStream *)sender;\n/*用户登陆，回调的方法*/\n- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender;\n- (void)xmppStream:(XMPPStream *)sender didNotAuthenticate:(NSXMLElement *)error;\n\n```\n\n##### 设置代理并激活\n\n初始化 **XMPPStream** 对象，并设置 **XMPPStreamDelegate** 代理组件，创建重连组件并将其在 **XMPPStream** 对象中生效(激活)。\n\n```Objective-C\n    self.xmppStream = [[XMPPStream alloc] init];\n    [self.xmppStream addDelegate:self delegateQueue:dispatch_get_main_queue()];\n\n    //创建XMPPReconnect重连组件，并把组件在XMPPStream中(激活)\n    self.xmppReconnect = [[XMPPReconnect alloc] init];\n    [self.xmppReconnect activate:self.xmppStream];\n```\n\n##### 连接服务器\n\n使用  **XMPPJID** 连接到服务器，注意此处需要设置服务器的端口号和IP地址(hostName)。\n\n```Objective-C\n    //若需要修改IP和port则在连接服务器前进行修改。\n    _xmppStream.hostPort = hostPort;\n    _xmppStream.hostName = hostIP;\n\n    //创建JID；将JID添加到xmppStream中\n    XMPPJID * jid = [XMPPJID jidWithString:self.jid resource:LTXMPP_RESOURCE];\n    [self.xmppStream setMyJID:jid];\n\n    //开始连接服务器\n    NSError *error = nil;\n    if (![self.xmppStream connectWithTimeout:XMPPStreamTimeoutNone error:&error]) {\n        NSLog(@\"%s - %s\",__FILE__,__FUNCTION__);\n        NSLog(@\"连接服务器失败：%@\",error);\n        return NO;\n    }\n    NSLog(@\"连接服务器成功！\");\n\n```\n\n > 需要说明的一点是：jid可以是已经有账户和待注册账户，通常形式为 \"name@domain\"\n\n##### 完成注册／认证\n\n具体注册／认证是看你调用了XMPPStream的方法。\n\n```Objective-C\n   - (BOOL)registerWithPassword:(NSString *)password error:(NSError **)errPtr\n   - (BOOL)authenticateWithPassword:(NSString *)password error:(NSError **)errPtr\n```\n\n在执行注册／认证方法后，通过协议回调查看执行结果，例如登录：\n\n\n```Objective-C\n/*用户上线*/\n-(void)goOnline{\n    if([self connect]){\n        NSError *error = nil;\n        [self.xmppStream authenticateWithPassword:self.userPwd error:&error];\n        if (error) {\n            NSLog(@\"%s - %s\",__FILE__,__FUNCTION__);\n            NSLog(@\"登陆认证失败：%@\",error);\n        }\n    }\n}\n/*用户登陆，回调的方法*/\n- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender{\n    NSLog(@\"%s - %s\",__FILE__,__FUNCTION__);\n    NSLog(@\"登陆认证成功！！\");\n    //存储用户信息，下次自动登录\n}\n- (void)xmppStream:(XMPPStream *)sender didNotAuthenticate:(NSXMLElement *)error{\n    NSLog(@\"%s - %s\",__FILE__,__FUNCTION__);\n    NSLog(@\"登陆失败：%@\",error);\n}\n```\n\n##### 发送Presence用户状态数据\n\n用户登录成功后，需要发送表示用户状态 **XMPPPresence** 数据\n\n```Objective-C\n    XMPPPresence * presence = [XMPPPresence presence];//默认type是available\n    [presence addChild:[DDXMLElement elementWithName:@\"show\" stringValue:@\"away\"]];\n    [presence addChild:[DDXMLElement elementWithName:@\"status\" stringValue:@\"今天是个好日子,这里是显示的状态(iOS)\"]];\n    [self.xmppStream sendElement:presence];\n}\n```\n\n好了，本节就讲这些，下一节讲述：XMPPFramework之花名册获取。\n","source":"_posts/ios_instance_message_xmpp_sign.md","raw":"---\nlayout:     post\ntitle:      XMPP之用户注册／登录\ndate:       2017-09-22 17:51:43\nauthor:     liangtong\ncatalog: true\ncategories: 即时通讯\ntags: xmpp\n\n---\n\n\n[XMPP](https://xmpp.org/)是一个以XML为基础的开源的即时通讯协议。具有开放、标准、可用、分布式、安全、可扩展、多样性等优点。因为最近工作接触，在此进行记录。希望对你有帮助。\n本文为XMPP开发的第一讲，记录XMPP的用户注册／登录。\n\n\n#### 环境配置\n\n使用GitHub上现有的[XMPPFramework](https://github.com/robbiehanson/XMPPFramework)，直接将其依赖加入到工程的Podfile中后，执行 **pod install** 下载：    \n```Objective-C\nplatform :ios, '8.0'\nuse_frameworks!\ntarget 'LTIM' do\n    pod 'XMPPFramework', '~> 3.7.0'\nend\n```\n\n<!-- more -->\n\n#### 登录流程\n\nXMPP的登录主要需要了解 **XMPPStreamDelegate** 协议，用户登录分为以下几个步骤：\n\n + 设置代理并激活\n + 连接服务器\n + 完成注册／认证\n + 发送Presence状态数据\n\n对应需要重点关注 **XMPPStreamDelegate** 协议中的以下方法，其他方法根据需要进行实现即可：\n\n```Objective-C\n#pragma mark - XMPPStreamDelegate\n\n/*证书相关*/\n- (void)xmppStream:(XMPPStream *)sender willSecureWithSettings:(NSMutableDictionary *)settings;\n/*连接服务器之后，回调的方法*/\n- (void)xmppStreamDidConnect:(XMPPStream *)sender;\n/*新用户注册，回调的方法*/\n- (void)xmppStreamDidRegister:(XMPPStream *)sender;\n/*用户登陆，回调的方法*/\n- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender;\n- (void)xmppStream:(XMPPStream *)sender didNotAuthenticate:(NSXMLElement *)error;\n\n```\n\n##### 设置代理并激活\n\n初始化 **XMPPStream** 对象，并设置 **XMPPStreamDelegate** 代理组件，创建重连组件并将其在 **XMPPStream** 对象中生效(激活)。\n\n```Objective-C\n    self.xmppStream = [[XMPPStream alloc] init];\n    [self.xmppStream addDelegate:self delegateQueue:dispatch_get_main_queue()];\n\n    //创建XMPPReconnect重连组件，并把组件在XMPPStream中(激活)\n    self.xmppReconnect = [[XMPPReconnect alloc] init];\n    [self.xmppReconnect activate:self.xmppStream];\n```\n\n##### 连接服务器\n\n使用  **XMPPJID** 连接到服务器，注意此处需要设置服务器的端口号和IP地址(hostName)。\n\n```Objective-C\n    //若需要修改IP和port则在连接服务器前进行修改。\n    _xmppStream.hostPort = hostPort;\n    _xmppStream.hostName = hostIP;\n\n    //创建JID；将JID添加到xmppStream中\n    XMPPJID * jid = [XMPPJID jidWithString:self.jid resource:LTXMPP_RESOURCE];\n    [self.xmppStream setMyJID:jid];\n\n    //开始连接服务器\n    NSError *error = nil;\n    if (![self.xmppStream connectWithTimeout:XMPPStreamTimeoutNone error:&error]) {\n        NSLog(@\"%s - %s\",__FILE__,__FUNCTION__);\n        NSLog(@\"连接服务器失败：%@\",error);\n        return NO;\n    }\n    NSLog(@\"连接服务器成功！\");\n\n```\n\n > 需要说明的一点是：jid可以是已经有账户和待注册账户，通常形式为 \"name@domain\"\n\n##### 完成注册／认证\n\n具体注册／认证是看你调用了XMPPStream的方法。\n\n```Objective-C\n   - (BOOL)registerWithPassword:(NSString *)password error:(NSError **)errPtr\n   - (BOOL)authenticateWithPassword:(NSString *)password error:(NSError **)errPtr\n```\n\n在执行注册／认证方法后，通过协议回调查看执行结果，例如登录：\n\n\n```Objective-C\n/*用户上线*/\n-(void)goOnline{\n    if([self connect]){\n        NSError *error = nil;\n        [self.xmppStream authenticateWithPassword:self.userPwd error:&error];\n        if (error) {\n            NSLog(@\"%s - %s\",__FILE__,__FUNCTION__);\n            NSLog(@\"登陆认证失败：%@\",error);\n        }\n    }\n}\n/*用户登陆，回调的方法*/\n- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender{\n    NSLog(@\"%s - %s\",__FILE__,__FUNCTION__);\n    NSLog(@\"登陆认证成功！！\");\n    //存储用户信息，下次自动登录\n}\n- (void)xmppStream:(XMPPStream *)sender didNotAuthenticate:(NSXMLElement *)error{\n    NSLog(@\"%s - %s\",__FILE__,__FUNCTION__);\n    NSLog(@\"登陆失败：%@\",error);\n}\n```\n\n##### 发送Presence用户状态数据\n\n用户登录成功后，需要发送表示用户状态 **XMPPPresence** 数据\n\n```Objective-C\n    XMPPPresence * presence = [XMPPPresence presence];//默认type是available\n    [presence addChild:[DDXMLElement elementWithName:@\"show\" stringValue:@\"away\"]];\n    [presence addChild:[DDXMLElement elementWithName:@\"status\" stringValue:@\"今天是个好日子,这里是显示的状态(iOS)\"]];\n    [self.xmppStream sendElement:presence];\n}\n```\n\n好了，本节就讲这些，下一节讲述：XMPPFramework之花名册获取。\n","slug":"ios_instance_message_xmpp_sign","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4v7004woko8kdlnptlv","content":"<p><a href=\"https://xmpp.org/\" target=\"_blank\" rel=\"external\">XMPP</a>是一个以XML为基础的开源的即时通讯协议。具有开放、标准、可用、分布式、安全、可扩展、多样性等优点。因为最近工作接触，在此进行记录。希望对你有帮助。<br>本文为XMPP开发的第一讲，记录XMPP的用户注册／登录。</p>\n<h4 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h4><p>使用GitHub上现有的<a href=\"https://github.com/robbiehanson/XMPPFramework\" target=\"_blank\" rel=\"external\">XMPPFramework</a>，直接将其依赖加入到工程的Podfile中后，执行 <strong>pod install</strong> 下载：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">platform :ios, &apos;8.0&apos;</div><div class=\"line\">use_frameworks!</div><div class=\"line\">target &apos;LTIM&apos; do</div><div class=\"line\">    pod &apos;XMPPFramework&apos;, &apos;~&gt; 3.7.0&apos;</div><div class=\"line\">end</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h4 id=\"登录流程\"><a href=\"#登录流程\" class=\"headerlink\" title=\"登录流程\"></a>登录流程</h4><p>XMPP的登录主要需要了解 <strong>XMPPStreamDelegate</strong> 协议，用户登录分为以下几个步骤：</p>\n<ul>\n<li>设置代理并激活</li>\n<li>连接服务器</li>\n<li>完成注册／认证</li>\n<li>发送Presence状态数据</li>\n</ul>\n<p>对应需要重点关注 <strong>XMPPStreamDelegate</strong> 协议中的以下方法，其他方法根据需要进行实现即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">#pragma mark - XMPPStreamDelegate</div><div class=\"line\"></div><div class=\"line\">/*证书相关*/</div><div class=\"line\">- (void)xmppStream:(XMPPStream *)sender willSecureWithSettings:(NSMutableDictionary *)settings;</div><div class=\"line\">/*连接服务器之后，回调的方法*/</div><div class=\"line\">- (void)xmppStreamDidConnect:(XMPPStream *)sender;</div><div class=\"line\">/*新用户注册，回调的方法*/</div><div class=\"line\">- (void)xmppStreamDidRegister:(XMPPStream *)sender;</div><div class=\"line\">/*用户登陆，回调的方法*/</div><div class=\"line\">- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender;</div><div class=\"line\">- (void)xmppStream:(XMPPStream *)sender didNotAuthenticate:(NSXMLElement *)error;</div></pre></td></tr></table></figure>\n<h5 id=\"设置代理并激活\"><a href=\"#设置代理并激活\" class=\"headerlink\" title=\"设置代理并激活\"></a>设置代理并激活</h5><p>初始化 <strong>XMPPStream</strong> 对象，并设置 <strong>XMPPStreamDelegate</strong> 代理组件，创建重连组件并将其在 <strong>XMPPStream</strong> 对象中生效(激活)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">self.xmppStream = [[XMPPStream alloc] init];</div><div class=\"line\">[self.xmppStream addDelegate:self delegateQueue:dispatch_get_main_queue()];</div><div class=\"line\"></div><div class=\"line\">//创建XMPPReconnect重连组件，并把组件在XMPPStream中(激活)</div><div class=\"line\">self.xmppReconnect = [[XMPPReconnect alloc] init];</div><div class=\"line\">[self.xmppReconnect activate:self.xmppStream];</div></pre></td></tr></table></figure>\n<h5 id=\"连接服务器\"><a href=\"#连接服务器\" class=\"headerlink\" title=\"连接服务器\"></a>连接服务器</h5><p>使用  <strong>XMPPJID</strong> 连接到服务器，注意此处需要设置服务器的端口号和IP地址(hostName)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">//若需要修改IP和port则在连接服务器前进行修改。</div><div class=\"line\">_xmppStream.hostPort = hostPort;</div><div class=\"line\">_xmppStream.hostName = hostIP;</div><div class=\"line\"></div><div class=\"line\">//创建JID；将JID添加到xmppStream中</div><div class=\"line\">XMPPJID * jid = [XMPPJID jidWithString:self.jid resource:LTXMPP_RESOURCE];</div><div class=\"line\">[self.xmppStream setMyJID:jid];</div><div class=\"line\"></div><div class=\"line\">//开始连接服务器</div><div class=\"line\">NSError *error = nil;</div><div class=\"line\">if (![self.xmppStream connectWithTimeout:XMPPStreamTimeoutNone error:&amp;error]) &#123;</div><div class=\"line\">    NSLog(@&quot;%s - %s&quot;,__FILE__,__FUNCTION__);</div><div class=\"line\">    NSLog(@&quot;连接服务器失败：%@&quot;,error);</div><div class=\"line\">    return NO;</div><div class=\"line\">&#125;</div><div class=\"line\">NSLog(@&quot;连接服务器成功！&quot;);</div></pre></td></tr></table></figure>\n<blockquote>\n<p>需要说明的一点是：jid可以是已经有账户和待注册账户，通常形式为 “name@domain”</p>\n</blockquote>\n<h5 id=\"完成注册／认证\"><a href=\"#完成注册／认证\" class=\"headerlink\" title=\"完成注册／认证\"></a>完成注册／认证</h5><p>具体注册／认证是看你调用了XMPPStream的方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (BOOL)registerWithPassword:(NSString *)password error:(NSError **)errPtr</div><div class=\"line\">- (BOOL)authenticateWithPassword:(NSString *)password error:(NSError **)errPtr</div></pre></td></tr></table></figure>\n<p>在执行注册／认证方法后，通过协议回调查看执行结果，例如登录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*用户上线*/</div><div class=\"line\">-(void)goOnline&#123;</div><div class=\"line\">    if([self connect])&#123;</div><div class=\"line\">        NSError *error = nil;</div><div class=\"line\">        [self.xmppStream authenticateWithPassword:self.userPwd error:&amp;error];</div><div class=\"line\">        if (error) &#123;</div><div class=\"line\">            NSLog(@&quot;%s - %s&quot;,__FILE__,__FUNCTION__);</div><div class=\"line\">            NSLog(@&quot;登陆认证失败：%@&quot;,error);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">/*用户登陆，回调的方法*/</div><div class=\"line\">- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender&#123;</div><div class=\"line\">    NSLog(@&quot;%s - %s&quot;,__FILE__,__FUNCTION__);</div><div class=\"line\">    NSLog(@&quot;登陆认证成功！！&quot;);</div><div class=\"line\">    //存储用户信息，下次自动登录</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)xmppStream:(XMPPStream *)sender didNotAuthenticate:(NSXMLElement *)error&#123;</div><div class=\"line\">    NSLog(@&quot;%s - %s&quot;,__FILE__,__FUNCTION__);</div><div class=\"line\">    NSLog(@&quot;登陆失败：%@&quot;,error);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"发送Presence用户状态数据\"><a href=\"#发送Presence用户状态数据\" class=\"headerlink\" title=\"发送Presence用户状态数据\"></a>发送Presence用户状态数据</h5><p>用户登录成功后，需要发送表示用户状态 <strong>XMPPPresence</strong> 数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">    XMPPPresence * presence = [XMPPPresence presence];//默认type是available</div><div class=\"line\">    [presence addChild:[DDXMLElement elementWithName:@&quot;show&quot; stringValue:@&quot;away&quot;]];</div><div class=\"line\">    [presence addChild:[DDXMLElement elementWithName:@&quot;status&quot; stringValue:@&quot;今天是个好日子,这里是显示的状态(iOS)&quot;]];</div><div class=\"line\">    [self.xmppStream sendElement:presence];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>好了，本节就讲这些，下一节讲述：XMPPFramework之花名册获取。</p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://xmpp.org/\" target=\"_blank\" rel=\"external\">XMPP</a>是一个以XML为基础的开源的即时通讯协议。具有开放、标准、可用、分布式、安全、可扩展、多样性等优点。因为最近工作接触，在此进行记录。希望对你有帮助。<br>本文为XMPP开发的第一讲，记录XMPP的用户注册／登录。</p>\n<h4 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h4><p>使用GitHub上现有的<a href=\"https://github.com/robbiehanson/XMPPFramework\" target=\"_blank\" rel=\"external\">XMPPFramework</a>，直接将其依赖加入到工程的Podfile中后，执行 <strong>pod install</strong> 下载：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">platform :ios, &apos;8.0&apos;</div><div class=\"line\">use_frameworks!</div><div class=\"line\">target &apos;LTIM&apos; do</div><div class=\"line\">    pod &apos;XMPPFramework&apos;, &apos;~&gt; 3.7.0&apos;</div><div class=\"line\">end</div></pre></td></tr></table></figure></p>","more":"<h4 id=\"登录流程\"><a href=\"#登录流程\" class=\"headerlink\" title=\"登录流程\"></a>登录流程</h4><p>XMPP的登录主要需要了解 <strong>XMPPStreamDelegate</strong> 协议，用户登录分为以下几个步骤：</p>\n<ul>\n<li>设置代理并激活</li>\n<li>连接服务器</li>\n<li>完成注册／认证</li>\n<li>发送Presence状态数据</li>\n</ul>\n<p>对应需要重点关注 <strong>XMPPStreamDelegate</strong> 协议中的以下方法，其他方法根据需要进行实现即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">#pragma mark - XMPPStreamDelegate</div><div class=\"line\"></div><div class=\"line\">/*证书相关*/</div><div class=\"line\">- (void)xmppStream:(XMPPStream *)sender willSecureWithSettings:(NSMutableDictionary *)settings;</div><div class=\"line\">/*连接服务器之后，回调的方法*/</div><div class=\"line\">- (void)xmppStreamDidConnect:(XMPPStream *)sender;</div><div class=\"line\">/*新用户注册，回调的方法*/</div><div class=\"line\">- (void)xmppStreamDidRegister:(XMPPStream *)sender;</div><div class=\"line\">/*用户登陆，回调的方法*/</div><div class=\"line\">- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender;</div><div class=\"line\">- (void)xmppStream:(XMPPStream *)sender didNotAuthenticate:(NSXMLElement *)error;</div></pre></td></tr></table></figure>\n<h5 id=\"设置代理并激活\"><a href=\"#设置代理并激活\" class=\"headerlink\" title=\"设置代理并激活\"></a>设置代理并激活</h5><p>初始化 <strong>XMPPStream</strong> 对象，并设置 <strong>XMPPStreamDelegate</strong> 代理组件，创建重连组件并将其在 <strong>XMPPStream</strong> 对象中生效(激活)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">self.xmppStream = [[XMPPStream alloc] init];</div><div class=\"line\">[self.xmppStream addDelegate:self delegateQueue:dispatch_get_main_queue()];</div><div class=\"line\"></div><div class=\"line\">//创建XMPPReconnect重连组件，并把组件在XMPPStream中(激活)</div><div class=\"line\">self.xmppReconnect = [[XMPPReconnect alloc] init];</div><div class=\"line\">[self.xmppReconnect activate:self.xmppStream];</div></pre></td></tr></table></figure>\n<h5 id=\"连接服务器\"><a href=\"#连接服务器\" class=\"headerlink\" title=\"连接服务器\"></a>连接服务器</h5><p>使用  <strong>XMPPJID</strong> 连接到服务器，注意此处需要设置服务器的端口号和IP地址(hostName)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">//若需要修改IP和port则在连接服务器前进行修改。</div><div class=\"line\">_xmppStream.hostPort = hostPort;</div><div class=\"line\">_xmppStream.hostName = hostIP;</div><div class=\"line\"></div><div class=\"line\">//创建JID；将JID添加到xmppStream中</div><div class=\"line\">XMPPJID * jid = [XMPPJID jidWithString:self.jid resource:LTXMPP_RESOURCE];</div><div class=\"line\">[self.xmppStream setMyJID:jid];</div><div class=\"line\"></div><div class=\"line\">//开始连接服务器</div><div class=\"line\">NSError *error = nil;</div><div class=\"line\">if (![self.xmppStream connectWithTimeout:XMPPStreamTimeoutNone error:&amp;error]) &#123;</div><div class=\"line\">    NSLog(@&quot;%s - %s&quot;,__FILE__,__FUNCTION__);</div><div class=\"line\">    NSLog(@&quot;连接服务器失败：%@&quot;,error);</div><div class=\"line\">    return NO;</div><div class=\"line\">&#125;</div><div class=\"line\">NSLog(@&quot;连接服务器成功！&quot;);</div></pre></td></tr></table></figure>\n<blockquote>\n<p>需要说明的一点是：jid可以是已经有账户和待注册账户，通常形式为 “name@domain”</p>\n</blockquote>\n<h5 id=\"完成注册／认证\"><a href=\"#完成注册／认证\" class=\"headerlink\" title=\"完成注册／认证\"></a>完成注册／认证</h5><p>具体注册／认证是看你调用了XMPPStream的方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">- (BOOL)registerWithPassword:(NSString *)password error:(NSError **)errPtr</div><div class=\"line\">- (BOOL)authenticateWithPassword:(NSString *)password error:(NSError **)errPtr</div></pre></td></tr></table></figure>\n<p>在执行注册／认证方法后，通过协议回调查看执行结果，例如登录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*用户上线*/</div><div class=\"line\">-(void)goOnline&#123;</div><div class=\"line\">    if([self connect])&#123;</div><div class=\"line\">        NSError *error = nil;</div><div class=\"line\">        [self.xmppStream authenticateWithPassword:self.userPwd error:&amp;error];</div><div class=\"line\">        if (error) &#123;</div><div class=\"line\">            NSLog(@&quot;%s - %s&quot;,__FILE__,__FUNCTION__);</div><div class=\"line\">            NSLog(@&quot;登陆认证失败：%@&quot;,error);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">/*用户登陆，回调的方法*/</div><div class=\"line\">- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender&#123;</div><div class=\"line\">    NSLog(@&quot;%s - %s&quot;,__FILE__,__FUNCTION__);</div><div class=\"line\">    NSLog(@&quot;登陆认证成功！！&quot;);</div><div class=\"line\">    //存储用户信息，下次自动登录</div><div class=\"line\">&#125;</div><div class=\"line\">- (void)xmppStream:(XMPPStream *)sender didNotAuthenticate:(NSXMLElement *)error&#123;</div><div class=\"line\">    NSLog(@&quot;%s - %s&quot;,__FILE__,__FUNCTION__);</div><div class=\"line\">    NSLog(@&quot;登陆失败：%@&quot;,error);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h5 id=\"发送Presence用户状态数据\"><a href=\"#发送Presence用户状态数据\" class=\"headerlink\" title=\"发送Presence用户状态数据\"></a>发送Presence用户状态数据</h5><p>用户登录成功后，需要发送表示用户状态 <strong>XMPPPresence</strong> 数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">    XMPPPresence * presence = [XMPPPresence presence];//默认type是available</div><div class=\"line\">    [presence addChild:[DDXMLElement elementWithName:@&quot;show&quot; stringValue:@&quot;away&quot;]];</div><div class=\"line\">    [presence addChild:[DDXMLElement elementWithName:@&quot;status&quot; stringValue:@&quot;今天是个好日子,这里是显示的状态(iOS)&quot;]];</div><div class=\"line\">    [self.xmppStream sendElement:presence];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>好了，本节就讲这些，下一节讲述：XMPPFramework之花名册获取。</p>"},{"layout":"post","title":"XMPP之用户花名册","date":"2017-10-12T14:11:43.000Z","author":"liangtong","catalog":true,"_content":"\n\n上一节讲了XMPP的用户注册／登录，这节介绍花名册的使用。花名册的存储可以直接使用XMPPFramework中的coreData存储，也可以自己建立数据库存储。本节介绍两种方式：\n\n * 使用XMPPFramework来存储。\n * 不使用CoreData的存储方法。\n\n\n<!-- more -->\n\n\n#### XMPPRoster\n\n花名册的获取主要使用到 **XMPPRoster** 类，使用该类，可以实现好友的管理、同步、申请和删除。花名册的同步需要了解协议 **XMPPRosterDelegate**。\n\n#### CoreData中存储\n\n使用CoreData存储时，XMPPFramework已经为我们做了管理，我们需要做的仅仅是创建对象、添加代理、激活： \n   \n```Objective-C\n@property (nonatomic, strong) XMPPStream *xmppStream;\n@property (nonatomic, strong) XMPPRoster *xmppRoster;\n@property (nonatomic, strong) XMPPRosterMemoryStorage *xmppRosterMemoryStorage;\n```\n\nXMPPStream这里不再赘述，直接介绍花名册相关。\n\n##### 初始化、激活\n   \n```Objective-C\n  _xmppRosterMemoryStorage = [[XMPPRosterMemoryStorage alloc] init];\n  _xmppRoster = [[XMPPRoster alloc] initWithRosterStorage:_xmppRosterMemoryStorage];\n  [_xmppRoster activate:self.xmppStream];\n```\n\n##### 设置代理\n   \n```Objective-C\n  //同时给_xmppRosterMemoryStorage 和 _xmppRoster都添加了代理\n  [_xmppRoster addDelegate:self delegateQueue:dispatch_get_main_queue()];\n  //设置好友同步策略,XMPP一旦连接成功，同步好友到本地\n  [_xmppRoster setAutoFetchRoster:YES]; //自动同步，从服务器取出好友\n```\n\n##### 好友请求相关\n\n如果想自行处理好友请求，则需要关闭自动好友请求\n   \n```Objective-C\n  //关掉自动接收好友请求，默认开启自动同意\n  [_xmppRoster setAutoAcceptKnownPresenceSubscriptionRequests:NO];\n```\n\n##### 监听协议\n\n协议 **XMPPRosterDelegate** 中，包含花名册同步、好友变更相关协议。其中好友相关的主要如下\n\n```Objective-C\n  //如果对方想添加我为好友（订阅我），会触发该回调\n\n  //可以在此回调后，弹出好友请求界面\n  - (void)xmppRoster:(XMPPRoster *)sender didReceivePresenceSubscriptionRequest:(XMPPPresence *)presence\n  //可以根据此回调中presence的type判断是不是别人删除了好友\n  - (void)xmppStream:(XMPPStream *)sender didReceivePresence:(XMPPPresence *)presence;\n```\n\n好友列表的同步，会调用以下协议方法，在结束同步的方法之后，CoreData中好友列表就可以使用了。\n\n```Objective-C\n  //开始同步服务器发送过来的自己的好友列表\n  - (void)xmppRosterDidBeginPopulating:(XMPPRoster *)sender\n  //同步结束\n  - (void)xmppRosterDidEndPopulating:(XMPPRoster *)sender;\n```\n\n当然，如果程序运行过程中，好友列表发生变更了该怎么办，当然还是协议方法了。\n\n```Objective-C\n  //收到每一个好友\n  - (void)xmppRoster:(XMPPRoster *)sender didReceiveRosterItem:(NSXMLElement *)item\n  //如果不是初始化同步来的roster,那么会自动存入我的好友存储器\n   - (void)xmppRosterDidChange:(XMPPRosterMemoryStorage *)sender;\n```\n\n因为XMPPFramework的CoreData数据库已经将大多数操作进行了封装，我们如果使用CoreData，只需要在好友列表同步结束和好友花名册变更的回调中，发送个好友列表变更通知，使用好友花名册的地方根据实际需求处理即可\n\n\n#### 不使用CoreData存储\n\n如果不使用CoreData进行数据存储，我们主要需要在两个协议回调中做文章。\n\n * 好友列表同步结束时，我们需要解析 ** XMPPIQ** 中的XML数据，存储好友列表。\n * 收到好友花名册变更时，与存储的好友列表内好友比较，更新列表及列表中状态。\n\n```Objective-C\n  -(BOOL)xmppStream:(XMPPStream *)sender didReceiveIQ:(XMPPIQ *)iq\n  -(void)xmppStream:(XMPPStream *)sender didReceivePresence:(XMPPPresence *)presence\n```\n\n其中，解析 **XMPPIQ** 中的XML携带有好友列表相关数据， **XMPPPresence** 会携带状态数据或者其他。一定要注意的是好友列表是由两者根据用户JID共同维护的。\n解析XML方法此处不在说明。\n\n\n好了，本节就讲这些，下一节讲述：WebRTC实时通讯。\n","source":"_posts/ios_instance_message_xmpp_roster.md","raw":"---\nlayout:     post\ntitle:      XMPP之用户花名册\ndate:       2017-10-12 22:11:43\nauthor:     liangtong\ncatalog: true\ncategories: 即时通讯\ntags: xmpp\n\n---\n\n\n上一节讲了XMPP的用户注册／登录，这节介绍花名册的使用。花名册的存储可以直接使用XMPPFramework中的coreData存储，也可以自己建立数据库存储。本节介绍两种方式：\n\n * 使用XMPPFramework来存储。\n * 不使用CoreData的存储方法。\n\n\n<!-- more -->\n\n\n#### XMPPRoster\n\n花名册的获取主要使用到 **XMPPRoster** 类，使用该类，可以实现好友的管理、同步、申请和删除。花名册的同步需要了解协议 **XMPPRosterDelegate**。\n\n#### CoreData中存储\n\n使用CoreData存储时，XMPPFramework已经为我们做了管理，我们需要做的仅仅是创建对象、添加代理、激活： \n   \n```Objective-C\n@property (nonatomic, strong) XMPPStream *xmppStream;\n@property (nonatomic, strong) XMPPRoster *xmppRoster;\n@property (nonatomic, strong) XMPPRosterMemoryStorage *xmppRosterMemoryStorage;\n```\n\nXMPPStream这里不再赘述，直接介绍花名册相关。\n\n##### 初始化、激活\n   \n```Objective-C\n  _xmppRosterMemoryStorage = [[XMPPRosterMemoryStorage alloc] init];\n  _xmppRoster = [[XMPPRoster alloc] initWithRosterStorage:_xmppRosterMemoryStorage];\n  [_xmppRoster activate:self.xmppStream];\n```\n\n##### 设置代理\n   \n```Objective-C\n  //同时给_xmppRosterMemoryStorage 和 _xmppRoster都添加了代理\n  [_xmppRoster addDelegate:self delegateQueue:dispatch_get_main_queue()];\n  //设置好友同步策略,XMPP一旦连接成功，同步好友到本地\n  [_xmppRoster setAutoFetchRoster:YES]; //自动同步，从服务器取出好友\n```\n\n##### 好友请求相关\n\n如果想自行处理好友请求，则需要关闭自动好友请求\n   \n```Objective-C\n  //关掉自动接收好友请求，默认开启自动同意\n  [_xmppRoster setAutoAcceptKnownPresenceSubscriptionRequests:NO];\n```\n\n##### 监听协议\n\n协议 **XMPPRosterDelegate** 中，包含花名册同步、好友变更相关协议。其中好友相关的主要如下\n\n```Objective-C\n  //如果对方想添加我为好友（订阅我），会触发该回调\n\n  //可以在此回调后，弹出好友请求界面\n  - (void)xmppRoster:(XMPPRoster *)sender didReceivePresenceSubscriptionRequest:(XMPPPresence *)presence\n  //可以根据此回调中presence的type判断是不是别人删除了好友\n  - (void)xmppStream:(XMPPStream *)sender didReceivePresence:(XMPPPresence *)presence;\n```\n\n好友列表的同步，会调用以下协议方法，在结束同步的方法之后，CoreData中好友列表就可以使用了。\n\n```Objective-C\n  //开始同步服务器发送过来的自己的好友列表\n  - (void)xmppRosterDidBeginPopulating:(XMPPRoster *)sender\n  //同步结束\n  - (void)xmppRosterDidEndPopulating:(XMPPRoster *)sender;\n```\n\n当然，如果程序运行过程中，好友列表发生变更了该怎么办，当然还是协议方法了。\n\n```Objective-C\n  //收到每一个好友\n  - (void)xmppRoster:(XMPPRoster *)sender didReceiveRosterItem:(NSXMLElement *)item\n  //如果不是初始化同步来的roster,那么会自动存入我的好友存储器\n   - (void)xmppRosterDidChange:(XMPPRosterMemoryStorage *)sender;\n```\n\n因为XMPPFramework的CoreData数据库已经将大多数操作进行了封装，我们如果使用CoreData，只需要在好友列表同步结束和好友花名册变更的回调中，发送个好友列表变更通知，使用好友花名册的地方根据实际需求处理即可\n\n\n#### 不使用CoreData存储\n\n如果不使用CoreData进行数据存储，我们主要需要在两个协议回调中做文章。\n\n * 好友列表同步结束时，我们需要解析 ** XMPPIQ** 中的XML数据，存储好友列表。\n * 收到好友花名册变更时，与存储的好友列表内好友比较，更新列表及列表中状态。\n\n```Objective-C\n  -(BOOL)xmppStream:(XMPPStream *)sender didReceiveIQ:(XMPPIQ *)iq\n  -(void)xmppStream:(XMPPStream *)sender didReceivePresence:(XMPPPresence *)presence\n```\n\n其中，解析 **XMPPIQ** 中的XML携带有好友列表相关数据， **XMPPPresence** 会携带状态数据或者其他。一定要注意的是好友列表是由两者根据用户JID共同维护的。\n解析XML方法此处不在说明。\n\n\n好了，本节就讲这些，下一节讲述：WebRTC实时通讯。\n","slug":"ios_instance_message_xmpp_roster","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4v80050oko89mae8gfm","content":"<p>上一节讲了XMPP的用户注册／登录，这节介绍花名册的使用。花名册的存储可以直接使用XMPPFramework中的coreData存储，也可以自己建立数据库存储。本节介绍两种方式：</p>\n<ul>\n<li>使用XMPPFramework来存储。</li>\n<li>不使用CoreData的存储方法。</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"XMPPRoster\"><a href=\"#XMPPRoster\" class=\"headerlink\" title=\"XMPPRoster\"></a>XMPPRoster</h4><p>花名册的获取主要使用到 <strong>XMPPRoster</strong> 类，使用该类，可以实现好友的管理、同步、申请和删除。花名册的同步需要了解协议 <strong>XMPPRosterDelegate</strong>。</p>\n<h4 id=\"CoreData中存储\"><a href=\"#CoreData中存储\" class=\"headerlink\" title=\"CoreData中存储\"></a>CoreData中存储</h4><p>使用CoreData存储时，XMPPFramework已经为我们做了管理，我们需要做的仅仅是创建对象、添加代理、激活： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property (nonatomic, strong) XMPPStream *xmppStream;</div><div class=\"line\">@property (nonatomic, strong) XMPPRoster *xmppRoster;</div><div class=\"line\">@property (nonatomic, strong) XMPPRosterMemoryStorage *xmppRosterMemoryStorage;</div></pre></td></tr></table></figure>\n<p>XMPPStream这里不再赘述，直接介绍花名册相关。</p>\n<h5 id=\"初始化、激活\"><a href=\"#初始化、激活\" class=\"headerlink\" title=\"初始化、激活\"></a>初始化、激活</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">_xmppRosterMemoryStorage = [[XMPPRosterMemoryStorage alloc] init];</div><div class=\"line\">_xmppRoster = [[XMPPRoster alloc] initWithRosterStorage:_xmppRosterMemoryStorage];</div><div class=\"line\">[_xmppRoster activate:self.xmppStream];</div></pre></td></tr></table></figure>\n<h5 id=\"设置代理\"><a href=\"#设置代理\" class=\"headerlink\" title=\"设置代理\"></a>设置代理</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//同时给_xmppRosterMemoryStorage 和 _xmppRoster都添加了代理</div><div class=\"line\">[_xmppRoster addDelegate:self delegateQueue:dispatch_get_main_queue()];</div><div class=\"line\">//设置好友同步策略,XMPP一旦连接成功，同步好友到本地</div><div class=\"line\">[_xmppRoster setAutoFetchRoster:YES]; //自动同步，从服务器取出好友</div></pre></td></tr></table></figure>\n<h5 id=\"好友请求相关\"><a href=\"#好友请求相关\" class=\"headerlink\" title=\"好友请求相关\"></a>好友请求相关</h5><p>如果想自行处理好友请求，则需要关闭自动好友请求</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">//关掉自动接收好友请求，默认开启自动同意</div><div class=\"line\">[_xmppRoster setAutoAcceptKnownPresenceSubscriptionRequests:NO];</div></pre></td></tr></table></figure>\n<h5 id=\"监听协议\"><a href=\"#监听协议\" class=\"headerlink\" title=\"监听协议\"></a>监听协议</h5><p>协议 <strong>XMPPRosterDelegate</strong> 中，包含花名册同步、好友变更相关协议。其中好友相关的主要如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//如果对方想添加我为好友（订阅我），会触发该回调</div><div class=\"line\"></div><div class=\"line\">//可以在此回调后，弹出好友请求界面</div><div class=\"line\">- (void)xmppRoster:(XMPPRoster *)sender didReceivePresenceSubscriptionRequest:(XMPPPresence *)presence</div><div class=\"line\">//可以根据此回调中presence的type判断是不是别人删除了好友</div><div class=\"line\">- (void)xmppStream:(XMPPStream *)sender didReceivePresence:(XMPPPresence *)presence;</div></pre></td></tr></table></figure>\n<p>好友列表的同步，会调用以下协议方法，在结束同步的方法之后，CoreData中好友列表就可以使用了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//开始同步服务器发送过来的自己的好友列表</div><div class=\"line\">- (void)xmppRosterDidBeginPopulating:(XMPPRoster *)sender</div><div class=\"line\">//同步结束</div><div class=\"line\">- (void)xmppRosterDidEndPopulating:(XMPPRoster *)sender;</div></pre></td></tr></table></figure>\n<p>当然，如果程序运行过程中，好友列表发生变更了该怎么办，当然还是协议方法了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//收到每一个好友</div><div class=\"line\">- (void)xmppRoster:(XMPPRoster *)sender didReceiveRosterItem:(NSXMLElement *)item</div><div class=\"line\">//如果不是初始化同步来的roster,那么会自动存入我的好友存储器</div><div class=\"line\"> - (void)xmppRosterDidChange:(XMPPRosterMemoryStorage *)sender;</div></pre></td></tr></table></figure>\n<p>因为XMPPFramework的CoreData数据库已经将大多数操作进行了封装，我们如果使用CoreData，只需要在好友列表同步结束和好友花名册变更的回调中，发送个好友列表变更通知，使用好友花名册的地方根据实际需求处理即可</p>\n<h4 id=\"不使用CoreData存储\"><a href=\"#不使用CoreData存储\" class=\"headerlink\" title=\"不使用CoreData存储\"></a>不使用CoreData存储</h4><p>如果不使用CoreData进行数据存储，我们主要需要在两个协议回调中做文章。</p>\n<ul>\n<li>好友列表同步结束时，我们需要解析 <strong> XMPPIQ</strong> 中的XML数据，存储好友列表。</li>\n<li>收到好友花名册变更时，与存储的好友列表内好友比较，更新列表及列表中状态。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(BOOL)xmppStream:(XMPPStream *)sender didReceiveIQ:(XMPPIQ *)iq</div><div class=\"line\">-(void)xmppStream:(XMPPStream *)sender didReceivePresence:(XMPPPresence *)presence</div></pre></td></tr></table></figure>\n<p>其中，解析 <strong>XMPPIQ</strong> 中的XML携带有好友列表相关数据， <strong>XMPPPresence</strong> 会携带状态数据或者其他。一定要注意的是好友列表是由两者根据用户JID共同维护的。<br>解析XML方法此处不在说明。</p>\n<p>好了，本节就讲这些，下一节讲述：WebRTC实时通讯。</p>\n","site":{"data":{}},"excerpt":"<p>上一节讲了XMPP的用户注册／登录，这节介绍花名册的使用。花名册的存储可以直接使用XMPPFramework中的coreData存储，也可以自己建立数据库存储。本节介绍两种方式：</p>\n<ul>\n<li>使用XMPPFramework来存储。</li>\n<li>不使用CoreData的存储方法。</li>\n</ul>","more":"<h4 id=\"XMPPRoster\"><a href=\"#XMPPRoster\" class=\"headerlink\" title=\"XMPPRoster\"></a>XMPPRoster</h4><p>花名册的获取主要使用到 <strong>XMPPRoster</strong> 类，使用该类，可以实现好友的管理、同步、申请和删除。花名册的同步需要了解协议 <strong>XMPPRosterDelegate</strong>。</p>\n<h4 id=\"CoreData中存储\"><a href=\"#CoreData中存储\" class=\"headerlink\" title=\"CoreData中存储\"></a>CoreData中存储</h4><p>使用CoreData存储时，XMPPFramework已经为我们做了管理，我们需要做的仅仅是创建对象、添加代理、激活： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">@property (nonatomic, strong) XMPPStream *xmppStream;</div><div class=\"line\">@property (nonatomic, strong) XMPPRoster *xmppRoster;</div><div class=\"line\">@property (nonatomic, strong) XMPPRosterMemoryStorage *xmppRosterMemoryStorage;</div></pre></td></tr></table></figure>\n<p>XMPPStream这里不再赘述，直接介绍花名册相关。</p>\n<h5 id=\"初始化、激活\"><a href=\"#初始化、激活\" class=\"headerlink\" title=\"初始化、激活\"></a>初始化、激活</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">_xmppRosterMemoryStorage = [[XMPPRosterMemoryStorage alloc] init];</div><div class=\"line\">_xmppRoster = [[XMPPRoster alloc] initWithRosterStorage:_xmppRosterMemoryStorage];</div><div class=\"line\">[_xmppRoster activate:self.xmppStream];</div></pre></td></tr></table></figure>\n<h5 id=\"设置代理\"><a href=\"#设置代理\" class=\"headerlink\" title=\"设置代理\"></a>设置代理</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//同时给_xmppRosterMemoryStorage 和 _xmppRoster都添加了代理</div><div class=\"line\">[_xmppRoster addDelegate:self delegateQueue:dispatch_get_main_queue()];</div><div class=\"line\">//设置好友同步策略,XMPP一旦连接成功，同步好友到本地</div><div class=\"line\">[_xmppRoster setAutoFetchRoster:YES]; //自动同步，从服务器取出好友</div></pre></td></tr></table></figure>\n<h5 id=\"好友请求相关\"><a href=\"#好友请求相关\" class=\"headerlink\" title=\"好友请求相关\"></a>好友请求相关</h5><p>如果想自行处理好友请求，则需要关闭自动好友请求</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">//关掉自动接收好友请求，默认开启自动同意</div><div class=\"line\">[_xmppRoster setAutoAcceptKnownPresenceSubscriptionRequests:NO];</div></pre></td></tr></table></figure>\n<h5 id=\"监听协议\"><a href=\"#监听协议\" class=\"headerlink\" title=\"监听协议\"></a>监听协议</h5><p>协议 <strong>XMPPRosterDelegate</strong> 中，包含花名册同步、好友变更相关协议。其中好友相关的主要如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//如果对方想添加我为好友（订阅我），会触发该回调</div><div class=\"line\"></div><div class=\"line\">//可以在此回调后，弹出好友请求界面</div><div class=\"line\">- (void)xmppRoster:(XMPPRoster *)sender didReceivePresenceSubscriptionRequest:(XMPPPresence *)presence</div><div class=\"line\">//可以根据此回调中presence的type判断是不是别人删除了好友</div><div class=\"line\">- (void)xmppStream:(XMPPStream *)sender didReceivePresence:(XMPPPresence *)presence;</div></pre></td></tr></table></figure>\n<p>好友列表的同步，会调用以下协议方法，在结束同步的方法之后，CoreData中好友列表就可以使用了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//开始同步服务器发送过来的自己的好友列表</div><div class=\"line\">- (void)xmppRosterDidBeginPopulating:(XMPPRoster *)sender</div><div class=\"line\">//同步结束</div><div class=\"line\">- (void)xmppRosterDidEndPopulating:(XMPPRoster *)sender;</div></pre></td></tr></table></figure>\n<p>当然，如果程序运行过程中，好友列表发生变更了该怎么办，当然还是协议方法了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">//收到每一个好友</div><div class=\"line\">- (void)xmppRoster:(XMPPRoster *)sender didReceiveRosterItem:(NSXMLElement *)item</div><div class=\"line\">//如果不是初始化同步来的roster,那么会自动存入我的好友存储器</div><div class=\"line\"> - (void)xmppRosterDidChange:(XMPPRosterMemoryStorage *)sender;</div></pre></td></tr></table></figure>\n<p>因为XMPPFramework的CoreData数据库已经将大多数操作进行了封装，我们如果使用CoreData，只需要在好友列表同步结束和好友花名册变更的回调中，发送个好友列表变更通知，使用好友花名册的地方根据实际需求处理即可</p>\n<h4 id=\"不使用CoreData存储\"><a href=\"#不使用CoreData存储\" class=\"headerlink\" title=\"不使用CoreData存储\"></a>不使用CoreData存储</h4><p>如果不使用CoreData进行数据存储，我们主要需要在两个协议回调中做文章。</p>\n<ul>\n<li>好友列表同步结束时，我们需要解析 <strong> XMPPIQ</strong> 中的XML数据，存储好友列表。</li>\n<li>收到好友花名册变更时，与存储的好友列表内好友比较，更新列表及列表中状态。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">-(BOOL)xmppStream:(XMPPStream *)sender didReceiveIQ:(XMPPIQ *)iq</div><div class=\"line\">-(void)xmppStream:(XMPPStream *)sender didReceivePresence:(XMPPPresence *)presence</div></pre></td></tr></table></figure>\n<p>其中，解析 <strong>XMPPIQ</strong> 中的XML携带有好友列表相关数据， <strong>XMPPPresence</strong> 会携带状态数据或者其他。一定要注意的是好友列表是由两者根据用户JID共同维护的。<br>解析XML方法此处不在说明。</p>\n<p>好了，本节就讲这些，下一节讲述：WebRTC实时通讯。</p>"},{"layout":"post","title":"chmod修改权限","date":"2017-08-17T05:51:43.000Z","author":"liangtong","catalog":true,"_content":"\n\n  Unix是多任务、多用户的操作系统，这以为着多个用户可以在同一时间使用同一台计算机。用户拥有文件或目录，则该用户对这个文件或目录的访问权限具有控制权。而用户又属于一个用户组(可以包含一个或多个用户)，用户组成员由文件或目录的所有者授予对文件或目录的访问权限。除了对用户组授权外，文件所有者可以给每个人一些权限。\n    在Unix系统中，可以通过shell中输入命令 id 来查看身份信息，系统中每个用户的uid是不同的。    \n```shell\nliangtongdeiMac:~ liangtong$ id\nuid=501(liangtong) gid=20(staff) groups=20(staff),701(com.apple.sharepoint.group.1),12(everyone),61(localaccounts),79(_appserverusr),80(admin),81(_appserveradm),98(_lpadmin),33(_appstore),100(_lpoperator),204(_developer),395(com.apple.access_ftp),398(com.apple.access_screensharing),399(com.apple.access_ssh)\nliangtongdeiMac:~ liangtong$ \n\n```\n\n<!-- more -->\n\n### 文件的读写与执行    \n对于文件的读写与执行，首先通过一下命令查看输出的结果：   \n```shell\nliangtongdeiMac:playground liangtong$ mkdir test_authority\nliangtongdeiMac:playground liangtong$ cd test_authority/\nliangtongdeiMac:test_authority liangtong$ > authority_test.txt\nliangtongdeiMac:test_authority liangtong$ ls -l authority_test.txt \n-rw-r--r--  1 liangtong  staff  0  8 16 18:43 authority_test.txt\nliangtongdeiMac:test_authority liangtong$ \n\n```\n这里创建了一个目录test_authority，并在目录中创建了一个文件authority_test.txt。之后查看文件线索。这里我们主要说前十个字符 *-rw-r--r--*。\n+ 第一个代表的是文件类型。\n   - *-* 表示普通文件\n   - *d* 表示目录\n   - 其他，比如 *l* 符号链接、 *c* 字符设备文件，比如终端机或者调制解调器、 *b* 块设备文件比如硬盘，CD-ROM盘\n+ 剩下的九个字符叫做文件模式，代表文件所有者，文件组所有者，其他人的读、写、执行权限  \n\n| Owner | Group | World |\n| :---: | :---: | :---: |\n|  rwx  |  rwx  |  rwx  |\n\n当设置文件模式后，r、w、x模式属性对文件和目录产生以下影响：\n\n|  属性  | 文件                   | 目录                         |\n| :--: | :------------------- | :------------------------- |\n|  r   | 读取文件的内容              | 允许列出目录内容，前提是目录必须可执行        |\n|  w   | 写入文件内容，但不允许重命名或删除    | 可以在目录下新增、修改、重命名，前提是目录必须可执行 |\n|  x   | 允许文件作为程序来执行，前提必须置为可读 | 允许进入目录，例如 cd xx            |\n\n以下举几个例子：\n\n|    文件属性    | 含义                                       |\n| :--------: | :--------------------------------------- |\n| -rwx------ | 普通文件，文件所有者可读可写可执行，其他人无任何权限               |\n| -rw------- | 普通文件，文件所有者可读可写，其他人无任何权限                  |\n| -rw-r--r-- | 普通文件，文件所有者可读可写，文件所有者所在组可读，其他人可读          |\n| -rwxr-xr-x | 普通文件，文件所有者可读可写可执行，文件所有者所在组可读可执行，其他人可读可执行 |\n| drwxrwx--- | 目录，目录所有者及所有者所在的分组可以访问目录，在目录中新建、修改、删除文件，其他人无权限 |\n| drwxr-x--- | 目录，目录所有者可以访问目录，在目录中新建、修改、删除文件；文件所有者所在分组可以访问目录，其他人无权限 |\n\n### chmod 修改文件模式\n\n文件／目录的所有者或者超级管理员可以用 *chmod* 命令来更改文件或者目录的权限。\nchmod命令支持两种不同的方式来更改文件模式：   \n+ 八进制数字表示法\n   - 每个八进制数字代表了3个二进制数字。\n   - 可以使用命令 *chmod 600 authority_test.txt* 将文件模式修改为可读可写\n\n| 十进制  | 二进制  | 文件模式 |   说明   |\n| :--: | :--: | :--: | :---- |\n|  0   | 000  | ---  |  无权限   |\n|  1   | 001  | --x  |   执行   |\n|  2   | 010  | -w-  |   写    |\n|  3   | 011  | -wx  |  写、执行  |\n|  4   | 100  | r--  |   读    |\n|  5   | 101  | r-x  |  读、执行  |\n|  6   | 110  | rw-  |  读、写   |\n|  7   | 111  | rwx  | 读、写、执行 |\n\n+ 符号表示法\n   - 由3部分组成。\n     - 会影响谁，包括 *u* 、  *g* 、  *o* 、  *a* \n     - 具体操作，包括 *+* 、  *-*  、  *=* \n     - 设置的权限，由 r 、 w 、 x 进行组合，例如 *x* 、  *rw*  、 *rwx* 等\n\n| 影响谁  | 含义                          |\n| :--: | :-------------------------- |\n|  u   | \"user\"的简写，意思是文件或目录的所有者。     |\n|  g   | 用户组                         |\n|  o   | \"others\"的简写，意思是其他所有的人       |\n|  a   | \"all\"的简写，是\"u\", \"g\"和“o”三者的联合 |\n|      | 如果没有指定字符，则假定使用”all”         |\n\n| 具体操作 | 含义                   |\n| :--: | :------------------- |\n|  +   | 加上一个权限               |\n|  -   | 删掉一个权限               |\n|  =   | 只有指定的权限可用，其它所有的权限被删除 |\n​\n以下举几个例子：   \n\n|   符号表示    | 含义                                       |\n| :-------: | :--------------------------------------- |\n|    u+x    | 为文件所有者添加可执行权限                            |\n|    +x     | 为文件所有者，用户组，和其他所有人添加可执行权限。 等价于 a+x。       |\n|   o-rw    | 除了文件所有者和用户组，删除其他人的读权限和写权限                |\n|   go=rw   | 给群组的主人和任意文件拥有者的人读写权限。如果群组的主人或全局之前已经有了执行的权限，他们将被移除。 |\n| u+x,go=rw | 给文件拥有者执行权限并给组和其他人限定读和执行的权限。多种设定可以用逗号分开。  |\n\n\n\n","source":"_posts/os_shell_authority_chmod.md","raw":"---\nlayout:     post\ntitle:      chmod修改权限\ndate:       2017-08-17 13:51:43\nauthor:     liangtong\ncatalog: true\ncategories: 操作系统\ntags: shell\n\n---\n\n\n  Unix是多任务、多用户的操作系统，这以为着多个用户可以在同一时间使用同一台计算机。用户拥有文件或目录，则该用户对这个文件或目录的访问权限具有控制权。而用户又属于一个用户组(可以包含一个或多个用户)，用户组成员由文件或目录的所有者授予对文件或目录的访问权限。除了对用户组授权外，文件所有者可以给每个人一些权限。\n    在Unix系统中，可以通过shell中输入命令 id 来查看身份信息，系统中每个用户的uid是不同的。    \n```shell\nliangtongdeiMac:~ liangtong$ id\nuid=501(liangtong) gid=20(staff) groups=20(staff),701(com.apple.sharepoint.group.1),12(everyone),61(localaccounts),79(_appserverusr),80(admin),81(_appserveradm),98(_lpadmin),33(_appstore),100(_lpoperator),204(_developer),395(com.apple.access_ftp),398(com.apple.access_screensharing),399(com.apple.access_ssh)\nliangtongdeiMac:~ liangtong$ \n\n```\n\n<!-- more -->\n\n### 文件的读写与执行    \n对于文件的读写与执行，首先通过一下命令查看输出的结果：   \n```shell\nliangtongdeiMac:playground liangtong$ mkdir test_authority\nliangtongdeiMac:playground liangtong$ cd test_authority/\nliangtongdeiMac:test_authority liangtong$ > authority_test.txt\nliangtongdeiMac:test_authority liangtong$ ls -l authority_test.txt \n-rw-r--r--  1 liangtong  staff  0  8 16 18:43 authority_test.txt\nliangtongdeiMac:test_authority liangtong$ \n\n```\n这里创建了一个目录test_authority，并在目录中创建了一个文件authority_test.txt。之后查看文件线索。这里我们主要说前十个字符 *-rw-r--r--*。\n+ 第一个代表的是文件类型。\n   - *-* 表示普通文件\n   - *d* 表示目录\n   - 其他，比如 *l* 符号链接、 *c* 字符设备文件，比如终端机或者调制解调器、 *b* 块设备文件比如硬盘，CD-ROM盘\n+ 剩下的九个字符叫做文件模式，代表文件所有者，文件组所有者，其他人的读、写、执行权限  \n\n| Owner | Group | World |\n| :---: | :---: | :---: |\n|  rwx  |  rwx  |  rwx  |\n\n当设置文件模式后，r、w、x模式属性对文件和目录产生以下影响：\n\n|  属性  | 文件                   | 目录                         |\n| :--: | :------------------- | :------------------------- |\n|  r   | 读取文件的内容              | 允许列出目录内容，前提是目录必须可执行        |\n|  w   | 写入文件内容，但不允许重命名或删除    | 可以在目录下新增、修改、重命名，前提是目录必须可执行 |\n|  x   | 允许文件作为程序来执行，前提必须置为可读 | 允许进入目录，例如 cd xx            |\n\n以下举几个例子：\n\n|    文件属性    | 含义                                       |\n| :--------: | :--------------------------------------- |\n| -rwx------ | 普通文件，文件所有者可读可写可执行，其他人无任何权限               |\n| -rw------- | 普通文件，文件所有者可读可写，其他人无任何权限                  |\n| -rw-r--r-- | 普通文件，文件所有者可读可写，文件所有者所在组可读，其他人可读          |\n| -rwxr-xr-x | 普通文件，文件所有者可读可写可执行，文件所有者所在组可读可执行，其他人可读可执行 |\n| drwxrwx--- | 目录，目录所有者及所有者所在的分组可以访问目录，在目录中新建、修改、删除文件，其他人无权限 |\n| drwxr-x--- | 目录，目录所有者可以访问目录，在目录中新建、修改、删除文件；文件所有者所在分组可以访问目录，其他人无权限 |\n\n### chmod 修改文件模式\n\n文件／目录的所有者或者超级管理员可以用 *chmod* 命令来更改文件或者目录的权限。\nchmod命令支持两种不同的方式来更改文件模式：   \n+ 八进制数字表示法\n   - 每个八进制数字代表了3个二进制数字。\n   - 可以使用命令 *chmod 600 authority_test.txt* 将文件模式修改为可读可写\n\n| 十进制  | 二进制  | 文件模式 |   说明   |\n| :--: | :--: | :--: | :---- |\n|  0   | 000  | ---  |  无权限   |\n|  1   | 001  | --x  |   执行   |\n|  2   | 010  | -w-  |   写    |\n|  3   | 011  | -wx  |  写、执行  |\n|  4   | 100  | r--  |   读    |\n|  5   | 101  | r-x  |  读、执行  |\n|  6   | 110  | rw-  |  读、写   |\n|  7   | 111  | rwx  | 读、写、执行 |\n\n+ 符号表示法\n   - 由3部分组成。\n     - 会影响谁，包括 *u* 、  *g* 、  *o* 、  *a* \n     - 具体操作，包括 *+* 、  *-*  、  *=* \n     - 设置的权限，由 r 、 w 、 x 进行组合，例如 *x* 、  *rw*  、 *rwx* 等\n\n| 影响谁  | 含义                          |\n| :--: | :-------------------------- |\n|  u   | \"user\"的简写，意思是文件或目录的所有者。     |\n|  g   | 用户组                         |\n|  o   | \"others\"的简写，意思是其他所有的人       |\n|  a   | \"all\"的简写，是\"u\", \"g\"和“o”三者的联合 |\n|      | 如果没有指定字符，则假定使用”all”         |\n\n| 具体操作 | 含义                   |\n| :--: | :------------------- |\n|  +   | 加上一个权限               |\n|  -   | 删掉一个权限               |\n|  =   | 只有指定的权限可用，其它所有的权限被删除 |\n​\n以下举几个例子：   \n\n|   符号表示    | 含义                                       |\n| :-------: | :--------------------------------------- |\n|    u+x    | 为文件所有者添加可执行权限                            |\n|    +x     | 为文件所有者，用户组，和其他所有人添加可执行权限。 等价于 a+x。       |\n|   o-rw    | 除了文件所有者和用户组，删除其他人的读权限和写权限                |\n|   go=rw   | 给群组的主人和任意文件拥有者的人读写权限。如果群组的主人或全局之前已经有了执行的权限，他们将被移除。 |\n| u+x,go=rw | 给文件拥有者执行权限并给组和其他人限定读和执行的权限。多种设定可以用逗号分开。  |\n\n\n\n","slug":"os_shell_authority_chmod","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4v90052oko8d43hof9o","content":"<p>  Unix是多任务、多用户的操作系统，这以为着多个用户可以在同一时间使用同一台计算机。用户拥有文件或目录，则该用户对这个文件或目录的访问权限具有控制权。而用户又属于一个用户组(可以包含一个或多个用户)，用户组成员由文件或目录的所有者授予对文件或目录的访问权限。除了对用户组授权外，文件所有者可以给每个人一些权限。<br>    在Unix系统中，可以通过shell中输入命令 id 来查看身份信息，系统中每个用户的uid是不同的。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">liangtongdeiMac:~ liangtong$ id</div><div class=\"line\">uid=501(liangtong) gid=20(staff) groups=20(staff),701(com.apple.sharepoint.group.1),12(everyone),61(localaccounts),79(_appserverusr),80(admin),81(_appserveradm),98(_lpadmin),33(_appstore),100(_lpoperator),204(_developer),395(com.apple.access_ftp),398(com.apple.access_screensharing),399(com.apple.access_ssh)</div><div class=\"line\">liangtongdeiMac:~ liangtong$</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h3 id=\"文件的读写与执行\"><a href=\"#文件的读写与执行\" class=\"headerlink\" title=\"文件的读写与执行\"></a>文件的读写与执行</h3><p>对于文件的读写与执行，首先通过一下命令查看输出的结果：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">liangtongdeiMac:playground liangtong$ mkdir test_authority</div><div class=\"line\">liangtongdeiMac:playground liangtong$ cd test_authority/</div><div class=\"line\">liangtongdeiMac:test_authority liangtong$ &gt; authority_test.txt</div><div class=\"line\">liangtongdeiMac:test_authority liangtong$ ls -l authority_test.txt </div><div class=\"line\">-rw-r--r--  1 liangtong  staff  0  8 16 18:43 authority_test.txt</div><div class=\"line\">liangtongdeiMac:test_authority liangtong$</div></pre></td></tr></table></figure></p>\n<p>这里创建了一个目录test_authority，并在目录中创建了一个文件authority_test.txt。之后查看文件线索。这里我们主要说前十个字符 <em>-rw-r–r–</em>。</p>\n<ul>\n<li>第一个代表的是文件类型。<ul>\n<li><em>-</em> 表示普通文件</li>\n<li><em>d</em> 表示目录</li>\n<li>其他，比如 <em>l</em> 符号链接、 <em>c</em> 字符设备文件，比如终端机或者调制解调器、 <em>b</em> 块设备文件比如硬盘，CD-ROM盘</li>\n</ul>\n</li>\n<li>剩下的九个字符叫做文件模式，代表文件所有者，文件组所有者，其他人的读、写、执行权限  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Owner</th>\n<th style=\"text-align:center\">Group</th>\n<th style=\"text-align:center\">World</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">rwx</td>\n<td style=\"text-align:center\">rwx</td>\n<td style=\"text-align:center\">rwx</td>\n</tr>\n</tbody>\n</table>\n<p>当设置文件模式后，r、w、x模式属性对文件和目录产生以下影响：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">属性</th>\n<th style=\"text-align:left\">文件</th>\n<th style=\"text-align:left\">目录</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">r</td>\n<td style=\"text-align:left\">读取文件的内容</td>\n<td style=\"text-align:left\">允许列出目录内容，前提是目录必须可执行</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">w</td>\n<td style=\"text-align:left\">写入文件内容，但不允许重命名或删除</td>\n<td style=\"text-align:left\">可以在目录下新增、修改、重命名，前提是目录必须可执行</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">x</td>\n<td style=\"text-align:left\">允许文件作为程序来执行，前提必须置为可读</td>\n<td style=\"text-align:left\">允许进入目录，例如 cd xx</td>\n</tr>\n</tbody>\n</table>\n<p>以下举几个例子：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">文件属性</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-rwx——</td>\n<td style=\"text-align:left\">普通文件，文件所有者可读可写可执行，其他人无任何权限</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-rw——-</td>\n<td style=\"text-align:left\">普通文件，文件所有者可读可写，其他人无任何权限</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-rw-r–r–</td>\n<td style=\"text-align:left\">普通文件，文件所有者可读可写，文件所有者所在组可读，其他人可读</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-rwxr-xr-x</td>\n<td style=\"text-align:left\">普通文件，文件所有者可读可写可执行，文件所有者所在组可读可执行，其他人可读可执行</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">drwxrwx—</td>\n<td style=\"text-align:left\">目录，目录所有者及所有者所在的分组可以访问目录，在目录中新建、修改、删除文件，其他人无权限</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">drwxr-x—</td>\n<td style=\"text-align:left\">目录，目录所有者可以访问目录，在目录中新建、修改、删除文件；文件所有者所在分组可以访问目录，其他人无权限</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"chmod-修改文件模式\"><a href=\"#chmod-修改文件模式\" class=\"headerlink\" title=\"chmod 修改文件模式\"></a>chmod 修改文件模式</h3><p>文件／目录的所有者或者超级管理员可以用 <em>chmod</em> 命令来更改文件或者目录的权限。<br>chmod命令支持两种不同的方式来更改文件模式：   </p>\n<ul>\n<li>八进制数字表示法<ul>\n<li>每个八进制数字代表了3个二进制数字。</li>\n<li>可以使用命令 <em>chmod 600 authority_test.txt</em> 将文件模式修改为可读可写</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">十进制</th>\n<th style=\"text-align:center\">二进制</th>\n<th style=\"text-align:center\">文件模式</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">000</td>\n<td style=\"text-align:center\">—</td>\n<td style=\"text-align:left\">无权限</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">001</td>\n<td style=\"text-align:center\">–x</td>\n<td style=\"text-align:left\">执行</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">010</td>\n<td style=\"text-align:center\">-w-</td>\n<td style=\"text-align:left\">写</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">011</td>\n<td style=\"text-align:center\">-wx</td>\n<td style=\"text-align:left\">写、执行</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">100</td>\n<td style=\"text-align:center\">r–</td>\n<td style=\"text-align:left\">读</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">101</td>\n<td style=\"text-align:center\">r-x</td>\n<td style=\"text-align:left\">读、执行</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\">110</td>\n<td style=\"text-align:center\">rw-</td>\n<td style=\"text-align:left\">读、写</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">111</td>\n<td style=\"text-align:center\">rwx</td>\n<td style=\"text-align:left\">读、写、执行</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>符号表示法<ul>\n<li>由3部分组成。<ul>\n<li>会影响谁，包括 <em>u</em> 、  <em>g</em> 、  <em>o</em> 、  <em>a</em> </li>\n<li>具体操作，包括 <em>+</em> 、  <em>-</em>  、  <em>=</em> </li>\n<li>设置的权限，由 r 、 w 、 x 进行组合，例如 <em>x</em> 、  <em>rw</em>  、 <em>rwx</em> 等</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">影响谁</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">u</td>\n<td style=\"text-align:left\">“user”的简写，意思是文件或目录的所有者。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">g</td>\n<td style=\"text-align:left\">用户组</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">o</td>\n<td style=\"text-align:left\">“others”的简写，意思是其他所有的人</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">a</td>\n<td style=\"text-align:left\">“all”的简写，是”u”, “g”和“o”三者的联合</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\">如果没有指定字符，则假定使用”all”</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">具体操作</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">+</td>\n<td style=\"text-align:left\">加上一个权限</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:left\">删掉一个权限</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">=</td>\n<td style=\"text-align:left\">只有指定的权限可用，其它所有的权限被删除</td>\n</tr>\n</tbody>\n</table>\n<p>​<br>以下举几个例子：   </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">符号表示</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">u+x</td>\n<td style=\"text-align:left\">为文件所有者添加可执行权限</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">+x</td>\n<td style=\"text-align:left\">为文件所有者，用户组，和其他所有人添加可执行权限。 等价于 a+x。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">o-rw</td>\n<td style=\"text-align:left\">除了文件所有者和用户组，删除其他人的读权限和写权限</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">go=rw</td>\n<td style=\"text-align:left\">给群组的主人和任意文件拥有者的人读写权限。如果群组的主人或全局之前已经有了执行的权限，他们将被移除。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">u+x,go=rw</td>\n<td style=\"text-align:left\">给文件拥有者执行权限并给组和其他人限定读和执行的权限。多种设定可以用逗号分开。</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"<p>  Unix是多任务、多用户的操作系统，这以为着多个用户可以在同一时间使用同一台计算机。用户拥有文件或目录，则该用户对这个文件或目录的访问权限具有控制权。而用户又属于一个用户组(可以包含一个或多个用户)，用户组成员由文件或目录的所有者授予对文件或目录的访问权限。除了对用户组授权外，文件所有者可以给每个人一些权限。<br>    在Unix系统中，可以通过shell中输入命令 id 来查看身份信息，系统中每个用户的uid是不同的。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">liangtongdeiMac:~ liangtong$ id</div><div class=\"line\">uid=501(liangtong) gid=20(staff) groups=20(staff),701(com.apple.sharepoint.group.1),12(everyone),61(localaccounts),79(_appserverusr),80(admin),81(_appserveradm),98(_lpadmin),33(_appstore),100(_lpoperator),204(_developer),395(com.apple.access_ftp),398(com.apple.access_screensharing),399(com.apple.access_ssh)</div><div class=\"line\">liangtongdeiMac:~ liangtong$</div></pre></td></tr></table></figure></p>","more":"<h3 id=\"文件的读写与执行\"><a href=\"#文件的读写与执行\" class=\"headerlink\" title=\"文件的读写与执行\"></a>文件的读写与执行</h3><p>对于文件的读写与执行，首先通过一下命令查看输出的结果：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">liangtongdeiMac:playground liangtong$ mkdir test_authority</div><div class=\"line\">liangtongdeiMac:playground liangtong$ cd test_authority/</div><div class=\"line\">liangtongdeiMac:test_authority liangtong$ &gt; authority_test.txt</div><div class=\"line\">liangtongdeiMac:test_authority liangtong$ ls -l authority_test.txt </div><div class=\"line\">-rw-r--r--  1 liangtong  staff  0  8 16 18:43 authority_test.txt</div><div class=\"line\">liangtongdeiMac:test_authority liangtong$</div></pre></td></tr></table></figure></p>\n<p>这里创建了一个目录test_authority，并在目录中创建了一个文件authority_test.txt。之后查看文件线索。这里我们主要说前十个字符 <em>-rw-r–r–</em>。</p>\n<ul>\n<li>第一个代表的是文件类型。<ul>\n<li><em>-</em> 表示普通文件</li>\n<li><em>d</em> 表示目录</li>\n<li>其他，比如 <em>l</em> 符号链接、 <em>c</em> 字符设备文件，比如终端机或者调制解调器、 <em>b</em> 块设备文件比如硬盘，CD-ROM盘</li>\n</ul>\n</li>\n<li>剩下的九个字符叫做文件模式，代表文件所有者，文件组所有者，其他人的读、写、执行权限  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Owner</th>\n<th style=\"text-align:center\">Group</th>\n<th style=\"text-align:center\">World</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">rwx</td>\n<td style=\"text-align:center\">rwx</td>\n<td style=\"text-align:center\">rwx</td>\n</tr>\n</tbody>\n</table>\n<p>当设置文件模式后，r、w、x模式属性对文件和目录产生以下影响：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">属性</th>\n<th style=\"text-align:left\">文件</th>\n<th style=\"text-align:left\">目录</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">r</td>\n<td style=\"text-align:left\">读取文件的内容</td>\n<td style=\"text-align:left\">允许列出目录内容，前提是目录必须可执行</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">w</td>\n<td style=\"text-align:left\">写入文件内容，但不允许重命名或删除</td>\n<td style=\"text-align:left\">可以在目录下新增、修改、重命名，前提是目录必须可执行</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">x</td>\n<td style=\"text-align:left\">允许文件作为程序来执行，前提必须置为可读</td>\n<td style=\"text-align:left\">允许进入目录，例如 cd xx</td>\n</tr>\n</tbody>\n</table>\n<p>以下举几个例子：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">文件属性</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-rwx——</td>\n<td style=\"text-align:left\">普通文件，文件所有者可读可写可执行，其他人无任何权限</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-rw——-</td>\n<td style=\"text-align:left\">普通文件，文件所有者可读可写，其他人无任何权限</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-rw-r–r–</td>\n<td style=\"text-align:left\">普通文件，文件所有者可读可写，文件所有者所在组可读，其他人可读</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-rwxr-xr-x</td>\n<td style=\"text-align:left\">普通文件，文件所有者可读可写可执行，文件所有者所在组可读可执行，其他人可读可执行</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">drwxrwx—</td>\n<td style=\"text-align:left\">目录，目录所有者及所有者所在的分组可以访问目录，在目录中新建、修改、删除文件，其他人无权限</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">drwxr-x—</td>\n<td style=\"text-align:left\">目录，目录所有者可以访问目录，在目录中新建、修改、删除文件；文件所有者所在分组可以访问目录，其他人无权限</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"chmod-修改文件模式\"><a href=\"#chmod-修改文件模式\" class=\"headerlink\" title=\"chmod 修改文件模式\"></a>chmod 修改文件模式</h3><p>文件／目录的所有者或者超级管理员可以用 <em>chmod</em> 命令来更改文件或者目录的权限。<br>chmod命令支持两种不同的方式来更改文件模式：   </p>\n<ul>\n<li>八进制数字表示法<ul>\n<li>每个八进制数字代表了3个二进制数字。</li>\n<li>可以使用命令 <em>chmod 600 authority_test.txt</em> 将文件模式修改为可读可写</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">十进制</th>\n<th style=\"text-align:center\">二进制</th>\n<th style=\"text-align:center\">文件模式</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">000</td>\n<td style=\"text-align:center\">—</td>\n<td style=\"text-align:left\">无权限</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">001</td>\n<td style=\"text-align:center\">–x</td>\n<td style=\"text-align:left\">执行</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">010</td>\n<td style=\"text-align:center\">-w-</td>\n<td style=\"text-align:left\">写</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">011</td>\n<td style=\"text-align:center\">-wx</td>\n<td style=\"text-align:left\">写、执行</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">100</td>\n<td style=\"text-align:center\">r–</td>\n<td style=\"text-align:left\">读</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">101</td>\n<td style=\"text-align:center\">r-x</td>\n<td style=\"text-align:left\">读、执行</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\">110</td>\n<td style=\"text-align:center\">rw-</td>\n<td style=\"text-align:left\">读、写</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">7</td>\n<td style=\"text-align:center\">111</td>\n<td style=\"text-align:center\">rwx</td>\n<td style=\"text-align:left\">读、写、执行</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>符号表示法<ul>\n<li>由3部分组成。<ul>\n<li>会影响谁，包括 <em>u</em> 、  <em>g</em> 、  <em>o</em> 、  <em>a</em> </li>\n<li>具体操作，包括 <em>+</em> 、  <em>-</em>  、  <em>=</em> </li>\n<li>设置的权限，由 r 、 w 、 x 进行组合，例如 <em>x</em> 、  <em>rw</em>  、 <em>rwx</em> 等</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">影响谁</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">u</td>\n<td style=\"text-align:left\">“user”的简写，意思是文件或目录的所有者。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">g</td>\n<td style=\"text-align:left\">用户组</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">o</td>\n<td style=\"text-align:left\">“others”的简写，意思是其他所有的人</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">a</td>\n<td style=\"text-align:left\">“all”的简写，是”u”, “g”和“o”三者的联合</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\">如果没有指定字符，则假定使用”all”</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">具体操作</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">+</td>\n<td style=\"text-align:left\">加上一个权限</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:left\">删掉一个权限</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">=</td>\n<td style=\"text-align:left\">只有指定的权限可用，其它所有的权限被删除</td>\n</tr>\n</tbody>\n</table>\n<p>​<br>以下举几个例子：   </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">符号表示</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">u+x</td>\n<td style=\"text-align:left\">为文件所有者添加可执行权限</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">+x</td>\n<td style=\"text-align:left\">为文件所有者，用户组，和其他所有人添加可执行权限。 等价于 a+x。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">o-rw</td>\n<td style=\"text-align:left\">除了文件所有者和用户组，删除其他人的读权限和写权限</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">go=rw</td>\n<td style=\"text-align:left\">给群组的主人和任意文件拥有者的人读写权限。如果群组的主人或全局之前已经有了执行的权限，他们将被移除。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">u+x,go=rw</td>\n<td style=\"text-align:left\">给文件拥有者执行权限并给组和其他人限定读和执行的权限。多种设定可以用逗号分开。</td>\n</tr>\n</tbody>\n</table>"},{"layout":"post","title":"修改文件所有者","date":"2017-08-28T03:51:43.000Z","author":"liangtong","catalog":true,"_content":"\n#### chown\n\n  使用超级管理员用户权限时，可以更改文件的所有者和用户组，命令如下：   \n\n > chown [owner][:[group]] file...\n\n命令将文件更改为第一个参数所表示的所有者 :所在分组。 例如：\n\n```shell\nliangtongdeiMac:test_authority liangtong$ sudo chown guest authority_test.txt \nPassword:\nliangtongdeiMac:test_authority liangtong$ ls -l\ntotal 0\n-rw-r--r--  1 Guest  staff  0  8 16 18:43 authority_test.txt\nliangtongdeiMac:test_authority liangtong$ \n\n```\n\n + 若命令中只包含 *用户名* ，则是把所有者更改为用户。\n + 若命令中包含 *:用户组* ，则将文件的用户组修改。\n + 特别的，若命令中参数格式是 *用户:* ， 即未指明用户组，那么用户组指的是用户所在的分组。\n\n#### chgrp\n  使用超级管理员用户权限时，可以使用 *chgrp* 来修改用户组，命令与chown相似：\n\n > chgrp group file\n\n\n\n\n","source":"_posts/os_shell_authority_chown.md","raw":"---\nlayout:     post\ntitle:      修改文件所有者\ndate:       2017-08-28 11:51:43\nauthor:     liangtong\ncatalog: true\ncategories: 操作系统\ntags: shell\n\n---\n\n#### chown\n\n  使用超级管理员用户权限时，可以更改文件的所有者和用户组，命令如下：   \n\n > chown [owner][:[group]] file...\n\n命令将文件更改为第一个参数所表示的所有者 :所在分组。 例如：\n\n```shell\nliangtongdeiMac:test_authority liangtong$ sudo chown guest authority_test.txt \nPassword:\nliangtongdeiMac:test_authority liangtong$ ls -l\ntotal 0\n-rw-r--r--  1 Guest  staff  0  8 16 18:43 authority_test.txt\nliangtongdeiMac:test_authority liangtong$ \n\n```\n\n + 若命令中只包含 *用户名* ，则是把所有者更改为用户。\n + 若命令中包含 *:用户组* ，则将文件的用户组修改。\n + 特别的，若命令中参数格式是 *用户:* ， 即未指明用户组，那么用户组指的是用户所在的分组。\n\n#### chgrp\n  使用超级管理员用户权限时，可以使用 *chgrp* 来修改用户组，命令与chown相似：\n\n > chgrp group file\n\n\n\n\n","slug":"os_shell_authority_chown","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4vb0057oko8l3swwnmo","content":"<h4 id=\"chown\"><a href=\"#chown\" class=\"headerlink\" title=\"chown\"></a>chown</h4><p>  使用超级管理员用户权限时，可以更改文件的所有者和用户组，命令如下：   </p>\n<blockquote>\n<p>chown [owner][:[group]] file…</p>\n</blockquote>\n<p>命令将文件更改为第一个参数所表示的所有者 :所在分组。 例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">liangtongdeiMac:test_authority liangtong$ sudo chown guest authority_test.txt </div><div class=\"line\">Password:</div><div class=\"line\">liangtongdeiMac:test_authority liangtong$ ls -l</div><div class=\"line\">total 0</div><div class=\"line\">-rw-r--r--  1 Guest  staff  0  8 16 18:43 authority_test.txt</div><div class=\"line\">liangtongdeiMac:test_authority liangtong$</div></pre></td></tr></table></figure>\n<ul>\n<li>若命令中只包含 <em>用户名</em> ，则是把所有者更改为用户。</li>\n<li>若命令中包含 <em>:用户组</em> ，则将文件的用户组修改。</li>\n<li>特别的，若命令中参数格式是 <em>用户:</em> ， 即未指明用户组，那么用户组指的是用户所在的分组。</li>\n</ul>\n<h4 id=\"chgrp\"><a href=\"#chgrp\" class=\"headerlink\" title=\"chgrp\"></a>chgrp</h4><p>  使用超级管理员用户权限时，可以使用 <em>chgrp</em> 来修改用户组，命令与chown相似：</p>\n<blockquote>\n<p>chgrp group file</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"chown\"><a href=\"#chown\" class=\"headerlink\" title=\"chown\"></a>chown</h4><p>  使用超级管理员用户权限时，可以更改文件的所有者和用户组，命令如下：   </p>\n<blockquote>\n<p>chown [owner][:[group]] file…</p>\n</blockquote>\n<p>命令将文件更改为第一个参数所表示的所有者 :所在分组。 例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">liangtongdeiMac:test_authority liangtong$ sudo chown guest authority_test.txt </div><div class=\"line\">Password:</div><div class=\"line\">liangtongdeiMac:test_authority liangtong$ ls -l</div><div class=\"line\">total 0</div><div class=\"line\">-rw-r--r--  1 Guest  staff  0  8 16 18:43 authority_test.txt</div><div class=\"line\">liangtongdeiMac:test_authority liangtong$</div></pre></td></tr></table></figure>\n<ul>\n<li>若命令中只包含 <em>用户名</em> ，则是把所有者更改为用户。</li>\n<li>若命令中包含 <em>:用户组</em> ，则将文件的用户组修改。</li>\n<li>特别的，若命令中参数格式是 <em>用户:</em> ， 即未指明用户组，那么用户组指的是用户所在的分组。</li>\n</ul>\n<h4 id=\"chgrp\"><a href=\"#chgrp\" class=\"headerlink\" title=\"chgrp\"></a>chgrp</h4><p>  使用超级管理员用户权限时，可以使用 <em>chgrp</em> 来修改用户组，命令与chown相似：</p>\n<blockquote>\n<p>chgrp group file</p>\n</blockquote>\n"},{"layout":"post","title":"重定向","date":"2017-08-29T01:51:43.000Z","author":"liangtong","catalog":true,"_content":"\n在linux系统下，一切皆是文件，对文件的操作，一般要用到文件标识符。\n\n#### 常用的FD(File Descriptor)\n\nlinux启动后，会默认打开3个文件描述符。分别是：   \n\n + 0 - 标准输入，/dev/stdin，可以理解为键盘\n + 1 - 标准输出，/dev/stdout，正确的输出，可以理解为屏幕\n + 2 - 标准错误输出，/dev/stderr，错误输出\n\n对于任何一条linux命令，都会有以上默认的3个描述符。也可以简单的理解为每个程序(函数)都会有输入、正确／错误输出。\n\n<!-- more -->\n\n#### 重定向\n\n重定向分为输入重定向和输出重定向。\n\n##### 输入重定向\n\n即不从键盘读入、而是从文件或者其他。\n > *<* 表示输入重定向运算符。\n\n例如命令先删除b.txt文件中内容，然后将a.txt文件中内容复制到b.txt文件中。\n\n```shell\nliangtongdeiMac:playground liangtong$ > b.txt \nliangtongdeiMac:playground liangtong$ cat > b.txt  < a.txt \n```\n\n等同与\n\n```shell\nliangtongdeiMac:playground liangtong$ > b.txt \nliangtongdeiMac:playground liangtong$ less a.txt >b.txt \n```\n\n> *<<* 表示当前标准输入来自命令行，符号后边跟随的是『结束的输入字符』。\n\n```shell\nliangtongdeiMac:playground liangtong$ > b.txt \nliangtongdeiMac:playground liangtong$ less b.txt \nliangtongdeiMac:playground liangtong$ > b.txt \nliangtongdeiMac:playground liangtong$ cat > b.txt << eof\n> hello\n> world\n> eof\nliangtongdeiMac:playground liangtong$ \nliangtongdeiMac:playground liangtong$ cat >>b.txt  << endofinput\n> hahaha\n> endofinput\nliangtongdeiMac:playground liangtong$ cat >>b.txt  << endofinput\n> adsfasdf\n> endofinput\nliangtongdeiMac:playground liangtong$ less b.txt \n\n```\n\n\n##### 输出重定向\n\n将一条命令执行结果（标准输出，或者错误输出，本来都要打印到屏幕上面的）  重定向其它输出设备（文件，打开文件操作符，或打印机等等）1,2分别是标准输出，错误输出\n\n + *>* 会判断右边文件是否存在，如果存在就先删除，并且创建新文件。不存在直接创建。\n + *>>*  判断右边文件，如果不存在，先创建。以添加方式打开文件。\n\n例如以下命令对应3种操作。 \n + 创建c.txt文件或者清除c.txt文件内容。\n + 将a.txt内容写入c.txt中。\n + 将b.txt内容追加写入c.txt中。\n\n```shell\nliangtongdeiMac:playground liangtong$ > c.txt\nliangtongdeiMac:playground liangtong$ less a.txt > c.txt \nliangtongdeiMac:playground liangtong$ less b.txt  >> c.txt \n\n```\n\n +  命令执行完后，绑定文件的描述符也自动失效。0,1,2又会空闲\n\n####  典型案例分析\n\n经过上述介绍，下面我们看一些典型的例子，这些尤其在makefile中很常见。 **特别注意的是，多个重定下复合时，按照顺序执行，例如 1>/dev/null 2>&1 和 2>&1 1>/dev//null 执行结果不一样**\n\n > & 是一个描述符，如果1或2前不加&，会被当成一个普通文件\n \n##### 1>&2和2>&1和&>filename\n\n1>&2 意思是标准输出重定向到标准错误。比如以下命令将a.txt\n2>&1 意思是把标准错误输出重定向到标准输出\n&>filename 意思是把标准输出和标准错误输出都重定向到文件filename中\n\n比如，以下命令分别 *ls -l *命令的标准输出、错误输出重定向到right.txt和error.txt文件中\n\n```Shell\nliangtongdeiMac:playground liangtong$ ls -l not_exist.txt a.txt 1>right.txt 2>error.txt\nliangtongdeiMac:playground liangtong$ less right.txt \nliangtongdeiMac:playground liangtong$ less error.txt \n```\n\n以下命令将标准输出重定向到right.txt文件中，将标准错误输出重定向到标准输出（此时是right.txt文件），此时right.txt文件将存放命令执行的标准输出和标准错误输出。\n\n```Shell\nliangtongdeiMac:playground liangtong$ ls -l not_exist.txt a.txt 1>right.txt 2>&1\nliangtongdeiMac:playground liangtong$ less right.txt \n```\n\n##### /dev/null\n\n/dev/null是一个垃圾箱，是一个无底洞，表示的含义为不显示。直接丢弃。\n比如以下命令效果一样，对标准输入、标准错误输出均丢弃\n\n```Shell\nliangtongdeiMac:playground liangtong$ ls -l not_exist.txt a.txt 1>/dev/null 2>/dev/null\nliangtongdeiMac:playground liangtong$ ls -l not_exist.txt a.txt 1>/dev/null 2>&1\n```\n\n##### 2>&1 1>/dev/null \n\n将标准错误输出在屏幕上（标准输出）表示，将标准输出丢弃，此时屏幕上只输出标准错误日志。\n\n##### 1>/dev/null 2>&1\n\n将标准输出丢弃，将标准错误重定向到标准输出，此时无任何输出(均被丢弃)。\n","source":"_posts/os_shell_std_in_out_error_redirect.md","raw":"---\nlayout:     post\ntitle:      重定向\ndate:       2017-08-29 09:51:43\nauthor:     liangtong\ncatalog: true\ncategories: 操作系统\ntags: shell\n\n---\n\n在linux系统下，一切皆是文件，对文件的操作，一般要用到文件标识符。\n\n#### 常用的FD(File Descriptor)\n\nlinux启动后，会默认打开3个文件描述符。分别是：   \n\n + 0 - 标准输入，/dev/stdin，可以理解为键盘\n + 1 - 标准输出，/dev/stdout，正确的输出，可以理解为屏幕\n + 2 - 标准错误输出，/dev/stderr，错误输出\n\n对于任何一条linux命令，都会有以上默认的3个描述符。也可以简单的理解为每个程序(函数)都会有输入、正确／错误输出。\n\n<!-- more -->\n\n#### 重定向\n\n重定向分为输入重定向和输出重定向。\n\n##### 输入重定向\n\n即不从键盘读入、而是从文件或者其他。\n > *<* 表示输入重定向运算符。\n\n例如命令先删除b.txt文件中内容，然后将a.txt文件中内容复制到b.txt文件中。\n\n```shell\nliangtongdeiMac:playground liangtong$ > b.txt \nliangtongdeiMac:playground liangtong$ cat > b.txt  < a.txt \n```\n\n等同与\n\n```shell\nliangtongdeiMac:playground liangtong$ > b.txt \nliangtongdeiMac:playground liangtong$ less a.txt >b.txt \n```\n\n> *<<* 表示当前标准输入来自命令行，符号后边跟随的是『结束的输入字符』。\n\n```shell\nliangtongdeiMac:playground liangtong$ > b.txt \nliangtongdeiMac:playground liangtong$ less b.txt \nliangtongdeiMac:playground liangtong$ > b.txt \nliangtongdeiMac:playground liangtong$ cat > b.txt << eof\n> hello\n> world\n> eof\nliangtongdeiMac:playground liangtong$ \nliangtongdeiMac:playground liangtong$ cat >>b.txt  << endofinput\n> hahaha\n> endofinput\nliangtongdeiMac:playground liangtong$ cat >>b.txt  << endofinput\n> adsfasdf\n> endofinput\nliangtongdeiMac:playground liangtong$ less b.txt \n\n```\n\n\n##### 输出重定向\n\n将一条命令执行结果（标准输出，或者错误输出，本来都要打印到屏幕上面的）  重定向其它输出设备（文件，打开文件操作符，或打印机等等）1,2分别是标准输出，错误输出\n\n + *>* 会判断右边文件是否存在，如果存在就先删除，并且创建新文件。不存在直接创建。\n + *>>*  判断右边文件，如果不存在，先创建。以添加方式打开文件。\n\n例如以下命令对应3种操作。 \n + 创建c.txt文件或者清除c.txt文件内容。\n + 将a.txt内容写入c.txt中。\n + 将b.txt内容追加写入c.txt中。\n\n```shell\nliangtongdeiMac:playground liangtong$ > c.txt\nliangtongdeiMac:playground liangtong$ less a.txt > c.txt \nliangtongdeiMac:playground liangtong$ less b.txt  >> c.txt \n\n```\n\n +  命令执行完后，绑定文件的描述符也自动失效。0,1,2又会空闲\n\n####  典型案例分析\n\n经过上述介绍，下面我们看一些典型的例子，这些尤其在makefile中很常见。 **特别注意的是，多个重定下复合时，按照顺序执行，例如 1>/dev/null 2>&1 和 2>&1 1>/dev//null 执行结果不一样**\n\n > & 是一个描述符，如果1或2前不加&，会被当成一个普通文件\n \n##### 1>&2和2>&1和&>filename\n\n1>&2 意思是标准输出重定向到标准错误。比如以下命令将a.txt\n2>&1 意思是把标准错误输出重定向到标准输出\n&>filename 意思是把标准输出和标准错误输出都重定向到文件filename中\n\n比如，以下命令分别 *ls -l *命令的标准输出、错误输出重定向到right.txt和error.txt文件中\n\n```Shell\nliangtongdeiMac:playground liangtong$ ls -l not_exist.txt a.txt 1>right.txt 2>error.txt\nliangtongdeiMac:playground liangtong$ less right.txt \nliangtongdeiMac:playground liangtong$ less error.txt \n```\n\n以下命令将标准输出重定向到right.txt文件中，将标准错误输出重定向到标准输出（此时是right.txt文件），此时right.txt文件将存放命令执行的标准输出和标准错误输出。\n\n```Shell\nliangtongdeiMac:playground liangtong$ ls -l not_exist.txt a.txt 1>right.txt 2>&1\nliangtongdeiMac:playground liangtong$ less right.txt \n```\n\n##### /dev/null\n\n/dev/null是一个垃圾箱，是一个无底洞，表示的含义为不显示。直接丢弃。\n比如以下命令效果一样，对标准输入、标准错误输出均丢弃\n\n```Shell\nliangtongdeiMac:playground liangtong$ ls -l not_exist.txt a.txt 1>/dev/null 2>/dev/null\nliangtongdeiMac:playground liangtong$ ls -l not_exist.txt a.txt 1>/dev/null 2>&1\n```\n\n##### 2>&1 1>/dev/null \n\n将标准错误输出在屏幕上（标准输出）表示，将标准输出丢弃，此时屏幕上只输出标准错误日志。\n\n##### 1>/dev/null 2>&1\n\n将标准输出丢弃，将标准错误重定向到标准输出，此时无任何输出(均被丢弃)。\n","slug":"os_shell_std_in_out_error_redirect","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4vb0059oko8jids9g48","content":"<p>在linux系统下，一切皆是文件，对文件的操作，一般要用到文件标识符。</p>\n<h4 id=\"常用的FD-File-Descriptor\"><a href=\"#常用的FD-File-Descriptor\" class=\"headerlink\" title=\"常用的FD(File Descriptor)\"></a>常用的FD(File Descriptor)</h4><p>linux启动后，会默认打开3个文件描述符。分别是：   </p>\n<ul>\n<li>0 - 标准输入，/dev/stdin，可以理解为键盘</li>\n<li>1 - 标准输出，/dev/stdout，正确的输出，可以理解为屏幕</li>\n<li>2 - 标准错误输出，/dev/stderr，错误输出</li>\n</ul>\n<p>对于任何一条linux命令，都会有以上默认的3个描述符。也可以简单的理解为每个程序(函数)都会有输入、正确／错误输出。</p>\n<a id=\"more\"></a>\n<h4 id=\"重定向\"><a href=\"#重定向\" class=\"headerlink\" title=\"重定向\"></a>重定向</h4><p>重定向分为输入重定向和输出重定向。</p>\n<h5 id=\"输入重定向\"><a href=\"#输入重定向\" class=\"headerlink\" title=\"输入重定向\"></a>输入重定向</h5><p>即不从键盘读入、而是从文件或者其他。</p>\n<blockquote>\n<p><em>&lt;</em> 表示输入重定向运算符。</p>\n</blockquote>\n<p>例如命令先删除b.txt文件中内容，然后将a.txt文件中内容复制到b.txt文件中。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">liangtongdeiMac:playground liangtong$ &gt; b.txt </div><div class=\"line\">liangtongdeiMac:playground liangtong$ cat &gt; b.txt  &lt; a.txt</div></pre></td></tr></table></figure>\n<p>等同与</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">liangtongdeiMac:playground liangtong$ &gt; b.txt </div><div class=\"line\">liangtongdeiMac:playground liangtong$ less a.txt &gt;b.txt</div></pre></td></tr></table></figure>\n<blockquote>\n<p><em>&lt;&lt;</em> 表示当前标准输入来自命令行，符号后边跟随的是『结束的输入字符』。</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">liangtongdeiMac:playground liangtong$ &gt; b.txt </div><div class=\"line\">liangtongdeiMac:playground liangtong$ less b.txt </div><div class=\"line\">liangtongdeiMac:playground liangtong$ &gt; b.txt </div><div class=\"line\">liangtongdeiMac:playground liangtong$ cat &gt; b.txt &lt;&lt; eof</div><div class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> hello</span></div><div class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> world</span></div><div class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> eof</span></div><div class=\"line\">liangtongdeiMac:playground liangtong$ </div><div class=\"line\">liangtongdeiMac:playground liangtong$ cat &gt;&gt;b.txt  &lt;&lt; endofinput</div><div class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> hahaha</span></div><div class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> endofinput</span></div><div class=\"line\">liangtongdeiMac:playground liangtong$ cat &gt;&gt;b.txt  &lt;&lt; endofinput</div><div class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> adsfasdf</span></div><div class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> endofinput</span></div><div class=\"line\">liangtongdeiMac:playground liangtong$ less b.txt</div></pre></td></tr></table></figure>\n<h5 id=\"输出重定向\"><a href=\"#输出重定向\" class=\"headerlink\" title=\"输出重定向\"></a>输出重定向</h5><p>将一条命令执行结果（标准输出，或者错误输出，本来都要打印到屏幕上面的）  重定向其它输出设备（文件，打开文件操作符，或打印机等等）1,2分别是标准输出，错误输出</p>\n<ul>\n<li><em>&gt;</em> 会判断右边文件是否存在，如果存在就先删除，并且创建新文件。不存在直接创建。</li>\n<li><em>&gt;&gt;</em>  判断右边文件，如果不存在，先创建。以添加方式打开文件。</li>\n</ul>\n<p>例如以下命令对应3种操作。 </p>\n<ul>\n<li>创建c.txt文件或者清除c.txt文件内容。</li>\n<li>将a.txt内容写入c.txt中。</li>\n<li>将b.txt内容追加写入c.txt中。</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">liangtongdeiMac:playground liangtong$ &gt; c.txt</div><div class=\"line\">liangtongdeiMac:playground liangtong$ less a.txt &gt; c.txt </div><div class=\"line\">liangtongdeiMac:playground liangtong$ less b.txt  &gt;&gt; c.txt</div></pre></td></tr></table></figure>\n<ul>\n<li>命令执行完后，绑定文件的描述符也自动失效。0,1,2又会空闲</li>\n</ul>\n<h4 id=\"典型案例分析\"><a href=\"#典型案例分析\" class=\"headerlink\" title=\"典型案例分析\"></a>典型案例分析</h4><p>经过上述介绍，下面我们看一些典型的例子，这些尤其在makefile中很常见。 <strong>特别注意的是，多个重定下复合时，按照顺序执行，例如 1&gt;/dev/null 2&gt;&amp;1 和 2&gt;&amp;1 1&gt;/dev//null 执行结果不一样</strong></p>\n<blockquote>\n<p>&amp; 是一个描述符，如果1或2前不加&amp;，会被当成一个普通文件</p>\n</blockquote>\n<h5 id=\"1-gt-amp-2和2-gt-amp-1和-amp-gt-filename\"><a href=\"#1-gt-amp-2和2-gt-amp-1和-amp-gt-filename\" class=\"headerlink\" title=\"1&gt;&amp;2和2&gt;&amp;1和&amp;&gt;filename\"></a>1&gt;&amp;2和2&gt;&amp;1和&amp;&gt;filename</h5><p>1&gt;&amp;2 意思是标准输出重定向到标准错误。比如以下命令将a.txt<br>2&gt;&amp;1 意思是把标准错误输出重定向到标准输出<br>&amp;&gt;filename 意思是把标准输出和标准错误输出都重定向到文件filename中</p>\n<p>比如，以下命令分别 <em>ls -l </em>命令的标准输出、错误输出重定向到right.txt和error.txt文件中</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">liangtongdeiMac:playground liangtong$ ls -l not_exist.txt a.txt 1&gt;right.txt 2&gt;error.txt</div><div class=\"line\">liangtongdeiMac:playground liangtong$ less right.txt </div><div class=\"line\">liangtongdeiMac:playground liangtong$ less error.txt</div></pre></td></tr></table></figure>\n<p>以下命令将标准输出重定向到right.txt文件中，将标准错误输出重定向到标准输出（此时是right.txt文件），此时right.txt文件将存放命令执行的标准输出和标准错误输出。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">liangtongdeiMac:playground liangtong$ ls -l not_exist.txt a.txt 1&gt;right.txt 2&gt;&amp;1</div><div class=\"line\">liangtongdeiMac:playground liangtong$ less right.txt</div></pre></td></tr></table></figure>\n<h5 id=\"dev-null\"><a href=\"#dev-null\" class=\"headerlink\" title=\"/dev/null\"></a>/dev/null</h5><p>/dev/null是一个垃圾箱，是一个无底洞，表示的含义为不显示。直接丢弃。<br>比如以下命令效果一样，对标准输入、标准错误输出均丢弃</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">liangtongdeiMac:playground liangtong$ ls -l not_exist.txt a.txt 1&gt;/dev/null 2&gt;/dev/null</div><div class=\"line\">liangtongdeiMac:playground liangtong$ ls -l not_exist.txt a.txt 1&gt;/dev/null 2&gt;&amp;1</div></pre></td></tr></table></figure>\n<h5 id=\"2-gt-amp-1-1-gt-dev-null\"><a href=\"#2-gt-amp-1-1-gt-dev-null\" class=\"headerlink\" title=\"2&gt;&amp;1 1&gt;/dev/null\"></a>2&gt;&amp;1 1&gt;/dev/null</h5><p>将标准错误输出在屏幕上（标准输出）表示，将标准输出丢弃，此时屏幕上只输出标准错误日志。</p>\n<h5 id=\"1-gt-dev-null-2-gt-amp-1\"><a href=\"#1-gt-dev-null-2-gt-amp-1\" class=\"headerlink\" title=\"1&gt;/dev/null 2&gt;&amp;1\"></a>1&gt;/dev/null 2&gt;&amp;1</h5><p>将标准输出丢弃，将标准错误重定向到标准输出，此时无任何输出(均被丢弃)。</p>\n","site":{"data":{}},"excerpt":"<p>在linux系统下，一切皆是文件，对文件的操作，一般要用到文件标识符。</p>\n<h4 id=\"常用的FD-File-Descriptor\"><a href=\"#常用的FD-File-Descriptor\" class=\"headerlink\" title=\"常用的FD(File Descriptor)\"></a>常用的FD(File Descriptor)</h4><p>linux启动后，会默认打开3个文件描述符。分别是：   </p>\n<ul>\n<li>0 - 标准输入，/dev/stdin，可以理解为键盘</li>\n<li>1 - 标准输出，/dev/stdout，正确的输出，可以理解为屏幕</li>\n<li>2 - 标准错误输出，/dev/stderr，错误输出</li>\n</ul>\n<p>对于任何一条linux命令，都会有以上默认的3个描述符。也可以简单的理解为每个程序(函数)都会有输入、正确／错误输出。</p>","more":"<h4 id=\"重定向\"><a href=\"#重定向\" class=\"headerlink\" title=\"重定向\"></a>重定向</h4><p>重定向分为输入重定向和输出重定向。</p>\n<h5 id=\"输入重定向\"><a href=\"#输入重定向\" class=\"headerlink\" title=\"输入重定向\"></a>输入重定向</h5><p>即不从键盘读入、而是从文件或者其他。</p>\n<blockquote>\n<p><em>&lt;</em> 表示输入重定向运算符。</p>\n</blockquote>\n<p>例如命令先删除b.txt文件中内容，然后将a.txt文件中内容复制到b.txt文件中。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">liangtongdeiMac:playground liangtong$ &gt; b.txt </div><div class=\"line\">liangtongdeiMac:playground liangtong$ cat &gt; b.txt  &lt; a.txt</div></pre></td></tr></table></figure>\n<p>等同与</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">liangtongdeiMac:playground liangtong$ &gt; b.txt </div><div class=\"line\">liangtongdeiMac:playground liangtong$ less a.txt &gt;b.txt</div></pre></td></tr></table></figure>\n<blockquote>\n<p><em>&lt;&lt;</em> 表示当前标准输入来自命令行，符号后边跟随的是『结束的输入字符』。</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">liangtongdeiMac:playground liangtong$ &gt; b.txt </div><div class=\"line\">liangtongdeiMac:playground liangtong$ less b.txt </div><div class=\"line\">liangtongdeiMac:playground liangtong$ &gt; b.txt </div><div class=\"line\">liangtongdeiMac:playground liangtong$ cat &gt; b.txt &lt;&lt; eof</div><div class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> hello</span></div><div class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> world</span></div><div class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> eof</span></div><div class=\"line\">liangtongdeiMac:playground liangtong$ </div><div class=\"line\">liangtongdeiMac:playground liangtong$ cat &gt;&gt;b.txt  &lt;&lt; endofinput</div><div class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> hahaha</span></div><div class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> endofinput</span></div><div class=\"line\">liangtongdeiMac:playground liangtong$ cat &gt;&gt;b.txt  &lt;&lt; endofinput</div><div class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> adsfasdf</span></div><div class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> endofinput</span></div><div class=\"line\">liangtongdeiMac:playground liangtong$ less b.txt</div></pre></td></tr></table></figure>\n<h5 id=\"输出重定向\"><a href=\"#输出重定向\" class=\"headerlink\" title=\"输出重定向\"></a>输出重定向</h5><p>将一条命令执行结果（标准输出，或者错误输出，本来都要打印到屏幕上面的）  重定向其它输出设备（文件，打开文件操作符，或打印机等等）1,2分别是标准输出，错误输出</p>\n<ul>\n<li><em>&gt;</em> 会判断右边文件是否存在，如果存在就先删除，并且创建新文件。不存在直接创建。</li>\n<li><em>&gt;&gt;</em>  判断右边文件，如果不存在，先创建。以添加方式打开文件。</li>\n</ul>\n<p>例如以下命令对应3种操作。 </p>\n<ul>\n<li>创建c.txt文件或者清除c.txt文件内容。</li>\n<li>将a.txt内容写入c.txt中。</li>\n<li>将b.txt内容追加写入c.txt中。</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">liangtongdeiMac:playground liangtong$ &gt; c.txt</div><div class=\"line\">liangtongdeiMac:playground liangtong$ less a.txt &gt; c.txt </div><div class=\"line\">liangtongdeiMac:playground liangtong$ less b.txt  &gt;&gt; c.txt</div></pre></td></tr></table></figure>\n<ul>\n<li>命令执行完后，绑定文件的描述符也自动失效。0,1,2又会空闲</li>\n</ul>\n<h4 id=\"典型案例分析\"><a href=\"#典型案例分析\" class=\"headerlink\" title=\"典型案例分析\"></a>典型案例分析</h4><p>经过上述介绍，下面我们看一些典型的例子，这些尤其在makefile中很常见。 <strong>特别注意的是，多个重定下复合时，按照顺序执行，例如 1&gt;/dev/null 2&gt;&amp;1 和 2&gt;&amp;1 1&gt;/dev//null 执行结果不一样</strong></p>\n<blockquote>\n<p>&amp; 是一个描述符，如果1或2前不加&amp;，会被当成一个普通文件</p>\n</blockquote>\n<h5 id=\"1-gt-amp-2和2-gt-amp-1和-amp-gt-filename\"><a href=\"#1-gt-amp-2和2-gt-amp-1和-amp-gt-filename\" class=\"headerlink\" title=\"1&gt;&amp;2和2&gt;&amp;1和&amp;&gt;filename\"></a>1&gt;&amp;2和2&gt;&amp;1和&amp;&gt;filename</h5><p>1&gt;&amp;2 意思是标准输出重定向到标准错误。比如以下命令将a.txt<br>2&gt;&amp;1 意思是把标准错误输出重定向到标准输出<br>&amp;&gt;filename 意思是把标准输出和标准错误输出都重定向到文件filename中</p>\n<p>比如，以下命令分别 <em>ls -l </em>命令的标准输出、错误输出重定向到right.txt和error.txt文件中</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">liangtongdeiMac:playground liangtong$ ls -l not_exist.txt a.txt 1&gt;right.txt 2&gt;error.txt</div><div class=\"line\">liangtongdeiMac:playground liangtong$ less right.txt </div><div class=\"line\">liangtongdeiMac:playground liangtong$ less error.txt</div></pre></td></tr></table></figure>\n<p>以下命令将标准输出重定向到right.txt文件中，将标准错误输出重定向到标准输出（此时是right.txt文件），此时right.txt文件将存放命令执行的标准输出和标准错误输出。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">liangtongdeiMac:playground liangtong$ ls -l not_exist.txt a.txt 1&gt;right.txt 2&gt;&amp;1</div><div class=\"line\">liangtongdeiMac:playground liangtong$ less right.txt</div></pre></td></tr></table></figure>\n<h5 id=\"dev-null\"><a href=\"#dev-null\" class=\"headerlink\" title=\"/dev/null\"></a>/dev/null</h5><p>/dev/null是一个垃圾箱，是一个无底洞，表示的含义为不显示。直接丢弃。<br>比如以下命令效果一样，对标准输入、标准错误输出均丢弃</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">liangtongdeiMac:playground liangtong$ ls -l not_exist.txt a.txt 1&gt;/dev/null 2&gt;/dev/null</div><div class=\"line\">liangtongdeiMac:playground liangtong$ ls -l not_exist.txt a.txt 1&gt;/dev/null 2&gt;&amp;1</div></pre></td></tr></table></figure>\n<h5 id=\"2-gt-amp-1-1-gt-dev-null\"><a href=\"#2-gt-amp-1-1-gt-dev-null\" class=\"headerlink\" title=\"2&gt;&amp;1 1&gt;/dev/null\"></a>2&gt;&amp;1 1&gt;/dev/null</h5><p>将标准错误输出在屏幕上（标准输出）表示，将标准输出丢弃，此时屏幕上只输出标准错误日志。</p>\n<h5 id=\"1-gt-dev-null-2-gt-amp-1\"><a href=\"#1-gt-dev-null-2-gt-amp-1\" class=\"headerlink\" title=\"1&gt;/dev/null 2&gt;&amp;1\"></a>1&gt;/dev/null 2&gt;&amp;1</h5><p>将标准输出丢弃，将标准错误重定向到标准输出，此时无任何输出(均被丢弃)。</p>"},{"layout":"post","title":"Mac下使用Hexo搭建GitHub博客","date":"2017-08-04T06:25:19.000Z","author":"liangtong","_content":"\n\n\n### 创建GitHub账号   \n  注册[Github](https://github.com/)账号，建立个人博客仓库(Repository)，不在赘述。 \n\n### 安装Git工具\n  终端直接执行 *git* 命令，或者通过安装GitHub客户端。\n\n### 安装Node和NPM  \n  打开终端，通过以下命令安装：    \n```Shell\n$ brew install node\n```\n\n### 安装Hexo  \n  可以参照Hexo在[Github](https://github.com/hexojs/hexo)上的官方介绍，在终端依次执行以下命令进行：   \n```Shell\n$ npm install hexo-cli -g\n```    \n  安装成功后，可以通过以下命令进行查看   \n```Shell\n$ hexo\n```  \n\n<!-- more -->\n\n### 快速使用博客   \n\n通过在终端输入以下命令执行初始化\n```Shell\n$ hexo init blog_name\n$ cd blog_name\n```  \n修改Hexo配置文件_config.yml  \n\n```Script\n# Site\ntitle: liangtong\nsubtitle: \ndescription: Keep hungry keep foolish！\nauthor: liangtong\nlanguage: zh-Hans\ntimezone:\n```  \n\n通过在终端输入以下命令新建博客文章\n```Shell\n$ hexo new \"Hello Hexo\"\n```  \n通过在终端输入以下命令生成静态文件\n```Shell\n$ hexo generate\n``` \n通过在终端输入以下命令启动服务\n```Shell\n$ hexo server\n```  \n\n### 更换Hexo主题   \n这里使用GitHub上排名最靠前的主题[NexT](https://github.com/iissnan/hexo-theme-next)，在终端输入以下命令进行主题下载：   \n```Shell\n$ cd blog_name\n$ git clone https://github.com/iissnan/hexo-theme-next themes/next\n```     \n参照[NexT官方指导网站](http://theme-next.iissnan.com/getting-started.html)，对博客进行个性化配置，常用设置包括：   \n + 主题设定   \n + 标签   \n + 分类   \n + 侧边栏   \n + 打赏   \n + 友情链接\n + 动画效果\n + 评论分享   \n\n### 配置Hexo部署  \n\n在Hexo配置文件中完善部署信息，即你的Github个人博客地址信息：   \n\n```Script\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\ntype: git\nrepo: https://github.com/l900416/l900416.github.io.git\nbranch: master\n```    \n\n### 发布Hexo网站到GitHub   \n通过终端输入以下命令将Hexo博客发布到Github上：   \n```Shell\n$ hexo g\n```  \n此步骤如果出现错误 * Deployer not found: git * ：   \n + 检查Hexo配置的部署文件    \n + 终端输入命令：\n    - > npm install hexo-deployer-git --save \n\n### Hexo在GitHub上的维护    \n说下本人的做法，创建新的Branch，命名为hexo，用于存放博客源码，master用于个人博客。这样使用一个仓库来维护。\n\n### Hexo与Jekyll不同之处   \n + Hexo博客文件需要单独维护。对应GitHub仓库中的文件是通过Hexo部署进去的。\n + Jekyll博客文件直接上传到GitHub博客仓库中即可。\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/share_github_blog_hexo.md","raw":"---\nlayout:     post\ntitle:      Mac下使用Hexo搭建GitHub博客\ndate:       2017-08-04 14:25:19\nauthor:     liangtong\ncategories: 技术分享\ntags: GitHub\n\n---\n\n\n\n### 创建GitHub账号   \n  注册[Github](https://github.com/)账号，建立个人博客仓库(Repository)，不在赘述。 \n\n### 安装Git工具\n  终端直接执行 *git* 命令，或者通过安装GitHub客户端。\n\n### 安装Node和NPM  \n  打开终端，通过以下命令安装：    \n```Shell\n$ brew install node\n```\n\n### 安装Hexo  \n  可以参照Hexo在[Github](https://github.com/hexojs/hexo)上的官方介绍，在终端依次执行以下命令进行：   \n```Shell\n$ npm install hexo-cli -g\n```    \n  安装成功后，可以通过以下命令进行查看   \n```Shell\n$ hexo\n```  \n\n<!-- more -->\n\n### 快速使用博客   \n\n通过在终端输入以下命令执行初始化\n```Shell\n$ hexo init blog_name\n$ cd blog_name\n```  \n修改Hexo配置文件_config.yml  \n\n```Script\n# Site\ntitle: liangtong\nsubtitle: \ndescription: Keep hungry keep foolish！\nauthor: liangtong\nlanguage: zh-Hans\ntimezone:\n```  \n\n通过在终端输入以下命令新建博客文章\n```Shell\n$ hexo new \"Hello Hexo\"\n```  \n通过在终端输入以下命令生成静态文件\n```Shell\n$ hexo generate\n``` \n通过在终端输入以下命令启动服务\n```Shell\n$ hexo server\n```  \n\n### 更换Hexo主题   \n这里使用GitHub上排名最靠前的主题[NexT](https://github.com/iissnan/hexo-theme-next)，在终端输入以下命令进行主题下载：   \n```Shell\n$ cd blog_name\n$ git clone https://github.com/iissnan/hexo-theme-next themes/next\n```     \n参照[NexT官方指导网站](http://theme-next.iissnan.com/getting-started.html)，对博客进行个性化配置，常用设置包括：   \n + 主题设定   \n + 标签   \n + 分类   \n + 侧边栏   \n + 打赏   \n + 友情链接\n + 动画效果\n + 评论分享   \n\n### 配置Hexo部署  \n\n在Hexo配置文件中完善部署信息，即你的Github个人博客地址信息：   \n\n```Script\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\ntype: git\nrepo: https://github.com/l900416/l900416.github.io.git\nbranch: master\n```    \n\n### 发布Hexo网站到GitHub   \n通过终端输入以下命令将Hexo博客发布到Github上：   \n```Shell\n$ hexo g\n```  \n此步骤如果出现错误 * Deployer not found: git * ：   \n + 检查Hexo配置的部署文件    \n + 终端输入命令：\n    - > npm install hexo-deployer-git --save \n\n### Hexo在GitHub上的维护    \n说下本人的做法，创建新的Branch，命名为hexo，用于存放博客源码，master用于个人博客。这样使用一个仓库来维护。\n\n### Hexo与Jekyll不同之处   \n + Hexo博客文件需要单独维护。对应GitHub仓库中的文件是通过Hexo部署进去的。\n + Jekyll博客文件直接上传到GitHub博客仓库中即可。\n\n\n\n\n\n\n\n\n\n\n\n","slug":"share_github_blog_hexo","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4vd005eoko8s7awd5z0","content":"<h3 id=\"创建GitHub账号\"><a href=\"#创建GitHub账号\" class=\"headerlink\" title=\"创建GitHub账号\"></a>创建GitHub账号</h3><p>  注册<a href=\"https://github.com/\" target=\"_blank\" rel=\"external\">Github</a>账号，建立个人博客仓库(Repository)，不在赘述。 </p>\n<h3 id=\"安装Git工具\"><a href=\"#安装Git工具\" class=\"headerlink\" title=\"安装Git工具\"></a>安装Git工具</h3><p>  终端直接执行 <em>git</em> 命令，或者通过安装GitHub客户端。</p>\n<h3 id=\"安装Node和NPM\"><a href=\"#安装Node和NPM\" class=\"headerlink\" title=\"安装Node和NPM\"></a>安装Node和NPM</h3><p>  打开终端，通过以下命令安装：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> brew install node</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h3><p>  可以参照Hexo在<a href=\"https://github.com/hexojs/hexo\" target=\"_blank\" rel=\"external\">Github</a>上的官方介绍，在终端依次执行以下命令进行：   </p>\n<pre><code class=\"Shell\"><span class=\"meta\">$</span><span class=\"bash\"> npm install hexo-cli -g</span>\n</code></pre>\n<p>  安装成功后，可以通过以下命令进行查看   </p>\n<pre><code class=\"Shell\"><span class=\"meta\">$</span><span class=\"bash\"> hexo</span>\n</code></pre>\n<a id=\"more\"></a>\n<h3 id=\"快速使用博客\"><a href=\"#快速使用博客\" class=\"headerlink\" title=\"快速使用博客\"></a>快速使用博客</h3><p>通过在终端输入以下命令执行初始化</p>\n<pre><code class=\"Shell\"><span class=\"meta\">$</span><span class=\"bash\"> hexo init blog_name</span>\n<span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> blog_name</span>\n</code></pre>\n<p>修改Hexo配置文件_config.yml  </p>\n<pre><code class=\"Script\"># Site\ntitle: liangtong\nsubtitle: \ndescription: Keep hungry keep foolish！\nauthor: liangtong\nlanguage: zh-Hans\ntimezone:\n</code></pre>\n<p>通过在终端输入以下命令新建博客文章</p>\n<pre><code class=\"Shell\"><span class=\"meta\">$</span><span class=\"bash\"> hexo new <span class=\"string\">\"Hello Hexo\"</span></span>\n</code></pre>\n<p>通过在终端输入以下命令生成静态文件</p>\n<pre><code class=\"Shell\"><span class=\"meta\">$</span><span class=\"bash\"> hexo generate</span>\n</code></pre>\n<p>通过在终端输入以下命令启动服务</p>\n<pre><code class=\"Shell\"><span class=\"meta\">$</span><span class=\"bash\"> hexo server</span>\n</code></pre>\n<h3 id=\"更换Hexo主题\"><a href=\"#更换Hexo主题\" class=\"headerlink\" title=\"更换Hexo主题\"></a>更换Hexo主题</h3><p>这里使用GitHub上排名最靠前的主题<a href=\"https://github.com/iissnan/hexo-theme-next\" target=\"_blank\" rel=\"external\">NexT</a>，在终端输入以下命令进行主题下载：   </p>\n<pre><code class=\"Shell\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> blog_name</span>\n<span class=\"meta\">$</span><span class=\"bash\"> git <span class=\"built_in\">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span>\n</code></pre>\n<p>参照<a href=\"http://theme-next.iissnan.com/getting-started.html\" target=\"_blank\" rel=\"external\">NexT官方指导网站</a>，对博客进行个性化配置，常用设置包括：   </p>\n<ul>\n<li>主题设定   </li>\n<li>标签   </li>\n<li>分类   </li>\n<li>侧边栏   </li>\n<li>打赏   </li>\n<li>友情链接</li>\n<li>动画效果</li>\n<li>评论分享   </li>\n</ul>\n<h3 id=\"配置Hexo部署\"><a href=\"#配置Hexo部署\" class=\"headerlink\" title=\"配置Hexo部署\"></a>配置Hexo部署</h3><p>在Hexo配置文件中完善部署信息，即你的Github个人博客地址信息：   </p>\n<pre><code class=\"Script\"># Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\ntype: git\nrepo: https://github.com/l900416/l900416.github.io.git\nbranch: master\n</code></pre>\n<h3 id=\"发布Hexo网站到GitHub\"><a href=\"#发布Hexo网站到GitHub\" class=\"headerlink\" title=\"发布Hexo网站到GitHub\"></a>发布Hexo网站到GitHub</h3><p>通过终端输入以下命令将Hexo博客发布到Github上：   </p>\n<pre><code class=\"Shell\"><span class=\"meta\">$</span><span class=\"bash\"> hexo g</span>\n</code></pre>\n<p>此步骤如果出现错误 <em> Deployer not found: git </em> ：   </p>\n<ul>\n<li>检查Hexo配置的部署文件    </li>\n<li>终端输入命令：<ul>\n<li><blockquote>\n<p>npm install hexo-deployer-git –save </p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Hexo在GitHub上的维护\"><a href=\"#Hexo在GitHub上的维护\" class=\"headerlink\" title=\"Hexo在GitHub上的维护\"></a>Hexo在GitHub上的维护</h3><p>说下本人的做法，创建新的Branch，命名为hexo，用于存放博客源码，master用于个人博客。这样使用一个仓库来维护。</p>\n<h3 id=\"Hexo与Jekyll不同之处\"><a href=\"#Hexo与Jekyll不同之处\" class=\"headerlink\" title=\"Hexo与Jekyll不同之处\"></a>Hexo与Jekyll不同之处</h3><ul>\n<li>Hexo博客文件需要单独维护。对应GitHub仓库中的文件是通过Hexo部署进去的。</li>\n<li>Jekyll博客文件直接上传到GitHub博客仓库中即可。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"创建GitHub账号\"><a href=\"#创建GitHub账号\" class=\"headerlink\" title=\"创建GitHub账号\"></a>创建GitHub账号</h3><p>  注册<a href=\"https://github.com/\" target=\"_blank\" rel=\"external\">Github</a>账号，建立个人博客仓库(Repository)，不在赘述。 </p>\n<h3 id=\"安装Git工具\"><a href=\"#安装Git工具\" class=\"headerlink\" title=\"安装Git工具\"></a>安装Git工具</h3><p>  终端直接执行 <em>git</em> 命令，或者通过安装GitHub客户端。</p>\n<h3 id=\"安装Node和NPM\"><a href=\"#安装Node和NPM\" class=\"headerlink\" title=\"安装Node和NPM\"></a>安装Node和NPM</h3><p>  打开终端，通过以下命令安装：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> brew install node</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h3><p>  可以参照Hexo在<a href=\"https://github.com/hexojs/hexo\" target=\"_blank\" rel=\"external\">Github</a>上的官方介绍，在终端依次执行以下命令进行：   </p>\n<pre><code class=\"Shell\"><span class=\"meta\">$</span><span class=\"bash\"> npm install hexo-cli -g</span>\n</code></pre>\n<p>  安装成功后，可以通过以下命令进行查看   </p>\n<pre><code class=\"Shell\"><span class=\"meta\">$</span><span class=\"bash\"> hexo</span>\n</code></pre>","more":"<h3 id=\"快速使用博客\"><a href=\"#快速使用博客\" class=\"headerlink\" title=\"快速使用博客\"></a>快速使用博客</h3><p>通过在终端输入以下命令执行初始化</p>\n<pre><code class=\"Shell\"><span class=\"meta\">$</span><span class=\"bash\"> hexo init blog_name</span>\n<span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> blog_name</span>\n</code></pre>\n<p>修改Hexo配置文件_config.yml  </p>\n<pre><code class=\"Script\"># Site\ntitle: liangtong\nsubtitle: \ndescription: Keep hungry keep foolish！\nauthor: liangtong\nlanguage: zh-Hans\ntimezone:\n</code></pre>\n<p>通过在终端输入以下命令新建博客文章</p>\n<pre><code class=\"Shell\"><span class=\"meta\">$</span><span class=\"bash\"> hexo new <span class=\"string\">\"Hello Hexo\"</span></span>\n</code></pre>\n<p>通过在终端输入以下命令生成静态文件</p>\n<pre><code class=\"Shell\"><span class=\"meta\">$</span><span class=\"bash\"> hexo generate</span>\n</code></pre>\n<p>通过在终端输入以下命令启动服务</p>\n<pre><code class=\"Shell\"><span class=\"meta\">$</span><span class=\"bash\"> hexo server</span>\n</code></pre>\n<h3 id=\"更换Hexo主题\"><a href=\"#更换Hexo主题\" class=\"headerlink\" title=\"更换Hexo主题\"></a>更换Hexo主题</h3><p>这里使用GitHub上排名最靠前的主题<a href=\"https://github.com/iissnan/hexo-theme-next\" target=\"_blank\" rel=\"external\">NexT</a>，在终端输入以下命令进行主题下载：   </p>\n<pre><code class=\"Shell\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> blog_name</span>\n<span class=\"meta\">$</span><span class=\"bash\"> git <span class=\"built_in\">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span>\n</code></pre>\n<p>参照<a href=\"http://theme-next.iissnan.com/getting-started.html\" target=\"_blank\" rel=\"external\">NexT官方指导网站</a>，对博客进行个性化配置，常用设置包括：   </p>\n<ul>\n<li>主题设定   </li>\n<li>标签   </li>\n<li>分类   </li>\n<li>侧边栏   </li>\n<li>打赏   </li>\n<li>友情链接</li>\n<li>动画效果</li>\n<li>评论分享   </li>\n</ul>\n<h3 id=\"配置Hexo部署\"><a href=\"#配置Hexo部署\" class=\"headerlink\" title=\"配置Hexo部署\"></a>配置Hexo部署</h3><p>在Hexo配置文件中完善部署信息，即你的Github个人博客地址信息：   </p>\n<pre><code class=\"Script\"># Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\ntype: git\nrepo: https://github.com/l900416/l900416.github.io.git\nbranch: master\n</code></pre>\n<h3 id=\"发布Hexo网站到GitHub\"><a href=\"#发布Hexo网站到GitHub\" class=\"headerlink\" title=\"发布Hexo网站到GitHub\"></a>发布Hexo网站到GitHub</h3><p>通过终端输入以下命令将Hexo博客发布到Github上：   </p>\n<pre><code class=\"Shell\"><span class=\"meta\">$</span><span class=\"bash\"> hexo g</span>\n</code></pre>\n<p>此步骤如果出现错误 <em> Deployer not found: git </em> ：   </p>\n<ul>\n<li>检查Hexo配置的部署文件    </li>\n<li>终端输入命令：<ul>\n<li><blockquote>\n<p>npm install hexo-deployer-git –save </p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Hexo在GitHub上的维护\"><a href=\"#Hexo在GitHub上的维护\" class=\"headerlink\" title=\"Hexo在GitHub上的维护\"></a>Hexo在GitHub上的维护</h3><p>说下本人的做法，创建新的Branch，命名为hexo，用于存放博客源码，master用于个人博客。这样使用一个仓库来维护。</p>\n<h3 id=\"Hexo与Jekyll不同之处\"><a href=\"#Hexo与Jekyll不同之处\" class=\"headerlink\" title=\"Hexo与Jekyll不同之处\"></a>Hexo与Jekyll不同之处</h3><ul>\n<li>Hexo博客文件需要单独维护。对应GitHub仓库中的文件是通过Hexo部署进去的。</li>\n<li>Jekyll博客文件直接上传到GitHub博客仓库中即可。</li>\n</ul>"},{"layout":"post","title":"Mac下使用Jekyll搭建GitHub博客","date":"2017-08-07T08:25:19.000Z","author":"liangtong","_content":"\n[Jekyll](https://github.com/jekyll/jekyll)是一个静态网站和博客模版，本文介绍如何使用Jekyll进行个人GitHub博客的搭建。搭建前提是拥有个人[Github](https://github.com/)账号，且Mac上有安装 *git* 工具。\n\n### 安装Jekyll  \n  参照[Jekyll官方](https://jekyllrb.com/)介绍，打开终端，通过以下命令安装：    \n```Shell\n$ gem install jekyll bundler\n```\n\n注：gem的安装／更新可以自己去查，此处不再进行说明。Jekyll安装成功后，便可以进行个人博客／静态网站的创建了。\n\n\n### 快速使用博客   \n\n通过在终端输入以下命令执行初始化\n```Shell\n$ jekyll new my_blog\n$ cd my_blog\n$ bundle exec jekyll serve\n```\n参照[官方模版配置介绍](https://jekyllrb.com/docs/templates/),修改Jekyll配置文件_config.yml，如果没有特殊要求，建议直接GitHub找现成的[博客模板](http://jekyllthemes.org/)即可。  \n\n<!-- more -->\n\n### 快速使用博客  \n  此处选择使用博客模板[jekyll-now](https://github.com/barryclark/jekyll-now)，使用Github直接fork到自己的博客仓库中，然后将代码下载到本地。\n新建博客静态文件，格式:yyyy-MM-dd-articlename.md，使用markdown语法对编写博客内容。\n编写之后，直接在博客路径下，运行即可：     \n```Shell\n$ jekyll serve\n```\n\n### 推荐博客   \n  使用Jekyll搭建博客也可以添加很多自定制功能，比如统计、评论、标签等；可以根据自己的喜好，选择不同的主题。以下是个人曾经使用过的主题：      \n+ [Hux Blog](https://github.com/Huxpro/huxpro.github.io) 第一个GitHub博客系统就是从他的博客fork过去的。\n+ [Clean Blog](https://github.com/BlackrockDigital/startbootstrap-clean-blog-jekyll) 简单的Jekyll博客模板。\n\n\n\n### Jekyll在GitHub上的维护    \n直接将博客源码上传到GitHub博客仓库即可。\n\n\n### 其他   \n通过在GitHub上搭建Jekyll和Hexo博客，个人更倾向于使用Hexo博客。\n\n + Jekyll    \n    - 配置简单。\n    - 维护简单，只需要一个Branch即可。\n    - 使用简单，运行只需要 *jekyll server* 即可。\n    - 发布简单，只需要将代码push到对应仓库即可。\n    - 主题切换，比较麻烦。\n\n\n + Hexo\n    - 配置项相对较多，但是格式比较清晰。\n    - 博客和源码需要分开维护。需要两个Branch对博客系统进行维护。\n    - 使用相对简单。\n        + hexo clean  // 清理\n        + hexo g      // 生成\n        + hexo s      // 运行\n    - 发布简单。\n        + hexo d      // 将博客部署(到github)\n        + 将博客源码push到对应仓库单独保存\n    - 主题切换简单。\n        + 下载新主题到themes文件夹下；\n        + 修改站点配置文件_config.yml中对应的主题选项。\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/share_github_blog_jekyll.md","raw":"---\nlayout:     post\ntitle:      Mac下使用Jekyll搭建GitHub博客\ndate:       2017-08-07 16:25:19\nauthor:     liangtong\ncategories: 技术分享\ntags: GitHub\n\n---\n\n[Jekyll](https://github.com/jekyll/jekyll)是一个静态网站和博客模版，本文介绍如何使用Jekyll进行个人GitHub博客的搭建。搭建前提是拥有个人[Github](https://github.com/)账号，且Mac上有安装 *git* 工具。\n\n### 安装Jekyll  \n  参照[Jekyll官方](https://jekyllrb.com/)介绍，打开终端，通过以下命令安装：    \n```Shell\n$ gem install jekyll bundler\n```\n\n注：gem的安装／更新可以自己去查，此处不再进行说明。Jekyll安装成功后，便可以进行个人博客／静态网站的创建了。\n\n\n### 快速使用博客   \n\n通过在终端输入以下命令执行初始化\n```Shell\n$ jekyll new my_blog\n$ cd my_blog\n$ bundle exec jekyll serve\n```\n参照[官方模版配置介绍](https://jekyllrb.com/docs/templates/),修改Jekyll配置文件_config.yml，如果没有特殊要求，建议直接GitHub找现成的[博客模板](http://jekyllthemes.org/)即可。  \n\n<!-- more -->\n\n### 快速使用博客  \n  此处选择使用博客模板[jekyll-now](https://github.com/barryclark/jekyll-now)，使用Github直接fork到自己的博客仓库中，然后将代码下载到本地。\n新建博客静态文件，格式:yyyy-MM-dd-articlename.md，使用markdown语法对编写博客内容。\n编写之后，直接在博客路径下，运行即可：     \n```Shell\n$ jekyll serve\n```\n\n### 推荐博客   \n  使用Jekyll搭建博客也可以添加很多自定制功能，比如统计、评论、标签等；可以根据自己的喜好，选择不同的主题。以下是个人曾经使用过的主题：      \n+ [Hux Blog](https://github.com/Huxpro/huxpro.github.io) 第一个GitHub博客系统就是从他的博客fork过去的。\n+ [Clean Blog](https://github.com/BlackrockDigital/startbootstrap-clean-blog-jekyll) 简单的Jekyll博客模板。\n\n\n\n### Jekyll在GitHub上的维护    \n直接将博客源码上传到GitHub博客仓库即可。\n\n\n### 其他   \n通过在GitHub上搭建Jekyll和Hexo博客，个人更倾向于使用Hexo博客。\n\n + Jekyll    \n    - 配置简单。\n    - 维护简单，只需要一个Branch即可。\n    - 使用简单，运行只需要 *jekyll server* 即可。\n    - 发布简单，只需要将代码push到对应仓库即可。\n    - 主题切换，比较麻烦。\n\n\n + Hexo\n    - 配置项相对较多，但是格式比较清晰。\n    - 博客和源码需要分开维护。需要两个Branch对博客系统进行维护。\n    - 使用相对简单。\n        + hexo clean  // 清理\n        + hexo g      // 生成\n        + hexo s      // 运行\n    - 发布简单。\n        + hexo d      // 将博客部署(到github)\n        + 将博客源码push到对应仓库单独保存\n    - 主题切换简单。\n        + 下载新主题到themes文件夹下；\n        + 修改站点配置文件_config.yml中对应的主题选项。\n\n\n\n\n\n\n\n\n\n\n\n","slug":"share_github_blog_jekyll","published":1,"updated":"2017-10-13T10:44:09.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4vd005hoko82izhjf4z","content":"<p><a href=\"https://github.com/jekyll/jekyll\" target=\"_blank\" rel=\"external\">Jekyll</a>是一个静态网站和博客模版，本文介绍如何使用Jekyll进行个人GitHub博客的搭建。搭建前提是拥有个人<a href=\"https://github.com/\" target=\"_blank\" rel=\"external\">Github</a>账号，且Mac上有安装 <em>git</em> 工具。</p>\n<h3 id=\"安装Jekyll\"><a href=\"#安装Jekyll\" class=\"headerlink\" title=\"安装Jekyll\"></a>安装Jekyll</h3><p>  参照<a href=\"https://jekyllrb.com/\" target=\"_blank\" rel=\"external\">Jekyll官方</a>介绍，打开终端，通过以下命令安装：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> gem install jekyll bundler</span></div></pre></td></tr></table></figure></p>\n<p>注：gem的安装／更新可以自己去查，此处不再进行说明。Jekyll安装成功后，便可以进行个人博客／静态网站的创建了。</p>\n<h3 id=\"快速使用博客\"><a href=\"#快速使用博客\" class=\"headerlink\" title=\"快速使用博客\"></a>快速使用博客</h3><p>通过在终端输入以下命令执行初始化<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> jekyll new my_blog</span></div><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> my_blog</span></div><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> bundle <span class=\"built_in\">exec</span> jekyll serve</span></div></pre></td></tr></table></figure></p>\n<p>参照<a href=\"https://jekyllrb.com/docs/templates/\" target=\"_blank\" rel=\"external\">官方模版配置介绍</a>,修改Jekyll配置文件_config.yml，如果没有特殊要求，建议直接GitHub找现成的<a href=\"http://jekyllthemes.org/\" target=\"_blank\" rel=\"external\">博客模板</a>即可。  </p>\n<a id=\"more\"></a>\n<h3 id=\"快速使用博客-1\"><a href=\"#快速使用博客-1\" class=\"headerlink\" title=\"快速使用博客\"></a>快速使用博客</h3><p>  此处选择使用博客模板<a href=\"https://github.com/barryclark/jekyll-now\" target=\"_blank\" rel=\"external\">jekyll-now</a>，使用Github直接fork到自己的博客仓库中，然后将代码下载到本地。<br>新建博客静态文件，格式:yyyy-MM-dd-articlename.md，使用markdown语法对编写博客内容。<br>编写之后，直接在博客路径下，运行即可：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> jekyll serve</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"推荐博客\"><a href=\"#推荐博客\" class=\"headerlink\" title=\"推荐博客\"></a>推荐博客</h3><p>  使用Jekyll搭建博客也可以添加很多自定制功能，比如统计、评论、标签等；可以根据自己的喜好，选择不同的主题。以下是个人曾经使用过的主题：      </p>\n<ul>\n<li><a href=\"https://github.com/Huxpro/huxpro.github.io\" target=\"_blank\" rel=\"external\">Hux Blog</a> 第一个GitHub博客系统就是从他的博客fork过去的。</li>\n<li><a href=\"https://github.com/BlackrockDigital/startbootstrap-clean-blog-jekyll\" target=\"_blank\" rel=\"external\">Clean Blog</a> 简单的Jekyll博客模板。</li>\n</ul>\n<h3 id=\"Jekyll在GitHub上的维护\"><a href=\"#Jekyll在GitHub上的维护\" class=\"headerlink\" title=\"Jekyll在GitHub上的维护\"></a>Jekyll在GitHub上的维护</h3><p>直接将博客源码上传到GitHub博客仓库即可。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>通过在GitHub上搭建Jekyll和Hexo博客，个人更倾向于使用Hexo博客。</p>\n<ul>\n<li>Jekyll    <ul>\n<li>配置简单。</li>\n<li>维护简单，只需要一个Branch即可。</li>\n<li>使用简单，运行只需要 <em>jekyll server</em> 即可。</li>\n<li>发布简单，只需要将代码push到对应仓库即可。</li>\n<li>主题切换，比较麻烦。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>Hexo<ul>\n<li>配置项相对较多，但是格式比较清晰。</li>\n<li>博客和源码需要分开维护。需要两个Branch对博客系统进行维护。</li>\n<li>使用相对简单。<ul>\n<li>hexo clean  // 清理</li>\n<li>hexo g      // 生成</li>\n<li>hexo s      // 运行</li>\n</ul>\n</li>\n<li>发布简单。<ul>\n<li>hexo d      // 将博客部署(到github)</li>\n<li>将博客源码push到对应仓库单独保存</li>\n</ul>\n</li>\n<li>主题切换简单。<ul>\n<li>下载新主题到themes文件夹下；</li>\n<li>修改站点配置文件_config.yml中对应的主题选项。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/jekyll/jekyll\" target=\"_blank\" rel=\"external\">Jekyll</a>是一个静态网站和博客模版，本文介绍如何使用Jekyll进行个人GitHub博客的搭建。搭建前提是拥有个人<a href=\"https://github.com/\" target=\"_blank\" rel=\"external\">Github</a>账号，且Mac上有安装 <em>git</em> 工具。</p>\n<h3 id=\"安装Jekyll\"><a href=\"#安装Jekyll\" class=\"headerlink\" title=\"安装Jekyll\"></a>安装Jekyll</h3><p>  参照<a href=\"https://jekyllrb.com/\" target=\"_blank\" rel=\"external\">Jekyll官方</a>介绍，打开终端，通过以下命令安装：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> gem install jekyll bundler</span></div></pre></td></tr></table></figure></p>\n<p>注：gem的安装／更新可以自己去查，此处不再进行说明。Jekyll安装成功后，便可以进行个人博客／静态网站的创建了。</p>\n<h3 id=\"快速使用博客\"><a href=\"#快速使用博客\" class=\"headerlink\" title=\"快速使用博客\"></a>快速使用博客</h3><p>通过在终端输入以下命令执行初始化<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> jekyll new my_blog</span></div><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> my_blog</span></div><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> bundle <span class=\"built_in\">exec</span> jekyll serve</span></div></pre></td></tr></table></figure></p>\n<p>参照<a href=\"https://jekyllrb.com/docs/templates/\" target=\"_blank\" rel=\"external\">官方模版配置介绍</a>,修改Jekyll配置文件_config.yml，如果没有特殊要求，建议直接GitHub找现成的<a href=\"http://jekyllthemes.org/\" target=\"_blank\" rel=\"external\">博客模板</a>即可。  </p>","more":"<h3 id=\"快速使用博客-1\"><a href=\"#快速使用博客-1\" class=\"headerlink\" title=\"快速使用博客\"></a>快速使用博客</h3><p>  此处选择使用博客模板<a href=\"https://github.com/barryclark/jekyll-now\" target=\"_blank\" rel=\"external\">jekyll-now</a>，使用Github直接fork到自己的博客仓库中，然后将代码下载到本地。<br>新建博客静态文件，格式:yyyy-MM-dd-articlename.md，使用markdown语法对编写博客内容。<br>编写之后，直接在博客路径下，运行即可：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> jekyll serve</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"推荐博客\"><a href=\"#推荐博客\" class=\"headerlink\" title=\"推荐博客\"></a>推荐博客</h3><p>  使用Jekyll搭建博客也可以添加很多自定制功能，比如统计、评论、标签等；可以根据自己的喜好，选择不同的主题。以下是个人曾经使用过的主题：      </p>\n<ul>\n<li><a href=\"https://github.com/Huxpro/huxpro.github.io\" target=\"_blank\" rel=\"external\">Hux Blog</a> 第一个GitHub博客系统就是从他的博客fork过去的。</li>\n<li><a href=\"https://github.com/BlackrockDigital/startbootstrap-clean-blog-jekyll\" target=\"_blank\" rel=\"external\">Clean Blog</a> 简单的Jekyll博客模板。</li>\n</ul>\n<h3 id=\"Jekyll在GitHub上的维护\"><a href=\"#Jekyll在GitHub上的维护\" class=\"headerlink\" title=\"Jekyll在GitHub上的维护\"></a>Jekyll在GitHub上的维护</h3><p>直接将博客源码上传到GitHub博客仓库即可。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>通过在GitHub上搭建Jekyll和Hexo博客，个人更倾向于使用Hexo博客。</p>\n<ul>\n<li>Jekyll    <ul>\n<li>配置简单。</li>\n<li>维护简单，只需要一个Branch即可。</li>\n<li>使用简单，运行只需要 <em>jekyll server</em> 即可。</li>\n<li>发布简单，只需要将代码push到对应仓库即可。</li>\n<li>主题切换，比较麻烦。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>Hexo<ul>\n<li>配置项相对较多，但是格式比较清晰。</li>\n<li>博客和源码需要分开维护。需要两个Branch对博客系统进行维护。</li>\n<li>使用相对简单。<ul>\n<li>hexo clean  // 清理</li>\n<li>hexo g      // 生成</li>\n<li>hexo s      // 运行</li>\n</ul>\n</li>\n<li>发布简单。<ul>\n<li>hexo d      // 将博客部署(到github)</li>\n<li>将博客源码push到对应仓库单独保存</li>\n</ul>\n</li>\n<li>主题切换简单。<ul>\n<li>下载新主题到themes文件夹下；</li>\n<li>修改站点配置文件_config.yml中对应的主题选项。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>"},{"layout":"post","title":"CocoaPods个人代码组件管理","date":"2017-10-16T06:25:19.000Z","author":"liangtong","_content":"\n[Cocoapods](https://cocoapods.org/)是非常好用的一个iOS依赖管理工具，使用它可以方便的管理和更新项目中所使用到的第三方库，本节介绍如何将自己的组件代码交由它去管理。\n\n### 创建Git仓库\n\n  根据GitHub提示操作即可，建立自己的Git仓库。 \n\n### 创建podspec文件\n\n  终端直接执行以下命令，创建Pod项目工程文件，例如要创建一个叫做 **LTChat** 的Pod工程，命令执行成功后，会看到一个叫做 **LTChat.podspec** 的文件。\n\n```Shell\npod spec create \"LTChat\"\n```\n\n![](/post/share/github_pod_create_1.png)\n\n\n<!-- more -->\n\n### 编辑podspec文件  \n\n编辑文件时注意编辑工具的使用，Mac上默认的文本编辑文件编辑时很容易出现编码问题。\n修改Pod文件的配置信息，摘要如下：\n\n```Shell\n  # ―――  Spec Metadata  ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #\n  s.name         = \"LTChat\"\n  s.version      = \"0.0.1\"\n  #  summary 总结\n  s.summary      = \"Chat use XMPP framework and WebRTC framework.\"\n  #  description 描述，与summary不能相同\n  s.description  = <<-DESC\n基于XMPP和WebRTC框架进行聊天组件。\n                   DESC\n\n  s.homepage     = \"https://github.com/l900416/LTChat\"\n  # ―――  Spec License  ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #\n  s.license      = \"MIT\"\n  # ――― Platform Specifics ――――――――――――――――――――――――――――――――――――――――――――――――――――――― #\n  s.platform     = :ios, \"8.0\"\n\n  #  When using multiple platforms\n  s.ios.deployment_target = \"8.0\"\n  # ――― Source Location ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #\n  s.source       = { :git => \"https://github.com/l900416/LTChat.git\", :tag => \"#{s.version}\" }\n  # ――― Source Code ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #\n  s.source_files  = \"LTChat\", \"LTChat/**/*.{h,m}\"\n  s.exclude_files = \"LTChat/Exclude\"\n\n  s.public_header_files = \"LTChat/**/*.h\"\n  # ――― Resources ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #\n  s.resources = \"LTChat/**/*.{xib}\",\"LTChat/**/*.{png}\"\n\n  # ――― Project Linking ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #\n  # s.frameworks = \"SomeFramework\", \"AnotherFramework\"\n  # s.libraries = \"iconv\", \"xml2\"\n\n  # ――― Project Settings ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #\n  # s.requires_arc = true\n  s.dependency \"XMPPFramework\", \"~> 3.7.0\"\n  s.dependency \"GoogleWebRTC\"\n\n```\n\n### 建立TAG\n\n使用 **git tag** 和 **git push** 命令建立TAG\n\n![](/post/share/github_pod_create_2.png)\n\n\n### 验证Pod文件\n\n使用 **pod lib lint** 或 **pod spec lint**  验证Pod文件格式是否正确，可以添加 **--verbose** 获取更多的信息，添加 **--no-clean** 不对验证的工程进行清理，方便查看工程验证错误原因。两者的区别：\n\n  * pod lib lint 是只从本地验证pod是否能够通过验证\n  * pod sepc lint 是从本地和远程来验证pod是否通过验证。\n\n### 发布\n\n使用 **pod trunk** 发布程序，使用到的命令如下：\n\n  * pod trunk register 邮箱 '用户名'：注册，之后在邮件中进行验证。\n  * pod trunk me ： 查看个人信息，包括该邮件下已经注册的代码组件、个人信息、登陆session等。\n  * pod trunk push *.podspec : 发布podspec\n  * 等待审核\n  * pod search： 检查是否发布成功\n\n### 更新\n\n建立TAG，并发布。\n![](/post/share/github_pod_update_1.png)\n![](/post/share/github_pod_update_2.png)\n\n### 问题记录\n\n#### pod lib lint验证失败\n\n如果出现验证失败，则需要添加参数 **--verbose** 查看详细错误原因 。例如\n\n```Objective-C\nThe following build commands failed:\nLd /Users/liangtong/Library/Developer/Xcode/DerivedData/App-eowwjkrvluwvfdhhkljszfucgimo/Build/Intermediates.noindex/Pods.build/Release-iphonesimulator/LTChat.build/Objects-normal/i386/LTChat normal i386\n(1 failure)\n\n\n[!] LTChat did not pass validation, due to 1 error and 71 warnings.\n```\n\n原因是由于谷歌官方iOS版本的 **GoogleWebRTC** 仅支持处理器**x86_64 armv7 arm64**导致\n\n#### Swift Language Version\n\n根据失败的log日志，确认失败原因，比如LTChat依赖于XMPPFramework，而XMPPFramework又依赖了KissXML。此时编译的时候出现了Swift版本不明确的错误。\n\n```Objecitve-C\n=== BUILD TARGET KissXML OF PROJECT Pods WITH CONFIGURATION Release ===\n\nCheck dependencies\nThe “Swift Language Version” (SWIFT_VERSION) build setting must be set to a supported value for targets which use Swift. This setting can be set in the build settings editor.\nThe “Swift Language Version” (SWIFT_VERSION) build setting must be set to a supported value for targets which use Swift. This setting can be set in the build settings editor.\n\n** BUILD FAILED **\n\nThe following build commands failed:\nCheck dependencies\n```\n\n解决办法，指定 **Swift Language** 版本\n>  pod lib lint --swift-version=4.0\n\n\n#### 上传后查询不到最新版本\n\n解决办法：清理缓存，重新setup\n\n```Shell\n  rm -rf ~/.cocoapods/repos/master\n  pod setup\n```\n\n\n","source":"_posts/share_github_pod_usage.md","raw":"---\nlayout:     post\ntitle:      CocoaPods个人代码组件管理\ndate:       2017-10-16 14:25:19\nauthor:     liangtong\ncategories: 技术分享\ntags: GitHub\n      CocoaPods\n\n---\n\n[Cocoapods](https://cocoapods.org/)是非常好用的一个iOS依赖管理工具，使用它可以方便的管理和更新项目中所使用到的第三方库，本节介绍如何将自己的组件代码交由它去管理。\n\n### 创建Git仓库\n\n  根据GitHub提示操作即可，建立自己的Git仓库。 \n\n### 创建podspec文件\n\n  终端直接执行以下命令，创建Pod项目工程文件，例如要创建一个叫做 **LTChat** 的Pod工程，命令执行成功后，会看到一个叫做 **LTChat.podspec** 的文件。\n\n```Shell\npod spec create \"LTChat\"\n```\n\n![](/post/share/github_pod_create_1.png)\n\n\n<!-- more -->\n\n### 编辑podspec文件  \n\n编辑文件时注意编辑工具的使用，Mac上默认的文本编辑文件编辑时很容易出现编码问题。\n修改Pod文件的配置信息，摘要如下：\n\n```Shell\n  # ―――  Spec Metadata  ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #\n  s.name         = \"LTChat\"\n  s.version      = \"0.0.1\"\n  #  summary 总结\n  s.summary      = \"Chat use XMPP framework and WebRTC framework.\"\n  #  description 描述，与summary不能相同\n  s.description  = <<-DESC\n基于XMPP和WebRTC框架进行聊天组件。\n                   DESC\n\n  s.homepage     = \"https://github.com/l900416/LTChat\"\n  # ―――  Spec License  ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #\n  s.license      = \"MIT\"\n  # ――― Platform Specifics ――――――――――――――――――――――――――――――――――――――――――――――――――――――― #\n  s.platform     = :ios, \"8.0\"\n\n  #  When using multiple platforms\n  s.ios.deployment_target = \"8.0\"\n  # ――― Source Location ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #\n  s.source       = { :git => \"https://github.com/l900416/LTChat.git\", :tag => \"#{s.version}\" }\n  # ――― Source Code ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #\n  s.source_files  = \"LTChat\", \"LTChat/**/*.{h,m}\"\n  s.exclude_files = \"LTChat/Exclude\"\n\n  s.public_header_files = \"LTChat/**/*.h\"\n  # ――― Resources ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #\n  s.resources = \"LTChat/**/*.{xib}\",\"LTChat/**/*.{png}\"\n\n  # ――― Project Linking ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #\n  # s.frameworks = \"SomeFramework\", \"AnotherFramework\"\n  # s.libraries = \"iconv\", \"xml2\"\n\n  # ――― Project Settings ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #\n  # s.requires_arc = true\n  s.dependency \"XMPPFramework\", \"~> 3.7.0\"\n  s.dependency \"GoogleWebRTC\"\n\n```\n\n### 建立TAG\n\n使用 **git tag** 和 **git push** 命令建立TAG\n\n![](/post/share/github_pod_create_2.png)\n\n\n### 验证Pod文件\n\n使用 **pod lib lint** 或 **pod spec lint**  验证Pod文件格式是否正确，可以添加 **--verbose** 获取更多的信息，添加 **--no-clean** 不对验证的工程进行清理，方便查看工程验证错误原因。两者的区别：\n\n  * pod lib lint 是只从本地验证pod是否能够通过验证\n  * pod sepc lint 是从本地和远程来验证pod是否通过验证。\n\n### 发布\n\n使用 **pod trunk** 发布程序，使用到的命令如下：\n\n  * pod trunk register 邮箱 '用户名'：注册，之后在邮件中进行验证。\n  * pod trunk me ： 查看个人信息，包括该邮件下已经注册的代码组件、个人信息、登陆session等。\n  * pod trunk push *.podspec : 发布podspec\n  * 等待审核\n  * pod search： 检查是否发布成功\n\n### 更新\n\n建立TAG，并发布。\n![](/post/share/github_pod_update_1.png)\n![](/post/share/github_pod_update_2.png)\n\n### 问题记录\n\n#### pod lib lint验证失败\n\n如果出现验证失败，则需要添加参数 **--verbose** 查看详细错误原因 。例如\n\n```Objective-C\nThe following build commands failed:\nLd /Users/liangtong/Library/Developer/Xcode/DerivedData/App-eowwjkrvluwvfdhhkljszfucgimo/Build/Intermediates.noindex/Pods.build/Release-iphonesimulator/LTChat.build/Objects-normal/i386/LTChat normal i386\n(1 failure)\n\n\n[!] LTChat did not pass validation, due to 1 error and 71 warnings.\n```\n\n原因是由于谷歌官方iOS版本的 **GoogleWebRTC** 仅支持处理器**x86_64 armv7 arm64**导致\n\n#### Swift Language Version\n\n根据失败的log日志，确认失败原因，比如LTChat依赖于XMPPFramework，而XMPPFramework又依赖了KissXML。此时编译的时候出现了Swift版本不明确的错误。\n\n```Objecitve-C\n=== BUILD TARGET KissXML OF PROJECT Pods WITH CONFIGURATION Release ===\n\nCheck dependencies\nThe “Swift Language Version” (SWIFT_VERSION) build setting must be set to a supported value for targets which use Swift. This setting can be set in the build settings editor.\nThe “Swift Language Version” (SWIFT_VERSION) build setting must be set to a supported value for targets which use Swift. This setting can be set in the build settings editor.\n\n** BUILD FAILED **\n\nThe following build commands failed:\nCheck dependencies\n```\n\n解决办法，指定 **Swift Language** 版本\n>  pod lib lint --swift-version=4.0\n\n\n#### 上传后查询不到最新版本\n\n解决办法：清理缓存，重新setup\n\n```Shell\n  rm -rf ~/.cocoapods/repos/master\n  pod setup\n```\n\n\n","slug":"share_github_pod_usage","published":1,"updated":"2017-11-10T09:38:36.000Z","comments":1,"photos":[],"link":"","_id":"cjahxo4ve005moko8ctpcsapz","content":"<p><a href=\"https://cocoapods.org/\" target=\"_blank\" rel=\"external\">Cocoapods</a>是非常好用的一个iOS依赖管理工具，使用它可以方便的管理和更新项目中所使用到的第三方库，本节介绍如何将自己的组件代码交由它去管理。</p>\n<h3 id=\"创建Git仓库\"><a href=\"#创建Git仓库\" class=\"headerlink\" title=\"创建Git仓库\"></a>创建Git仓库</h3><p>  根据GitHub提示操作即可，建立自己的Git仓库。 </p>\n<h3 id=\"创建podspec文件\"><a href=\"#创建podspec文件\" class=\"headerlink\" title=\"创建podspec文件\"></a>创建podspec文件</h3><p>  终端直接执行以下命令，创建Pod项目工程文件，例如要创建一个叫做 <strong>LTChat</strong> 的Pod工程，命令执行成功后，会看到一个叫做 <strong>LTChat.podspec</strong> 的文件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod spec create \"LTChat\"</div></pre></td></tr></table></figure>\n<p><img src=\"/post/share/github_pod_create_1.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h3 id=\"编辑podspec文件\"><a href=\"#编辑podspec文件\" class=\"headerlink\" title=\"编辑podspec文件\"></a>编辑podspec文件</h3><p>编辑文件时注意编辑工具的使用，Mac上默认的文本编辑文件编辑时很容易出现编码问题。<br>修改Pod文件的配置信息，摘要如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> ―――  Spec Metadata  ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― <span class=\"comment\">#</span></span></div><div class=\"line\">  s.name         = \"LTChat\"</div><div class=\"line\">  s.version      = \"0.0.1\"</div><div class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\">  summary 总结</span></div><div class=\"line\">  s.summary      = \"Chat use XMPP framework and WebRTC framework.\"</div><div class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\">  description 描述，与summary不能相同</span></div><div class=\"line\">  s.description  = &lt;&lt;-DESC</div><div class=\"line\">基于XMPP和WebRTC框架进行聊天组件。</div><div class=\"line\">                   DESC</div><div class=\"line\"></div><div class=\"line\">  s.homepage     = \"https://github.com/l900416/LTChat\"</div><div class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> ―――  Spec License  ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― <span class=\"comment\">#</span></span></div><div class=\"line\">  s.license      = \"MIT\"</div><div class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> ――― Platform Specifics ――――――――――――――――――――――――――――――――――――――――――――――――――――――― <span class=\"comment\">#</span></span></div><div class=\"line\">  s.platform     = :ios, \"8.0\"</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\">  When using multiple platforms</span></div><div class=\"line\">  s.ios.deployment_target = \"8.0\"</div><div class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> ――― Source Location ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― <span class=\"comment\">#</span></span></div><div class=\"line\">  s.source       = &#123; :git =&gt; \"https://github.com/l900416/LTChat.git\", :tag =&gt; \"#&#123;s.version&#125;\" &#125;</div><div class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> ――― Source Code ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― <span class=\"comment\">#</span></span></div><div class=\"line\">  s.source_files  = \"LTChat\", \"LTChat/**/*.&#123;h,m&#125;\"</div><div class=\"line\">  s.exclude_files = \"LTChat/Exclude\"</div><div class=\"line\"></div><div class=\"line\">  s.public_header_files = \"LTChat/**/*.h\"</div><div class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> ――― Resources ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― <span class=\"comment\">#</span></span></div><div class=\"line\">  s.resources = \"LTChat/**/*.&#123;xib&#125;\",\"LTChat/**/*.&#123;png&#125;\"</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> ――― Project Linking ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― <span class=\"comment\">#</span></span></div><div class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> s.frameworks = <span class=\"string\">\"SomeFramework\"</span>, <span class=\"string\">\"AnotherFramework\"</span></span></div><div class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> s.libraries = <span class=\"string\">\"iconv\"</span>, <span class=\"string\">\"xml2\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> ――― Project Settings ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― <span class=\"comment\">#</span></span></div><div class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> s.requires_arc = <span class=\"literal\">true</span></span></div><div class=\"line\">  s.dependency \"XMPPFramework\", \"~&gt; 3.7.0\"</div><div class=\"line\">  s.dependency \"GoogleWebRTC\"</div></pre></td></tr></table></figure>\n<h3 id=\"建立TAG\"><a href=\"#建立TAG\" class=\"headerlink\" title=\"建立TAG\"></a>建立TAG</h3><p>使用 <strong>git tag</strong> 和 <strong>git push</strong> 命令建立TAG</p>\n<p><img src=\"/post/share/github_pod_create_2.png\" alt=\"\"></p>\n<h3 id=\"验证Pod文件\"><a href=\"#验证Pod文件\" class=\"headerlink\" title=\"验证Pod文件\"></a>验证Pod文件</h3><p>使用 <strong>pod lib lint</strong> 或 <strong>pod spec lint</strong>  验证Pod文件格式是否正确，可以添加 <strong>–verbose</strong> 获取更多的信息，添加 <strong>–no-clean</strong> 不对验证的工程进行清理，方便查看工程验证错误原因。两者的区别：</p>\n<ul>\n<li>pod lib lint 是只从本地验证pod是否能够通过验证</li>\n<li>pod sepc lint 是从本地和远程来验证pod是否通过验证。</li>\n</ul>\n<h3 id=\"发布\"><a href=\"#发布\" class=\"headerlink\" title=\"发布\"></a>发布</h3><p>使用 <strong>pod trunk</strong> 发布程序，使用到的命令如下：</p>\n<ul>\n<li>pod trunk register 邮箱 ‘用户名’：注册，之后在邮件中进行验证。</li>\n<li>pod trunk me ： 查看个人信息，包括该邮件下已经注册的代码组件、个人信息、登陆session等。</li>\n<li>pod trunk push *.podspec : 发布podspec</li>\n<li>等待审核</li>\n<li>pod search： 检查是否发布成功</li>\n</ul>\n<h3 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h3><p>建立TAG，并发布。<br><img src=\"/post/share/github_pod_update_1.png\" alt=\"\"><br><img src=\"/post/share/github_pod_update_2.png\" alt=\"\"></p>\n<h3 id=\"问题记录\"><a href=\"#问题记录\" class=\"headerlink\" title=\"问题记录\"></a>问题记录</h3><h4 id=\"pod-lib-lint验证失败\"><a href=\"#pod-lib-lint验证失败\" class=\"headerlink\" title=\"pod lib lint验证失败\"></a>pod lib lint验证失败</h4><p>如果出现验证失败，则需要添加参数 <strong>–verbose</strong> 查看详细错误原因 。例如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">The following build commands failed:</div><div class=\"line\">Ld /Users/liangtong/Library/Developer/Xcode/DerivedData/App-eowwjkrvluwvfdhhkljszfucgimo/Build/Intermediates.noindex/Pods.build/Release-iphonesimulator/LTChat.build/Objects-normal/i386/LTChat normal i386</div><div class=\"line\">(1 failure)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">[!] LTChat did not pass validation, due to 1 error and 71 warnings.</div></pre></td></tr></table></figure>\n<p>原因是由于谷歌官方iOS版本的 <strong>GoogleWebRTC</strong> 仅支持处理器<strong>x86_64 armv7 arm64</strong>导致</p>\n<h4 id=\"Swift-Language-Version\"><a href=\"#Swift-Language-Version\" class=\"headerlink\" title=\"Swift Language Version\"></a>Swift Language Version</h4><p>根据失败的log日志，确认失败原因，比如LTChat依赖于XMPPFramework，而XMPPFramework又依赖了KissXML。此时编译的时候出现了Swift版本不明确的错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">=== BUILD TARGET KissXML OF PROJECT Pods WITH CONFIGURATION Release ===</div><div class=\"line\"></div><div class=\"line\">Check dependencies</div><div class=\"line\">The “Swift Language Version” (SWIFT_VERSION) build setting must be set to a supported value for targets which use Swift. This setting can be set in the build settings editor.</div><div class=\"line\">The “Swift Language Version” (SWIFT_VERSION) build setting must be set to a supported value for targets which use Swift. This setting can be set in the build settings editor.</div><div class=\"line\"></div><div class=\"line\">** BUILD FAILED **</div><div class=\"line\"></div><div class=\"line\">The following build commands failed:</div><div class=\"line\">Check dependencies</div></pre></td></tr></table></figure>\n<p>解决办法，指定 <strong>Swift Language</strong> 版本</p>\n<blockquote>\n<p> pod lib lint –swift-version=4.0</p>\n</blockquote>\n<h4 id=\"上传后查询不到最新版本\"><a href=\"#上传后查询不到最新版本\" class=\"headerlink\" title=\"上传后查询不到最新版本\"></a>上传后查询不到最新版本</h4><p>解决办法：清理缓存，重新setup</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">rm -rf ~/.cocoapods/repos/master</div><div class=\"line\">pod setup</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://cocoapods.org/\" target=\"_blank\" rel=\"external\">Cocoapods</a>是非常好用的一个iOS依赖管理工具，使用它可以方便的管理和更新项目中所使用到的第三方库，本节介绍如何将自己的组件代码交由它去管理。</p>\n<h3 id=\"创建Git仓库\"><a href=\"#创建Git仓库\" class=\"headerlink\" title=\"创建Git仓库\"></a>创建Git仓库</h3><p>  根据GitHub提示操作即可，建立自己的Git仓库。 </p>\n<h3 id=\"创建podspec文件\"><a href=\"#创建podspec文件\" class=\"headerlink\" title=\"创建podspec文件\"></a>创建podspec文件</h3><p>  终端直接执行以下命令，创建Pod项目工程文件，例如要创建一个叫做 <strong>LTChat</strong> 的Pod工程，命令执行成功后，会看到一个叫做 <strong>LTChat.podspec</strong> 的文件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod spec create \"LTChat\"</div></pre></td></tr></table></figure>\n<p><img src=\"/post/share/github_pod_create_1.png\" alt=\"\"></p>","more":"<h3 id=\"编辑podspec文件\"><a href=\"#编辑podspec文件\" class=\"headerlink\" title=\"编辑podspec文件\"></a>编辑podspec文件</h3><p>编辑文件时注意编辑工具的使用，Mac上默认的文本编辑文件编辑时很容易出现编码问题。<br>修改Pod文件的配置信息，摘要如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> ―――  Spec Metadata  ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― <span class=\"comment\">#</span></span></div><div class=\"line\">  s.name         = \"LTChat\"</div><div class=\"line\">  s.version      = \"0.0.1\"</div><div class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\">  summary 总结</span></div><div class=\"line\">  s.summary      = \"Chat use XMPP framework and WebRTC framework.\"</div><div class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\">  description 描述，与summary不能相同</span></div><div class=\"line\">  s.description  = &lt;&lt;-DESC</div><div class=\"line\">基于XMPP和WebRTC框架进行聊天组件。</div><div class=\"line\">                   DESC</div><div class=\"line\"></div><div class=\"line\">  s.homepage     = \"https://github.com/l900416/LTChat\"</div><div class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> ―――  Spec License  ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― <span class=\"comment\">#</span></span></div><div class=\"line\">  s.license      = \"MIT\"</div><div class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> ――― Platform Specifics ――――――――――――――――――――――――――――――――――――――――――――――――――――――― <span class=\"comment\">#</span></span></div><div class=\"line\">  s.platform     = :ios, \"8.0\"</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\">  When using multiple platforms</span></div><div class=\"line\">  s.ios.deployment_target = \"8.0\"</div><div class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> ――― Source Location ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― <span class=\"comment\">#</span></span></div><div class=\"line\">  s.source       = &#123; :git =&gt; \"https://github.com/l900416/LTChat.git\", :tag =&gt; \"#&#123;s.version&#125;\" &#125;</div><div class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> ――― Source Code ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― <span class=\"comment\">#</span></span></div><div class=\"line\">  s.source_files  = \"LTChat\", \"LTChat/**/*.&#123;h,m&#125;\"</div><div class=\"line\">  s.exclude_files = \"LTChat/Exclude\"</div><div class=\"line\"></div><div class=\"line\">  s.public_header_files = \"LTChat/**/*.h\"</div><div class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> ――― Resources ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― <span class=\"comment\">#</span></span></div><div class=\"line\">  s.resources = \"LTChat/**/*.&#123;xib&#125;\",\"LTChat/**/*.&#123;png&#125;\"</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> ――― Project Linking ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― <span class=\"comment\">#</span></span></div><div class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> s.frameworks = <span class=\"string\">\"SomeFramework\"</span>, <span class=\"string\">\"AnotherFramework\"</span></span></div><div class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> s.libraries = <span class=\"string\">\"iconv\"</span>, <span class=\"string\">\"xml2\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> ――― Project Settings ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― <span class=\"comment\">#</span></span></div><div class=\"line\"><span class=\"meta\">  #</span><span class=\"bash\"> s.requires_arc = <span class=\"literal\">true</span></span></div><div class=\"line\">  s.dependency \"XMPPFramework\", \"~&gt; 3.7.0\"</div><div class=\"line\">  s.dependency \"GoogleWebRTC\"</div></pre></td></tr></table></figure>\n<h3 id=\"建立TAG\"><a href=\"#建立TAG\" class=\"headerlink\" title=\"建立TAG\"></a>建立TAG</h3><p>使用 <strong>git tag</strong> 和 <strong>git push</strong> 命令建立TAG</p>\n<p><img src=\"/post/share/github_pod_create_2.png\" alt=\"\"></p>\n<h3 id=\"验证Pod文件\"><a href=\"#验证Pod文件\" class=\"headerlink\" title=\"验证Pod文件\"></a>验证Pod文件</h3><p>使用 <strong>pod lib lint</strong> 或 <strong>pod spec lint</strong>  验证Pod文件格式是否正确，可以添加 <strong>–verbose</strong> 获取更多的信息，添加 <strong>–no-clean</strong> 不对验证的工程进行清理，方便查看工程验证错误原因。两者的区别：</p>\n<ul>\n<li>pod lib lint 是只从本地验证pod是否能够通过验证</li>\n<li>pod sepc lint 是从本地和远程来验证pod是否通过验证。</li>\n</ul>\n<h3 id=\"发布\"><a href=\"#发布\" class=\"headerlink\" title=\"发布\"></a>发布</h3><p>使用 <strong>pod trunk</strong> 发布程序，使用到的命令如下：</p>\n<ul>\n<li>pod trunk register 邮箱 ‘用户名’：注册，之后在邮件中进行验证。</li>\n<li>pod trunk me ： 查看个人信息，包括该邮件下已经注册的代码组件、个人信息、登陆session等。</li>\n<li>pod trunk push *.podspec : 发布podspec</li>\n<li>等待审核</li>\n<li>pod search： 检查是否发布成功</li>\n</ul>\n<h3 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h3><p>建立TAG，并发布。<br><img src=\"/post/share/github_pod_update_1.png\" alt=\"\"><br><img src=\"/post/share/github_pod_update_2.png\" alt=\"\"></p>\n<h3 id=\"问题记录\"><a href=\"#问题记录\" class=\"headerlink\" title=\"问题记录\"></a>问题记录</h3><h4 id=\"pod-lib-lint验证失败\"><a href=\"#pod-lib-lint验证失败\" class=\"headerlink\" title=\"pod lib lint验证失败\"></a>pod lib lint验证失败</h4><p>如果出现验证失败，则需要添加参数 <strong>–verbose</strong> 查看详细错误原因 。例如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">The following build commands failed:</div><div class=\"line\">Ld /Users/liangtong/Library/Developer/Xcode/DerivedData/App-eowwjkrvluwvfdhhkljszfucgimo/Build/Intermediates.noindex/Pods.build/Release-iphonesimulator/LTChat.build/Objects-normal/i386/LTChat normal i386</div><div class=\"line\">(1 failure)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">[!] LTChat did not pass validation, due to 1 error and 71 warnings.</div></pre></td></tr></table></figure>\n<p>原因是由于谷歌官方iOS版本的 <strong>GoogleWebRTC</strong> 仅支持处理器<strong>x86_64 armv7 arm64</strong>导致</p>\n<h4 id=\"Swift-Language-Version\"><a href=\"#Swift-Language-Version\" class=\"headerlink\" title=\"Swift Language Version\"></a>Swift Language Version</h4><p>根据失败的log日志，确认失败原因，比如LTChat依赖于XMPPFramework，而XMPPFramework又依赖了KissXML。此时编译的时候出现了Swift版本不明确的错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">=== BUILD TARGET KissXML OF PROJECT Pods WITH CONFIGURATION Release ===</div><div class=\"line\"></div><div class=\"line\">Check dependencies</div><div class=\"line\">The “Swift Language Version” (SWIFT_VERSION) build setting must be set to a supported value for targets which use Swift. This setting can be set in the build settings editor.</div><div class=\"line\">The “Swift Language Version” (SWIFT_VERSION) build setting must be set to a supported value for targets which use Swift. This setting can be set in the build settings editor.</div><div class=\"line\"></div><div class=\"line\">** BUILD FAILED **</div><div class=\"line\"></div><div class=\"line\">The following build commands failed:</div><div class=\"line\">Check dependencies</div></pre></td></tr></table></figure>\n<p>解决办法，指定 <strong>Swift Language</strong> 版本</p>\n<blockquote>\n<p> pod lib lint –swift-version=4.0</p>\n</blockquote>\n<h4 id=\"上传后查询不到最新版本\"><a href=\"#上传后查询不到最新版本\" class=\"headerlink\" title=\"上传后查询不到最新版本\"></a>上传后查询不到最新版本</h4><p>解决办法：清理缓存，重新setup</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">rm -rf ~/.cocoapods/repos/master</div><div class=\"line\">pod setup</div></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjahxo4rp0005oko8clbgcxec","category_id":"cjahxo4rl0002oko8u1ips845","_id":"cjahxo4s1000coko8vqo22vcb"},{"post_id":"cjahxo4rg0000oko85uwhbv00","category_id":"cjahxo4rl0002oko8u1ips845","_id":"cjahxo4s3000goko8aut76yph"},{"post_id":"cjahxo4rr0006oko89f18uk5t","category_id":"cjahxo4rl0002oko8u1ips845","_id":"cjahxo4s3000joko8ojecikza"},{"post_id":"cjahxo4rx000aoko8ck4z3g0r","category_id":"cjahxo4rl0002oko8u1ips845","_id":"cjahxo4s5000noko8ykr43oep"},{"post_id":"cjahxo4rk0001oko8avaoe5rr","category_id":"cjahxo4rl0002oko8u1ips845","_id":"cjahxo4s6000qoko89ghrvxyd"},{"post_id":"cjahxo4ro0004oko89ftifc9k","category_id":"cjahxo4rl0002oko8u1ips845","_id":"cjahxo4s7000uoko8qmezjekf"},{"post_id":"cjahxo4s4000moko873rrrf65","category_id":"cjahxo4s4000koko86xbiuhil","_id":"cjahxo4s8000xoko8zjm2i25o"},{"post_id":"cjahxo4rz000boko8xdj5lmoe","category_id":"cjahxo4s4000koko86xbiuhil","_id":"cjahxo4se0012oko8ivg1j04i"},{"post_id":"cjahxo4s5000poko86fxx63x2","category_id":"cjahxo4rl0002oko8u1ips845","_id":"cjahxo4sf0015oko8ql1n3s3r"},{"post_id":"cjahxo4s7000toko801kkjimq","category_id":"cjahxo4s4000koko86xbiuhil","_id":"cjahxo4sf0019oko8ym8ap3ez"},{"post_id":"cjahxo4s2000foko8xh1octfc","category_id":"cjahxo4s4000koko86xbiuhil","_id":"cjahxo4sg001boko82djd6lc6"},{"post_id":"cjahxo4s8000woko8y3d3ly9x","category_id":"cjahxo4s4000koko86xbiuhil","_id":"cjahxo4sg001eoko86t4klge9"},{"post_id":"cjahxo4s3000ioko8xit9krng","category_id":"cjahxo4s4000koko86xbiuhil","_id":"cjahxo4sg001goko8gb9q4lge"},{"post_id":"cjahxo4sc0011oko80cupl7u3","category_id":"cjahxo4sf0018oko8fule36y4","_id":"cjahxo4sh001ioko8e8uer83q"},{"post_id":"cjahxo4se0014oko8o2bywwpj","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4si001loko82me2vyvr"},{"post_id":"cjahxo4tp001uoko855agfdwh","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4tv0023oko87ymbtpel"},{"post_id":"cjahxo4tr001woko8n9pud0nx","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4tz0026oko8mspt0d3l"},{"post_id":"cjahxo4tu001zoko8uww46vkb","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4u10029oko88af9nktg"},{"post_id":"cjahxo4tv0022oko8opwvlpth","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4u3002coko8j6sds5gf"},{"post_id":"cjahxo4tw0025oko8w21mz95n","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4u4002foko8a3zkyo5e"},{"post_id":"cjahxo4u00027oko80x2bdqub","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4u5002ioko86i1fpt6c"},{"post_id":"cjahxo4u2002boko853zqhjqk","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4u6002koko8lq2wipvu"},{"post_id":"cjahxo4u3002doko8whaso814","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4u7002ooko8gagcggmm"},{"post_id":"cjahxo4u5002hoko8fqjh1ct2","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4u8002roko861f3gbcn"},{"post_id":"cjahxo4u5002joko8yrcewr03","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4ua002voko8aopjkiyo"},{"post_id":"cjahxo4u6002noko8zd3trl5k","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4ub002yoko8an2sj1hy"},{"post_id":"cjahxo4u7002qoko82f2dhdb5","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4uc0032oko8rcv06tju"},{"post_id":"cjahxo4u8002uoko8m8c13clg","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4ud0035oko8299mxqnv"},{"post_id":"cjahxo4ub002xoko8y3wmj0r4","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4uf0039oko86ujzfmi2"},{"post_id":"cjahxo4uc0031oko8hhs79kg9","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4uh003coko86yhg3qls"},{"post_id":"cjahxo4ud0034oko8tyjz6bsq","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4uj003foko87lv8v1c3"},{"post_id":"cjahxo4uf0038oko8exqiibtb","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4ul003ioko8ivf0nxas"},{"post_id":"cjahxo4ug003boko89uqip9gk","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4ul003loko8e37ehbnz"},{"post_id":"cjahxo4ui003eoko8uosvsb4l","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4un003ooko8koqscv1w"},{"post_id":"cjahxo4uk003hoko8u7zniiii","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4uo003roko8omu5ine7"},{"post_id":"cjahxo4ul003koko861c4cbpa","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4up003uoko89adknhvd"},{"post_id":"cjahxo4um003noko84wpxmt9p","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4uq003xoko85rnejknh"},{"post_id":"cjahxo4uo003qoko8x8lqlm8y","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4us0040oko8vdooskzj"},{"post_id":"cjahxo4uo003toko89beqqv4g","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4ut0044oko8y32wx1li"},{"post_id":"cjahxo4up003woko8us417d9t","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4uu0047oko87o9gvezl"},{"post_id":"cjahxo4ur003zoko8l4tszzot","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4uy004aoko8ugv7idwz"},{"post_id":"cjahxo4us0043oko8vftgamk0","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4v0004doko882co6b0z"},{"post_id":"cjahxo4ut0046oko8grgmvle1","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4v2004goko8em8fult5"},{"post_id":"cjahxo4uw0049oko8uyamqwe4","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4v3004joko8tsfpmd8e"},{"post_id":"cjahxo4uz004coko8pwzq7cob","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4v3004moko8zgw8oqo6"},{"post_id":"cjahxo4v1004foko8hfxztlkl","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4v5004qoko8jgwb2qx7"},{"post_id":"cjahxo4v2004ioko8vjgqbks3","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4v6004toko8zsuoemdf"},{"post_id":"cjahxo4v3004loko8jsyphqxm","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4v8004yoko8001dncc8"},{"post_id":"cjahxo4v6004soko86rihifpg","category_id":"cjahxo4sg001doko8cju6m1b9","_id":"cjahxo4va0053oko8f58mwfpp"},{"post_id":"cjahxo4v80050oko89mae8gfm","category_id":"cjahxo4v7004uoko8u9bksv4f","_id":"cjahxo4vc005aoko8t0knwoj0"},{"post_id":"cjahxo4v4004poko8hy5ghqix","category_id":"cjahxo4v7004uoko8u9bksv4f","_id":"cjahxo4vd005foko8q6ysaq5n"},{"post_id":"cjahxo4v7004woko8kdlnptlv","category_id":"cjahxo4v7004uoko8u9bksv4f","_id":"cjahxo4ve005ioko8nyceg1sk"},{"post_id":"cjahxo4v90052oko8d43hof9o","category_id":"cjahxo4vc005boko85qapyann","_id":"cjahxo4vg005poko8vqrk0u3y"},{"post_id":"cjahxo4vb0057oko8l3swwnmo","category_id":"cjahxo4vc005boko85qapyann","_id":"cjahxo4vh005toko8z1fuofwd"},{"post_id":"cjahxo4vb0059oko8jids9g48","category_id":"cjahxo4vc005boko85qapyann","_id":"cjahxo4vi005woko8jhei32cy"},{"post_id":"cjahxo4vd005eoko8s7awd5z0","category_id":"cjahxo4vh005soko8ah1atv6o","_id":"cjahxo4vj0061oko8remabw55"},{"post_id":"cjahxo4vd005hoko82izhjf4z","category_id":"cjahxo4vh005soko8ah1atv6o","_id":"cjahxo4vk0064oko848l1ivg1"},{"post_id":"cjahxo4ve005moko8ctpcsapz","category_id":"cjahxo4vh005soko8ah1atv6o","_id":"cjahxo4vl0067oko8cyrk0oe3"}],"PostTag":[{"post_id":"cjahxo4rg0000oko85uwhbv00","tag_id":"cjahxo4ro0003oko8w83fgrqp","_id":"cjahxo4rx0009oko83rahu3yj"},{"post_id":"cjahxo4rk0001oko8avaoe5rr","tag_id":"cjahxo4ru0008oko85i231al0","_id":"cjahxo4s3000hoko810ch1ew6"},{"post_id":"cjahxo4ro0004oko89ftifc9k","tag_id":"cjahxo4s2000eoko8ykxhf9jk","_id":"cjahxo4s5000ooko8jzc4sw2x"},{"post_id":"cjahxo4rp0005oko8clbgcxec","tag_id":"cjahxo4s2000eoko8ykxhf9jk","_id":"cjahxo4s8000voko8bkgq1lp8"},{"post_id":"cjahxo4s5000poko86fxx63x2","tag_id":"cjahxo4s2000eoko8ykxhf9jk","_id":"cjahxo4s9000zoko8dugs2af5"},{"post_id":"cjahxo4s7000toko801kkjimq","tag_id":"cjahxo4ro0003oko8w83fgrqp","_id":"cjahxo4se0013oko8is3a29c6"},{"post_id":"cjahxo4rr0006oko89f18uk5t","tag_id":"cjahxo4s2000eoko8ykxhf9jk","_id":"cjahxo4sf0016oko85yxdqacl"},{"post_id":"cjahxo4rx000aoko8ck4z3g0r","tag_id":"cjahxo4s2000eoko8ykxhf9jk","_id":"cjahxo4sg001aoko8iddc96wc"},{"post_id":"cjahxo4rz000boko8xdj5lmoe","tag_id":"cjahxo4sf0017oko81phnlo8m","_id":"cjahxo4sg001foko851ebncca"},{"post_id":"cjahxo4s2000foko8xh1octfc","tag_id":"cjahxo4sf0017oko81phnlo8m","_id":"cjahxo4sh001joko87g41s4cn"},{"post_id":"cjahxo4s3000ioko8xit9krng","tag_id":"cjahxo4sg001hoko8wm4z25mi","_id":"cjahxo4sj001moko8mgtz4gvo"},{"post_id":"cjahxo4s4000moko873rrrf65","tag_id":"cjahxo4sg001hoko8wm4z25mi","_id":"cjahxo4sk001ooko8taoh7qfr"},{"post_id":"cjahxo4s8000woko8y3d3ly9x","tag_id":"cjahxo4sf0017oko81phnlo8m","_id":"cjahxo4sl001qoko8v0iypztu"},{"post_id":"cjahxo4sc0011oko80cupl7u3","tag_id":"cjahxo4sk001poko8tad5w7la","_id":"cjahxo4sl001soko898g4g9to"},{"post_id":"cjahxo4se0014oko8o2bywwpj","tag_id":"cjahxo4sl001roko81bnh1snk","_id":"cjahxo4sl001toko8m89j5vsp"},{"post_id":"cjahxo4tp001uoko855agfdwh","tag_id":"cjahxo4sl001roko81bnh1snk","_id":"cjahxo4tu001yoko8p4kvsrrt"},{"post_id":"cjahxo4tr001woko8n9pud0nx","tag_id":"cjahxo4tv0021oko8jx6vb0rr","_id":"cjahxo4u2002aoko8socrapi1"},{"post_id":"cjahxo4tu001zoko8uww46vkb","tag_id":"cjahxo4tv0021oko8jx6vb0rr","_id":"cjahxo4u4002goko8p9wnk505"},{"post_id":"cjahxo4u5002hoko8fqjh1ct2","tag_id":"cjahxo4u4002eoko8rz1hgn10","_id":"cjahxo4u6002moko8fspkaju4"},{"post_id":"cjahxo4tv0022oko8opwvlpth","tag_id":"cjahxo4u4002eoko8rz1hgn10","_id":"cjahxo4u7002poko8x8vq91iw"},{"post_id":"cjahxo4u5002joko8yrcewr03","tag_id":"cjahxo4u4002eoko8rz1hgn10","_id":"cjahxo4u8002toko8tawc65cv"},{"post_id":"cjahxo4u6002noko8zd3trl5k","tag_id":"cjahxo4u4002eoko8rz1hgn10","_id":"cjahxo4ub002woko8lpmwcxkd"},{"post_id":"cjahxo4tw0025oko8w21mz95n","tag_id":"cjahxo4u4002eoko8rz1hgn10","_id":"cjahxo4uc0030oko8hvvyt5ix"},{"post_id":"cjahxo4u7002qoko82f2dhdb5","tag_id":"cjahxo4u4002eoko8rz1hgn10","_id":"cjahxo4ud0033oko8e5d08sof"},{"post_id":"cjahxo4u8002uoko8m8c13clg","tag_id":"cjahxo4u4002eoko8rz1hgn10","_id":"cjahxo4uf0037oko8xqdaqmnz"},{"post_id":"cjahxo4u00027oko80x2bdqub","tag_id":"cjahxo4u4002eoko8rz1hgn10","_id":"cjahxo4uf003aoko8usxv554i"},{"post_id":"cjahxo4ub002xoko8y3wmj0r4","tag_id":"cjahxo4u4002eoko8rz1hgn10","_id":"cjahxo4ui003doko87aga6fcm"},{"post_id":"cjahxo4uc0031oko8hhs79kg9","tag_id":"cjahxo4u4002eoko8rz1hgn10","_id":"cjahxo4uk003goko89faczkdr"},{"post_id":"cjahxo4u2002boko853zqhjqk","tag_id":"cjahxo4u4002eoko8rz1hgn10","_id":"cjahxo4ul003joko8v9qyuia4"},{"post_id":"cjahxo4ud0034oko8tyjz6bsq","tag_id":"cjahxo4u4002eoko8rz1hgn10","_id":"cjahxo4ul003moko8nosvrr7t"},{"post_id":"cjahxo4uf0038oko8exqiibtb","tag_id":"cjahxo4u4002eoko8rz1hgn10","_id":"cjahxo4un003poko8wxxozydl"},{"post_id":"cjahxo4u3002doko8whaso814","tag_id":"cjahxo4u4002eoko8rz1hgn10","_id":"cjahxo4uo003soko8p3vk04uh"},{"post_id":"cjahxo4ug003boko89uqip9gk","tag_id":"cjahxo4u4002eoko8rz1hgn10","_id":"cjahxo4up003voko84txa665q"},{"post_id":"cjahxo4ui003eoko8uosvsb4l","tag_id":"cjahxo4u4002eoko8rz1hgn10","_id":"cjahxo4ur003yoko8eb7dg64a"},{"post_id":"cjahxo4uk003hoko8u7zniiii","tag_id":"cjahxo4u4002eoko8rz1hgn10","_id":"cjahxo4us0042oko8sywiags3"},{"post_id":"cjahxo4ul003koko861c4cbpa","tag_id":"cjahxo4u4002eoko8rz1hgn10","_id":"cjahxo4ut0045oko876k9nhh6"},{"post_id":"cjahxo4um003noko84wpxmt9p","tag_id":"cjahxo4u4002eoko8rz1hgn10","_id":"cjahxo4uv0048oko8hynim33c"},{"post_id":"cjahxo4uo003qoko8x8lqlm8y","tag_id":"cjahxo4u4002eoko8rz1hgn10","_id":"cjahxo4uy004boko879bpi3zm"},{"post_id":"cjahxo4uo003toko89beqqv4g","tag_id":"cjahxo4u4002eoko8rz1hgn10","_id":"cjahxo4v0004eoko8lv9mvp04"},{"post_id":"cjahxo4ur003zoko8l4tszzot","tag_id":"cjahxo4tv0021oko8jx6vb0rr","_id":"cjahxo4v2004hoko8pctzat8i"},{"post_id":"cjahxo4us0043oko8vftgamk0","tag_id":"cjahxo4u4002eoko8rz1hgn10","_id":"cjahxo4v3004koko8gjfr3x1t"},{"post_id":"cjahxo4ut0046oko8grgmvle1","tag_id":"cjahxo4u4002eoko8rz1hgn10","_id":"cjahxo4v4004ooko8wv3njtxm"},{"post_id":"cjahxo4up003woko8us417d9t","tag_id":"cjahxo4us0041oko8lvw69dmg","_id":"cjahxo4v5004roko83ec4ikqc"},{"post_id":"cjahxo4uw0049oko8uyamqwe4","tag_id":"cjahxo4u4002eoko8rz1hgn10","_id":"cjahxo4v7004voko8t3u4yh1o"},{"post_id":"cjahxo4uz004coko8pwzq7cob","tag_id":"cjahxo4us0041oko8lvw69dmg","_id":"cjahxo4v8004zoko8952oj9uv"},{"post_id":"cjahxo4v1004foko8hfxztlkl","tag_id":"cjahxo4us0041oko8lvw69dmg","_id":"cjahxo4v90051oko86l2uozf7"},{"post_id":"cjahxo4v3004loko8jsyphqxm","tag_id":"cjahxo4us0041oko8lvw69dmg","_id":"cjahxo4va0056oko8272irz7i"},{"post_id":"cjahxo4v6004soko86rihifpg","tag_id":"cjahxo4v4004noko8v0ymj9te","_id":"cjahxo4vb0058oko8uyy4fr5x"},{"post_id":"cjahxo4v2004ioko8vjgqbks3","tag_id":"cjahxo4v4004noko8v0ymj9te","_id":"cjahxo4vc005doko8445irmmv"},{"post_id":"cjahxo4v4004poko8hy5ghqix","tag_id":"cjahxo4v8004xoko8t1fz79vv","_id":"cjahxo4vd005goko8llaabv2g"},{"post_id":"cjahxo4v7004woko8kdlnptlv","tag_id":"cjahxo4va0055oko8qygha997","_id":"cjahxo4ve005loko8fc5wyped"},{"post_id":"cjahxo4v80050oko89mae8gfm","tag_id":"cjahxo4va0055oko8qygha997","_id":"cjahxo4vf005noko8mua9c9gz"},{"post_id":"cjahxo4v90052oko8d43hof9o","tag_id":"cjahxo4ve005koko8fil36e29","_id":"cjahxo4vh005roko8wsv4il6x"},{"post_id":"cjahxo4vb0057oko8l3swwnmo","tag_id":"cjahxo4ve005koko8fil36e29","_id":"cjahxo4vi005voko8kq0qpcnc"},{"post_id":"cjahxo4vb0059oko8jids9g48","tag_id":"cjahxo4ve005koko8fil36e29","_id":"cjahxo4vj005zoko82w9gcupm"},{"post_id":"cjahxo4vd005eoko8s7awd5z0","tag_id":"cjahxo4vj005yoko8gaezgo9v","_id":"cjahxo4vk0063oko80eii79hx"},{"post_id":"cjahxo4vd005hoko82izhjf4z","tag_id":"cjahxo4vj005yoko8gaezgo9v","_id":"cjahxo4vl0066oko8knzktzub"},{"post_id":"cjahxo4ve005moko8ctpcsapz","tag_id":"cjahxo4vl0065oko824cfep62","_id":"cjahxo4vl0068oko8xx542ojr"}],"Tag":[{"name":"位置","_id":"cjahxo4ro0003oko8w83fgrqp"},{"name":"Search","_id":"cjahxo4ru0008oko85i231al0"},{"name":"Sort","_id":"cjahxo4s2000eoko8ykxhf9jk"},{"name":"Bluetooth","_id":"cjahxo4sf0017oko81phnlo8m"},{"name":"iBeacon","_id":"cjahxo4sg001hoko8wm4z25mi"},{"name":"SQLite3","_id":"cjahxo4sk001poko8tad5w7la"},{"name":"Menu","_id":"cjahxo4sl001roko81bnh1snk"},{"name":"Note","_id":"cjahxo4tv0021oko8jx6vb0rr"},{"name":"Swift","_id":"cjahxo4u4002eoko8rz1hgn10"},{"name":"随笔","_id":"cjahxo4us0041oko8lvw69dmg"},{"name":"问题记录","_id":"cjahxo4v4004noko8v0ymj9te"},{"name":"WebRTC","_id":"cjahxo4v8004xoko8t1fz79vv"},{"name":"xmpp","_id":"cjahxo4va0055oko8qygha997"},{"name":"shell","_id":"cjahxo4ve005koko8fil36e29"},{"name":"GitHub","_id":"cjahxo4vj005yoko8gaezgo9v"},{"name":"GitHub CocoaPods","_id":"cjahxo4vl0065oko824cfep62"}]}}