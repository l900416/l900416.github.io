<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[XMPP之用户注册／登录]]></title>
    <url>%2F2017%2F09%2F22%2Fios_instance_message_xmpp%2F</url>
    <content type="text"><![CDATA[XMPP是一个以XML为基础的开源的即时通讯协议。具有开放、标准、可用、分布式、安全、可扩展、多样性等优点。因为最近工作接触，在此进行记录。希望对你有帮助。本文为XMPP开发的第一讲，记录XMPP的用户注册／登录。 环境配置使用GitHub上现有的XMPPFramework，直接将其依赖加入到工程的Podfile中后，执行 pod install 下载：12345platform :ios, &apos;8.0&apos;use_frameworks!target &apos;LTIM&apos; do pod &apos;XMPPFramework&apos;, &apos;~&gt; 3.7.0&apos;end 登录流程XMPP的登录主要需要了解 XMPPStreamDelegate 协议，用户登录分为以下几个步骤： 设置代理并激活 连接服务器 完成注册／认证 发送Presence状态数据 对应需要重点关注 XMPPStreamDelegate 协议中的以下方法，其他方法根据需要进行实现即可： 1234567891011#pragma mark - XMPPStreamDelegate/*证书相关*/- (void)xmppStream:(XMPPStream *)sender willSecureWithSettings:(NSMutableDictionary *)settings;/*连接服务器之后，回调的方法*/- (void)xmppStreamDidConnect:(XMPPStream *)sender;/*新用户注册，回调的方法*/- (void)xmppStreamDidRegister:(XMPPStream *)sender;/*用户登陆，回调的方法*/- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender;- (void)xmppStream:(XMPPStream *)sender didNotAuthenticate:(NSXMLElement *)error; 设置代理并激活初始化 XMPPStream 对象，并设置 XMPPStreamDelegate 代理组件，创建重连组件并将其在 XMPPStream 对象中生效(激活)。 123456self.xmppStream = [[XMPPStream alloc] init];[self.xmppStream addDelegate:self delegateQueue:dispatch_get_main_queue()];//创建XMPPReconnect重连组件，并把组件在XMPPStream中(激活)self.xmppReconnect = [[XMPPReconnect alloc] init];[self.xmppReconnect activate:self.xmppStream]; 连接服务器使用 XMPPJID 连接到服务器，注意此处需要设置服务器的端口号和IP地址(hostName)。 12345678910111213141516//若需要修改IP和port则在连接服务器前进行修改。_xmppStream.hostPort = hostPort;_xmppStream.hostName = hostIP;//创建JID；将JID添加到xmppStream中XMPPJID * jid = [XMPPJID jidWithString:self.jid resource:LTXMPP_RESOURCE];[self.xmppStream setMyJID:jid];//开始连接服务器NSError *error = nil;if (![self.xmppStream connectWithTimeout:XMPPStreamTimeoutNone error:&amp;error]) &#123; NSLog(@&quot;%s - %s&quot;,__FILE__,__FUNCTION__); NSLog(@&quot;连接服务器失败：%@&quot;,error); return NO;&#125;NSLog(@&quot;连接服务器成功！&quot;); 需要说明的一点是：jid可以是已经有账户和待注册账户，通常形式为 “name@domain” 完成注册／认证具体注册／认证是看你调用了XMPPStream的方法。 12- (BOOL)registerWithPassword:(NSString *)password error:(NSError **)errPtr- (BOOL)authenticateWithPassword:(NSString *)password error:(NSError **)errPtr 在执行注册／认证方法后，通过协议回调查看执行结果，例如登录： 123456789101112131415161718192021/*用户上线*/-(void)goOnline&#123; if([self connect])&#123; NSError *error = nil; [self.xmppStream authenticateWithPassword:self.userPwd error:&amp;error]; if (error) &#123; NSLog(@&quot;%s - %s&quot;,__FILE__,__FUNCTION__); NSLog(@&quot;登陆认证失败：%@&quot;,error); &#125; &#125;&#125;/*用户登陆，回调的方法*/- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender&#123; NSLog(@&quot;%s - %s&quot;,__FILE__,__FUNCTION__); NSLog(@&quot;登陆认证成功！！&quot;); //存储用户信息，下次自动登录&#125;- (void)xmppStream:(XMPPStream *)sender didNotAuthenticate:(NSXMLElement *)error&#123; NSLog(@&quot;%s - %s&quot;,__FILE__,__FUNCTION__); NSLog(@&quot;登陆失败：%@&quot;,error);&#125; 发送Presence用户状态数据用户登录成功后，需要发送表示用户状态 XMPPPresence 数据 12345 XMPPPresence * presence = [XMPPPresence presence];//默认type是available [presence addChild:[DDXMLElement elementWithName:@&quot;show&quot; stringValue:@&quot;away&quot;]]; [presence addChild:[DDXMLElement elementWithName:@&quot;status&quot; stringValue:@&quot;今天是个好日子,这里是显示的状态(iOS)&quot;]]; [self.xmppStream sendElement:presence];&#125; 好了，本节就讲这些，下一节讲述：XMPPFramework之花名册获取。]]></content>
      <categories>
        <category>即时通讯</category>
      </categories>
      <tags>
        <tag>xmpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重定向]]></title>
    <url>%2F2017%2F08%2F29%2Fos_shell_std_in_out_error_redirect%2F</url>
    <content type="text"><![CDATA[在linux系统下，一切皆是文件，对文件的操作，一般要用到文件标识符。 常用的FD(File Descriptor)linux启动后，会默认打开3个文件描述符。分别是： 0 - 标准输入，/dev/stdin，可以理解为键盘 1 - 标准输出，/dev/stdout，正确的输出，可以理解为屏幕 2 - 标准错误输出，/dev/stderr，错误输出 对于任何一条linux命令，都会有以上默认的3个描述符。也可以简单的理解为每个程序(函数)都会有输入、正确／错误输出。 重定向重定向分为输入重定向和输出重定向。 输入重定向即不从键盘读入、而是从文件或者其他。 &lt; 表示输入重定向运算符。 例如命令先删除b.txt文件中内容，然后将a.txt文件中内容复制到b.txt文件中。 12liangtongdeiMac:playground liangtong$ &gt; b.txt liangtongdeiMac:playground liangtong$ cat &gt; b.txt &lt; a.txt 等同与 12liangtongdeiMac:playground liangtong$ &gt; b.txt liangtongdeiMac:playground liangtong$ less a.txt &gt;b.txt &lt;&lt; 表示当前标准输入来自命令行，符号后边跟随的是『结束的输入字符』。 123456789101112131415liangtongdeiMac:playground liangtong$ &gt; b.txt liangtongdeiMac:playground liangtong$ less b.txt liangtongdeiMac:playground liangtong$ &gt; b.txt liangtongdeiMac:playground liangtong$ cat &gt; b.txt &lt;&lt; eof&gt; hello&gt; world&gt; eofliangtongdeiMac:playground liangtong$ liangtongdeiMac:playground liangtong$ cat &gt;&gt;b.txt &lt;&lt; endofinput&gt; hahaha&gt; endofinputliangtongdeiMac:playground liangtong$ cat &gt;&gt;b.txt &lt;&lt; endofinput&gt; adsfasdf&gt; endofinputliangtongdeiMac:playground liangtong$ less b.txt 输出重定向将一条命令执行结果（标准输出，或者错误输出，本来都要打印到屏幕上面的） 重定向其它输出设备（文件，打开文件操作符，或打印机等等）1,2分别是标准输出，错误输出 &gt; 会判断右边文件是否存在，如果存在就先删除，并且创建新文件。不存在直接创建。 &gt;&gt; 判断右边文件，如果不存在，先创建。以添加方式打开文件。 例如以下命令对应3种操作。 创建c.txt文件或者清除c.txt文件内容。 将a.txt内容写入c.txt中。 将b.txt内容追加写入c.txt中。 123liangtongdeiMac:playground liangtong$ &gt; c.txtliangtongdeiMac:playground liangtong$ less a.txt &gt; c.txt liangtongdeiMac:playground liangtong$ less b.txt &gt;&gt; c.txt 命令执行完后，绑定文件的描述符也自动失效。0,1,2又会空闲 典型案例分析经过上述介绍，下面我们看一些典型的例子，这些尤其在makefile中很常见。 特别注意的是，多个重定下复合时，按照顺序执行，例如 1&gt;/dev/null 2&gt;&amp;1 和 2&gt;&amp;1 1&gt;/dev//null 执行结果不一样 &amp; 是一个描述符，如果1或2前不加&amp;，会被当成一个普通文件 1&gt;&amp;2和2&gt;&amp;1和&amp;&gt;filename1&gt;&amp;2 意思是标准输出重定向到标准错误。比如以下命令将a.txt2&gt;&amp;1 意思是把标准错误输出重定向到标准输出&amp;&gt;filename 意思是把标准输出和标准错误输出都重定向到文件filename中 比如，以下命令分别 ls -l 命令的标准输出、错误输出重定向到right.txt和error.txt文件中 123liangtongdeiMac:playground liangtong$ ls -l not_exist.txt a.txt 1&gt;right.txt 2&gt;error.txtliangtongdeiMac:playground liangtong$ less right.txt liangtongdeiMac:playground liangtong$ less error.txt 以下命令将标准输出重定向到right.txt文件中，将标准错误输出重定向到标准输出（此时是right.txt文件），此时right.txt文件将存放命令执行的标准输出和标准错误输出。 12liangtongdeiMac:playground liangtong$ ls -l not_exist.txt a.txt 1&gt;right.txt 2&gt;&amp;1liangtongdeiMac:playground liangtong$ less right.txt /dev/null/dev/null是一个垃圾箱，是一个无底洞，表示的含义为不显示。直接丢弃。比如以下命令效果一样，对标准输入、标准错误输出均丢弃 12liangtongdeiMac:playground liangtong$ ls -l not_exist.txt a.txt 1&gt;/dev/null 2&gt;/dev/nullliangtongdeiMac:playground liangtong$ ls -l not_exist.txt a.txt 1&gt;/dev/null 2&gt;&amp;1 2&gt;&amp;1 1&gt;/dev/null将标准错误输出在屏幕上（标准输出）表示，将标准输出丢弃，此时屏幕上只输出标准错误日志。 1&gt;/dev/null 2&gt;&amp;1将标准输出丢弃，将标准错误重定向到标准输出，此时无任何输出(均被丢弃)。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改文件所有者]]></title>
    <url>%2F2017%2F08%2F28%2Fos_shell_authority_chown%2F</url>
    <content type="text"><![CDATA[chown 使用超级管理员用户权限时，可以更改文件的所有者和用户组，命令如下： chown [owner][:[group]] file… 命令将文件更改为第一个参数所表示的所有者 :所在分组。 例如： 123456liangtongdeiMac:test_authority liangtong$ sudo chown guest authority_test.txt Password:liangtongdeiMac:test_authority liangtong$ ls -ltotal 0-rw-r--r-- 1 Guest staff 0 8 16 18:43 authority_test.txtliangtongdeiMac:test_authority liangtong$ 若命令中只包含 用户名 ，则是把所有者更改为用户。 若命令中包含 :用户组 ，则将文件的用户组修改。 特别的，若命令中参数格式是 用户: ， 即未指明用户组，那么用户组指的是用户所在的分组。 chgrp 使用超级管理员用户权限时，可以使用 chgrp 来修改用户组，命令与chown相似： chgrp group file]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝牙Central模式 - 水准仪蓝牙交互]]></title>
    <url>%2F2017%2F08%2F24%2Fbluetooth_central_level%2F</url>
    <content type="text"><![CDATA[​ 工程测量中，Trimble电子水准仪(DiNi Level)在测量完成后，通过蓝牙模块与外设进行数据交互，本文介绍外设如何作为中心模式与水准仪进行数据交互。 前期准备前期准备工作包括以下几个方面： 蓝牙外设扫描 蓝牙外设连接 外设服务发现 特征值发现 订阅 可以参照iOS蓝牙开发 - Central模式，此处不再赘述，参照以下摘要信息： 1234567891011121314152017-08-24 16:15:39.860 RoadBridgeOnline[1067:189910] CBCentralManagerStatePoweredOn2017-08-24 16:15:50.121 RoadBridgeOnline[1067:189910] -[BluetoothViewModel centralManager:didConnectPeripheral:], line = 198, CRTB_BT_MODULE=连接成功2017-08-24 16:15:50.188 RoadBridgeOnline[1067:189910] -- 发现服务 -- :&lt;CBService: 0x15e6301c0, isPrimary = YES, UUID = 1101&gt;2017-08-24 16:15:50.189 RoadBridgeOnline[1067:189910] -- 发现服务 -- :&lt;CBService: 0x15e6a6590, isPrimary = YES, UUID = 00001016-D102-11E1-9B23-00025B00A5A5&gt;2017-08-24 16:15:50.191 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didDiscoverCharacteristicsForService:error:], line = 2362017-08-24 16:15:50.191 RoadBridgeOnline[1067:189910] characteristic name:1102 value is: 2017-08-24 16:15:50.193 RoadBridgeOnline[1067:189910] characteristic name:1103 value is:2017-08-24 16:15:50.194 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didDiscoverCharacteristicsForService:error:], line = 2362017-08-24 16:15:50.195 RoadBridgeOnline[1067:189910] characteristic name:00001013-D102-11E1-9B23-00025B00A5A5 value is:2017-08-24 16:15:50.197 RoadBridgeOnline[1067:189910] characteristic name:00001018-D102-11E1-9B23-00025B00A5A5 value is:2017-08-24 16:15:50.198 RoadBridgeOnline[1067:189910] characteristic name:00001014-D102-11E1-9B23-00025B00A5A5 value is:2017-08-24 16:15:50.199 RoadBridgeOnline[1067:189910] characteristic name:00001011-D102-11E1-9B23-00025B00A5A5 value is:2017-08-24 16:15:50.248 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 2482017-08-24 16:15:50.248 RoadBridgeOnline[1067:189910] characteristic name:1102 value is: 特征值订阅／监听水准仪与蓝牙外设的通讯，主要是通过特征值来实现，故此处进行单独介绍。在特征值发现之后，我们可以根据特征值进行过滤，监听特定的特征值，这样，当特征值发生变更的时候，会通过CBPeripheralDelegate协议回调特征值数据。使用蓝牙外设对象 CBPeripheral 的方法 setNotifyValue:forCharacteristic: 来进行监听 12//订阅 - 接受通知 [self.connectedPeripheral setNotifyValue:YES forCharacteristic:characteristics]; 通过协议回调处理特征值。 12345678910111213141516171819202122232425262728293031323334/** * CBPeripheralDelegate协议，当特征值发生变更的时候，回调 **/- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error&#123; NSLog(@&quot;%s, line = %d&quot;, __FUNCTION__, __LINE__); NSString* valueString = [[NSString alloc] initWithData:characteristic.value encoding:NSUTF8StringEncoding]; [self.readValueArray addObject:valueString]; [self postRecievedCharacteristicValue]; NSLog(@&quot;characteristic name:%@ value is:%@&quot;,characteristic.UUID,valueString);// NSLog(@&quot;接收到的数组：\n%@&quot;,self.readValueArray);&#125;/** * 将水准仪返回的数据进行处理，获取关键字段，数据处理成功后，直接发全局Event通知。 * 单点测量 * 水准线路测量 - 后视 * 水准线路测量 - 前视 **/-(void)postRecievedCharacteristicValue&#123; if ([self.readValueArray count] &gt; 0) &#123; NSString * fullString = [self.readValueArray componentsJoinedByString:@&quot;&quot;]; NSLog(@&quot;待处理的特质值为：\n %@ \n&quot;,fullString); NSArray* sepArray = [fullString componentsSeparatedByString:@&quot;|&quot;]; NSMutableDictionary* postDic = [[NSMutableDictionary alloc] init]; //处理字符串数据，将不同数据进行封装，代码略 if ([[postDic allKeys] count] &gt; 0) &#123;//直接全局通知 [[NSNotificationCenter defaultCenter] jk_postNotificationOnMainThreadName:RBBluetoothMeasureUpdateKey object:postDic]; &#125; &#125;&#125; 需要注意的是水准仪蓝牙数据的回传时将字符串进行了分隔。我们需要首先进行数据拼接，之后才能进行数据提取操作，以下是拼接后的字符串及原始字符串： 1234567891011121314151617//以下是拼接后的字符串（水准线路测量 - 前视）For M5|Adr 32|KD1 5-a g 15:49:151 L1|Rf 1.49585 m |HD 9.988 m | | For M5|Adr 33|KD1 5-a g 15:49:15 L1| | |Z -0.43374 m | //以下是回调log信息：For M5|Adr |K2017-08-24 16:18:42.299 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 2482017-08-24 16:18:42.300 RoadBridgeOnline[1067:189910] characteristic name:1102 value is:D1 16 2 16:2017-08-24 16:18:42.327 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 2482017-08-24 16:18:42.328 RoadBridgeOnline[1067:189910] characteristic name:1102 value is:17:37 L41| 2017-08-24 16:18:42.329 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 2482017-08-24 16:18:42.330 RoadBridgeOnline[1067:189910] characteristic name:1102 value is: | 2017-08-24 16:18:42.357 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 2482017-08-24 16:18:42.358 RoadBridgeOnline[1067:189910] characteristic name:1102 value is: |Z 2017-08-24 16:18:42.387 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 2482017-08-24 16:18:42.398 RoadBridgeOnline[1067:189910] characteristic name:1102 value is: 44.98000 m |2017-08-24 16:18:42.477 RoadBridgeOnline[1067:189910] -[BluetoothViewModel peripheral:didUpdateValueForCharacteristic:error:], line = 248 测量数据处理在前台界面相关的 界面控制器 中，使用 NSNotificationCenter 进行监听，对监听到的数据进行相应的业务逻辑处理 123456789101112131415161718192021-(void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(recieveLocalNotification:) name:BluetoothPeripheralUpdateKey object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(recieveLocalNotification:) name:RBBluetoothMeasureUpdateKey object:nil];&#125;-(void)recieveLocalNotification:(NSNotification*)notification&#123; NSString* notificationKeyName = [notification name]; //蓝牙连接状态发生变更 //蓝牙单点测量数据变更通知 if ([notificationKeyName isEqualToString:BluetoothPeripheralUpdateKey]) &#123; [self updateBluetoothConnectionImage]; &#125;else if ([notificationKeyName isEqualToString:RBBluetoothMeasureUpdateKey]) &#123; NSDictionary* measuredDic = notification.object; [self uploadBluetoothMeasureData:measuredDic]; &#125;&#125;-(void)viewWillDisappear:(BOOL)animated&#123; [super viewWillDisappear:animated]; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125; ​]]></content>
      <categories>
        <category>蓝牙</category>
      </categories>
      <tags>
        <tag>Bluetooth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于蓝牙的室内定位]]></title>
    <url>%2F2017%2F08%2F23%2Fbluetooth_location_maximum_likelihood%2F</url>
    <content type="text"><![CDATA[基于Wi-Fi的室内定位，首先采集指纹库，即取多个角度的RSSI值，然后对原始RSSI值进行指纹数据入口。AP扫描硬件设备的RSSI和指纹库数据进行碰撞。来计算出设备的位置。指纹库数据对采集设备的依赖比较大。尤其是目前各手机硬件厂商的蓝牙模块不同的情况下，定位精度影响比较大。 利用蓝牙进行室内定位，由目标设备本身采集周围定位用蓝牙信号，从而在目标设备上进行定位运算，来实现室内定位。 蓝牙定位使用蓝牙定位需要解决的一个问题是定位设备与目标设备的距离问题。我们可以轻松的通过蓝牙扫描来获取定位设备的RSSI值，那么问题的关键就是如何将RSSI值转换成距离了。目前有两种方式来实现： 基于高度定制的蓝牙设备，由其提供距离参数，比如iBeacon技术的EstimoteBeacon 距离可以直接获取 被硬件绑定 基于统一的蓝牙设备的RSSI，自行计算距离 定位用蓝牙设备可以自行选取 距离可以自行通过校正函数进行获取：d = 10((abs(RSSI) - A) / (10 * n)) d - 计算所得距离 RSSI - 接收信号强度（负值） A - 发射端和接收端相隔1米时的信号强度 n - 环境衰减因子 通过RSSI进行距离计算的时候，需要考虑蓝牙设备的校正因子measuredPower 当获取到距离后，可以通过极大似然估算法进行目标设备室内定位计算。可以参照基于二维空间的极大似然估计算法 。 定位数据处理受外界干扰，当扫描到的定位用蓝牙设备RSSI太小(或者距离过大)的时候，我们就可以考虑忽略掉。取有效的参数进行计算。结合设备本身对传感器信息，对定位数据进行展示。 定位数据摘要信息如下： 参照文档​ https://wenku.baidu.com/view/3dba1baef524ccbff12184af.html?re=view​ http://hxqhit.blog.163.com/blog/static/15357922200948112142918/]]></content>
      <categories>
        <category>蓝牙</category>
      </categories>
      <tags>
        <tag>位置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于二维空间的极大似然估计算法]]></title>
    <url>%2F2017%2F08%2F23%2Falgorithm_location_maximum_likelihood%2F</url>
    <content type="text"><![CDATA[基于距离的极大似然估计法利用多个已知节点的位置及节点与目标点位置的距离来计算出目标点的位置。 极大似然估算法极大似然估算法定位原理：假设定位区域目标点，n个已知位置和距离目标点距离的节点，可得到目标点与n个节点之间的距离方程。设节点的坐标为(x1,y1) , (x2,y2) , … , (xn,yn)，目标点坐标 (x,y)，各节点到目标点的距离d1 , d2,…, dn，则可的方程组 ( xi - x )² + (yi -y)² = di² , 其中I∈[1,n]。对方程组进行求解，可得x，y坐标 代码实现用于运算的节点简单二维空间节点对象，主要包含坐标及距离，用于极大似然算法估算。 12345678910111213141516171819/** * 节点对象，包含坐标点和距离属性 **/@interface LikelihoodNode : NSObject@property (nonatomic , assign) CGPoint point;@property (nonatomic , assign) float distance-(id)initWithX:(float)x Y:(CGFloat)y distance:(float)distance;@end@implementation LikelihoodNode-(id)initWithX:(float)x Y:(CGFloat)y distance:(float)distance&#123; self = [super init]; if (self != nil) &#123; self.point = CGPointMake(x, y); self.distance = distance; &#125; return self;&#125;@end 极大似然算法，对已知节点进行计算，得到目标节点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * 极大似然估算，输入多个点数组，计算出目标点坐标 **/@interface MaximumLikelihood : NSObject+ (CGPoint) maximumLikelihoodPointFromArray:(NSArray*)array;@end@implementation MaximumLikelihood+ (CGPoint) maximumLikelihoodPointFromArray:(NSArray*)array&#123; CGPoint retPoint = CGPointZero; if (array.count &gt; 2) &#123;//至少3个点来计算极大似然数 long double segmaDeletaX = 0.0; long double segmaDeletaY = 0.0; long double segmaDeletaX_Y = 0.0; LikelihoodNode* lastNode = [array lastObject]; /** * segma deleta x 2 * segma deleta y 2 * segma deleta x * delta y **/ for (int i = 0; i &lt; array.count - 1; ++i) &#123; LikelihoodNode* node = [array objectAtIndex:i]; long double deltaX = [MaximumLikelihood deltaXiWithNode:node and:lastNode]; long double deltaY = [MaximumLikelihood deltaYiWithNode:node and:lastNode]; segmaDeletaX += pow(deltaX,2); segmaDeletaY += pow(deltaY,2); segmaDeletaX_Y += deltaX * deltaY; &#125; long double preNumber = 0.0; long double temp = segmaDeletaX * segmaDeletaY - pow(segmaDeletaX_Y, 2); if (temp != 0) &#123; preNumber = (2 / temp) / 4; &#125; long double maximumLikehoodX = 0.0; long double maximumLikehoodY = 0.0; for (int i = 0; i &lt; array.count - 1; ++i) &#123; LikelihoodNode* node = [array objectAtIndex:i]; long double deltaX = [MaximumLikelihood deltaXiWithNode:node and:lastNode]; long double deltaY = [MaximumLikelihood deltaYiWithNode:node and:lastNode]; long double fDi = [MaximumLikelihood getFr_xFrom:node and:lastNode]; maximumLikehoodX += (segmaDeletaY * deltaX - segmaDeletaX_Y * deltaY) * fDi; maximumLikehoodY += (segmaDeletaX * deltaY - segmaDeletaX_Y * deltaX) * fDi; &#125; retPoint.x = maximumLikehoodX * preNumber; retPoint.y = maximumLikehoodY * preNumber; &#125; return retPoint;&#125;//deltaX+(long double)deltaXiWithNode:(LikelihoodNode*)node and:(LikelihoodNode*)lastNode&#123; long double ans = 0.0; ans = node.point.x - lastNode.point.x; return ans;&#125;//deltaY+(long double)deltaYiWithNode:(LikelihoodNode*)node and:(LikelihoodNode*)lastNode&#123; long double ans = 0.0; ans = node.point.y - lastNode.point.y; return ans;&#125;//f(di)+(float)getFr_xFrom:(LikelihoodNode*)node and:(LikelihoodNode*)lastNode&#123; double ans = 0.0; ans = (node.point.x * node.point.x) - (lastNode.point.x * lastNode.point.x) + (node.point.y * node.point.y) - (lastNode.point.y * lastNode.point.y) - (node.distance * node.distance) + (lastNode.distance * lastNode.distance); return ans;&#125; 考虑到实际情况下，节点与目标点会随距离的增大导致误差变大，故可以通过节点吸附对目标点坐标进行校正。在参与节点与目标点满足情况的前提下，校正步骤如下： 判断目标点距离最近节点nNode的距离distance 若disatance小于吸附临界值(比如：1m) 根据像素与实际地理米转换关系计算出极大似然估算法节点mNode与nNode的距离distancePointToNearest 若distancePointToNearest不大于distance，则不需要进行校正 否则计算出mNode与nNode位置之间连线与distnace处交点的坐标，即为校正后的坐标 否则不进行吸附校正 12345678910111213141516171819202122232425/** * 校正、吸附算法。 * 假设参与计算的节点按照距目标点距离递增的顺序排列 * 此处仅在计算结果与最近节点距离小于1米的情况下进行校正。 **/+ (CGPoint) maximumLikelihoodPointFromArray:(NSArray*)array mToPxScale:(CGFloat)mToPxScale&#123; CGPoint retPoint = [MaximumLikelihood maximumLikelihoodPointFromArray:array]; //根据像素与米的转换关系，判断若最近的小于1米，且计算坐标在最近区域外时，取交点坐标为最终结果坐标 if (array.count &gt; 2) &#123; LikelihoodNode* nearest = [array firstObject]; if (nearest.distance &lt;= 1.0) &#123; CGFloat xDist = (retPoint.x - nearest.point.x) * mToPxScale; CGFloat yDist = (retPoint.y - nearest.point.y) * mToPxScale; CGFloat distancePointToNearest = sqrt((xDist * xDist) + (yDist * yDist)); if (distancePointToNearest &gt; nearest.distance) &#123; CGFloat λ = nearest.distance / (distancePointToNearest - nearest.distance); CGFloat x = (nearest.point.x + λ * retPoint.x) / (1 + λ); CGFloat y = (nearest.point.y + λ * retPoint.y) / (1 + λ); retPoint = CGPointMake(x, y); &#125; &#125; &#125; return retPoint;&#125; 参考文档https://wenku.baidu.com/view/1db9c08a71fe910ef12df8df.htmlhttps://wenku.baidu.com/view/3dba1baef524ccbff12184af.html?re=viewhttp://www.doc88.com/p-6037723035623.html]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>位置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chmod修改权限]]></title>
    <url>%2F2017%2F08%2F17%2Fos_shell_authority_chmod%2F</url>
    <content type="text"><![CDATA[Unix是多任务、多用户的操作系统，这以为着多个用户可以在同一时间使用同一台计算机。用户拥有文件或目录，则该用户对这个文件或目录的访问权限具有控制权。而用户又属于一个用户组(可以包含一个或多个用户)，用户组成员由文件或目录的所有者授予对文件或目录的访问权限。除了对用户组授权外，文件所有者可以给每个人一些权限。 在Unix系统中，可以通过shell中输入命令 id 来查看身份信息，系统中每个用户的uid是不同的。123liangtongdeiMac:~ liangtong$ iduid=501(liangtong) gid=20(staff) groups=20(staff),701(com.apple.sharepoint.group.1),12(everyone),61(localaccounts),79(_appserverusr),80(admin),81(_appserveradm),98(_lpadmin),33(_appstore),100(_lpoperator),204(_developer),395(com.apple.access_ftp),398(com.apple.access_screensharing),399(com.apple.access_ssh)liangtongdeiMac:~ liangtong$ 文件的读写与执行对于文件的读写与执行，首先通过一下命令查看输出的结果：123456liangtongdeiMac:playground liangtong$ mkdir test_authorityliangtongdeiMac:playground liangtong$ cd test_authority/liangtongdeiMac:test_authority liangtong$ &gt; authority_test.txtliangtongdeiMac:test_authority liangtong$ ls -l authority_test.txt -rw-r--r-- 1 liangtong staff 0 8 16 18:43 authority_test.txtliangtongdeiMac:test_authority liangtong$ 这里创建了一个目录test_authority，并在目录中创建了一个文件authority_test.txt。之后查看文件线索。这里我们主要说前十个字符 -rw-r–r–。 第一个代表的是文件类型。 - 表示普通文件 d 表示目录 其他，比如 l 符号链接、 c 字符设备文件，比如终端机或者调制解调器、 b 块设备文件比如硬盘，CD-ROM盘 剩下的九个字符叫做文件模式，代表文件所有者，文件组所有者，其他人的读、写、执行权限 Owner Group World rwx rwx rwx 当设置文件模式后，r、w、x模式属性对文件和目录产生以下影响： 属性 文件 目录 r 读取文件的内容 允许列出目录内容，前提是目录必须可执行 w 写入文件内容，但不允许重命名或删除 可以在目录下新增、修改、重命名，前提是目录必须可执行 x 允许文件作为程序来执行，前提必须置为可读 允许进入目录，例如 cd xx 以下举几个例子： 文件属性 含义 -rwx—— 普通文件，文件所有者可读可写可执行，其他人无任何权限 -rw——- 普通文件，文件所有者可读可写，其他人无任何权限 -rw-r–r– 普通文件，文件所有者可读可写，文件所有者所在组可读，其他人可读 -rwxr-xr-x 普通文件，文件所有者可读可写可执行，文件所有者所在组可读可执行，其他人可读可执行 drwxrwx— 目录，目录所有者及所有者所在的分组可以访问目录，在目录中新建、修改、删除文件，其他人无权限 drwxr-x— 目录，目录所有者可以访问目录，在目录中新建、修改、删除文件；文件所有者所在分组可以访问目录，其他人无权限 chmod 修改文件模式文件／目录的所有者或者超级管理员可以用 chmod 命令来更改文件或者目录的权限。chmod命令支持两种不同的方式来更改文件模式： 八进制数字表示法 每个八进制数字代表了3个二进制数字。 可以使用命令 chmod 600 authority_test.txt 将文件模式修改为可读可写 十进制 二进制 文件模式 说明 0 000 — 无权限 1 001 –x 执行 2 010 -w- 写 3 011 -wx 写、执行 4 100 r– 读 5 101 r-x 读、执行 6 110 rw- 读、写 7 111 rwx 读、写、执行 符号表示法 由3部分组成。 会影响谁，包括 u 、 g 、 o 、 a 具体操作，包括 + 、 - 、 = 设置的权限，由 r 、 w 、 x 进行组合，例如 x 、 rw 、 rwx 等 影响谁 含义 u “user”的简写，意思是文件或目录的所有者。 g 用户组 o “others”的简写，意思是其他所有的人 a “all”的简写，是”u”, “g”和“o”三者的联合 如果没有指定字符，则假定使用”all” 具体操作 含义 + 加上一个权限 - 删掉一个权限 = 只有指定的权限可用，其它所有的权限被删除 ​以下举几个例子： 符号表示 含义 u+x 为文件所有者添加可执行权限 +x 为文件所有者，用户组，和其他所有人添加可执行权限。 等价于 a+x。 o-rw 除了文件所有者和用户组，删除其他人的读权限和写权限 go=rw 给群组的主人和任意文件拥有者的人读写权限。如果群组的主人或全局之前已经有了执行的权限，他们将被移除。 u+x,go=rw 给文件拥有者执行权限并给组和其他人限定读和执行的权限。多种设定可以用逗号分开。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS蓝牙开发 - Peripheral模式]]></title>
    <url>%2F2017%2F08%2F08%2Fbluetooth_peripheral%2F</url>
    <content type="text"><![CDATA[Peripheral模式周边模式(Peripheral Model)，可以简单理解为设备App作为周边，供其他蓝牙设备连接。区别于中心模式。蓝牙设备不能同时作为周边和中心设备，在某次连接中，只能担当一个角色。 功能集成 作为蓝牙使用者，程序需要请求蓝牙设备授权，在info.plist配置文件中，添加代码:123&lt;/array&gt;&lt;key&gt;NSBluetoothPeripheralUsageDescription&lt;/key&gt;&lt;string&gt;蓝牙设备请求描述，比如：程序需要使用蓝牙进行设备发现&lt;/string&gt; 项目Targets对应的 Build Phases 中，引入 CoreBluetooth.framework ，使用的代码中引入头文件1#import &lt;CoreBluetooth/CoreBluetooth.h&gt; 请求蓝牙服务 使用CBPeripheralManagerDelegate来进行蓝牙服务管理(授权请求)，监听蓝牙状态变化。1234567891011@property (nonatomic, strong) CBPeripheralManagerDelegate *perManager;//对象创建成功后，会请求使用蓝牙，CBPeripheralManagerDelegate协议会回调蓝牙的各个状态_perManager = [[CBPeripheralManager alloc] initWithDelegate:self queue:nil];#pragma mark - CBPeripheralManagerDelegate- (void)peripheralManagerDidUpdateState:(CBPeripheralManager *)peripheral&#123; if (peripheral.state == CBManagerStatePoweredOn) &#123; &#125;&#125; 在蓝牙开启的情况下，可以创建服务、创建特质值等。 带特质值的服务创建 在设备蓝牙开启的情况下，可以建立服务 CBMutableService 和特征值 CBCharacteristic 并通过 CBPeripheralManagerDelegate 的 addService: 方法将带有特征值的服务注册给蓝牙设备。注册成功后，通过 CBPeripheralManagerDelegate 协议将服务返回。12345678910111213141516171819202122232425262728 //创建服务，其中服务关键字UUID换成自己的 CBMutableService * service = [[CBMutableService alloc] initWithType: [CBUUID UUIDWithString:@&quot;service UUID&quot;] primary:YES]; //创建特征值，其中特征值的UUID换成自己的，特征值可以携带value信息（nsdata） CBCharacteristic * characteristic = [[CBMutableCharacteristic alloc] initWithType:[CBUUID UUIDWithString:@&quot;characteristic UUID&quot;] properties:(CBCharacteristicPropertyRead | CBCharacteristicPropertyWrite | CBCharacteristicPropertyNotify) value:[@&quot;characteristic value&quot; dataUsingEncoding:NSUTF8StringEncoding] permissions:CBAttributePermissionsReadable]; //将特征值加入到服务中 service.characteristics = @[characteristic]; //给设备添加服务，注册服务 [_perManager addService:service];#pragma mark - CBPeripheralManagerDelegate//服务注册成功后，会通过以下回调将信息返回- (void)peripheralManager:(CBPeripheralManager *)peripheral didAddService:(CBService *)service error:(NSError *)error&#123; //对于注册成功的服务，蓝牙设备可以直接进行广播 //开启广播，此处我们广播刚才注册的服务，UUID是：service uuid [_perManager startAdvertising: @&#123;CBAdvertisementDataServiceUUIDsKey:[CBUUID UUIDWithString:@&quot;service UUID&quot;]&#125;]; &#125; 注：一个服务可以携带多个特征值，一个蓝牙周边设备可以注册多个服务。 开启广播 通过CBPeripheralManager的 startAdvertising: 方法开启广播，成功后通过CBPeripheralManagerDelegate协议回调。1234567 //开启广播 [_perManager startAdvertising:@&#123;CBAdvertisementDataServiceUUIDsKey:[CBUUID UUIDWithString:@&quot;service UUID&quot;]&#125;]; //开启广播的回调- (void)peripheralManagerDidStartAdvertising:(CBPeripheralManager *)peripheral error:(NSError *)error &#123;&#125; 数据读写当外设蓝牙设备收到ATT特征值请求时，协议 CBPeripheralManagerDelegate 的方法会被触发。参照协议描述，在处理数据读／写操作的协议回调方法中，必须执行方法 respondToRequest:withResult: 123456789101112131415161718// 读数据请求- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveReadRequest:(CBATTRequest *)request &#123; //请求的响应 NSData *data = request.characteristic.value; //蓝牙中心设备想读取的数据 [request setValue:data];// 读取的值 [_perManager respondToRequest:request withResult:CBATTErrorSuccess];&#125;//写数据请求- (void)peripheralManager:(CBPeripheralManager *)peripheral didReceiveWriteRequests:(NSArray&lt;CBATTRequest *&gt; *)requests &#123; //请求的响应 //需要转换成CBMutableCharacteristic对象才能进行写值 for (CBATTRequest* request in requests) &#123; CBMutableCharacteristic *c =(CBMutableCharacteristic *)request.characteristic; c.value = request.value; [_perManager respondToRequest:[requests firstObject] withResult:CBATTErrorSuccess]; &#125;&#125; ​ 特征值订阅当蓝牙中心设备在进行蓝牙设备服务的特征发现时，若将特征值配置包含被通知 CBCharacteristicPropertyNotify ， 则协议中的以下回调会被调用。 1234567891011121314151617181920//订阅characteristics-(void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didSubscribeToCharacteristic:(CBCharacteristic *)characteristic&#123; NSLog(@&quot;订阅了 %@的数据&quot;,characteristic.UUID); //每秒执行一次给主设备发送一个当前时间的秒数 _timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(sendData:) userInfo:characteristic repeats:YES];&#125;//如果不设置订阅的设备，则代表全部。-(void)sendData:(NSTimer *)t &#123; CBMutableCharacteristic *characteristic = t.userInfo; [_perManager updateValue:[@&quot;Subscribe To Characteristic Value Send &quot; dataUsingEncoding:NSUTF8StringEncoding] forCharacteristic:characteristic onSubscribedCentrals:nil];&#125;//取消订阅characteristics-(void)peripheralManager:(CBPeripheralManager *)peripheral central:(CBCentral *)central didUnsubscribeFromCharacteristic:(CBCharacteristic *)characteristic&#123; NSLog(@&quot;取消订阅 %@的数据&quot;,characteristic.UUID); //取消回应 [_timer invalidate];&#125;]]></content>
      <categories>
        <category>蓝牙</category>
      </categories>
      <tags>
        <tag>Bluetooth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下使用Jekyll搭建GitHub博客]]></title>
    <url>%2F2017%2F08%2F07%2Fshare_github_blog_jekyll%2F</url>
    <content type="text"><![CDATA[Jekyll是一个静态网站和博客模版，本文介绍如何使用Jekyll进行个人GitHub博客的搭建。搭建前提是拥有个人Github账号，且Mac上有安装 git 工具。 安装Jekyll 参照Jekyll官方介绍，打开终端，通过以下命令安装：1$ gem install jekyll bundler 注：gem的安装／更新可以自己去查，此处不再进行说明。Jekyll安装成功后，便可以进行个人博客／静态网站的创建了。 快速使用博客通过在终端输入以下命令执行初始化123$ jekyll new my_blog$ cd my_blog$ bundle exec jekyll serve 参照官方模版配置介绍,修改Jekyll配置文件_config.yml，如果没有特殊要求，建议直接GitHub找现成的博客模板即可。 快速使用博客 此处选择使用博客模板jekyll-now，使用Github直接fork到自己的博客仓库中，然后将代码下载到本地。新建博客静态文件，格式:yyyy-MM-dd-articlename.md，使用markdown语法对编写博客内容。编写之后，直接在博客路径下，运行即可：1$ jekyll serve 推荐博客 使用Jekyll搭建博客也可以添加很多自定制功能，比如统计、评论、标签等；可以根据自己的喜好，选择不同的主题。以下是个人曾经使用过的主题： Hux Blog 第一个GitHub博客系统就是从他的博客fork过去的。 Clean Blog 简单的Jekyll博客模板。 Jekyll在GitHub上的维护直接将博客源码上传到GitHub博客仓库即可。 其他通过在GitHub上搭建Jekyll和Hexo博客，个人更倾向于使用Hexo博客。 Jekyll 配置简单。 维护简单，只需要一个Branch即可。 使用简单，运行只需要 jekyll server 即可。 发布简单，只需要将代码push到对应仓库即可。 主题切换，比较麻烦。 Hexo 配置项相对较多，但是格式比较清晰。 博客和源码需要分开维护。需要两个Branch对博客系统进行维护。 使用相对简单。 hexo clean // 清理 hexo g // 生成 hexo s // 运行 发布简单。 hexo d // 将博客部署(到github) 将博客源码push到对应仓库单独保存 主题切换简单。 下载新主题到themes文件夹下； 修改站点配置文件_config.yml中对应的主题选项。]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下使用Hexo搭建GitHub博客]]></title>
    <url>%2F2017%2F08%2F04%2Fshare_github_blog_hexo%2F</url>
    <content type="text"><![CDATA[创建GitHub账号 注册Github账号，建立个人博客仓库(Repository)，不在赘述。 安装Git工具 终端直接执行 git 命令，或者通过安装GitHub客户端。 安装Node和NPM 打开终端，通过以下命令安装：1$ brew install node 安装Hexo 可以参照Hexo在Github上的官方介绍，在终端依次执行以下命令进行： $ npm install hexo-cli -g 安装成功后，可以通过以下命令进行查看 $ hexo 快速使用博客通过在终端输入以下命令执行初始化 $ hexo init blog_name $ cd blog_name 修改Hexo配置文件_config.yml # Site title: liangtong subtitle: description: Keep hungry keep foolish！ author: liangtong language: zh-Hans timezone: 通过在终端输入以下命令新建博客文章 $ hexo new "Hello Hexo" 通过在终端输入以下命令生成静态文件 $ hexo generate 通过在终端输入以下命令启动服务 $ hexo server 更换Hexo主题这里使用GitHub上排名最靠前的主题NexT，在终端输入以下命令进行主题下载： $ cd blog_name $ git clone https://github.com/iissnan/hexo-theme-next themes/next 参照NexT官方指导网站，对博客进行个性化配置，常用设置包括： 主题设定 标签 分类 侧边栏 打赏 友情链接 动画效果 评论分享 配置Hexo部署在Hexo配置文件中完善部署信息，即你的Github个人博客地址信息： # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: https://github.com/l900416/l900416.github.io.git branch: master 发布Hexo网站到GitHub通过终端输入以下命令将Hexo博客发布到Github上： $ hexo g 此步骤如果出现错误 Deployer not found: git ： 检查Hexo配置的部署文件 终端输入命令： npm install hexo-deployer-git –save Hexo在GitHub上的维护说下本人的做法，创建新的Branch，命名为hexo，用于存放博客源码，master用于个人博客。这样使用一个仓库来维护。 Hexo与Jekyll不同之处 Hexo博客文件需要单独维护。对应GitHub仓库中的文件是通过Hexo部署进去的。 Jekyll博客文件直接上传到GitHub博客仓库中即可。]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS蓝牙开发 - Central模式]]></title>
    <url>%2F2017%2F07%2F27%2Fbluetooth_central%2F</url>
    <content type="text"><![CDATA[Central模式中心模式(Central Model)，可以简单理解为设备App作为中心，连接其他蓝牙外设设备。区别于外设模式，官方介绍可自行Google。这里主要介绍iOS上蓝牙设备作为中心模式的集成。 功能集成 作为蓝牙使用者，程序需要请求蓝牙设备授权，在info.plist配置文件中，添加代码:123&lt;/array&gt;&lt;key&gt;NSBluetoothPeripheralUsageDescription&lt;/key&gt;&lt;string&gt;蓝牙设备请求描述，比如：程序需要使用蓝牙进行设备发现&lt;/string&gt; 项目Targets对应的 BuildPhases 中，引入 CoreBluetooth.framework ，使用的代码中引入头文件1#import &lt;CoreBluetooth/CoreBluetooth.h&gt; 请求蓝牙服务 使用CBCentralManager来进行蓝牙服务管理(授权请求)，监听蓝牙状态变化。123456789101112131415161718192021222324252627282930313233343536@property (nonatomic, strong) CBCentralManager *cMgr;//对象创建成功后，会请求使用蓝牙，CBCentralManagerDelegate协议会回调蓝牙的各个状态_cMgr = [[CBCentralManager alloc] initWithDelegate:self queue:nil];#pragma mark - CBCentralManagerDelegate- (void)centralManagerDidUpdateState:(CBCentralManager *)central&#123; switch (central.state) &#123; case 0: NSLog(@"CBCentralManagerStateUnknown"); break; case 1: NSLog(@"CBCentralManagerStateResetting"); break; case 2: NSLog(@"CBCentralManagerStateUnsupported");//不支持蓝牙 break; case 3: NSLog(@"CBCentralManagerStateUnauthorized"); break; case 4: NSLog(@"CBCentralManagerStatePoweredOff");//蓝牙未开启 break; case 5: &#123; NSLog(@"CBCentralManagerStatePoweredOn");//蓝牙已开启 // 在中心管理者成功开启后再进行一些操作 // 搜索外设， 搜索成功之后,会调用我们找到外设的代理方法 [self.cMgr scanForPeripheralsWithServices:nil // 通过某些服务筛选外设 options:nil]; // dict,条件 &#125; break; default: break; &#125;&#125; 设备(外设)搜索 在设备蓝牙开启的情况下，通过 CBCentralManager 的 scanForPeripheralsWithServices:options: 方法来搜索蓝牙外设，搜索成功后通过CBCentralManagerDelegate协议回调将外设返回。123456789101112131415 //可以通过服务和选项进行蓝牙外设的过滤 [self.cMgr scanForPeripheralsWithServices:nil options:nil]#pragma mark - CBCentralManagerDelegate//CBCentralManagerDelegate协议对应发现外设，协议回调函数附带外设携带的数据advertisementData和外设的信号强度RSSI- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary&lt;NSString *, id&gt; *)advertisementData RSSI:(NSNumber *)RSSI&#123; //此处我们可以将外设设备组织成列表展示出来，以便用户根据实际情况进行特定外设的连接。 if (![self.self.peripheralList containsObject:peripheral]) &#123; [self.peripheralList addObject:item]; [[NSNotificationCenter defaultCenter] jk_postNotificationOnMainThreadName:BluetoothPeripheralUpdateKey object:nil userInfo:nil]; &#125; //也可以根据信号强度、外设名称或者携带信息，直接过滤并通过CBCentralManager进行连接 //[self.cMgr connectPeripheral:self.peripheral options:nil];&#125; 设备连接 通过CBCentralManager的 connectPeripheral:options: 方法进行外设的连接，连接成功后通过CBCentralManagerDelegate协议回调将外设返回。123456789101112131415161718 //外设的连接 [self.cMgr connectPeripheral:self.peripheral options:nil]; //中心管理者连接外设成功,协议回调返回- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral&#123; //设置外设代理 peripheral.delegate = self;&#125;``` 此处需要注意的是，蓝牙连接受环境及设备的影响，经常会遇到连接断开的情况。此时可以通过在断开连接的协议回调中重新连接外设即可，此时连接时间非常快。 ```Objective-C// 丢失连接- (void)centralManager:(CBCentralManager *)central didDisconnectPeripheral:(CBPeripheral *)peripheral error:(NSError *)error&#123; NSLog(@&quot;%s, line = %d, %@=断开连接&quot;, __FUNCTION__, __LINE__, peripheral.name); if (self.connectedPeripheral) &#123; [self.cMgr connectPeripheral:self.peripheral options:nil]; &#125;&#125; 通常情况下，我们在外设连接成功的回调中，设置外设回调相关协议代理CBPeripheralDelegate，以便后续的服务发现等操作。 服务发现 在蓝牙外设连接成功的情况下，我们通过外设的 discoverServices: 方法进行外设服务的发现，发现成功后，通过外设协议CBPeripheralDelegate回调外设提供的服务信息。 //外设服务发现 [self.peripheral discoverServices:nil]; //外设服务回调 - (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(nullable NSError *)error{ // NSLog(@&quot;%s, line = %d&quot;, __FUNCTION__, __LINE__); for (CBService *s in peripheral.services) { NSLog(@&quot; -- 发现服务 -- :%@&quot;, s); [self.connectedPeripheral discoverCharacteristics:nil forService:s]; } } 通常情况下，我们会对发现的服务进行过滤，查找有用的服务，并查阅其特征值。以上代码读取的所有服务的特征值。 特征值发现 外设服务发现的前提下，通过外设的方法 discoverCharacteristics:forService: 来进行服务特征值的发现。通过外设协议CBPeripheralDelegate回调服务携带的特征值信息。 //特征值发现 [self.peripheral discoverCharacteristics:nil forService:s]; //特征值发现回调 - (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(nullable NSError *)error{ NSLog(@&quot;%s, line = %d&quot;, __FUNCTION__, __LINE__); for (CBCharacteristic *characteristics in service.characteristics) { //NSLog(@&quot;%s, line = %d, char = %@&quot;, __FUNCTION__, __LINE__, cha); NSLog(@&quot;characteristic name:%@ value is:%@&quot;,characteristics.UUID,characteristics.value); [self.peripheral readValueForCharacteristic:characteristics];//读取特征值 [self.peripheral discoverDescriptorsForCharacteristic:characteristics];//发现特征值所携带的描述信息 } } 发现外设特征值后，我们便可以读取特征值及发现特征值所携带的描述信息了 读取特征值 发现特征值后，通过外设的方法 readValueForCharacteristic: 读取特征值。通过外设协议CBPeripheralDelegate回调服务携带的特征值信息。 //特征值读取 [self.peripheral readValueForCharacteristic:characteristics]; //特征值更新回调 - (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error{ NSLog(@&quot;%s, line = %d&quot;, __FUNCTION__, __LINE__); //特征值更新 } 特征值携带的UUID、value信息可以直接读取，若特征值发生更新，则通过协议回调进行读取。 读取描述发现特征值后，通过外设的方法 *discoverDescriptorsForCharacteristic:* 读取特征值的描述信息。通过外设协议CBPeripheralDelegate回调服务携带的特征值信息。 当特征值发生变更的时候，若想要监听，则需要调用蓝牙外设的方法 *- (void)setNotifyValue:(BOOL)enabled forCharacteristic:(CBCharacteristic *)characteristic* //特征值描述字段读取 [self.peripheral discoverDescriptorsForCharacteristic:characteristics]; //特征值变更通知 [self.peripheral setNotifyValue:YES forCharacteristic:characteristics];//接受通知 //特征值描述更新回调 - (void)peripheral:(CBPeripheral *)peripheral didDiscoverDescriptorsForCharacteristic:(CBCharacteristic *)characteristic error:(nullable NSError *)error{ NSLog(@&quot;===characteristic name:%@&quot;,characteristic.service.UUID); for (CBDescriptor *d in characteristic.descriptors) { NSLog(@&quot;CBDescriptor name is :%@&quot;,d.UUID); [self.peripheral readValueForDescriptor:d]; } } - (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForDescriptor:(CBDescriptor *)descriptor error:(nullable NSError *)error{ NSLog(@&quot;Descriptor name:%@ value is:%@&quot;,descriptor.characteristic.UUID, descriptor.value); } 可读取描述的UUID和value等信息。 其他​]]></content>
      <categories>
        <category>蓝牙</category>
      </categories>
      <tags>
        <tag>Bluetooth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件的查看]]></title>
    <url>%2F2017%2F06%2F19%2FiOS_ObjC_file_preview%2F</url>
    <content type="text"><![CDATA[前言对于特定格式（比如DWG等）文件的预览，没有必要耗费代价去自行开发功能，此时可能需要使用第三方应用来打开特定格式的文件。本文中记录三种方式：UIDocumentInteractionController、UIActivityViewController和特定第三方分享方式。 UIDocumentInteractionController界面表现上和AirDrop长得很像，这个也可以进行AirDrop蓝牙分享很强大的功能，与之不同的是，在与文件类型关联的备选APP列表中，会有类似 [拷贝至 微信] 应用的选择，如下： 创建对象1234567891011//引用@property (nonatomic, strong) UIDocumentInteractionController* docInteractionController;//初始化及动作定义NSURL* filePath = xxx;//文件路径_docInteractionController = [UIDocumentInteractionController interactionControllerWithURL:filePath];_docInteractionController.delegate = self;[_docInteractionController presentOpenInMenuFromRect:CGRectZero inView:self.view animated:YES]; 实现常用协议123456789101112#pragma mark - UIDocumentInteractionControllerDelegate-(void)documentInteractionController:(UIDocumentInteractionController *)controller willBeginSendingToApplication:(NSString *)application &#123;//将要发送的应用&#125;//下面是他的代理方法-(void)documentInteractionController:(UIDocumentInteractionController *)controller didEndSendingToApplication:(NSString *)application&#123;//已经发送的应用&#125;-(void)documentInteractionControllerDidDismissOpenInMenu:(UIDocumentInteractionController *)controller&#123;//dismiss&#125; UIActivityViewController与UIDocumentInteractionController不同的是，UIActivityViewController无类似 [拷贝至 微信] 应用的选择。其界面和备选应用等可自行定制(屏蔽)，如下： NSURL* fileURL = [NSURL URLWithString:@&quot;http://xxx.dwg&quot;]; //注：activityItems可以是包含文字、图片、URL地址的数组，至少包含一项；applicationActivities参数可以对平台进行自定义 UIActivityViewController *activity = [[UIActivityViewController alloc] initWithActivityItems:@[_fileURL] applicationActivities:nil]; activity.excludedActivityTypes = @[UIActivityTypeAirDrop];//可用于屏蔽掉的应用列表，参照UIActivityType UIPopoverPresentationController *popover = activity.popoverPresentationController; if (popover) { popover.sourceView = self.shareBtn; popover.permittedArrowDirections = UIPopoverArrowDirectionUp; } [self presentViewController:activity animated:YES completion:nil]; 分享第三方平台比如微信、新浪微博等平台的分享，集成其提供的SDK即可。此处不再赘述。若需要多分享平台集成，建议使用第三方平台比如友盟、ShareSDK等]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基数排序]]></title>
    <url>%2F2017%2F06%2F13%2Falgorithm_sort_radix%2F</url>
    <content type="text"><![CDATA[​ 基数排序（radix sort）属于“分配式排序”（distribution sort），基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。参照斯坦福大学算法公开课视频 基本思想及实现基本思想： 对于一个整型数组： ① 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。 ② 排序算法使用计数排序思想 使用Swift编写简单的代码实现，如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/*** 基数排序* 分布式排序算法* 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。* 基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。* 排序使用 - 计数排序**//**** @brief 基数排序 - LSD* @param sortArray 待排序整形数组* @param loop 排序轮次* @param step 步长***/func radixSort(sortArray:inout Array&lt;Int&gt;, loop:Int,step:Int)&#123; let length = sortArray.count;//待排序数组长度 /** * 根据最高位和最低位，确定每次进行计数排序的中间位数 **/ var msb = 1;//最高位 var minimum = 1;//最低位 for _ in 0 ..&lt; loop * step &#123; msb = msb * 10; &#125; for _ in 0 ..&lt; step &#123; minimum = minimum * 10; &#125; /** * 计数排序 - 非基于比较的排序算法 。 可参照上一篇文章 */ var countArray = Array&lt;Int&gt;(); var buckets = Array&lt;Int&gt;() for _ in 0 ... minimum &#123; countArray.append(0); &#125; for _ in 0 ..&lt; length&#123; buckets.append(0); &#125; //第一个步骤：统计数量 for i in 0 ..&lt; length &#123;//统计小于位置i的元素个数 let sortValue = sortArray[i] / msb % minimum; countArray[sortValue] = countArray[sortValue] + 1; &#125; for i in 1 ... minimum &#123;//统计出小于等于位置i的元素个数 countArray[i] = countArray[i] + countArray[i - 1]; &#125; //第二个步骤：逆向扫描数组sortArray，将i位置元素放置到retArray中countArray对应值的位置上，同时修正countArray的值 for i in (0 ..&lt; length).reversed() &#123; let value = sortArray[i] / msb % minimum; let countValue = countArray[value]; buckets[countValue - 1] = sortArray[i]; countArray[value] = countArray[value] - 1; &#125; //对本次基数排序结果进行排序 for i in 0 ..&lt; length &#123; sortArray[i] = buckets[i]; &#125;&#125; 测试用例及结果123456789101112131415161718192021222324252627282930313233343536 var intArray = [14, 22, 28, 39, 43, 81, 93, 100, 92, 96, 99, 95, 10563, 55, 7, 65, 73, 999, 1024, 20490, 1]; var maxValue = 0; var maxLength = 1; var step = 2; var loopTimes = 0; for i in 0 ..&lt; intArray.count&#123; if intArray[i] &gt; maxValue&#123; maxValue = intArray[i]; &#125; &#125; while(maxValue / 10 != 0)&#123; maxLength = maxLength + 1; maxValue = maxValue / 10; &#125; if maxLength % step &gt; 0&#123; loopTimes = 1; &#125; loopTimes = loopTimes + maxLength / step; print("待排序数组\(intArray)"); print("步长：\(step)"); for i in 0 ..&lt; loopTimes&#123; radixSort(sortArray: &amp;intArray, loop: i, step: step); print("第\(i)次基数排序后结果：\(intArray)"); &#125;//程序输出待排序数组[14, 22, 28, 39, 43, 81, 93, 100, 92, 96, 99, 95, 10563, 55, 7, 65, 73, 999, 1024, 20490, 1]步长：2第0次基数排序后结果：[100, 1, 7, 14, 22, 1024, 28, 39, 43, 55, 10563, 65, 73, 81, 20490, 92, 93, 95, 96, 99, 999]第1次基数排序后结果：[1, 7, 14, 22, 28, 39, 43, 55, 65, 73, 81, 92, 93, 95, 96, 99, 100, 20490, 10563, 999, 1024]第2次基数排序后结果：[1, 7, 14, 22, 28, 39, 43, 55, 65, 73, 81, 92, 93, 95, 96, 99, 100, 999, 1024, 10563, 20490]]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LTxMenu]]></title>
    <url>%2F2017%2F05%2F19%2FiOS_ObjC_LTxMenu_v2.0.0%2F</url>
    <content type="text"><![CDATA[[ Update v2.0.0 ] Similar to Facebook News Feed , Alipay Life , QZone and other social applications . click a drop-down button to display more functions Introduction​ In Facebook News Feed , Alipay Life , QZone and other social applications , they all contain a function drop-down button which would show a list of more functions when taped . I didn’t find any on GitHub , so I wrote a similar UI controls myself using Objective-C. ： GitHub link : LTxMenu Get Start Manually add the files into your Xcode project. LTxMenu is available as LTxMenu in Cocoapods. How To Use​ Create a LTxMenuView Object: 1234567891011121314/*** class instance method with dataSource and delegate. you can also create with [[LTxMenuView alloc] init] then set the dataSource and the delegate.**/+ (instancetype)instanceWithDataSource:(id &lt;LTxMenuViewDataSource&gt;)dataSource delegate:(id &lt;LTxMenuViewDelegate&gt;)delegate;/*** show menuView in viewController from a special position.* @param viewController the menuview &apos;s container* @param position the menuview &apos;s arrow direction**/- (void)showMenu:(UIViewController*)viewController from:(CGRect)position;/*** hide the menuview. usually you did not need to call this method**/- (void)dismissMenu; ​ DataSource &amp;&amp; Delegate 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#pragma mark LTxMenuViewDelegate@protocol LTxMenuViewDelegate&lt;NSObject&gt;@optional/*** called when a specified index was selected.**/-(void)didSelectRowAtIndex:(NSInteger)index;/*** called when a specified accessoryView was selected.**/-(void)didSelectAccessoryView:(UIView*)accessoryViewatIndex:(NSInteger)index;@end#pragma mark LTxMenuViewDataSource@protocol LTxMenuViewDataSource&lt;NSObject&gt;@required/*** Returns the number of rows**/- (NSInteger)numberOfRows;@optional/*** Returns the height of specified index. default value is 50.**/- (CGFloat)heightForRowAtIndex:(NSInteger)index;/*** Returns the attributedTitle of specified index.**/- (NSAttributedString*)attributedTitleForRowAtIndex:(NSInteger)index;/*** Returns the image of specified index.**/- (UIImage*)imageForRowAtIndex:(NSInteger)index;/*** Returns the accessoryViews placed at the end of specified index.**/- (NSArray&lt;UIView*&gt;*)accessoryViewsAtIndex:(NSInteger)index;@end; How it works​ LTxMenu use LTxMenuItem class to config view showed in row. and LTxMenuView class with callback methods to calculate the UI performance . draw arrow and the border use UIBezierPath class . and the show/hide animation use UIKit. Reference​ https://github.com/kolyvan/kxmenu]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Menu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计数排序]]></title>
    <url>%2F2017%2F05%2F18%2Falgorithm_sort_count%2F</url>
    <content type="text"><![CDATA[​ 计数排序是一个非基于比较的整数排序算法，用空间换时间，优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围）。 基本思想及实现基本思想： 假设输入的线性表L的长度为n，L=L1,L2,..,Ln；线性表的元素属于有限偏序集S，|S|=k且k=O(n)，S={S1,S2,..Sk}；则计数排序可以描述如下： ① 扫描整个集合S，对每一个Si∈S，找到在线性表L中小于等于Si的元素的个数T(Si)； ② 扫描整个线性表L，对L中的每一个元素Li，将Li放在输出线性表的第T(Li)个位置上，并将T(Li)减1。 使用Swift编写简单的代码实现，如下：123456789101112131415161718192021222324252627282930313233343536/*** 计数排序* 计数排序是一个非基于比较的排序算法，优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。当然这是一种牺牲空间换取时间的做法，而且当O(k)&gt;O(n*log(n))的时候其效率反而不如基于比较的排序。* ① 扫描整个集合S，对每一个Si∈S，找到在线性表L中小于等于Si的元素的个数T(Si)；* ② 扫描整个线性表L，对L中的每一个元素Li，将Li放在输出线性表的第T(Li)个位置上，并将T(Li)减1。**/func countSort(sortArray:inout Array&lt;Int&gt;, maxValue:Int) -&gt; Array&lt;Int&gt;&#123;let count = sortArray.count;var retArray = Array&lt;Int&gt;();//用于存放返回值if count &gt; 0 &#123;var countArray = Array&lt;Int&gt;();//用于存放计数器for _ in 0 ... maxValue &#123;//初始化计数器countArray.append(0);&#125;for _ in 0 ..&lt; count &#123;retArray.append(0);&#125;//第一个步骤：统计数量for i in 0 ..&lt; count &#123;//统计小于位置i的元素个数countArray[sortArray[i]] = countArray[sortArray[i]] + 1;&#125;for i in 1 ... maxValue &#123;//统计出小于等于位置i的元素个数countArray[i] = countArray[i] + countArray[i-1];&#125;//第二个步骤：逆向扫描数组sortArray，将i位置元素放置到retArray中countArray对应值的位置上，同时修正countArray的值for i in (0 ..&lt; count).reversed() &#123;let value = sortArray[i];let countValue = countArray[value];retArray[countValue - 1] = value;countArray[value] = countArray[value] - 1;&#125;&#125;return retArray;&#125; 测试用例及结果12345678910var intArray = [2, 5, 3, 0, 2, 3, 0, 3];print(countSort(sortArray: &amp;intArray,maxValue:5));intArray = [100,93,97,92,96,99,92,89,93,97,90,94,92,95];print(countSort(sortArray: &amp;intArray,maxValue:100));//程序输出[0, 0, 2, 2, 3, 3, 3, 5][89, 90, 92, 92, 92, 93, 93, 94, 95, 96, 97, 97, 99, 100]]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2017%2F05%2F11%2Falgorithm_sort_quick%2F</url>
    <content type="text"><![CDATA[​ 快速排序是采用分治法（Divide and Conquer）的应用。和归并排序不同的是，她不需要额外的存储空间，时间复杂度： T(n) = Θ(nlgn)，最坏情况下是：T(n) = Θ(n²)。 基本原理及实现基本原理： 使用递归、分治的思想，每次调用排序方法，随机选取一个key值，结果保证：key值所在数组中的位置，且能保证key左侧位置的数据总小于key值；右侧位置数据总大于key值 ① 当数组为空时，数组不需要排序，算法结束。 ② 选取一个key值，可以是带排序数组中任意位置的元素，这里选第一个元素。 ③ 遍历数组(角标j)，将所有比key值小的元素移动到数组前边(角标i)。遍历结束时，i即是中间位置。 ④ 将key值与角标i位置元素位置互换。 ⑤ 递归对i位置左侧、右侧数组进行快速排序。 使用Swift编写简单的代码实现，如下：123456789101112131415161718192021222324252627282930313233343536373839/*** 快速排序* 使用递归、分治的思想，每次调用排序方法，选取一个key值，结果保证：key值所在数组中的位置，且能保证key左侧位置的数据总小于key值；右侧位置数据总大于key值* ① 当数组为空时，数组不需要排序，算法结束。* ② 选取一个key值，可以是带排序数组中任意位置的元素，这里选第一个元素。* ③ 遍历数组(角标j)，将所有比key值小的元素移动到数组前边(角标i)。遍历结束时，i即是中间位置。* ④ 将key值与角标i位置元素位置互换。* ⑤ 递归对i位置左侧、右侧数组进行快速排序。**/func quickSort&lt;T:Comparable&gt;(array:inout Array&lt;T&gt;, start:Int, end:Int)&#123;if end &lt;= start &#123;return;&#125;let key = array[start];//随机选取key值 - 这里我们固定选择第一个元素var i = start;var j = i + 1;while j &lt;= end &#123;//从key后开始遍历，查找所有比key小的元素，移动到数组前边let aj = array[j];if key &gt; aj &#123;//交换元素let tempValue = array[i+1];array[i+1] = aj;array[j] = tempValue;//重新设置角标i += 1;&#125;j += 1;//数组遍历&#125;//i位置即是最后一个比key值小的元素位置，然后交换key值和i位置元素let ai = array[i];array[i] = key;array[start] = ai;print("sorting：key：\(key) values: \(array[start...end])");//对i位置左侧、右侧的数组进行排序方法调用quickSort(array: &amp;array, start: start, end: i - 1)quickSort(array: &amp;array, start: i+1, end: end);&#125; 测试用例及结果1234567891011121314151617181920212223242526272829var intArray = [6,10,13,5,8,3,2,11];quickSort(array: &amp;intArray,start:0,end:intArray.count-1);print("排序结束：\(intArray)");//程序输出sorting：key：6 values: [2, 5, 3, 6, 8, 13, 10, 11]sorting：key：2 values: [2, 5, 3]sorting：key：5 values: [3, 5]sorting：key：8 values: [8, 13, 10, 11]sorting：key：13 values: [11, 10, 13]sorting：key：11 values: [10, 11]排序结束：[2, 3, 5, 6, 8, 10, 11, 13]var stringArray = ["Java","C#","Python","Objective-C","Swift","PHP","BASIC","Pasical","Assembly"];quickSort(array: &amp;stringArray,start:0,end:stringArray.count-1);print("排序结束：\(stringArray)");//程序输出sorting：key：Java values: ["Assembly", "C#", "BASIC", "Java", "Swift", "PHP", "Python", "Pasical", "Objective-C"]sorting：key：Assembly values: ["Assembly", "C#", "BASIC"]sorting：key：C# values: ["BASIC", "C#"]sorting：key：Swift values: ["Objective-C", "PHP", "Python", "Pasical", "Swift"]sorting：key：Objective-C values: ["Objective-C", "PHP", "Python", "Pasical"]sorting：key：PHP values: ["PHP", "Python", "Pasical"]sorting：key：Python values: ["Pasical", "Python"]排序结束：["Assembly", "BASIC", "C#", "Java", "Objective-C", "PHP", "Pasical", "Python", "Swift"]]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FMDB]]></title>
    <url>%2F2017%2F04%2F27%2Fdatabase_sqlite3_fmdb%2F</url>
    <content type="text"><![CDATA[​ SQLite是一款轻型的数据库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。它使用B+树存储表，整个SQLite数据库就是这些B+树组成的森林。。它的设计目标是嵌入式的，目前被广泛应用。 FMDB 是基于SQLite的实现 。 数据库（连接）数据库在使用前均需要建立连接，FMDB提供了两种方式对应数据库文件’通常xx.db’路径建立连接。FMDatabase是一个单一的用来执行SQL语句的数据库连接，使用同步的方式进行，如果需要在多线程执行查询或者更新，则需要使用FMDatabaseQueue FMDatabaseFMDatabase可以用来执行增、删、改、查相关的SQL语句，通常情况下，不会有什么问题。这里需要说明的一点是移动端在涉及到多线程操作时，不要使用单例模式建立一个FMDatabase对象，否则会发生死锁问题。其官方文档中也有给出警告: Do not instantiate a single FMDatabase object and use it across multiple threads. FMDatabaseQueueFMDatabaseQueue的方法调用时异步的，通常在多线程中使用。即使在不同的闭包中使用，也是在发送在同一个线程中。 表结构操作SQLite对于每个表的元数据(表名、根节点地址、表scheme等)信息均记录在一个叫’sql_master’的表中。常见的表结构变更包括创建、修改、删除，这些信息的变更均会影响’sql_master’表。 创建表的创建跟通常sql语句区别不大，通常在表创建时设置主键、默认值等。使用语法如下：1234CREATE TABLE IF NOT EXISTS RecordSign(recordId text NOT NULL PRIMARY KEY, projectName TEXT, visibleState INTEGER DEFAULT 0 , lastTriggerTime text DEFAULT '2017-03-13 23:59:59') 查询判断某个表是否存在，语法如下：1select * from sqlite_master where type = 'table' and name = '表名' 判断某个表中是否存在某列，语法如下（通过判断sql语句中是否包含列名）：1select * from sqlite_master where type = 'table' and name = '表名' and sql like %列表% 删除表的删除，使用drop语句：1DROP TABLE '表名' 表内容操作多表联合操作使用关键字：join，或者in(如果不需要跨表取字段的话)，比如：123NSString* filterBusinessIDSql = [NSString stringWithFormat:@"select businessID from BeaconRelatedPolicyAndBusiness where isValid = 1 and policyID in ('%@')", [minPriorityPolicyIDArray componentsJoinedByString:@"','"]]; NSString* retSql = [NSString stringWithFormat:@"select * from BeaconBusinessMsg where businessID in (%@) and isValid = 1 order by priority asc",filterBusinessIDSql]; 插入支持使用insert 或 insert or replace 或 insert or ignore 等语法1234[dbms executeUpdate:@"insert OR IGNORE into RecordSign (recordId, projectName,visibleState) values (?, ?, 1)", recordId, projectName ]; 更新使用update语句进行表结构的更新，如下：1234[dbms executeUpdate:@"update RecordSign set projectName = ? , visibleState = 1 where recordId = ? ", projectName, recordId ]; 查询使用 select 关键字进行表数据查询，返回 ResultSet ，然后可以根据具体情况进行处理。1[dbms executeQuery:@"select * from RecordSign where recordId = ? ",recordId]; 删除使用 delete 关键字来删除表中的记录。1[dbms executeUpdate:@"delete from RecordSign where visibleState = 0"]; 批处理当涉及到数据量比较大或者原子性操作时，可能会用到批处理相关操作，例如：123456789101112131415161718192021222324//假设数据量不是太大，不需要通过分批次提交[[GKDatabaseManager sharedInstance].dbQueue inTransaction:^(FMDatabase *dbms, BOOL *rollback) &#123; [dbms executeUpdate:@"update RecordSign set visibleState = 0 "]; for (NSDictionary* projectModel in projectList) &#123; NSString* recordId = [projectModel objectForKey:@"recordId"]; NSString* projectName = [projectModel objectForKey:@"projectName"]; FMResultSet* retSet = [dbms executeQuery:@"select * from RecordSign where recordId = ? ",recordId]; if ([retSet next]) &#123; [dbms executeUpdate:@"update RecordSign set projectName = ? , visibleState = 1 where recordId = ? ", projectName, recordId ]; &#125;else&#123; [dbms executeUpdate:@"insert OR IGNORE into RecordSign (recordId, projectName,visibleState) values (?, ?, 1)", recordId, projectName ]; &#125;//end if retSet [retSet close]; &#125;//end for [dbms executeUpdate:@"delete from RecordSign where visibleState = 0"];&#125;];[[GKDatabaseManager sharedInstance].dbQueue close]; 使用心结我的态度是：数据库能实现的东西，自己就没必要再折腾了。数据库本身是一个很强大的软件，她已经可以帮助我们解决很多的问题。所以在拿到需求后，别急着写代码逻辑，最好先考虑下是否可以利用这些现成的工具。有时候数据库处理数据的能力比自己写程序效率要高很多，且代价也比较小；数据库已经实现的功能，当然没有必要再自行编写程序解决，除非你觉得自己比数据库处理的好。 使用SQLite数据库处理缓存的话，需要考虑数据库表结构的更新。 建议在建立表结构的时候，添加版本信息，比如 tablename_v1。就像CoreData处理版本升级时的version版本号一样。 数据迁移。 表结构受损后的数据恢复。 数据库连接的选择 FMDatabase是同步操作，FMDatabaseQueue是异步操作。 不要单例FMDatabase对象，在多线程处理时各种死锁绝对够你受的。 不要将FMDatabase和FMDatabaseQueue同时使用，否则等着数据异常或者死锁崩溃吧。]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>SQLite3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>%2F2017%2F04%2F27%2Falgorithm_search_binary%2F</url>
    <content type="text"><![CDATA[​ 二分查找算法也称为折半搜索、二分搜索，是一种在有序数组中查找某一特定元素的搜索算法。算法是建立在有序数组基础上的。时间复杂度： T(n) = Θ(logn)。 原理及实现基本原理：使用递归、分治的思想 ① 当数组为空时，说明数组中不存在需查找的元素。 ② 用有序数组的中间位置元素与需查找元素进行大小比较，如果相等，则查找结束。 ③ 如果中间位置元素大于需查找元素，则从数组左侧位置进行递归查找。 ④ 如果中间位置元素小于需查找元素，则从数组右侧位置进行递归查找。 使用Swift编写简单的代码实现，如下： 123456789101112131415161718192021222324/** * 二分查找 * 使用递归、分治的思想 * ① 当数组为空时，说明数组中不存在需查找的元素。 * ② 用有序数组的中间位置元素与需查找元素进行大小比较，如果相等，则查找结束。 * ③ 如果中间位置元素大于需查找元素，则从数组左侧位置进行递归查找。 * ④ 如果中间位置元素小于需查找元素，则从数组右侧位置进行递归查找。 **/func binarySearch&lt;T:Comparable&gt;(array:Array&lt;T&gt;, start:Int, end:Int, value:T) -&gt; Int&#123; let count = end - start + 1; if count &lt;= 0 &#123; return -1;//没有查找到 &#125; let midIndex = (start + end) / 2; let midValue = array[midIndex]; if midValue &gt; value &#123;//在左侧查找 return binarySearch(array: array, start: start, end: midIndex - 1, value: value); &#125;else if midValue &lt; value &#123;//在右侧查找 return binarySearch(array: array, start: midIndex + 1, end: end, value: value); &#125;else&#123;//位置查找到，即当前数组中间位置元素 return midIndex; &#125;&#125; 测试用例及结果12345678910111213141516171819202122232425//方法调用func callBinarySearch&lt;T:Comparable&gt;(array: Array&lt;T&gt;, value:T)&#123; let index = binarySearch(array: array, start: 0, end: array.count - 1, value: value); print("Index Of Value \(value) In Array \(array) is : \(index)") &#125;var intArray = [1, 4, 7, 8, 9, 11, 11, 15, 16, 24];callBinarySearch(array: intArray , value: 3)callBinarySearch(array: intArray , value: 16)var stringArray = ["Assembly", "BASIC", "C#", "Java", "Objective-C", "PHP", "Swift"];callBinarySearch(array: stringArray,value:"Assembly")callBinarySearch(array: stringArray,value:"PHP")callBinarySearch(array: stringArray,value:"AAA")//程序输出Index Of Value 3 In Array [1, 4, 7, 8, 9, 11, 11, 15, 16, 24] is : -1Index Of Value 16 In Array [1, 4, 7, 8, 9, 11, 11, 15, 16, 24] is : 8Index Of Value Assembly In Array ["Assembly", "BASIC", "C#", "Java", "Objective-C", "PHP", "Swift"] is : 0Index Of Value PHP In Array ["Assembly", "BASIC", "C#", "Java", "Objective-C", "PHP", "Swift"] is : 5Index Of Value AAA In Array ["Assembly", "BASIC", "C#", "Java", "Objective-C", "PHP", "Swift"] is : -1]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2F2017%2F04%2F26%2Falgorithm_sort_merge%2F</url>
    <content type="text"><![CDATA[​ 归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。需要额外的存储空间，时间复杂度： T(n) = Θ(nlgn)。 基本原理及实现基本原理：使用递归、分治思想，将待排序数组分割成字数组，将排序后的字数组合并。 ① 当数组只包含一个元素时，直接返回该元素即可。 ② 取数组中间位置元素，递归调用左侧和右侧数组，进行归并排序。 ③ 将左侧和右侧排序后的有序数组进行合并。 使用Swift进行功能实现，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * 归并排序 - 算法思想 * 使用递归、分治的思想。 * ① 当数组只包含一个元素时，直接返回该元素即可。 * ② 取数组中间位置元素，递归调用左侧和右侧数组，进行归并排序。 * ③ 将左侧和右侧排序后的有序数组进行合并。 * **/func mergeSort&lt;T:Comparable&gt;(array: Array&lt;T&gt;, start:Int , end:Int) -&gt; Array&lt;T&gt;&#123; if start &gt;= end &#123;//① 只有一个元素，直接返回即可 return [array[start]]; &#125;else&#123; let middle = (start + end) / 2; //② 递归调用，给左侧数组排序 let leftSortArray = mergeSort(array:array,start:start,end:middle); //② 递归调用，给右侧数组排序 let rightSortedArray = mergeSort(array: array, start: middle + 1, end: end); //③ 合并有序数组 var leftIndex = 0; var rightIndex = 0; let leftCount = leftSortArray.count; let rightCount = rightSortedArray.count; var retArray:Array&lt;T&gt; = []; // 两个有序数组均存在值时，依次插入最小值 while leftIndex &lt; leftCount &amp;&amp; rightIndex &lt; rightCount &#123; let leftValue = leftSortArray[leftIndex]; let rightValue = rightSortedArray[rightIndex]; if leftValue &lt; rightValue &#123; retArray.append(leftValue); leftIndex += 1; &#125;else&#123; retArray.append(rightValue); rightIndex += 1; &#125; &#125; // 将左侧有序数组剩余部分依次插入到排序结果中 while leftIndex &lt; leftCount &#123; let leftValue = leftSortArray[leftIndex]; retArray.append(leftValue); leftIndex += 1; &#125; // 将右侧有序数组剩余部分依次插入到排序结果中 while rightIndex &lt; rightCount &#123; let rightValue = rightSortedArray[rightIndex]; retArray.append(rightValue); rightIndex += 1; &#125; return retArray; &#125;&#125;//调用方法func callMergeSort&lt;T:Comparable&gt;(array:Array&lt;T&gt;)-&gt;Array&lt;T&gt;&#123; let count = array.count; if count &gt; 0 &#123; return mergeSort(array: array, start: 0, end: count - 1); &#125;else&#123; return []; &#125;&#125; 测试用例及结果123456789//测试用例var intArray = [16,4,7,9,8,11,11,15,24,1];print("待排序数组：\(intArray)");let sortedArray = callMergeSort(array: intArray);print("排序后数组：\(sortedArray)");//程序输出待排序数组：[16, 4, 7, 9, 8, 11, 11, 15, 24, 1]排序后数组：[1, 4, 7, 8, 9, 11, 11, 15, 16, 24] 123456789//测试用例var stringArray = ["Java","C#","Python","Objective-C","Swift","PHP","BASIC","Pasical","Assembly"];print("待排序数组：\(stringArray)");let sortedStringArray = callMergeSort(array: stringArray);print("排序后数组：\(sortedStringArray)");//程序输出待排序数组：["Java", "C#", "Python", "Objective-C", "Swift", "PHP", "BASIC", "Pasical", "Assembly"]排序后数组：["Assembly", "BASIC", "C#", "Java", "Objective-C", "PHP", "Pasical", "Python", "Swift"]]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入排序]]></title>
    <url>%2F2017%2F04%2F25%2Falgorithm_sort_insert%2F</url>
    <content type="text"><![CDATA[​ 每次将一个待排序的记录，按其大小插入到前面已经排好序的子序列中的适当位置，直到全部记录插入完成为止。时间复杂度 T(n) = Θ(n²)。 原理及实现基本原理：对待排序数组a[n]，假设第i(i∈[1,n])个元素左侧已排序，右侧未排序。 ① 从i位置左侧已排序数组位置中，逆序遍历，查找元素a[i]的目标位置，即第一个比a[i]小的元素后边targetPos（或者第一个位置）。 ② 移动元素：将数组元素[targetPos + 1 .. i - 1] 整体向后移动一位。 ③ 将第i(i∈[1,n])个元素a[i]放置到[targetPos + 1]位置。 ④ 遍历执行①、②、③操作，直到最后一个元素a[n]。 使用Swift进行功能实现，如下： 1234567891011121314151617181920212223242526272829303132333435363738/** * 插入排序 - 算法思想 * 对待排序数组a[n]，假设第i(i∈[1,n])个元素左侧已排序，右侧未排序。 * ① 从i位置左侧已排序数组位置中，逆序遍历，查找元素a[i]的目标位置，即第一个比a[i]小的元素后边targetPos（或者第一个位置）。 * ② 移动元素：将数组元素[targetPos + 1 .. i - 1] 整体向后移动一位。 * ③ 将第i(i∈[1,n])个元素a[i]放置到[targetPos + 1]位置。 * ④ 遍历执行①、②、③操作，直到最后一个元素a[n]。 * **/func insertSort&lt;T: Comparable&gt;(array: inout Array&lt;T&gt;)&#123; let count = array.count; if count &gt; 1 &#123; //第i个元素的左侧为有序，右侧为无序。遍历执行操作④ for i in 1 ..&lt; count &#123; let ai = array[i]; var targetPos = i - 1; var aj = array[targetPos]; //如果当前元素不小于前一个元素，表明数据已经是有序的，无需后续操作 if ai &lt; aj &#123; //操作①，查找第一个比a[i]小的元素位置targetPos while ai &lt; aj &amp;&amp; targetPos &gt;= 0 &#123; targetPos = targetPos - 1; if targetPos &gt;= 0 &#123; aj = array[targetPos]; &#125; &#125; //操作②，移动元素 for index in (targetPos + 1 ..&lt; i).reversed() &#123; array[index + 1] = array[index]; &#125; //操作③，赋值 array[targetPos + 1] = ai; &#125; print("第\(i)次处理结果： \(array)") &#125; &#125;&#125; 测试用例及结果12345678910111213141516//测试用例var intArray = [16,4,7,9,8,11,11,15,24,1];print("待排序整形数组：\(intArray)");insertSort(array: &amp;intArray);//程序输出待排序整形数组：[16, 4, 7, 9, 8, 11, 11, 15, 24, 1]第1次处理结果： [4, 16, 7, 9, 8, 11, 11, 15, 24, 1]第2次处理结果： [4, 7, 16, 9, 8, 11, 11, 15, 24, 1]第3次处理结果： [4, 7, 9, 16, 8, 11, 11, 15, 24, 1]第4次处理结果： [4, 7, 8, 9, 16, 11, 11, 15, 24, 1]第5次处理结果： [4, 7, 8, 9, 11, 16, 11, 15, 24, 1]第6次处理结果： [4, 7, 8, 9, 11, 11, 16, 15, 24, 1]第7次处理结果： [4, 7, 8, 9, 11, 11, 15, 16, 24, 1]第8次处理结果： [4, 7, 8, 9, 11, 11, 15, 16, 24, 1]第9次处理结果： [1, 4, 7, 8, 9, 11, 11, 15, 16, 24] 123456789101112131415//测试用例var stringArray = ["Java","C#","Python","Objective-C","Swift","PHP","BASIC","Pasical","Assembly"];print("待排序字符串数组：\(stringArray)");insertSort(array: &amp;stringArray);//程序输出待排序字符串数组：["Java", "C#", "Python", "Objective-C", "Swift", "PHP", "BASIC", "Pasical", "Assembly"]第1次处理结果： ["C#", "Java", "Python", "Objective-C", "Swift", "PHP", "BASIC", "Pasical", "Assembly"]第2次处理结果： ["C#", "Java", "Python", "Objective-C", "Swift", "PHP", "BASIC", "Pasical", "Assembly"]第3次处理结果： ["C#", "Java", "Objective-C", "Python", "Swift", "PHP", "BASIC", "Pasical", "Assembly"]第4次处理结果： ["C#", "Java", "Objective-C", "Python", "Swift", "PHP", "BASIC", "Pasical", "Assembly"]第5次处理结果： ["C#", "Java", "Objective-C", "PHP", "Python", "Swift", "BASIC", "Pasical", "Assembly"]第6次处理结果： ["BASIC", "C#", "Java", "Objective-C", "PHP", "Python", "Swift", "Pasical", "Assembly"]第7次处理结果： ["BASIC", "C#", "Java", "Objective-C", "PHP", "Pasical", "Python", "Swift", "Assembly"]第8次处理结果： ["Assembly", "BASIC", "C#", "Java", "Objective-C", "PHP", "Pasical", "Python", "Swift"]]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iBeacon应用]]></title>
    <url>%2F2017%2F03%2F13%2Fbluetooth_iBeacon2%2F</url>
    <content type="text"><![CDATA[​ 讲述iBeacon技术的方案设想、设计及实际应用。充分利用iBeacon的优势，位置、距离、感知相关的场合构造合适的场景。 方案设想在上一篇文章中有提到iBeacon应用场景举例。这里从3各方面进行描述： 测距 主要是在程序前台激活状态下，可能会用到的场景： 周边摇、现场摇、签到等 产品介绍，商场导购，博物馆导游等 位置修正，iBeacon的精度可以辅助一些其他功能 精确区域预警、地理围栏 室内导航等 监听 托管给iOS系统，程序本身不需要打开即可触发功能，可能会用到以下场景： 欢迎语：比如当用户手持设备进入任意场景区域内时，进行交互提醒。 业务联动：比如当用户进入某个控制区后，告知概况，同周边设备联动。 区域预警：比如设置特定的围栏区域。 其他：比如与门禁系统联动等 角色交换 通常情况下，iBeacon设备作为基站，移动设备比如iPhone和iPad来接收信号，从而进行机遇位置的场景交互。我们也可以讲iPhone和iPad作为基站，给其设定特定的区域值进行广播。而接收设备位置固定等。可以设想以下场景： 演示大屏上展示周边设备。 教师要求输入动态口令进行签到。 基础方案​ 理想情况下，以下数据需要预缓存，保证在无网络或者网络环境差的情况下，交互动作可以顺利进行。因此，各类信息的版本控制需要在前期考虑。 iBeacon策略​ iBeacon策略，或者说应用场景。如上一篇文章中所说，这里主要在iBeacon对应的区域Region（ProximityUUID &amp; Major &amp; Minor）上的三个值上做文章。 比如： ProximityUUID ： 公司编码 Major ： 建筑编码 Minor ： 某类区域（物品）编码 策略相关信息确定后，就可以给不同的策略配置个性化信息了，比如进入／离开策略对应的区域时，定制以下信息： 通知声音：个性化提示音 通知内容：跟具体业务相关 通知优先级：当多个策略同时触发时，可根据优先级来动态显示 通知频次：用来确保特定时间段内，不重复通知 iBeacon业务​ 单纯的触发iBeacon对应区域的策略，仅仅是对用户的消息提醒，我们比较关注的是策略的后续动作。比如当用户到达某个iBeacon区域（或者在某个区域驻足时间较长）后，收到了个性化的策略通知。很自然的点击查看感兴趣的消息，那么后续的动作就是这里所说的iBeacon业务。通常情况下，后续动作包括以下几种： 打开某个本地模块 打开某个Web网页 打开某个本地网页 无后续动作 需要注意的是，后续动作可能不止一种。 策略业务关联​ 为了保证数据的灵活，策略与业务的对应关系为1:N（N &gt;= 0），当策略对应多个业务的时候，需要考虑各业务的优先级等。 用户策略​ 除了一些共通的策略外，用户也可以拥有独特权限的策略，比如同一个区域，不同角色进入时，看到的数据根据其权限表现出差异。 应用设备选择iBeacon设备选取可能会考虑的几个因素包括： 电池及续航 设备运维 设备部署 设备美感 设备软件能力 设备使用 通常情况下，电池、部署、软件能力需要着重考虑。 设备部署部署时可能需要考虑以下几个因素： 环境干扰 工厂校正电压 放置位置（高度／间距） 总结​ iBeacon技术在旅游景点、博物馆、商场、酒店、会议室等场景中可以给人很好的用户体验，但在成本、运维部署方面一直存在着问题。目前情况下小范围内玩iBeacon，还是很有搞头的。]]></content>
      <categories>
        <category>蓝牙</category>
      </categories>
      <tags>
        <tag>iBeacon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iBeacon基础]]></title>
    <url>%2F2017%2F02%2F11%2Fbluetooth_iBeacon1%2F</url>
    <content type="text"><![CDATA[​ iBeacon 标准是Apple在2013年WWDC上提出的，运行在iOS7+系统的设备上，且要求设备配备低功耗蓝牙BLE通信功能。本文简单介绍下iBeacon在位置、感知、距离方面的基本能力。 位置服务​ 位置服务(Location Service)通常是在某个区域(Region)，通过GPS来实现的某些功能。比如当你手持安装星巴克应用的苹果手机在星巴克附近时，锁屏状态下会在屏幕左下角显示该应用的图标。 高德地图 中的地理围栏就是一个实际应用场景。位置服务有以下缺点： GPS本身定位精度能力有限，位置服务不可能提供精确的位置服务； 室内环境下GPS信号普遍不好，或者信号不可达； iBeacon​ iBeacon技术是基于基站的形式。一个iBeacon可以被认为是一个区域（物体所在位置+覆盖半径），由于使用低功耗蓝牙技术，实验环境下其精度可以达到10cm范围内（虽然有些吹嘘，但亲测是相当精确的）。关于iBeacon的软件部分，需要了解以下几个概念： Region : ProximityUUID &amp; Major &amp; Minor Advertise Interval Measured Power RSSI 关于iBeacon区域的定义，由3个值来唯一确定一个区域，举例如下图：图描述的很清楚了，我们可以通过ProximityUUID、Major和Minor三个值来定义不同的有关联的区域（事物），并通过不同的值组合来做很多有意思的事情。 iBeacon基础场景监听​ 区域监听(Region Monitoring)即当设备进入／离开某个／某类区域的时候，可以触发后续联动，其监听的区域可能是ProximityUUID代表的某个大的类别区域比如一个公司在全国的所有子公司、或者由ProximityUUID和Major组合的相对小的区域比如某个城市中的子公司。至于什么区域就比较灵活了。​ 一般情况下，iOS程序退出或者后台挂起后，程序是不能执行的(其他Background-Mode除外)。但是这里所说的区域监听是托管给iOS系统，也就是说程序设置完监听区域后，iOS系统会托管，当设备进入／离开监听区域时，系统会触发相应的操作，并唤醒程序。 测距测距（Ranging）即设备与Beacon区域中心点的接近距离（接近状态），包括： Immediate 非常近 Near 1～3米 Far 3米以外 Unknown 距离不可测量 测距是在iOS程序处于前台激活状态下使用的，程序推到后台时，该功能便不可用。 应用场景举例监听：由iOS系统接管，所以该功能需慎用，搞不好会让用户厌烦。 欢迎语：比如商店入口／出口放置，用来给顾客相关提示。 物品介绍：比如在博物馆某些区域，导游和网络信号不好的情况下，可以通过给文物贴上标签(iBeacon)，让每个设备都当导游。 业务确认：比如在某些病房中放置，在特定时刻向病人确定吃药情况。 预警：比如钥匙坠，当不在身边时及时提醒。 其他：比如门禁、宠物饰品等 测距：需要程序处于前台激活状态下使用，这里主要用在区域相关和用户互动的场景。 商场活动：比如现场抽奖、现场摇一摇 自动售货机：付款 活动签到：上课／开会等 商场导购：在某个商品前停留，自动推该商品信息、折扣信息等 微信摇一摇周边 其他：室内导航等 现状​ 经过这么多年的发展，iBeacon技术并没有达到前几年预想的效果。可能是受成本及运维的影响，也可能是关于位置感知的场景化需求太少，一直没有流行起来。目前国内主要的厂商包括：智石科技、四月兄弟、DropBeacon等，提供了Beacon的基础能力，但在设备美观及精确度方面个人不敢恭维。国外Beacon技术相对先进不少，应该是受苹果的影响。比较突出的一个是 Estiomte ，他家的产品及配套SDK是真心不错，就是略贵。]]></content>
      <categories>
        <category>蓝牙</category>
      </categories>
      <tags>
        <tag>iBeacon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈iOS框架]]></title>
    <url>%2F2016%2F12%2F21%2FiOS_develop_overview_framework_2%2F</url>
    <content type="text"><![CDATA[记录下个人从事iOS开发过程中，使用过的程序框架，谈谈个人的理解。 前言​ 回顾最近三年，我主要从事iOS前端开发工作。一个一无所知的摸石头过河，慢慢在前端开发的道路上寻找、探索。之前我是做嵌入式开发的，转做iOS前端开发可以说是一个幸运的意外。因为业务需要，看了两个星期的斯坦福大学大学iOS公开课，就开始了我的踩坑、脱坑之旅。这里就聊一聊近3年来iOS前端开发使用的框架吧。 MVC​ 第一次接触MVC这个框架，是在大三的一门《J2EE》教材的最后一章，当时还沉浸在JSP+Servlet各种组合中，提到这个的时候，因为是接触的第一个框架，所以印象特别深刻，直到后来实习的时候使用Struct框架做了一个管理系统，才算真正的理解。后来在斯坦福iOS视频教程中又一次的遇到她。概念不用再赘述，当时主要是使用Xib+ObjC开发。鉴于应用本身的弱Model，当时的整个应用看起来都是ViewController。文件组织特别的乱，结果就是很不好维护。在经历了iOS5～iOS10系统的适配后，在代码复用方面，简直是个噩梦！在这里就主要记录下使用她的过程中遇到的问题吧 基础知识不熟练。 零基础的代码编写，主要精力放在了逻辑编写上，很少关注代码结构。 很多组件使用不规范。虽然UI上达到了效果。 第三方库的使用。直接拖拽、修改代码。 系统不熟悉，等。 以上很多因素，最终导致了App的ViewController特别臃肿，且页面间组织关系不好梳理，代码复用等这里真心无力再吐槽了。期间界面组织方式有StoryBoard+ObjC、Xib+ObjC和ObjC纯代码，开发的应用包括《效率助手》、《知识库》、《因泰在线》，使用该框架过程中对其结构进行了调整，和后边的MVVM框架思想类似。 MVVM​ 对于这个框架，感觉是先使用后，才了解到其概念的。先使用的主要原因是MVC的Controller太过庞大，且维护起来很不容易。很多逻辑感觉不应该放到控制器中，所以将Controller进行了分割，使用起来确实解决了代码复用问题，程序结构变得清晰起来。使用该框架开发的应用包括《数据采集》、《路桥在线》等。因为在查询框架资料时，使用的和这个不谋而合。所以这个框架使用的周期相对较短。 自定义框架​ 之前主要从事嵌入式开发，对某个车载导航产品的结构比较熟悉，所以就仿造她自己编写了一套框架，主要为了解决代码分类。层级结构包括：界面展示层HMI、交互层PF、数据传输层HMI-Core、核心功能层FunctionCore、数据持有层Model、共同层Common等，功能模块横向纵向通过Symbol（Event或者Notification）的形式实现，通过反射等机制来协调各功能。 MVVM变种​ 这个(自己定的名字)是主要使用的，一个类似MVMCV但严格上来说不属于MVMCV框架的框架。与之的主要区别是View-Model的组织，我目前在VM（View-Model）中放置了部分业务逻辑，少量的业务逻辑还是在C（Controller）中。主要原因是目前iOS前端移动应用由我一人进行承担，部分业务逻辑放在Controller中一定程度上可以加快开发速度（应该是错觉，反正我说了算）。这里主要提一点就是 pod 的使用，她解决了很大的APP适配问题。 MVMCV​ 目前使用这个框架开发过聊天功能界面。感觉多人合作的时候这个框架还是非常清晰的；从工作分配到代码编写、问题调查，实在是找不出拒绝她的理由。 总结​ 虽然目前主要使用MVVM的一种变种形式，将View-Model中的逻辑进行了初步的分类。但后续过程中，我还是会向MVMCV结构变更的，因为现在已经尝到了MVMCV结构的甜头。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift Access Control]]></title>
    <url>%2F2016%2F12%2F05%2FiOS_Swift_language_note_Access-Control%2F</url>
    <content type="text"><![CDATA[​​ 访问控制可以限定其他源文件或模块中的代码对你的代码的访问级别。这个特性可以让我们隐藏代码的一些实现细节，并且可以为其他人可以访问和使用的代码提供接口。 你可以明确地给单个类型（类、结构体、枚举）设置访问级别，也可以给这些类型的属性、方法、构造器、下标等设置访问级别。协议也可以被限定在一定的范围内使用，包括协议里的全局常量、变量和函数。Swift 不仅提供了多种不同的访问级别，还为某些典型场景提供了默认的访问级别，这样就不需要我们在每段代码中都申明显式访问级别。其实，如果只是开发一个单一目标的应用程序，我们完全可以不用显式声明代码的访问级别。 模板和源文件Swift 中的访问控制模型基于模块和源文件这两个概念。模块指的是独立的代码单元，框架或应用程序会作为一个独立的模块来构建和发布。在 Swift 中，一个模块可以使用 import 关键字导入另外一个模块。在 Swift 中，Xcode 的每个目标（例如框架或应用程序）都被当作独立的模块处理。如果你是为了实现某个通用的功能，或者是为了封装一些常用方法而将代码打包成独立的框架，这个框架就是 Swift 中的一个模块。当它被导入到某个应用程序或者其他框架时，框架内容都将属于这个独立的模块。源文件就是 Swift 中的源代码文件，它通常属于一个模块，即一个应用程序或者框架。尽管我们一般会将不同的类型分别定义在不同的源文件中，但是同一个源文件也可以包含多个类型、函数之类的定义。 访问级别Swift 为代码中的实体提供了五种不同的访问级别。这些访问级别不仅与源文件中定义的实体相关，同时也与源文件所属的模块相关。 开放访问和公开访问可以访问同一模块源文件中的任何实体，在模块外也可以通过导入该模块来访问源文件里的所有实体。通常情况下，框架中的某个接口可以被任何人使用时，你可以将其设置为开放或者公开访问。 内部访问可以访问同一模块源文件中的任何实体，但是不能从模块外访问该模块源文件中的实体。通常情况下，某个接口只在应用程序或框架内部使用时，你可以将其设置为内部访问。 文件私有访问限制实体只能被所定义的文件内部访问。当需要把这些细节被整个文件使用的时候，使用文件私有访问隐藏了一些特定功能的实现细节。 私有访问限制实体只能在所定义的作用域内使用。需要把这些细节被整个作用域使用的时候，使用文件私有访问隐藏了一些特定功能的实现细节。 开放访问为最高（限制最少）访问级别，私有访问为最低（限制最多）访问级别。开放访问只作用于类类型和类的成员，它和公开访问的区别如下： 公开访问或者其他更严访问级别的类，只能在它们定义的模块内部被继承。 公开访问或者其他更严访问级别的类成员，只能在它们定义的模块内部的子类中重写。 开放访问的类，可以在它们定义的模块中被继承，也可以在引用它们的模块中被继承。 开放访问的类成员，可以在它们定义的模块中子类中重写，也可以在引用它们的模块中的子类重写。 把一个类标记为开放，显式地表明，你认为其他模块中的代码使用此类作为父类，然后你已经设计好了你的类的代码了。 访问级别基本原则Swift 中的访问级别遵循一个基本原则：不可以在某个实体中定义访问级别更低（更严格）的实体。例如： 一个公开访问级别的变量，其类型的访问级别不能是内部，文件私有或是私有类型的。因为无法保证变量的类型在使用变量的地方也具有访问权限。 函数的访问级别不能高于它的参数类型和返回类型的访问级别。因为这样就会出现函数可以在任何地方被访问，但是它的参数类型和返回类型却不可以的情况。 默认访问级别如果你不为代码中的实体显式指定访问级别，那么它们默认为 internal 级别（有一些例外情况，稍后会进行说明）。因此，在大多数情况下，我们不需要显式指定实体的访问级别。 单目标应用程序的访问级别当你编写一个单目标应用程序时，应用的所有功能都是为该应用服务，而不需要提供给其他应用或者模块使用，所以我们不需要明确设置访问级别，使用默认的访问级别 internal 即可。但是，你也可以使用文件私有访问或私有访问级别，用于隐藏一些功能的实现细节。 框架的访问级别当你开发框架时，就需要把一些对外的接口定义为开放访问或公开访问级别，以便使用者导入该框架后可以正常使用其功能。这些被你定义为对外的接口，就是这个框架的 API。 框架依然会使用默认的内部访问级别，也可以指定为文件私有访问或者私有访问级别。当你想把某个实体作为框架的 API 的时候，需显式为其指定开放访问或公开访问级别。 单元测试目标的访问级别当你的应用程序包含单元测试目标时，为了测试，测试模块需要访问应用程序模块中的代码。默认情况下只有开放访问或公开访问级别级别的实体才可以被其他模块访问。然而，如果在导入应用程序模块的语句前使用 @testable 特性，然后在允许测试的编译设置（Build Options -&gt; Enable Testability）下编译这个应用程序模块，单元测试目标就可以访问应用程序模块中所有内部级别的实体。 访问控制语法通过修饰符 open，public，internal，filepart，private 来声明实体的访问级别： 123456789public class SomePublicClass &#123;&#125;internal class SomeInternalClass &#123;&#125;fileprivate class SomeFilePrivateClass &#123;&#125;private class SomePrivateClass &#123;&#125; public var somePublicVariable = 0internal let someInternalConstant = 0fileprivate func someFilePrivateFunction() &#123;&#125;private func somePrivateFunction() &#123;&#125; 默认情况下，否则实体默认的访问级别为内部访问级别 自定义类型如果想为一个自定义类型指定访问级别，在定义类型时进行指定即可。新类型只能在它的访问级别限制范围内使用。例如，你定义了一个文件私有级别的类，那这个类就只能在定义它的源文件中使用，可以作为属性类型、函数参数类型或者返回类型，等等。一个类型的访问级别也会影响到类型成员（属性、方法、构造器、下标）的默认访问级别。如果你将类型指定为私有或者文件私有级别，那么该类型的所有成员的默认访问级别也会变成私有或者文件私有级别。如果你将类型指定为公开或者内部访问级别（或者不明确指定访问级别，而使用默认的内部访问级别），那么该类型的所有成员的默认访问级别将是内部访问。 一个公开类型的所有成员的访问级别默认为内部访问级别，而不是公开级别。如果你想将某个成员指定为公开访问级别，那么你必须显式指定。这样做的好处是，在你定义公共接口的时候，可以明确地选择哪些接口是需要公开的，哪些是内部使用的，避免不小心将内部使用的接口公开。 123456789101112131415161718192021public class SomePublicClass &#123; // explicitly public class public var somePublicProperty = 0 // explicitly public class member var someInternalProperty = 0 // implicitly internal class member fileprivate func someFilePrivateMethod() &#123;&#125; // explicitly file-private class member private func somePrivateMethod() &#123;&#125; // explicitly private class member&#125; class SomeInternalClass &#123; // implicitly internal class var someInternalProperty = 0 // implicitly internal class member fileprivate func someFilePrivateMethod() &#123;&#125; // explicitly file-private class member private func somePrivateMethod() &#123;&#125; // explicitly private class member&#125; fileprivate class SomeFilePrivateClass &#123; // explicitly file-private class func someFilePrivateMethod() &#123;&#125; // implicitly file-private class member private func somePrivateMethod() &#123;&#125; // explicitly private class member&#125; private class SomePrivateClass &#123; // explicitly private class func somePrivateMethod() &#123;&#125; // implicitly private class member&#125; 元组类型元组的访问级别将由元组中访问级别最严格的类型来决定。例如，如果你构建了一个包含两种不同类型的元组，其中一个类型为内部访问级别，另一个类型为私有访问级别，那么这个元组的访问级别为私有访问级别。 元组不同于类、结构体、枚举、函数那样有单独的定义。元组的访问级别是在它被使用时自动推断出的，而无法明确指定。 函数类型函数的访问级别根据访问级别最严格的参数类型或返回类型的访问级别来决定。但是，如果这种访问级别不符合函数定义所在环境的默认访问级别，那么就需要明确地指定该函数的访问级别。下面的例子定义了一个名为 someFunction() 的全局函数，并且没有明确地指定其访问级别。也许你会认为该函数应该拥有默认的访问级别 internal，但事实并非如此。事实上，如果按下面这种写法，代码将无法通过编译： 123func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) &#123; // function implementation goes here&#125; 我们可以看到，这个函数的返回类型是一个元组，该元组中包含两个自定义的类（可查阅自定义类型）。其中一个类的访问级别是 internal，另一个的访问级别是 private，所以根据元组访问级别的原则，该元组的访问级别是 private（元组的访问级别与元组中访问级别最低的类型一致）。因为该函数返回类型的访问级别是 private，所以你必须使用 private 修饰符，明确指定该函数的访问级别： 123private func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) &#123; // function implementation goes here&#125; 将该函数指定为 public 或 internal，或者使用默认的访问级别 internal 都是错误的，因为如果把该函数当做 public 或 internal 级别来使用的话，可能会无法访问 private 级别的返回值。 枚举类型枚举成员的访问级别和该枚举类型相同，你不能为枚举成员单独指定不同的访问级别。比如下面的例子，枚举 CompassPoint 被明确指定为 public 级别，那么它的成员 North、South、East、West 的访问级别同样也是 public： 123456public enum CompassPoint &#123; case north case south case east case west&#125; 原始值和关联值枚举定义中的任何原始值或关联值的类型的访问级别至少不能低于枚举类型的访问级别。例如，你不能在一个 internal 访问级别的枚举中定义 private 级别的原始值类型。 嵌套类型如果在 private 级别的类型中定义嵌套类型，那么该嵌套类型就自动拥有 private 访问级别。如果在 public 或者 internal 级别的类型中定义嵌套类型，那么该嵌套类型自动拥有 internal 访问级别。如果想让嵌套类型拥有 public 访问级别，那么需要明确指定该嵌套类型的访问级别。 子类子类的访问级别不得高于父类的访问级别。例如，父类的访问级别是 internal，子类的访问级别就不能是 public。此外，你可以在符合当前访问级别的条件下重写任意类成员（方法、属性、构造器、下标等）。可以通过重写为继承来的类成员提供更高的访问级别。下面的例子中，类 A 的访问级别是 public，它包含一个方法 someMethod()，访问级别为 private。类 B 继承自类 A，访问级别为 internal，但是在类 B 中重写了类 A 中访问级别为 private 的方法 someMethod()，并重新指定为 internal 级别。通过这种方式，我们就可以将某类中 private 级别的类成员重新指定为更高的访问级别，以便其他人使用： 1234567public class A &#123; fileprivate func someMethod() &#123;&#125;&#125; internal class B: A &#123; override internal func someMethod() &#123;&#125;&#125; 我们甚至可以在子类中，用子类成员去访问访问级别更低的父类成员，只要这一操作在相应访问级别的限制范围内（也就是说，在同一源文件中访问父类 private 级别的成员，在同一模块内访问父类 internal 级别的成员）： 123456789public class A &#123; fileprivate func someMethod() &#123;&#125;&#125; internal class B: A &#123; override internal func someMethod() &#123; super.someMethod() &#125;&#125; 因为父类 A 和子类 B 定义在同一个源文件中，所以在子类 B 可以在重写的 someMethod() 方法中调用 super.someMethod()。 常量、变量、属性、下标常量、变量、属性不能拥有比它们的类型更高的访问级别。例如，你不能定义一个 public 级别的属性，但是它的类型却是 private 级别的。同样，下标也不能拥有比索引类型或返回类型更高的访问级别。如果常量、变量、属性、下标的类型是 private 级别的，那么它们必须明确指定访问级别为 private： 1private var privateInstance = SomePrivateClass() Getter 和 Setter常量、变量、属性、下标的 Getters 和 Setters 的访问级别和它们所属类型的访问级别相同。Setter 的访问级别可以低于对应的 Getter 的访问级别，这样就可以控制变量、属性或下标的读写权限。在 var 或 subscript 关键字之前，你可以通过 fileprivate(set)，private(set) 或 internal(set) 为它们的写入权限指定更低的访问级别。 这个规则同时适用于存储型属性和计算型属性。即使你不明确指定存储型属性的 Getter 和 Setter，Swift 也会隐式地为其创建 Getter 和 Setter，用于访问该属性的后备存储。使用 fileprivate(set)，private(set) 和 internal(set) 可以改变 Setter 的访问级别，这对计算型属性也同样适用。 下面的例子中定义了一个名为 TrackedString 的结构体，它记录了 value 属性被修改的次数： 12345678struct TrackedString &#123; private(set) var numberOfEdits = 0 var value: String = "" &#123; didSet &#123; numberOfEdits += 1 &#125; &#125;&#125; TrackedString 结构体定义了一个用于存储 String 值的属性 value，并将初始值设为 “”（一个空字符串）。该结构体还定义了另一个用于存储 Int 值的属性 numberOfEdits，它用于记录属性 value 被修改的次数。这个功能通过属性 value 的 didSet 观察器实现，每当给 value 赋新值时就会调用 didSet 方法，然后将 numberOfEdits 的值加一。结构体 TrackedString 和它的属性 value 均没有显式指定访问级别，所以它们都拥有默认的访问级别 internal。但是该结构体的 numberOfEdits 属性使用了 private(set) 修饰符，这意味着 numberOfEdits 属性只能在定义该结构体的源文件中赋值。numberOfEdits 属性的 Getter 依然是默认的访问级别 internal，但是 Setter 的访问级别是 private，这表示该属性只有在当前的源文件中是可读写的，而在当前源文件所属的模块中只是一个可读的属性。如果你实例化 TrackedString 结构体，并多次对 value 属性的值进行修改，你就会看到 numberOfEdits 的值会随着修改次数而变化： 123456var stringToEdit = TrackedString()stringToEdit.value = "This string will be tracked."stringToEdit.value += " This edit will increment numberOfEdits."stringToEdit.value += " So will this one."print("The number of edits is \(stringToEdit.numberOfEdits)")// Prints "The number of edits is 3" 虽然你可以在其他的源文件中实例化该结构体并且获取到 numberOfEdits 属性的值，但是你不能对其进行赋值。这一限制保护了该记录功能的实现细节，同时还提供了方便的访问方式。你可以在必要时为 Getter 和 Setter 显式指定访问级别。下面的例子将 TrackedString 结构体明确指定为了 public 访问级别。结构体的成员（包括 numberOfEdits 属性）拥有默认的访问级别 internal。你可以结合 public 和 private(set) 修饰符把结构体中的 numberOfEdits 属性的 Getter 的访问级别设置为 public，而 Setter 的访问级别设置为 private： 123456789public struct TrackedString &#123; public private(set) var numberOfEdits = 0 public var value: String = "" &#123; didSet &#123; numberOfEdits += 1 &#125; &#125; public init() &#123;&#125;&#125; 构造器自定义构造器的访问级别可以低于或等于其所属类型的访问级别。唯一的例外是必要构造器，它的访问级别必须和所属类型的访问级别相同。如同函数或方法的参数，构造器参数的访问级别也不能低于构造器本身的访问级别。 默认构造器Swift 会为结构体和类提供一个默认的无参数的构造器，只要它们为所有存储型属性设置了默认初始值，并且未提供自定义的构造器。默认构造器的访问级别与所属类型的访问级别相同，除非类型的访问级别是 public。如果一个类型被指定为 public 级别，那么默认构造器的访问级别将为 internal。如果你希望一个 public 级别的类型也能在其他模块中使用这种无参数的默认构造器，你只能自己提供一个 public 访问级别的无参数构造器。 结构体默认的成员逐一构造器如果结构体中任意存储型属性的访问级别为 private，那么该结构体默认的成员逐一构造器的访问级别就是 private。否则，这种构造器的访问级别依然是 internal。 如同前面提到的默认构造器，如果你希望一个 public 级别的结构体也能在其他模块中使用其默认的成员逐一构造器，你依然只能自己提供一个 public 访问级别的成员逐一构造器。 协议如果想为一个协议类型明确地指定访问级别，在定义协议时指定即可。这将限制该协议只能在适当的访问级别范围内被采纳。协议中的每一个要求都具有和该协议相同的访问级别。你不能将协议中的要求设置为其他访问级别。这样才能确保该协议的所有要求对于任意采纳者都将可用。 如果你定义了一个 public 访问级别的协议，那么该协议的所有实现也会是 public 访问级别。这一点不同于其他类型，例如，当类型是 public 访问级别时，其成员的访问级别却只是 internal。 协议继承如果定义了一个继承自其他协议的新协议，那么新协议拥有的访问级别最高也只能和被继承协议的访问级别相同。例如，你不能将继承自 internal 协议的新协议定义为 public 协议。 协议一致性一个类型可以采纳比自身访问级别低的协议。例如，你可以定义一个 public 级别的类型，它可以在其他模块中使用，同时它也可以采纳一个 internal 级别的协议，但是只能在该协议所在的模块中作为符合该协议的类型使用。采纳了协议的类型的访问级别取它本身和所采纳协议两者间最低的访问级别。也就是说如果一个类型是 public 级别，采纳的协议是 internal 级别，那么采纳了这个协议后，该类型作为符合协议的类型时，其访问级别也是 internal。如果你采纳了协议，那么实现了协议的所有要求后，你必须确保这些实现的访问级别不能低于协议的访问级别。例如，一个 public 级别的类型，采纳了 internal 级别的协议，那么协议的实现至少也得是 internal 级别。 Swift 和 Objective-C 一样，协议的一致性是全局的，也就是说，在同一程序中，一个类型不可能用两种不同的方式实现同一个协议。 扩展你可以在访问级别允许的情况下对类、结构体、枚举进行扩展。扩展成员具有和原始类型成员一致的访问级别。例如，你扩展了一个 public 或者 internal 类型，扩展中的成员具有默认的 internal 访问级别，和原始类型中的成员一致 。如果你扩展了一个 private 类型，扩展成员则拥有默认的 private 访问级别。或者，你可以明确指定扩展的访问级别（例如，private extension），从而给该扩展中的所有成员指定一个新的默认访问级别。这个新的默认访问级别仍然可以被单独指定的访问级别所覆盖。 通过扩展添加协议一致性如果你通过扩展来采纳协议，那么你就不能显式指定该扩展的访问级别了。协议拥有相应的访问级别，并会为该扩展中所有协议要求的实现提供默认的访问级别。 泛型泛型类型或泛型函数的访问级别取决于泛型类型或泛型函数本身的访问级别，还需结合类型参数的类型约束的访问级别，根据这些访问级别中的最低访问级别来确定。 类型别名你定义的任何类型别名都会被当作不同的类型，以便于进行访问控制。类型别名的访问级别不可高于其表示的类型的访问级别。例如，private 级别的类型别名可以作为 private，file-private，internal，public或者open类型的别名，但是 public 级别的类型别名只能作为 public 类型的别名，不能作为 internal，file-private，或 private 类型的别名。 这条规则也适用于为满足协议一致性而将类型别名用于关联类型的情况。 参照文档 AccessControl &gt;&gt; Copyright (c) liangtong. All rights reserved.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift Protocols]]></title>
    <url>%2F2016%2F12%2F02%2FiOS_Swift_language_note_Protocols%2F</url>
    <content type="text"><![CDATA[​ 协议 定义了用来实现某一特定任务或者功能的方法、属性，以及其他需要的东西的一个蓝图。类、结构体或枚举都可以遵循协议，并为协议定义的这些要求提供具体实现。任何类型能够满足某个协议的要求，就可以说该类型遵循这个协议。除了遵循协议的类型必须实现的要求外，还可以对协议进行扩展，通过扩展来实现一部分要求或者实现一些附加功能，这样遵循协议的类型就能够使用这些功能。 协议语法协议的定义方式与类、结构体和枚举的定义非常相似： 123protocol SomeProtocol &#123; // protocol definition goes here&#125; 要让自定义类型遵循某个协议，在定义类型时，需要在类型名称后加上协议名称，中间以冒号（:）分隔。遵循多个协议时，各协议之间用逗号（,）分隔： 123struct SomeStructure: FirstProtocol, AnotherProtocol &#123; // structure definition goes here&#125; 拥有父类的类在遵循协议时，应该将父类名放在协议名之前，以逗号分隔： 123class SomeClass: SomeSuperclass, FirstProtocol, AnotherProtocol &#123; // class definition goes here&#125; 属性要求协议可以要求遵循协议的类型提供特定名称和类型的实例属性或类型属性。协议不指定属性是存储型属性还是计算型属性，它只指定属性的名称和类型。此外，协议还指定属性是可读的还是可读可写的。如果协议要求属性是可读可写的，那么该属性不能是常量属性或只读的计算型属性。如果协议只要求属性是可读的，那么该属性不仅可以是可读的，如果代码需要的话，还可以是可写的。 协议总是用 var 关键字来声明变量属性，在类型声明后加上 { set get } 来表示属性是可读可写的，可读属性则用 { get } 来表示： 1234protocol SomeProtocol &#123; var mustBeSettable: Int &#123; get set &#125; var doesNotNeedToBeSettable: Int &#123; get &#125;&#125; 在协议中定义类型属性时，总是使用 static 关键字作为前缀。当类类型遵循协议时，除了 static 关键字，还可以使用 class 关键字来声明类型属性： 123protocol AnotherProtocol &#123; static var someTypeProperty: Int &#123; get set &#125;&#125; 如下所示，这是一个只含有一个实例属性要求的协议： 123protocol FullyNamed &#123; var fullName: String &#123; get &#125;&#125; FullyNamed 协议除了要求遵循协议的类型提供 fullName 属性外，并没有其他特别的要求。这个协议表示，任何遵循 FullyNamed 的类型，都必须有一个可读的 String 类型的实例属性 fullName。下面是一个遵循 FullyNamed 协议的简单结构体： 12345struct Person: FullyNamed &#123; var fullName: String&#125;let john = Person(fullName: "John Appleseed")// john.fullName is "John Appleseed" 这个例子中定义了一个叫做 Person 的结构体，用来表示一个具有名字的人。从第一行代码可以看出，它遵循了 FullyNamed 协议。Person 结构体的每一个实例都有一个 String 类型的存储型属性 fullName。这正好满足了 FullyNamed 协议的要求，也就意味着 Person 结构体正确地符合了协议。（如果协议要求未被完全满足，在编译时会报错。）下面是一个更为复杂的类，它适配并遵循了 FullyNamed 协议： 12345678910111213class Starship: FullyNamed &#123; var prefix: String? var name: String init(name: String, prefix: String? = nil) &#123; self.name = name self.prefix = prefix &#125; var fullName: String &#123; return (prefix != nil ? prefix! + " " : "") + name &#125;&#125;var ncc1701 = Starship(name: "Enterprise", prefix: "USS")// ncc1701.fullName is "USS Enterprise" Starship 类把 fullName 属性实现为只读的计算型属性。每一个 Starship 类的实例都有一个名为 name 的非可选属性和一个名为 prefix 的可选属性。 当 prefix 存在时，计算型属性 fullName 会将 prefix 插入到 name 之前，从而为星际飞船构建一个全名。 方法要求（Method Requirements）协议可以要求遵循协议的类型实现某些指定的实例方法或类方法。这些方法作为协议的一部分，像普通方法一样放在协议的定义中，但是不需要大括号和方法体。可以在协议中定义具有可变参数的方法，和普通方法的定义方式相同。但是，不支持为协议中的方法的参数提供默认值。正如属性要求中所述，在协议中定义类方法的时候，总是使用 static 关键字作为前缀。当类类型遵循协议时，除了 static 关键字，还可以使用 class 关键字作为前缀： 123protocol SomeProtocol &#123; static func someTypeMethod()&#125; 下面的例子定义了一个只含有一个实例方法的协议： 123protocol RandomNumberGenerator &#123; func random() -&gt; Double&#125; RandomNumberGenerator 协议要求遵循协议的类型必须拥有一个名为 random， 返回值类型为 Double 的实例方法。RandomNumberGenerator 协议并不关心每一个随机数是怎样生成的，它只要求必须提供一个随机数生成器。 如下所示，下边是一个遵循并符合 RandomNumberGenerator 协议的类。该类实现了一个叫做 线性同余生成器（linear congruential generator） 的伪随机数算法。 123456789101112131415class LinearCongruentialGenerator: RandomNumberGenerator &#123; var lastRandom = 42.0 let m = 139968.0 let a = 3877.0 let c = 29573.0 func random() -&gt; Double &#123; lastRandom = ((lastRandom * a + c).truncatingRemainder(dividingBy:m)) return lastRandom / m &#125;&#125;let generator = LinearCongruentialGenerator()print("Here's a random number: \(generator.random())")// Prints "Here's a random number: 0.37464991998171"print("And another one: \(generator.random())")// Prints "And another one: 0.729023776863283" Mutating 方法要求有时需要在方法中改变方法所属的实例。例如，在值类型（即结构体和枚举）的实例方法中，将 mutating 关键字作为方法的前缀，写在 func 关键字之前，表示可以在该方法中修改它所属的实例以及实例的任意属性的值。如果你在协议中定义了一个实例方法，该方法会改变遵循该协议的类型的实例，那么在定义协议时需要在方法前加 mutating 关键字。这使得结构体和枚举能够遵循此协议并满足此方法要求。 实现协议中的 mutating 方法时，若是类类型，则不用写 mutating 关键字。而对于结构体和枚举，则必须写 mutating 关键字。 如下所示，Togglable 协议只要求实现一个名为 toggle 的实例方法。根据名称的暗示，toggle() 方法将改变实例属性，从而切换遵循该协议类型的实例的状态。toggle() 方法在定义的时候，使用 mutating 关键字标记，这表明当它被调用时，该方法将会改变遵循协议的类型的实例： 123protocol Togglable &#123; mutating func toggle()&#125; 当使用枚举或结构体来实现 Togglable 协议时，需要提供一个带有 mutating 前缀的 toggle() 方法。下面定义了一个名为 OnOffSwitch 的枚举。这个枚举在两种状态之间进行切换，用枚举成员 On 和 Off 表示。枚举的 toggle() 方法被标记为 mutating，以满足 Togglable 协议的要求： 1234567891011121314enum OnOffSwitch: Togglable &#123; case off, on mutating func toggle() &#123; switch self &#123; case .off: self = .on case .on: self = .off &#125; &#125;&#125;var lightSwitch = OnOffSwitch.offlightSwitch.toggle()// lightSwitch is now equal to .on 构造器要求协议可以要求遵循协议的类型实现指定的构造器。你可以像编写普通构造器那样，在协议的定义里写下构造器的声明，但不需要写花括号和构造器的实体： 123protocol SomeProtocol &#123; init(someParameter: Int)&#125; 协议中的构造器在类中的实现你可以在遵循协议的类中实现构造器，无论是作为指定构造器，还是作为便利构造器。无论哪种情况，你都必须为构造器实现标上 required 修饰符： 12345class SomeClass: SomeProtocol &#123; required init(someParameter: Int) &#123; // initializer implementation goes here &#125;&#125; 使用 required 修饰符可以确保所有子类也必须提供此构造器实现，从而也能符合协议。 如果类已经被标记为 final，那么不需要在协议构造器的实现中使用 required 修饰符，因为 final 类不能有子类。 如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求，那么该构造器的实现需要同时标注 required 和 override 修饰符： 12345678910111213141516protocol SomeProtocol &#123; init()&#125; class SomeSuperClass &#123; init() &#123; // initializer implementation goes here &#125;&#125; class SomeSubClass: SomeSuperClass, SomeProtocol &#123; // "required" from SomeProtocol conformance; "override" from SomeSuperClass required override init() &#123; // initializer implementation goes here &#125;&#125; 可失败构造器要求协议还可以为遵循协议的类型定义可失败构造器要求遵循协议的类型可以通过可失败构造器（init?）或非可失败构造器（init）来满足协议中定义的可失败构造器要求。协议中定义的非可失败构造器要求可以通过非可失败构造器（init）或隐式解包可失败构造器（init!）来满足。 协议作为类型尽管协议本身并未实现任何功能，但是协议可以被当做一个成熟的类型来使用。协议可以像其他普通类型一样使用，使用场景包括： 作为函数、方法或构造器中的参数类型或返回值类型 作为常量、变量或属性的类型 作为数组、字典或其他容器中的元素类型 协议是一种类型，因此协议类型的名称应与其他类型（例如 Int，Double，String）的写法相同，使用大写字母开头的驼峰式写法，例如（FullyNamed 和 RandomNumberGenerator）。 下面是将协议作为类型使用的例子： 1234567891011class Dice &#123; let sides: Int let generator: RandomNumberGenerator init(sides: Int, generator: RandomNumberGenerator) &#123; self.sides = sides self.generator = generator &#125; func roll() -&gt; Int &#123; return Int(generator.random() * Double(sides)) + 1 &#125;&#125; 例子中定义了一个 Dice 类，用来代表桌游中拥有 N 个面的骰子。Dice 的实例含有 sides 和 generator 两个属性，前者是整型，用来表示骰子有几个面，后者为骰子提供一个随机数生成器，从而生成随机点数。generator 属性的类型为 RandomNumberGenerator，因此任何遵循了 RandomNumberGenerator 协议的类型的实例都可以赋值给 generator，除此之外并无其他要求。Dice 类还有一个构造器，用来设置初始状态。构造器有一个名为 generator，类型为 RandomNumberGenerator 的形参。在调用构造方法创建 Dice 的实例时，可以传入任何遵循 RandomNumberGenerator 协议的实例给 generator。Dice 类提供了一个名为 roll 的实例方法，用来模拟骰子的面值。它先调用 generator 的 random() 方法来生成一个 [0.0,1.0) 区间内的随机数，然后使用这个随机数生成正确的骰子面值。因为 generator 遵循了 RandomNumberGenerator 协议，可以确保它有个 random() 方法可供调用。 下面的例子展示了如何使用 LinearCongruentialGenerator 的实例作为随机数生成器来创建一个六面骰子： 123456789var d6 = Dice(sides: 6, generator: LinearCongruentialGenerator())for _ in 1...5 &#123; print("Random dice roll is \(d6.roll())")&#125;// Random dice roll is 3// Random dice roll is 5// Random dice roll is 4// Random dice roll is 5// Random dice roll is 4 委托（代理）模式委托是一种设计模式，它允许类或结构体将一些需要它们负责的功能委托给其他类型的实例。委托模式的实现很简单：定义协议来封装那些需要被委托的功能，这样就能确保遵循协议的类型能提供这些功能。委托模式可以用来响应特定的动作，或者接收外部数据源提供的数据，而无需关心外部数据源的类型。下面的例子定义了两个基于骰子游戏的协议： 123456789protocol DiceGame &#123; var dice: Dice &#123; get &#125; func play()&#125;protocol DiceGameDelegate &#123; func gameDidStart(_ game: DiceGame) func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) func gameDidEnd(_ game: DiceGame)&#125; DiceGame 协议可以被任意涉及骰子的游戏遵循。DiceGameDelegate 协议可以被任意类型遵循，用来追踪 DiceGame 的游戏过程。 如下所示，SnakesAndLadders 是 控制流 章节引入的蛇梯棋游戏的新版本。新版本使用 Dice 实例作为骰子，并且实现了 DiceGame 和 DiceGameDelegate 协议，后者用来记录游戏的过程： 123456789101112131415161718192021222324252627282930class SnakesAndLadders: DiceGame &#123; let finalSquare = 25 let dice = Dice(sides: 6, generator: LinearCongruentialGenerator()) var square = 0 var board: [Int] init() &#123; board = Array(repeating: 0, count: finalSquare + 1) board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02 board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08 &#125; var delegate: DiceGameDelegate? func play() &#123; square = 0 delegate?.gameDidStart(self) gameLoop: while square != finalSquare &#123; let diceRoll = dice.roll() delegate?.game(self, didStartNewTurnWithDiceRoll: diceRoll) switch square + diceRoll &#123; case finalSquare: break gameLoop case let newSquare where newSquare &gt; finalSquare: continue gameLoop default: square += diceRoll square += board[square] &#125; &#125; delegate?.gameDidEnd(self) &#125;&#125; 这个版本的游戏封装到了 SnakesAndLadders 类中，该类遵循了 DiceGame 协议，并且提供了相应的可读的 dice 属性和 play() 方法。（ dice 属性在构造之后就不再改变，且协议只要求 dice 为可读的，因此将 dice 声明为常量属性。）游戏使用 SnakesAndLadders 类的 init() 构造器来初始化游戏。所有的游戏逻辑被转移到了协议中的 play() 方法，play() 方法使用协议要求的 dice 属性提供骰子摇出的值。注意，delegate 并不是游戏的必备条件，因此 delegate 被定义为 DiceGameDelegate 类型的可选属性。因为 delegate 是可选值，因此会被自动赋予初始值 nil。随后，可以在游戏中为 delegate 设置适当的值。 DicegameDelegate 协议提供了三个方法用来追踪游戏过程。这三个方法被放置于游戏的逻辑中，即 play() 方法内。分别在游戏开始时，新一轮开始时，以及游戏结束时被调用。 因为 delegate 是一个 DiceGameDelegate 类型的可选属性，因此在 play() 方法中通过可选链式调用来调用它的方法。若 delegate 属性为 nil，则调用方法会优雅地失败，并不会产生错误。若 delegate 不为 nil，则方法能够被调用，并传递 SnakesAndLadders 实例作为参数。 如下示例定义了 DiceGameTracker 类，它遵循了 DiceGameDelegate 协议： 1234567891011121314151617class DiceGameTracker: DiceGameDelegate &#123; var numberOfTurns = 0 func gameDidStart(_ game: DiceGame) &#123; numberOfTurns = 0 if game is SnakesAndLadders &#123; print("Started a new game of Snakes and Ladders") &#125; print("The game is using a \(game.dice.sides)-sided dice") &#125; func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) &#123; numberOfTurns += 1 print("Rolled a \(diceRoll)") &#125; func gameDidEnd(_ game: DiceGame) &#123; print("The game lasted for \(numberOfTurns) turns") &#125;&#125; DiceGameTracker 实现了 DiceGameDelegate 协议要求的三个方法，用来记录游戏已经进行的轮数。当游戏开始时，numberOfTurns 属性被赋值为 0，然后在每新一轮中递增，游戏结束后，打印游戏的总轮数。DiceGameTracker 的运行情况如下所示： 1234567891011let tracker = DiceGameTracker()let game = SnakesAndLadders()game.delegate = trackergame.play()// Started a new game of Snakes and Ladders// The game is using a 6-sided dice// Rolled a 3// Rolled a 5// Rolled a 4// Rolled a 5// The game lasted for 4 turns 通过扩展遵循协议即便无法修改源代码，依然可以通过扩展令已有类型遵循并符合协议。扩展可以为已有类型添加属性、方法、下标以及构造器，因此可以符合协议中的相应要求。 通过扩展令已有类型遵循并符合协议时，该类型的所有实例也会随之获得协议中定义的各项功能。 例如下面这个 TextRepresentable 协议，任何想要通过文本表示一些内容的类型都可以实现该协议。这些想要表示的内容可以是实例本身的描述，也可以是实例当前状态的文本描述： 123protocol TextRepresentable &#123; var textualDescription: String &#123; get &#125;&#125; 可以通过扩展，令先前提到的 Dice 类遵循并符合 TextRepresentable 协议： 12345extension Dice: TextRepresentable &#123; var textualDescription: String &#123; return "A \(sides)-sided dice" &#125;&#125; 通过扩展遵循并符合协议，和在原始定义中遵循并符合协议的效果完全相同。协议名称写在类型名之后，以冒号隔开，然后在扩展的大括号内实现协议要求的内容。现在所有 Dice 的实例都可以看做 TextRepresentable 类型： 123let d12 = Dice(sides: 12, generator: LinearCongruentialGenerator())print(d12.textualDescription)// Prints "A 12-sided dice" 同样，SnakesAndLadders 类也可以通过扩展遵循并符合 TextRepresentable 协议： 1234567extension SnakesAndLadders: TextRepresentable &#123; var textualDescription: String &#123; return "A game of Snakes and Ladders with \(finalSquare) squares" &#125;&#125;print(game.textualDescription)// Prints "A game of Snakes and Ladders with 25 squares" 通过扩展遵循协议当一个类型已经符合了某个协议中的所有要求，却还没有声明遵循该协议时，可以通过空扩展体的扩展来遵循该协议： 1234567struct Hamster &#123; var name: String var textualDescription: String &#123; return "A hamster named \(name)" &#125;&#125;extension Hamster: TextRepresentable &#123;&#125; 从现在起，Hamster 的实例可以作为 TextRepresentable 类型使用： 1234let simonTheHamster = Hamster(name: "Simon")let somethingTextRepresentable: TextRepresentable = simonTheHamsterprint(somethingTextRepresentable.textualDescription)// Prints "A hamster named Simon" 即使满足了协议的所有要求，类型也不会自动遵循协议，必须显式地遵循协议。 协议类型的集合协议类型可以在数组或者字典这样的集合中使用，在协议类型提到了这样的用法。下面的例子创建了一个元素类型为 TextRepresentable 的数组： 1let things: [TextRepresentable] = [game, d12, simonTheHamster] 如下所示，可以遍历 things 数组，并打印每个元素的文本表示： 123456for thing in things &#123; print(thing.textualDescription)&#125;// A game of Snakes and Ladders with 25 squares// A 12-sided dice// A hamster named Simon thing 是 TextRepresentable 类型而不是 Dice，DiceGame，Hamster 等类型，即使实例在幕后确实是这些类型中的一种。由于 thing 是 TextRepresentable 类型，任何 TextRepresentable 的实例都有一个 textualDescription 属性，所以在每次循环中可以安全地访问 thing.textualDescription。 协议的继承协议能够继承一个或多个其他协议，可以在继承的协议的基础上增加新的要求。协议的继承语法与类的继承相似，多个被继承的协议间用逗号分隔： 123protocol InheritingProtocol: SomeProtocol, AnotherProtocol &#123; // protocol definition goes here&#125; 如下所示，PrettyTextRepresentable 协议继承了 TextRepresentable 协议： 123protocol PrettyTextRepresentable: TextRepresentable &#123; var prettyTextualDescription: String &#123; get &#125;&#125; 例子中定义了一个新的协议 PrettyTextRepresentable，它继承自 TextRepresentable 协议。任何遵循 PrettyTextRepresentable 协议的类型在满足该协议的要求时，也必须满足 TextRepresentable 协议的要求。在这个例子中，PrettyTextRepresentable 协议额外要求遵循协议的类型提供一个返回值为 String 类型的 prettyTextualDescription 属性。 如下所示，扩展 SnakesAndLadders，使其遵循并符合 PrettyTextRepresentable 协议： 12345678910111213141516extension SnakesAndLadders: PrettyTextRepresentable &#123; var prettyTextualDescription: String &#123; var output = textualDescription + ":\n" for index in 1...finalSquare &#123; switch board[index] &#123; case let ladder where ladder &gt; 0: output += "▲ " case let snake where snake &lt; 0: output += "▼ " default: output += "○ " &#125; &#125; return output &#125;&#125; 上述扩展令 SnakesAndLadders 遵循了 PrettyTextRepresentable 协议，并提供了协议要求的 prettyTextualDescription 属性。每个 PrettyTextRepresentable 类型同时也是 TextRepresentable 类型，所以在 prettyTextualDescription 的实现中，可以访问 textualDescription 属性。 任意 SankesAndLadders 的实例都可以使用 prettyTextualDescription 属性来打印一个漂亮的文本描述： 123print(game.prettyTextualDescription)// A game of Snakes and Ladders with 25 squares:// ○ ○ ▲ ○ ○ ▲ ○ ○ ▲ ▲ ○ ○ ○ ▼ ○ ○ ○ ○ ▼ ○ ○ ▼ ○ ▼ ○ 类类型专属协议你可以在协议的继承列表中，通过添加 class 关键字来限制协议只能被类类型遵循，而结构体或枚举不能遵循该协议。class 关键字必须第一个出现在协议的继承列表中，在其他继承的协议之前： 123protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol &#123; // class-only protocol definition goes here&#125; 在以上例子中，协议 SomeClassOnlyProtocol 只能被类类型遵循。如果尝试让结构体或枚举类型遵循该协议，则会导致编译错误。 当协议定义的要求需要遵循协议的类型必须是引用语义而非值语义时，应该采用类类型专属协议。 协议合成有时候需要同时遵循多个协议，你可以将多个协议采用 SomeProtocol &amp; AnotherProtocol 这样的格式进行组合，称为 协议合成（protocol composition）。你可以罗列任意多个你想要遵循的协议，以与符号(&amp;)分隔。 下面的例子中，将 Named 和 Aged 两个协议按照上述语法组合成一个协议，作为函数参数的类型： 12345678910111213141516protocol Named &#123; var name: String &#123; get &#125;&#125;protocol Aged &#123; var age: Int &#123; get &#125;&#125;struct Person: Named, Aged &#123; var name: String var age: Int&#125;func wishHappyBirthday(to celebrator: Named &amp; Aged) &#123; print("Happy birthday, \(celebrator.name), you're \(celebrator.age)!")&#125;let birthdayPerson = Person(name: "Malcolm", age: 21)wishHappyBirthday(to: birthdayPerson)// Prints "Happy birthday, Malcolm, you're 21!" Named 协议包含 String 类型的 name 属性。Aged 协议包含 Int 类型的 age 属性。Person 结构体遵循了这两个协议。wishHappyBirthday(to:) 函数的参数 celebrator 的类型为 Named &amp; Aged。这意味着它不关心参数的具体类型，只要参数符合这两个协议即可。上面的例子创建了一个名为 birthdayPerson 的 Person 的实例，作为参数传递给了 wishHappyBirthday(to:) 函数。因为 Person 同时符合这两个协议，所以这个参数合法，函数将打印生日问候语。 协议合成并不会生成新的、永久的协议类型，而是将多个协议中的要求合成到一个只在局部作用域有效的临时协议中。 检查协议一致性你可以使用类型转换中描述的 is 和 as 操作符来检查协议一致性，即是否符合某协议，并且可以转换到指定的协议类型。检查和转换到某个协议类型在语法上和类型的检查和转换完全相同： is 用来检查实例是否符合某个协议，若符合则返回 true，否则返回 false。 as? 返回一个可选值，当实例符合某个协议时，返回类型为协议类型的可选值，否则返回 nil。 as! 将实例强制向下转换到某个协议类型，如果强转失败，会引发运行时错误。 This example defines a protocol called HasArea, with a single property requirement of a gettable Double property called area: 123protocol HasArea &#123; var area: Double &#123; get &#125;&#125; Here are two classes, Circle and Country, both of which conform to the HasArea protocol: 12345678910class Circle: HasArea &#123; let pi = 3.1415927 var radius: Double var area: Double &#123; return pi * radius * radius &#125; init(radius: Double) &#123; self.radius = radius &#125;&#125;class Country: HasArea &#123; var area: Double init(area: Double) &#123; self.area = area &#125;&#125; Circle 类把 area 属性实现为基于存储型属性 radius 的计算型属性。Country 类则把 area 属性实现为存储型属性。这两个类都正确地符合了 HasArea 协议。 如下所示，Animal 是一个未遵循 HasArea 协议的类： 1234class Animal &#123; var legs: Int init(legs: Int) &#123; self.legs = legs &#125;&#125; Circle，Country，Animal 并没有一个共同的基类，尽管如此，它们都是类，它们的实例都可以作为 AnyObject 类型的值，存储在同一个数组中： 12345let objects: [AnyObject] = [ Circle(radius: 2.0), Country(area: 243_610), Animal(legs: 4)] 如下所示，objects 数组可以被迭代，并对迭代出的每一个元素进行检查，看它是否符合 HasArea 协议： 12345678910for object in objects &#123; if let objectWithArea = object as? HasArea &#123; print("Area is \(objectWithArea.area)") &#125; else &#123; print("Something that doesn't have an area") &#125;&#125;// Area is 12.5663708// Area is 243610.0// Something that doesn't have an area 当迭代出的元素符合 HasArea 协议时，将 as? 操作符返回的可选值通过可选绑定，绑定到 objectWithArea 常量上。objectWithArea 是 HasArea 协议类型的实例，因此 area 属性可以被访问和打印。 objects 数组中的元素的类型并不会因为强转而丢失类型信息，它们仍然是 Circle，Country，Animal 类型。然而，当它们被赋值给 objectWithArea 常量时，只被视为 HasArea 类型，因此只有 area 属性能够被访问。 可选的协议要求协议可以定义可选要求，遵循协议的类型可以选择是否实现这些要求。在协议中使用 optional 关键字作为前缀来定义可选要求。可选要求用在你需要和 Objective-C 打交道的代码中。协议和可选要求都必须带上@objc属性。标记 @objc 特性的协议只能被继承自 Objective-C 类的类或者 @objc 类遵循，其他类以及结构体和枚举均不能遵循这种协议。 使用可选要求时（例如，可选的方法或者属性），它们的类型会自动变成可选的。比如，一个类型为 (Int) -&gt; String 的方法会变成 ((Int) -&gt; String)? 协议中的可选要求可通过可选链式调用来使用，因为遵循协议的类型可能没有实现这些可选要求。类似 someOptionalMethod?(someArgument) 这样，你可以在可选方法名称后加上 ? 来调用可选方法。 下面的例子定义了一个名为 Counter 的用于整数计数的类，它使用外部的数据源来提供每次的增量。数据源由 CounterDataSource 协议定义，包含两个可选要求： 1234@objc protocol CounterDataSource &#123; @objc optional func increment(forCount count: Int) -&gt; Int @objc optional var fixedIncrement: Int &#123; get &#125;&#125; CounterDataSource 协议定义了一个可选方法 increment(forCount:) 和一个可选属性 fiexdIncrement，它们使用了不同的方法来从数据源中获取适当的增量值。 严格来讲，CounterDataSource 协议中的方法和属性都是可选的，因此遵循协议的类可以不实现这些要求 Counter 类含有 CounterDataSource? 类型的可选属性 dataSource，如下所示： 1234567891011class Counter &#123; var count = 0 var dataSource: CounterDataSource? func increment() &#123; if let amount = dataSource?.increment?(forCount: count) &#123; count += amount &#125; else if let amount = dataSource?.fixedIncrement &#123; count += amount &#125; &#125;&#125; 下面的例子展示了 CounterDataSource 的简单实现。ThreeSource 类遵循了 CounterDataSource 协议，它实现了可选属性 fixedIncrement，每次会返回 3： 123class ThreeSource: NSObject, CounterDataSource &#123; let fixedIncrement = 3&#125; 可以使用 ThreeSource 的实例作为 Counter 实例的数据源： 12345678910var counter = Counter()counter.dataSource = ThreeSource()for _ in 1...4 &#123; counter.increment() print(counter.count)&#125;// 3// 6// 9// 12 上述代码新建了一个 Counter 实例，并将它的数据源设置为一个 ThreeSource 的实例，然后调用 increment() 方法四次。和预期一样，每次调用都会将 count 的值增加 3. 下面是一个更为复杂的数据源 TowardsZeroSource，它将使得最后的值变为 0： 1234567891011@objc class TowardsZeroSource: NSObject, CounterDataSource &#123; func increment(forCount count: Int) -&gt; Int &#123; if count == 0 &#123; return 0 &#125; else if count &lt; 0 &#123; return 1 &#125; else &#123; return -1 &#125; &#125;&#125; 你可以使用 TowardsZeroSource 实例将 Counter 实例来从 -4 增加到 0。一旦增加到 0，数值便不会再有变动： 1234567891011counter.count = -4counter.dataSource = TowardsZeroSource()for _ in 1...5 &#123; counter.increment() print(counter.count)&#125;// -3// -2// -1// 0// 0 协议扩展协议可以通过扩展来为遵循协议的类型提供属性、方法以及下标的实现。通过这种方式，你可以基于协议本身来实现这些功能，而无需在每个遵循协议的类型中都重复同样的实现，也无需使用全局函数。例如，可以扩展 RandomNumberGenerator 协议来提供 randomBool() 方法。该方法使用协议中定义的 random() 方法来返回一个随机的 Bool 值： 12345extension RandomNumberGenerator &#123; func randomBool() -&gt; Bool &#123; return random() &gt; 0.5 &#125;&#125; 通过协议扩展，所有遵循协议的类型，都能自动获得这个扩展所增加的方法实现，无需任何额外修改： 12345let generator = LinearCongruentialGenerator()print("Here's a random number: \(generator.random())")// Prints "Here's a random number: 0.37464991998171"print("And here's a random Boolean: \(generator.randomBool())")// Prints "And here's a random Boolean: true" 提供默认实现可以通过协议扩展来为协议要求的属性、方法以及下标提供默认的实现。如果遵循协议的类型为这些要求提供了自己的实现，那么这些自定义实现将会替代扩展中的默认实现被使用。 通过协议扩展为协议要求提供的默认实现和可选的协议要求不同。虽然在这两种情况下，遵循协议的类型都无需自己实现这些要求，但是通过扩展提供的默认实现可以直接调用，而无需使用可选链式调用。 例如，PrettyTextRepresentable 协议继承自 TextRepresentable 协议，可以为其提供一个默认的 prettyTextualDescription 属性，只是简单地返回 textualDescription 属性的值： 12345extension PrettyTextRepresentable &#123; var prettyTextualDescription: String &#123; return textualDescription &#125;&#125; 为协议扩展添加限制条件在扩展协议的时候，可以指定一些限制条件，只有遵循协议的类型满足这些限制条件时，才能获得协议扩展提供的默认实现。这些限制条件写在协议名之后，使用 where 子句来描述例如，你可以扩展 CollectionType 协议，但是只适用于集合中的元素遵循了 TextRepresentable 协议的情况： 123456extension Collection where Iterator.Element: TextRepresentable &#123; var textualDescription: String &#123; let itemsAsText = self.map &#123; $0.textualDescription &#125; return "[" + itemsAsText.joined(separator: ", ") + "]" &#125;&#125; textualDescription 属性返回整个集合的文本描述，它将集合中的每个元素的文本描述以逗号分隔的方式连接起来，包在一对方括号中。现在我们来看看先前的 Hamster 结构体，它符合 TextRepresentable 协议，同时这里还有个装有 Hamster 的实例的数组： 1234let murrayTheHamster = Hamster(name: "Murray")let morganTheHamster = Hamster(name: "Morgan")let mauriceTheHamster = Hamster(name: "Maurice")let hamsters = [murrayTheHamster, morganTheHamster, mauriceTheHamster] 因为 Array 符合 CollectionType 协议，而数组中的元素又符合 TextRepresentable 协议，所以数组可以使用 textualDescription 属性得到数组内容的文本表示： 12print(hamsters.textualDescription)// Prints "[A hamster named Murray, A hamster named Morgan, A hamster named Maurice]" 如果多个协议扩展都为同一个协议要求提供了默认实现，而遵循协议的类型又同时满足这些协议扩展的限制条件，那么将会使用限制条件最多的那个协议扩展提供的默认实现。 参照文档 Protocols &gt;&gt; Copyright (c) liangtong. All rights reserved.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift Generics]]></title>
    <url>%2F2016%2F12%2F02%2FiOS_Swift_language_note_Generics%2F</url>
    <content type="text"><![CDATA[​​ 泛型代码让你编写出适用于任意类型、灵活可重用的函数及类型。它能让你避免代码的重复，用一种清晰和抽象的方式来表达代码的意图。 泛型所解决的问题下面是一个标准的非泛型函数 swapTwoInts(::)，用来交换两个 Int 值： 12345func swapTwoInts(_ a: inout Int, _ b: inout Int) &#123; let temporaryA = a a = b b = temporaryA&#125; swapTwoInts(::) 函数交换 b 的原始值到 a，并交换 a 的原始值到 b。你可以调用这个函数交换两个 Int 变量的值： 12345var someInt = 3var anotherInt = 107swapTwoInts(&amp;someInt, &amp;anotherInt)print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")// Prints "someInt is now 107, and anotherInt is now 3" swapTwoInts(::) 函数挺有用，但是它只能交换 Int 值，如果你想要交换两个 String 值或者 Double值，就不得不写更多的函数，例如 swapTwoStrings(::) 和 swapTwoDoubles(::)，如下所示： 1234567891011func swapTwoStrings(_ a: inout String, _ b: inout String) &#123; let temporaryA = a a = b b = temporaryA&#125; func swapTwoDoubles(_ a: inout Double, _ b: inout Double) &#123; let temporaryA = a a = b b = temporaryA&#125; swapTwoInts(::)、swapTwoStrings(::) 和 swapTwoDoubles(::) 的函数功能都是相同的，唯一不同之处就在于传入的变量类型不同，分别是 Int、String 和 Double。 泛型函数泛型函数可以适用于任何类型，下面的 swapTwoValues(::) 函数是上面三个函数的泛型版本： 12345func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) &#123; let temporaryA = a a = b b = temporaryA&#125; swapTwoValues(::) 的函数主体和 swapTwoInts(::) 函数是一样的，它们只在第一行有点不同：这个函数的泛型版本使用了占位类型名（在这里用字母 T 来表示）来代替实际类型名（例如 Int、String 或 Double）。占位类型名没有指明 T 必须是什么类型，但是它指明了 a 和 b 必须是同一类型 T，无论 T 代表什么类型。只有 swapTwoValues(::) 函数在调用时，才能根据所传入的实际类型决定 T 所代表的类型。另外一个不同之处在于这个泛型函数名（swapTwoValues(::)）后面跟着占位类型名（T），并用尖括号括起来（）。这个尖括号告诉 Swift 那个 T 是 swapTwoValues(::) 函数定义内的一个占位类型名，因此 Swift 不会去查找名为 T 的实际类型。 123456789var someInt = 3var anotherInt = 107swapTwoValues(&amp;someInt, &amp;anotherInt)// someInt is now 107, and anotherInt is now 3 var someString = "hello"var anotherString = "world"swapTwoValues(&amp;someString, &amp;anotherString)// someString is now "world", and anotherString is now "hello" 类型参数类型参数指定并命名一个占位类型，并且紧随在函数名后面，使用一对尖括号括起来（例如 ）。一旦一个类型参数被指定，你可以用它来定义一个函数的参数类型（例如 swapTwoValues(::) 函数中的参数 a 和 b），或者作为函数的返回类型，还可以用作函数主体中的注释类型。在这些情况下，类型参数会在函数调用时被实际类型所替换。（在上面的 swapTwoValues(::) 例子中，当函数第一次被调用时，T 被 Int 替换，第二次调用时，被 String 替换。）你可提供多个类型参数，将它们都写在尖括号中，用逗号分开。 命名类型参数在大多数情况下，类型参数具有一个描述性名字，例如 Dictionary 中的 Key 和 Value，以及 Array 中的 Element，这可以告诉阅读代码的人这些类型参数和泛型函数之间的关系。然而，当它们之间没有有意义的关系时，通常使用单个字母来命名，例如 T、U、V，正如上面演示的 swapTwoValues(::) 函数中的 T 一样。 请始终使用大写字母开头的驼峰命名法（例如 T 和 MyTypeParameter）来为类型参数命名，以表明它们是占位类型，而不是一个值。 泛型类型除了泛型函数，Swift 还允许你定义泛型类型。这些自定义类、结构体和枚举可以适用于任何类型，类似于 Array 和 Dictionary。 这部分内容将向你展示如何编写一个名为 Stack （栈）的泛型集合类型。栈是一系列值的有序集合，和 Array 类似，但它相比 Swift 的 Array 类型有更多的操作限制。数组允许在数组的任意位置插入新元素或是删除其中任意位置的元素。而栈只允许在集合的末端添加新的元素（称之为入栈）。类似的，栈也只能从末端移除元素（称之为出栈）。 下图展示了一个栈的入栈（push）和出栈（pop）的行为： 下面展示了如何编写一个非泛型版本的栈，以 Int 型的栈为例： 123456789struct IntStack &#123; var items = [Int]() mutating func push(_ item: Int) &#123; items.append(item) &#125; mutating func pop() -&gt; Int &#123; return items.removeLast() &#125;&#125; 这个结构体在栈中使用一个名为 items 的 Array 属性来存储值。Stack 提供了两个方法：push(_:) 和 pop()，用来向栈中压入值以及从栈中移除值。这些方法被标记为 mutating，因为它们需要修改结构体的 items 数组。上面的 IntStack 结构体只能用于 Int 类型。不过，可以定义一个泛型 Stack 结构体，从而能够处理任意类型的值。 下面是相同代码的泛型版本： 123456789struct Stack&lt;Element&gt; &#123; var items = [Element]() mutating func push(_ item: Element) &#123; items.append(item) &#125; mutating func pop() -&gt; Element &#123; return items.removeLast() &#125;&#125; Element 为待提供的类型定义了一个占位名。这种待提供的类型可以在结构体的定义中通过 Element 来引用。在这个例子中，Element 在如下三个地方被用作占位符： 创建 items 属性，使用 Element 类型的空数组对其进行初始化。 指定 push(_:) 方法的唯一参数 item 的类型必须是 Element 类型。 指定 pop() 方法的返回值类型必须是 Element 类型。 由于 Stack 是泛型类型，因此可以用来创建 Swift 中任意有效类型的栈，就像 Array 和 Dictionary 那样。 123456var stackOfStrings = Stack&lt;String&gt;()stackOfStrings.push("uno")stackOfStrings.push("dos")stackOfStrings.push("tres")stackOfStrings.push("cuatro")// the stack now contains 4 strings 移除并返回栈顶部的值 “cuatro”，即将其出栈： 12let fromTheTop = stackOfStrings.pop()// fromTheTop is equal to "cuatro", and the stack now contains 3 strings 扩展一个泛型类型当你扩展一个泛型类型的时候，你并不需要在扩展的定义中提供类型参数列表。原始类型定义中声明的类型参数列表在扩展中可以直接使用，并且这些来自原始类型中的参数名称会被用作原始定义中类型参数的引用。 下面的例子扩展了泛型类型 Stack，为其添加了一个名为 topItem 的只读计算型属性，它将会返回当前栈顶端的元素而不会将其从栈中移除： 12345extension Stack &#123; var topItem: Element? &#123; return items.isEmpty ? nil : items[items.count - 1] &#125;&#125; 注意，这个扩展并没有定义一个类型参数列表。相反的，Stack 类型已有的类型参数名称 Element，被用在扩展中来表示计算型属性 topItem 的可选类型。计算型属性 topItem 现在可以用来访问任意 Stack 实例的顶端元素且不移除它： 1234if let topItem = stackOfStrings.topItem &#123; print("The top item on the stack is \(topItem).")&#125;// Prints "The top item on the stack is tres." 类型约束swapTwoValues(::) 函数和 Stack 类型可以作用于任何类型。不过，有的时候如果能将使用在泛型函数和泛型类型中的类型添加一个特定的类型约束，将会是非常有用的。类型约束可以指定一个类型参数必须继承自指定类，或者符合一个特定的协议或协议组合。例如，Swift 的 Dictionary 类型对字典的键的类型做了些限制。在字典的描述中，字典的键的类型必须是可哈希（hashable）的。也就是说，必须有一种方法能够唯一地表示它。Dictionary 的键之所以要是可哈希的，是为了便于检查字典是否已经包含某个特定键的值。若没有这个要求，Dictionary 将无法判断是否可以插入或者替换某个指定键的值，也不能查找到已经存储在字典中的指定键的值。为了实现这个要求，一个类型约束被强制加到 Dictionary 的键类型上，要求其键类型必须符合 Hashable 协议，这是 Swift 标准库中定义的一个特定协议。所有的 Swift 基本类型（例如 String、Int、Double 和 Bool）默认都是可哈希的。当你创建自定义泛型类型时，你可以定义你自己的类型约束，这些约束将提供更为强大的泛型编程能力。抽象概念，例如可哈希的，描述的是类型在概念上的特征，而不是它们的显式类型。 类型约束语法你可以在一个类型参数名后面放置一个类名或者协议名，并用冒号进行分隔，来定义类型约束，它们将成为类型参数列表的一部分。对泛型函数添加类型约束的基本语法如下所示（作用于泛型类型时的语法与之相同）： 123func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) &#123; // function body goes here&#125; 上面这个函数有两个类型参数。第一个类型参数 T，有一个要求 T 必须是 SomeClass 子类的类型约束；第二个类型参数 U，有一个要求 U 必须符合 SomeProtocol 协议的类型约束。 类型约束实践这里有个名为 findIndex(ofString:in:) 的非泛型函数，该函数的功能是在一个 String 数组中查找给定 String 值的索引。若查找到匹配的字符串，findIndex(ofString:in:) 函数返回该字符串在数组中的索引值，否则返回 nil： 12345678func findIndex(ofString valueToFind: String, in array: [String]) -&gt; Int? &#123; for (index, value) in array.enumerated() &#123; if value == valueToFind &#123; return index &#125; &#125; return nil&#125; findIndex(ofString:in:) 函数可以用于查找字符串数组中的某个字符串： 12345let strings = ["cat", "dog", "llama", "parakeet", "terrapin"]if let foundIndex = findIndex(ofString: "llama", in: strings) &#123; print("The index of llama is \(foundIndex)")&#125;// Prints "The index of llama is 2" 下面展示了 findIndex(ofString:in:) 函数的泛型版本 findIndex(ofString:in:)。请注意这个函数返回值的类型仍然是 Int?，这是因为函数返回的是一个可选的索引数，而不是从数组中得到的一个可选值。需要提醒的是，这个函数无法通过编译，原因会在例子后面说明： 12345678func findIndex&lt;T&gt;(of valueToFind: T, in array:[T]) -&gt; Int? &#123; for (index, value) in array.enumerated() &#123; if value == valueToFind &#123; return index &#125; &#125; return nil&#125; 上面所写的函数无法通过编译。问题出在相等性检查上，即 “if value == valueToFind”。不是所有的 Swift 类型都可以用等式符（==）进行比较。比如说，如果你创建一个自定义的类或结构体来表示一个复杂的数据模型，那么 Swift 无法猜到对于这个类或结构体而言“相等”意味着什么。正因如此，这部分代码无法保证适用于每个可能的类型 T，当你试图编译这部分代码时会出现相应的错误。不过，所有的这些并不会让我们无从下手。Swift 标准库中定义了一个 Equatable 协议，该协议要求任何遵循该协议的类型必须实现等式符（==）及不等符(!=)，从而能对该类型的任意两个值进行比较。所有的 Swift 标准类型自动支持 Equatable 协议。 任何 Equatable 类型都可以安全地使用在 findIndex(of:in:) 函数中，因为其保证支持等式操作符。为了说明这个事实，当你定义一个函数时，你可以定义一个 Equatable 类型约束作为类型参数定义的一部分： 12345678func findIndex&lt;T: Equatable&gt;(of valueToFind: T, in array:[T]) -&gt; Int? &#123; for (index, value) in array.enumerated() &#123; if value == valueToFind &#123; return index &#125; &#125; return nil&#125; findIndex(of:in:) 唯一的类型参数写做 T: Equatable，也就意味着“任何符合 Equatable 协议的类型 T ”。 1234let doubleIndex = findIndex(of: 9.3, in: [3.14159, 0.1, 0.25])// doubleIndex is an optional Int with no value, because 9.3 is not in the arraylet stringIndex = findIndex(of: "Andrea", in: ["Mike", "Malcolm", "Andrea"])// stringIndex is an optional Int containing a value of 2 关联类型定义一个协议时，有的时候声明一个或多个关联类型作为协议定义的一部分将会非常有用。关联类型为协议中的某个类型提供了一个占位名（或者说别名），其代表的实际类型在协议被采纳时才会被指定。你可以通过 associatedtype 关键字来指定关联类型。 关联类型实践下面例子定义了一个 Container 协议，该协议定义了一个关联类型 ItemType： 123456protocol Container &#123; associatedtype ItemType mutating func append(_ item: ItemType) var count: Int &#123; get &#125; subscript(i: Int) -&gt; ItemType &#123; get &#125;&#125; Container 协议定义了三个任何采纳了该协议的类型（即容器）必须提供的功能： 必须可以通过 append(_:) 方法添加一个新元素到容器里。 必须可以通过 count 属性获取容器中元素的数量，并返回一个 Int 值。 必须可以通过索引值类型为 Int 的下标检索到容器中的每一个元素。 这个协议没有指定容器中元素该如何存储，以及元素必须是何种类型。这个协议只指定了三个任何遵从 Container 协议的类型必须提供的功能。遵从协议的类型在满足这三个条件的情况下也可以提供其他额外的功能。 为了定义这三个条件，Container 协议需要在不知道容器中元素的具体类型的情况下引用这种类型。Container 协议需要指定任何通过 append(_:) 方法添加到容器中的元素和容器中的元素是相同类型，并且通过容器下标返回的元素的类型也是这种类型。 为了达到这个目的，Container 协议声明了一个关联类型 ItemType，写作 associatedtype ItemType。这个协议无法定义 ItemType 是什么类型的别名，这个信息将留给遵从协议的类型来提供。尽管如此，ItemType 别名提供了一种方式来引用 Container 中元素的类型，并将之用于 append(_:) 方法和下标，从而保证任何 Container 的行为都能够正如预期地被执行。 下面是先前的非泛型的 IntStack 类型，这一版本采纳并符合了 Container 协议： 123456789101112131415161718192021struct IntStack: Container &#123; // original IntStack implementation var items = [Int]() mutating func push(_ item: Int) &#123; items.append(item) &#125; mutating func pop() -&gt; Int &#123; return items.removeLast() &#125; // conformance to the Container protocol typealias ItemType = Int mutating func append(_ item: Int) &#123; self.push(item) &#125; var count: Int &#123; return items.count &#125; subscript(i: Int) -&gt; Int &#123; return items[i] &#125;&#125; IntStack 结构体实现了 Container 协议的三个要求，其原有功能也不会和这些要求相冲突。此外，IntStack 在实现 Container 的要求时，指定 ItemType 为 Int 类型，即 typealias ItemType = Int，从而将 Container 协议中抽象的 ItemType 类型转换为具体的 Int 类型。 由于 Swift 的类型推断，你实际上不用在 IntStack 的定义中声明 ItemType 为 Int。因为 IntStack 符合 Container 协议的所有要求，Swift 只需通过 append(_:) 方法的 item 参数类型和下标返回值的类型，就可以推断出 ItemType 的具体类型。事实上，如果你在上面的代码中删除了 typealias ItemType = Int 这一行，一切仍旧可以正常工作，因为 Swift 清楚地知道 ItemType 应该是哪种类型。 你也可以让泛型 Stack 结构体遵从 Container 协议： 1234567891011121314151617181920struct Stack&lt;Element&gt;: Container &#123; // original Stack&lt;Element&gt; implementation var items = [Element]() mutating func push(_ item: Element) &#123; items.append(item) &#125; mutating func pop() -&gt; Element &#123; return items.removeLast() &#125; // conformance to the Container protocol mutating func append(_ item: Element) &#123; self.push(item) &#125; var count: Int &#123; return items.count &#125; subscript(i: Int) -&gt; Element &#123; return items[i] &#125;&#125; 这一次，占位类型参数 Element 被用作 append(_:) 方法的 item 参数和下标的返回类型。Swift 可以据此推断出 Element 的类型即是 ItemType 的类型。 通过扩展一个存在的类型来指定关联类型Swift 的 Array 类型已经提供 append(_:) 方法，一个 count 属性，以及一个接受 Int 类型索引值的下标用以检索其元素。这三个功能都符合 Container 协议的要求，也就意味着你只需简单地声明 Array 采纳该协议就可以扩展 Array，使其遵从 Container 协议。你可以通过一个空扩展来实现这点，正如通过扩展采纳协议中的描述： 1extension Array: Container &#123;&#125; 泛型 Where 语句类型约束让你能够为泛型函数或泛型类型的类型参数定义一些强制要求。 为关联类型定义约束也是非常有用的。你可以在参数列表中通过 where 子句为关联类型定义约束。你能通过 where 子句要求一个关联类型遵从某个特定的协议，以及某个特定的类型参数和关联类型必须类型相同。你可以通过将 where 关键字紧跟在类型参数列表后面来定义 where 子句，where 子句后跟一个或者多个针对关联类型的约束，以及一个或多个类型参数和关联类型间的相等关系。你可以在函数体或者类型的大括号之前添加 where 子句。 下面的例子定义了一个名为 allItemsMatch 的泛型函数，用来检查两个 Container 实例是否包含相同顺序的相同元素。如果所有的元素能够匹配，那么返回 true，否则返回 false。被检查的两个 Container 可以不是相同类型的容器（虽然它们可以相同），但它们必须拥有相同类型的元素。这个要求通过一个类型约束以及一个 where 子句来表示： 12345678910111213141516171819func allItemsMatch&lt;C1: Container, C2: Container&gt; (_ someContainer: C1, _ anotherContainer: C2) -&gt; Bool where C1.ItemType == C2.ItemType, C1.ItemType: Equatable &#123; // Check that both containers contain the same number of items. if someContainer.count != anotherContainer.count &#123; return false &#125; // Check each pair of items to see if they are equivalent. for i in 0..&lt;someContainer.count &#123; if someContainer[i] != anotherContainer[i] &#123; return false &#125; &#125; // All items match, so return true. return true&#125; 下面演示了 allItemsMatch(::) 函数的使用： 12345678910111213var stackOfStrings = Stack&lt;String&gt;()stackOfStrings.push("uno")stackOfStrings.push("dos")stackOfStrings.push("tres") var arrayOfStrings = ["uno", "dos", "tres"] if allItemsMatch(stackOfStrings, arrayOfStrings) &#123; print("All items match.")&#125; else &#123; print("Not all items match.")&#125;// Prints "All items match." 参照文档 Protocols &gt;&gt; Copyright (c) liangtong. All rights reserved.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift Extensions]]></title>
    <url>%2F2016%2F12%2F01%2FiOS_Swift_language_note_Extensions%2F</url>
    <content type="text"><![CDATA[​ 扩展为一个已有的类、结构体、枚举类型或者协议类型添加新功能。这包括在没有权限获取原始源代码的情况下扩展类型的能力（即 逆向建模 ）。扩展和 Objective-C 中的分类类似。（与 Objective-C 不同的是，Swift 的扩展没有名字。）在Swift中，扩展可以： 添加计算型属性和计算型类型属性 定义实例方法和类型方法 提供新的构造器 定义下标 定义和使用新的嵌套类型 使一个已有类型符合某个协议 在 Swift 中，你甚至可以对协议进行扩展，提供协议要求的实现，或者添加额外的功能，从而可以让符合协议的类型拥有这些功能。 扩展可以为一个类型添加新的功能，但是不能重写已有的功能。 扩展语法使用关键字 extension 来声明扩展： 123extension SomeType &#123; // new functionality to add to SomeType goes here&#125; 可以通过扩展来扩展一个已有类型，使其采纳一个或多个协议。在这种情况下，无论是类还是结构体，协议名字的书写方式完全一样： 123extension SomeType: SomeProtocol, AnotherProtocol &#123; // implementation of protocol requirements goes here&#125; 如果你通过扩展为一个已有类型添加新功能，那么新功能对该类型的所有已有实例都是可用的，即使它们是在这个扩展定义之前创建的。 计算型属性扩展可以为已有类型添加计算型实例属性和计算型类型属性。下面的例子为 Swift 的内建 Double 类型添加了五个计算型实例属性，从而提供与距离单位协作的基本支持： 12345678910111213extension Double &#123; var km: Double &#123; return self * 1_000.0 &#125; var m: Double &#123; return self &#125; var cm: Double &#123; return self / 100.0 &#125; var mm: Double &#123; return self / 1_000.0 &#125; var ft: Double &#123; return self / 3.28084 &#125;&#125;let oneInch = 25.4.mmprint("One inch is \(oneInch) meters")// Prints "One inch is 0.0254 meters"let threeFeet = 3.ftprint("Three feet is \(threeFeet) meters")// Prints "Three feet is 0.914399970739201 meters" 这些计算型属性表达的含义是把一个 Double 值看作是某单位下的长度值。即使它们被实现为计算型属性，但这些属性的名字仍可紧接一个浮点型字面值，从而通过点语法来使用，并以此实现距离转换。在上述例子中，Double 值 1.0 用来表示“1米”。这就是为什么计算型属性 m 返回 self，即表达式 1.m 被认为是计算 Double 值 1.0。其它单位则需要一些单位换算。一千米等于 1,000 米，所以计算型属性 km 要把值乘以 1_000.00 来实现千米到米的单位换算。类似地，一米有 3.28024 英尺，所以计算型属性 ft 要把对应的 Double 值除以 3.28024 来实现英尺到米的单位换算。 这些属性是只读的计算型属性，为了更简洁，省略了 get 关键字。它们的返回值是 Double，而且可以用于所有接受 Double 值的数学计算中： 123let aMarathon = 42.km + 195.mprint("A marathon is \(aMarathon) meters long")// Prints "A marathon is 42195.0 meters long" 扩展可以添加新的计算型属性，但是不可以添加存储型属性，也不可以为已有属性添加属性观察器。 构造器扩展可以为已有类型添加新的构造器。这可以让你扩展其它类型，将你自己的定制类型作为其构造器参数，或者提供该类型的原始实现中未提供的额外初始化选项。 扩展能为类添加新的便利构造器，但是它们不能为类添加新的指定构造器或析构器。指定构造器和析构器必须总是由原始的类实现来提供。 如果你使用扩展为一个值类型添加构造器，同时该值类型的原始实现中未定义任何定制的构造器且所有存储属性提供了默认值，那么我们就可以在扩展中的构造器里调用默认构造器和逐一成员构造器。如果你把定制的构造器写在值类型的原始实现中，规则将不再适用。 下面的例子定义了一个用于描述几何矩形的结构体 Rect。这个例子同时定义了两个辅助结构体 Size 和 Point，它们都把 0.0 作为所有属性的默认值： 12345678910struct Size &#123; var width = 0.0, height = 0.0&#125;struct Point &#123; var x = 0.0, y = 0.0&#125;struct Rect &#123; var origin = Point() var size = Size()&#125; 因为结构体 Rect 未提供定制的构造器，因此它会获得一个逐一成员构造器。又因为它为所有存储型属性提供了默认值，它又会获得一个默认构造器。 123let defaultRect = Rect()let memberwiseRect = Rect(origin: Point(x: 2.0, y: 2.0), size: Size(width: 5.0, height: 5.0)) 你可以提供一个额外的接受指定中心点和大小的构造器来扩展 Rect 结构体： 1234567extension Rect &#123; init(center: Point, size: Size) &#123; let originX = center.x - (size.width / 2) let originY = center.y - (size.height / 2) self.init(origin: Point(x: originX, y: originY), size: size) &#125;&#125; 这个新的构造器首先根据提供的 center 和 size 的值计算一个合适的原点。然后调用该结构体的逐一成员构造器 init(origin:size:)，该构造器将新的原点和大小的值保存到了相应的属性中： 123let centerRect = Rect(center: Point(x: 4.0, y: 4.0), size: Size(width: 3.0, height: 3.0))// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0) 如果你使用扩展提供了一个新的构造器，你依旧有责任确保构造过程能够让实例完全初始化。 方法扩展可以为已有类型添加新的实例方法和类型方法。下面的例子为 Int 类型添加了一个名为 repetitions 的实例方法： 1234567extension Int &#123; func repetitions(task: () -&gt; Void) &#123; for _ in 0..&lt;self &#123; task() &#125; &#125;&#125; 这个 repetitions(task:) 方法接受一个 () -&gt; Void 类型的单参数，表示没有参数且没有返回值的函数。定义该扩展之后，你就可以对任意整数调用 repetitions(task:) 方法，将闭包中的任务执行整数对应的次数： 1234563.repetitions &#123; print("Hello!")&#125;// Hello!// Hello!// Hello! 可变实例方法通过扩展添加的实例方法也可以修改该实例本身。结构体和枚举类型中修改 self 或其属性的方法必须将该实例方法标注为 mutating，正如来自原始实现的可变方法一样。下面的例子为 Swift 的 Int 类型添加了一个名为 square 的可变方法，用于计算原始值的平方值： 12345678extension Int &#123; mutating func square() &#123; self = self * self &#125;&#125;var someInt = 3someInt.square()// someInt is now 9 下标扩展可以为已有类型添加新下标。这个例子为 Swift 内建类型 Int 添加了一个整型下标。该下标 [n] 返回十进制数字从右向左数的第 n 个数字： 1234567891011121314151617extension Int &#123; subscript(digitIndex: Int) -&gt; Int &#123; var decimalBase = 1 for _ in 0..&lt;digitIndex &#123; decimalBase *= 10 &#125; return (self / decimalBase) % 10 &#125;&#125;746381295[0]// returns 5746381295[1]// returns 9746381295[2]// returns 2746381295[8]// returns 7 如果该 Int 值没有足够的位数，即下标越界，那么上述下标实现会返回 0，犹如在数字左边自动补 0： 123746381295[9]// returns 0, as if you had requested:0746381295[9] 嵌套类型扩展可以为已有的类、结构体和枚举添加新的嵌套类型： 123456789101112131415extension Int &#123; enum Kind &#123; case negative, zero, positive &#125; var kind: Kind &#123; switch self &#123; case 0: return .zero case let x where x &gt; 0: return .positive default: return .negative &#125; &#125;&#125; 该例子为 Int 添加了嵌套枚举。这个名为 Kind 的枚举表示特定整数的类型。具体来说，就是表示整数是正数、零或者负数。这个例子还为 Int 添加了一个计算型实例属性，即 kind，用来根据整数返回适当的 Kind 枚举成员。现在，这个嵌套枚举可以和任意 Int 值一起使用了： 123456789101112131415func printIntegerKinds(_ numbers: [Int]) &#123; for number in numbers &#123; switch number.kind &#123; case .negative: print("- ", terminator: "") case .zero: print("0 ", terminator: "") case .positive: print("+ ", terminator: "") &#125; &#125; print("")&#125;printIntegerKinds([3, 19, -27, 0, -6, 0, 7])// Prints "+ + - 0 - 0 + " 函数 printIntegerKinds(_:) 接受一个 Int 数组，然后对该数组进行迭代。在每次迭代过程中，对当前整数的计算型属性 kind 的值进行评估，并打印出适当的描述。 由于已知 number.kind 是 Int.Kind 类型，因此在 switch 语句中，Int.Kind 中的所有成员值都可以使用简写形式，例如使用 . Negative 而不是 Int.Kind.Negative。 参照文档 NestedTypes &gt;&gt; Copyright (c) liangtong. All rights reserved.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift Nested Types]]></title>
    <url>%2F2016%2F12%2F01%2FiOS_Swift_language_note_Nested-Types%2F</url>
    <content type="text"><![CDATA[​ 枚举常被用于为特定类或结构体实现某些功能。类似的，枚举可以方便的定义工具类或结构体，从而为某个复杂的类型所使用。为了实现这种功能，Swift 允许你定义嵌套类型，可以在支持的类型中定义嵌套的枚举、类和结构体。要在一个类型中嵌套另一个类型，将嵌套类型的定义写在其外部类型的{}内，而且可以根据需要定义多级嵌套。 嵌套类型实践下面这个例子定义了一个结构体BlackjackCard，用来模拟BlackjackCard中的扑克牌点数。BlackjackCard结构体包含两个嵌套定义的枚举类型Suit和Rank。在BlackjackCard中，Ace牌可以表示1或者11，Ace牌的这一特征通过一个嵌套在Rank枚举中的结构体Values来表示： 12345678910111213141516171819202122232425262728293031323334353637struct BlackjackCard &#123; // nested Suit enumeration enum Suit: Character &#123; case spades = "♠", hearts = "♡", diamonds = "♢", clubs = "♣" &#125; // nested Rank enumeration enum Rank: Int &#123; case two = 2, three, four, five, six, seven, eight, nine, ten case jack, queen, king, ace struct Values &#123; let first: Int, second: Int? &#125; var values: Values &#123; switch self &#123; case .ace: return Values(first: 1, second: 11) case .jack, .queen, .king: return Values(first: 10, second: nil) default: return Values(first: self.rawValue, second: nil) &#125; &#125; &#125; // BlackjackCard properties and methods let rank: Rank, suit: Suit var description: String &#123; var output = "suit is \(suit.rawValue)," output += " value is \(rank.values.first)" if let second = rank.values.second &#123; output += " or \(second)" &#125; return output &#125;&#125; Suit枚举用来描述扑克牌的四种花色，并用一个Character类型的原始值表示花色符号。Rank枚举用来描述扑克牌从Ace~10，以及J、Q、K，这13种牌，并用一个Int类型的原始值表示牌的面值。（这个Int类型的原始值未用于Ace、J、Q、K这4种牌。）如上所述，Rank枚举在内部定义了一个嵌套结构体Values。结构体Values中定义了两个属性，用于反映只有Ace有两个数值，其余牌都只有一个数值： first, of type Int second, of type Int?, or “optional Int” Rank还定义了一个计算型属性values，它将会返回一个Values结构体的实例。这个计算型属性会根据牌的面值，用适当的数值去初始化Values实例。对于J、Q、K、Ace这四种牌，会使用特殊数值。对于数字面值的牌，使用枚举实例的原始值。 BlackjackCard结构体拥有两个属性——rank与suit。它也同样定义了一个计算型属性description，description属性用rank和suit中的内容来构建对扑克牌名字和数值的描述。该属性使用可选绑定来检查可选类型second是否有值，若有值，则在原有的描述中增加对second的描述。 因为BlackjackCard是一个没有自定义构造器的结构体,有默认的成员构造器，所以你可以用默认的构造器去初始化新常量theAceOfSpades： 123let theAceOfSpades = BlackjackCard(rank: .ace, suit: .spades)print("theAceOfSpades: \(theAceOfSpades.description)")// Prints "theAceOfSpades: suit is ♠, value is 1 or 11" 尽管Rank和Suit嵌套在BlackjackCard中，但它们的类型仍可从上下文中推断出来，所以在初始化实例时能够单独通过成员名称（.Ace和.Spades）引用枚举实例。在上面的例子中，description属性正确地反映了黑桃A牌具有1和11两个值。 引用嵌套类型在外部引用嵌套类型时，在嵌套类型的类型名前加上其外部类型的类型名作为前缀： 12let heartsSymbol = BlackjackCard.Suit.hearts.rawValue// heartsSymbol is "♡" 对于上面这个例子，这样可以使Suit、Rank和Values的名字尽可能的短，因为它们的名字可以由定义它们的上下文来限定。 参照文档 NestedTypes &gt;&gt; Copyright (c) liangtong. All rights reserved.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift Type Casting]]></title>
    <url>%2F2016%2F11%2F30%2FiOS_Swift_language_note_Type-Casting%2F</url>
    <content type="text"><![CDATA[​ 类型转换 可以判断实例的类型，也可以将实例看做是其父类或者子类的实例。​类型转换在 Swift 中使用 is 和 as 操作符实现。这两个操作符提供了一种简单达意的方式去检查值的类型或者转换它的类型。也可以用它来检查一个类型是否实现了某个协议 定义一个类层次作为例子你可以将类型转换用在类和子类的层次结构上，检查特定类实例的类型并且转换这个类实例的类型成为这个层次结构中的其他类型。下面的三个代码段定义了一个类层次和一个包含了这些类实例的数组，作为类型转换的例子。第一个代码片段定义了一个新的基类 MediaItem。这个类为任何出现在数字媒体库的媒体项提供基础功能。特别的，它声明了一个 String 类型的 name 属性，和一个 init(name:) 初始化器。（假定所有的媒体项都有个名称。） 123456class MediaItem &#123; var name: String init(name: String) &#123; self.name = name &#125;&#125; 下一个代码段定义了 MediaItem 的两个子类。第一个子类 Movie 封装了与电影相关的额外信息，在父类（或者说基类）的基础上增加了一个 director（导演）属性，和相应的初始化器。第二个子类 Song，在父类的基础上增加了一个 artist（艺术家）属性，和相应的初始化器： 123456789101112131415class Movie: MediaItem &#123; var director: String init(name: String, director: String) &#123; self.director = director super.init(name: name) &#125;&#125; class Song: MediaItem &#123; var artist: String init(name: String, artist: String) &#123; self.artist = artist super.init(name: name) &#125;&#125; 最后一个代码段创建了一个数组常量 library，包含两个 Movie 实例和三个 Song 实例。library 的类型是在它被初始化时根据它数组中所包含的内容推断来的。Swift 的类型检测器能够推断出 Movie 和 Song 有共同的父类 MediaItem，所以它推断出 [MediaItem] 类作为 library 的类型： 12345678let library = [ Movie(name: "Casablanca", director: "Michael Curtiz"), Song(name: "Blue Suede Shoes", artist: "Elvis Presley"), Movie(name: "Citizen Kane", director: "Orson Welles"), Song(name: "The One And Only", artist: "Chesney Hawkes"), Song(name: "Never Gonna Give You Up", artist: "Rick Astley")]// the type of "library" is inferred to be [MediaItem] 在幕后 library 里存储的媒体项依然是 Movie 和 Song 类型的。但是，若你迭代它，依次取出的实例会是 MediaItem 类型的，而不是 Movie 和 Song 类型。为了让它们作为原本的类型工作，你需要检查它们的类型或者向下转换它们到其它类型，就像下面描述的一样。 检查类型用类型检查操作符（ is ）来检查一个实例是否属于特定子类型。若实例属于那个子类型，类型检查操作符返回 true ，否则返回 false 。 下面的例子定义了两个变量，movieCount 和 songCount，用来计算数组 library 中 Movie 和 Song 类型的实例数量： 12345678910111213var movieCount = 0var songCount = 0 for item in library &#123; if item is Movie &#123; movieCount += 1 &#125; else if item is Song &#123; songCount += 1 &#125;&#125; print("Media library contains \(movieCount) movies and \(songCount) songs")// Prints "Media library contains 2 movies and 3 songs" 若当前 MediaItem 是一个 Movie 类型的实例，item is Movie 返回 true，否则返回 false。同样的，item is Song 检查 item 是否为 Song 类型的实例。在循环结束后，movieCount 和 songCount 的值就是被找到的属于各自类型的实例的数量。 向下转型某类型的一个常量或变量可能在幕后实际上属于一个子类。当确定是这种情况时，你可以尝试向下转到它的子类型，用类型转换操作符（as? 或 as!）。因为向下转型可能会失败，类型转型操作符带有两种不同形式。条件形式as? 返回一个你试图向下转成的类型的可选值。强制形式 as! 把试图向下转型和强制解包转换结果结合为一个操作。 当你不确定向下转型可以成功时，用类型转换的条件形式（as?）。条件形式的类型转换总是返回一个可选值，并且若下转是不可能的，可选值将是 nil。这使你能够检查向下转型是否成功。只有你可以确定向下转型一定会成功时，才使用强制形式（as!）。当你试图向下转型为一个不正确的类型时，强制形式的类型转换会触发一个运行时错误。 下面的例子，迭代了 library 里的每一个 MediaItem，并打印出适当的描述。要这样做，item 需要真正作为 Movie 或 Song 的类型来使用，而不仅仅是作为 MediaItem。为了能够在描述中使用 Movie 或 Song 的 director 或 artist 属性，这是必要的。在这个示例中，数组中的每一个 item 可能是 Movie 或 Song。事前你不知道每个 item 的真实类型，所以这里使用条件形式的类型转换（as?）去检查循环里的每次下转： 12345678910111213for item in library &#123; if let movie = item as? Movie &#123; print("Movie: \(movie.name), dir. \(movie.director)") &#125; else if let song = item as? Song &#123; print("Song: \(song.name), by \(song.artist)") &#125;&#125; // Movie: Casablanca, dir. Michael Curtiz// Song: Blue Suede Shoes, by Elvis Presley// Movie: Citizen Kane, dir. Orson Welles// Song: The One And Only, by Chesney Hawkes// Song: Never Gonna Give You Up, by Rick Astley 示例首先试图将 item 下转为 Movie。因为 item 是一个 MediaItem 类型的实例，它可能是一个 Movie；同样，它也可能是一个 Song，或者仅仅是基类 MediaItem。因为不确定，as? 形式在试图下转时将返回一个可选值。item as? Movie 的返回值是 Movie? 或者说“可选 Movie”。 当向下转型为 Movie 应用在两个 Song 实例时将会失败。为了处理这种情况，上面的例子使用了可选绑定（optional binding）来检查可选 Movie 真的包含一个值（这个是为了判断下转是否成功。）可选绑定是这样写的“if let movie = item as? Movie”，可以这样解读： “尝试将 item 转为 Movie 类型。若成功，设置一个新的临时常量 movie 来存储返回的可选 Movie 中的值” 若向下转型成功，然后 movie 的属性将用于打印一个 Movie 实例的描述，包括它的导演的名字 director。相似的原理被用来检测 Song 实例，当 Song 被找到时则打印它的描述（包含 artist 的名字）。 转换没有真的改变实例或它的值。根本的实例保持不变；只是简单地把它作为它被转换成的类型来使用。 Any 和 AnyObject 的类型转换Swift 为不确定类型提供了两种特殊的类型别名： 可以表示任何类型，包括函数类型。 可以表示任何类类型的实例。 只有当你确实需要它们的行为和功能时才使用 Any 和 AnyObject。代码中最好使用明确的类型。 这里有个示例，使用 Any 类型来和混合的不同类型一起工作，包括函数类型和非类类型。它创建了一个可以存储 Any 类型的数组 things： 12345678910var things = [Any]() things.append(0)things.append(0.0)things.append(42)things.append(3.14159)things.append("hello")things.append((3.0, 5.0))things.append(Movie(name: "Ghostbusters", director: "Ivan Reitman"))things.append(&#123; (name: String) -&gt; String in "Hello, \(name)" &#125;) things 数组包含两个 Int 值，两个 Double 值，一个 String 值，一个元组 (Double, Double)，一个Movie实例“Ghostbusters”，以及一个接受 String 值并返回另一个 String 值的闭包表达式。你可以在 switch 表达式的 case 中使用 is 和 as 操作符来找出只知道是 Any 或 AnyObject 类型的常量或变量的具体类型。下面的示例迭代 things 数组中的每一项，并用 switch 语句查找每一项的类型。有几个 switch 语句的 case 绑定它们匹配到的值到一个指定类型的常量，从而可以打印这些值： 123456789101112131415161718192021222324252627282930313233for thing in things &#123; switch thing &#123; case 0 as Int: print("zero as an Int") case 0 as Double: print("zero as a Double") case let someInt as Int: print("an integer value of \(someInt)") case let someDouble as Double where someDouble &gt; 0: print("a positive double value of \(someDouble)") case is Double: print("some other double value that I don't want to print") case let someString as String: print("a string value of \"\(someString)\"") case let (x, y) as (Double, Double): print("an (x, y) point at \(x), \(y)") case let movie as Movie: print("a movie called \(movie.name), dir. \(movie.director)") case let stringConverter as (String) -&gt; String: print(stringConverter("Michael")) default: print("something else") &#125;&#125; // zero as an Int// zero as a Double// an integer value of 42// a positive double value of 3.14159// a string value of "hello"// an (x, y) point at 3.0, 5.0// a movie called Ghostbusters, dir. Ivan Reitman// Hello, Michael Any类型可以表示所有类型的值，包括可选类型。Swift 会在你用Any类型来表示一个可选值的时候，给你一个警告。如果你确实想使用Any类型来承载可选值，你可以使用as操作符显示转换为Any，如下所示： 123let optionalNumber: Int? = 3things.append(optionalNumber) // Warningthings.append(optionalNumber as Any) // No warning 参照文档 Type Casting &gt;&gt; Copyright (c) liangtong. All rights reserved.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift Error Handling]]></title>
    <url>%2F2016%2F11%2F30%2FiOS_Swift_language_note_Error-Handling%2F</url>
    <content type="text"><![CDATA[​ 错误处理（Error handling）是响应错误以及从错误中恢复的过程。Swift 提供了在运行时对可恢复错误的抛出、捕获、传递和操作的一等公民支持。某些操作无法保证总是执行完所有代码或总是生成有用的结果。可选类型可用来表示值缺失，但是当某个操作失败时，最好能得知失败的原因，从而可以作出相应的应对。举个例子，假如有个从磁盘上的某个文件读取数据并进行处理的任务，该任务会有多种可能失败的情况，包括指定路径下文件并不存在，文件不具有可读权限，或者文件编码格式不兼容。区分这些不同的失败情况可以让程序解决并处理某些错误，然后把它解决不了的错误报告给用户。 Swift 中的错误处理涉及到错误处理模式，这会用到 Cocoa 和 Objective-C 中的NSError。 表示并抛出错误在 Swift 中，错误用符合Error协议的类型的值来表示。这个空协议表明该类型可以用于错误处理。Swift 的枚举类型尤为适合构建一组相关的错误状态，枚举的关联值还可以提供错误状态的额外信息。例如，你可以这样表示在一个游戏中操作自动贩卖机时可能会出现的错误状态： 12345enum VendingMachineError: Error &#123; case invalidSelection case insufficientFunds(coinsNeeded: Int) case outOfStock&#125; 抛出一个错误可以让你表明有意外情况发生，导致正常的执行流程无法继续执行。抛出错误使用throw关键字。例如，下面的代码抛出一个错误，提示贩卖机还需要5个硬币： 1throw VendingMachineError.insufficientFunds(coinsNeeded: 5) 处理错误某个错误被抛出时，附近的某部分代码必须负责处理这个错误，例如纠正这个问题、尝试另外一种方式、或是向用户报告错误。Swift 中有4种处理错误的方式。你可以把函数抛出的错误传递给调用此函数的代码、用do-catch语句处理错误、将错误作为可选类型处理、或者断言此错误根本不会发生。 当一个函数抛出一个错误时，你的程序流程会发生改变，所以重要的是你能迅速识别代码中会抛出错误的地方。为了标识出这些地方，在调用一个能抛出错误的函数、方法或者构造器之前，加上 try 关键字，或者 try? 或 try! 这种变体。 Swift 中的错误处理和其他语言中用try，catch和throw进行异常处理很像。和其他语言中（包括 Objective-C ）的异常处理不同的是，Swift 中的错误处理并不涉及解除调用栈，这是一个计算代价高昂的过程。就此而言，throw语句的性能特性是可以和return语句相媲美的。 用 throwing 函数传递错误为了表示一个函数、方法或构造器可以抛出错误，在函数声明的参数列表之后加上throws关键字。一个标有 throws 关键字的函数被称作throwing 函数。如果这个函数指明了返回值类型，throws关键词需要写在箭头（-&gt;）的前面。 123func canThrowErrors() throws -&gt; String func cannotThrowErrors() -&gt; String 一个 throwing 函数可以在其内部抛出错误，并将错误传递到函数被调用时的作用域。 只有 throwing 函数可以传递错误。任何在某个非 throwing 函数内部抛出的错误只能在函数内部处理。 下面的例子中，VendingMechine类有一个vend(itemNamed:)方法，如果请求的物品不存在、缺货或者投入金额小于物品价格，该方法就会抛出一个相应的VendingMachineError： 1234567891011121314151617181920212223242526272829303132333435struct Item &#123; var price: Int var count: Int&#125; class VendingMachine &#123; var inventory = [ "Candy Bar": Item(price: 12, count: 7), "Chips": Item(price: 10, count: 4), "Pretzels": Item(price: 7, count: 11) ] var coinsDeposited = 0 func vend(itemNamed name: String) throws &#123; guard let item = inventory[name] else &#123; throw VendingMachineError.invalidSelection &#125; guard item.count &gt; 0 else &#123; throw VendingMachineError.outOfStock &#125; guard item.price &lt; coinsDeposited else &#123; throw VendingMachineError.insufficientFunds(coinsNeeded: item.price - coinsDeposited) &#125; coinsDeposited -= item.price var newItem = item newItem.count -= 1 inventory[name] = newItem print("Dispensing \(name)") &#125;&#125; 在vend(itemNamed:)方法的实现中使用了guard语句来提前退出方法，确保在购买某个物品所需的条件中，有任一条件不满足时，能提前退出方法并抛出相应的错误。由于throw语句会立即退出方法，所以物品只有在所有条件都满足时才会被售出。 因为vend(itemNamed:)方法会传递出它抛出的任何错误，在你的代码中调用此方法的地方，必须要么直接处理这些错误——使用do-catch语句，try?或try!；要么继续将这些错误传递下去。例如下面例子中，buyFavoriteSnack(_:vendingMachine:)同样是一个 throwing 函数，任何由vend(itemNamed:)方法抛出的错误会一直被传递到buyFavoriteSnack(person:vendingMachine:)函数被调用的地方。 123456789let favoriteSnacks = [ "Alice": "Chips", "Bob": "Licorice", "Eve": "Pretzels",]func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws &#123; let snackName = favoriteSnacks[person] ?? "Candy Bar" try vendingMachine.vend(itemNamed: snackName)&#125; 上例中，buyFavoriteSnack(person:vendingMachine:)函数会查找某人最喜欢的零食，并通过调用vend(itemNamed:)方法来尝试为他们购买。因为vend(itemNamed:)方法能抛出错误，所以在调用的它时候在它前面加了try关键字。throwing构造器能像throwing函数一样传递错误.例如下面代码中的PurchasedSnack构造器在构造过程中调用了throwing函数,并且通过传递到它的调用者来处理这些错误。 1234567struct PurchasedSnack &#123; let name: String init(name: String, vendingMachine: VendingMachine) throws &#123; try vendingMachine.vend(itemNamed: name) self.name = name &#125;&#125; 用 do-Catch 处理错误可以使用一个do-catch语句运行一段闭包代码来处理错误。如果在do子句中的代码抛出了一个错误，这个错误会与catch子句做匹配，从而决定哪条子句能处理它。 下面是do-catch语句的一般形式： 12345678do &#123; try expression statements&#125; catch pattern 1 &#123; statements&#125; catch pattern 2 where condition &#123; statements&#125; 在catch后面写一个匹配模式来表明这个子句能处理什么样的错误。如果一条catch子句没有指定匹配模式，那么这条子句可以匹配任何错误，并且把错误绑定到一个名字为error的局部常量 catch子句不必将do子句中的代码所抛出的每一个可能的错误都作处理。如果所有catch子句都未处理错误，错误就会传递到周围的作用域。然而，错误还是必须要被某个周围的作用域处理的——要么是一个外围的do-catch错误处理语句，要么是一个 throwing 函数的内部。举例来说，下面的代码处理了VendingMachineError枚举类型的全部枚举值，但是所有其它的错误就必须由它周围的作用域处理： 123456789101112var vendingMachine = VendingMachine()vendingMachine.coinsDeposited = 8do &#123; try buyFavoriteSnack(person: "Alice", vendingMachine: vendingMachine)&#125; catch VendingMachineError.invalidSelection &#123; print("Invalid Selection.")&#125; catch VendingMachineError.outOfStock &#123; print("Out of Stock.")&#125; catch VendingMachineError.insufficientFunds(let coinsNeeded) &#123; print("Insufficient funds. Please insert an additional \(coinsNeeded) coins.")&#125;// Prints "Insufficient funds. Please insert an additional 2 coins." 上面的例子中，buyFavoriteSnack(person:vendingMachine:)函数在一个try表达式中调用，因为它能抛出错误。如果错误被抛出，相应的执行会马上转移到catch子句中，并判断这个错误是否要被继续传递下去。如果没有错误抛出，do子句中余下的语句就会被执行。 将错误转换成可选值可以使用try?通过将错误转换成一个可选值来处理错误。如果在评估try?表达式时一个错误被抛出，那么表达式的值就是nil。例如,在下面的代码中,x和y有着相同的数值和等价的含义： 123456789101112func someThrowingFunction() throws -&gt; Int &#123; // ...&#125; let x = try? someThrowingFunction() let y: Int?do &#123; y = try someThrowingFunction()&#125; catch &#123; y = nil&#125; 如果someThrowingFunction()抛出一个错误，x和y的值是nil。否则x和y的值就是该函数的返回值。注意，无论someThrowingFunction()的返回值类型是什么类型，x和y都是这个类型的可选类型。例子中此函数返回一个整型，所以x和y是可选整型。如果你想对所有的错误都采用同样的方式来处理，用try?就可以让你写出简洁的错误处理代码。例如，下面的代码用几种方式来获取数据，如果所有方式都失败了则返回nil： 12345func fetchData() -&gt; Data? &#123; if let data = try? fetchDataFromDisk() &#123; return data &#125; if let data = try? fetchDataFromServer() &#123; return data &#125; return nil&#125; 禁用错误传递例如，下面的代码使用了loadImage(atPath:)函数，该函数从给定的路径加载图片资源，如果图片无法载入则抛出一个错误。在这种情况下，因为图片是和应用绑定的，运行时不会有错误抛出，所以适合禁用错误传递： 1let photo = try! loadImage(atPath: "./Resources/John Appleseed.jpg") 指定清理操作可以使用defer语句在即将离开当前代码块时执行一系列语句。该语句让你能执行一些必要的清理工作，不管是以何种方式离开当前代码块的——无论是由于抛出错误而离开，还是由于诸如return或者break的语句。例如，你可以用defer语句来确保文件描述符得以关闭，以及手动分配的内存得以释放。 defer语句将代码的执行延迟到当前的作用域退出之前。该语句由defer关键字和要被延迟执行的语句组成。延迟执行的语句不能包含任何控制转移语句，例如break或是return语句，或是抛出一个错误。延迟执行的操作会按照它们被指定时的顺序的相反顺序执行——也就是说，第一条defer语句中的代码会在第二条defer语句中的代码被执行之后才执行，以此类推。 123456789101112func processFile(filename: String) throws &#123; if exists(filename) &#123; let file = open(filename) defer &#123; close(file) &#125; while let line = try file.readline() &#123; // Work with the file. &#125; // close(file) is called here, at the end of the scope. &#125;&#125; 上面的代码使用一条defer语句来确保open(:)函数有一个相应的对close(:)函数的调用。 即使没有涉及到错误处理，你也可以使用defer语句。 参照文档 ErrorHandling &gt;&gt; Copyright (c) liangtong. All rights reserved.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift Optional Chaining]]></title>
    <url>%2F2016%2F11%2F30%2FiOS_Swift_language_note_Optional-Chaining%2F</url>
    <content type="text"><![CDATA[​ 可选链式调用是一种可以在当前值可能为nil的可选值上请求和调用属性、方法及下标的方法。如果可选值有值，那么调用就会成功；如果可选值是nil，那么调用将返回nil。多个调用可以连接在一起形成一个调用链，如果其中任何一个节点为nil，整个调用链都会失败，即返回nil。 Swift 的可选链式调用和 Objective-C 中向nil发送消息有些相像，但是 Swift 的可选链式调用可以应用于任意类型，并且能检查调用是否成功。 使用可选链式调用代替强制展开通过在想调用的属性、方法、或下标的可选值后面放一个问号（?），可以定义一个可选链。这一点很像在可选值后面放一个叹号（!）来强制展开它的值。它们的主要区别在于当可选值为空时可选链式调用只会调用失败，然而强制展开将会触发运行时错误。 为了反映可选链式调用可以在空值（nil）上调用的事实，不论这个调用的属性、方法及下标返回的值是不是可选值，它的返回结果都是一个可选值。你可以利用这个返回值来判断你的可选链式调用是否调用成功，如果调用有返回值则说明调用成功，返回nil则说明调用失败。 特别地，可选链式调用的返回结果与原本的返回结果具有相同的类型，但是被包装成了一个可选值。例如，使用可选链式调用访问属性，当可选链式调用成功时，如果属性原本的返回结果是Int类型，则会变为Int?类型。 下面几段代码将解释可选链式调用和强制展开的不同。首先定义两个类Person和Residence： 1234567class Person &#123; var residence: Residence?&#125; class Residence &#123; var numberOfRooms = 1&#125; Residence有一个Int类型的属性numberOfRooms，其默认值为1。Person具有一个可选的residence属性，其类型为Residence?。假如你创建了一个新的Person实例,它的residence属性由于是是可选型而将初始化为nil,在下面的代码中,john有一个值为nil的residence属性： 1let john = Person() 如果使用叹号（!）强制展开获得这个john的residence属性中的numberOfRooms值，会触发运行时错误，因为这时residence没有可以展开的值： 12let roomCount = john.residence!.numberOfRooms// this triggers a runtime error john.residence为非nil值的时候，上面的调用会成功，并且把roomCount设置为Int类型的房间数量。正如上面提到的，当residence为nil的时候上面这段代码会触发运行时错误。 可选链式调用提供了另一种访问numberOfRooms的方式，使用问号（?）来替代原来的叹号（!）： 123456if let roomCount = john.residence?.numberOfRooms &#123; print("John's residence has \(roomCount) room(s).")&#125; else &#123; print("Unable to retrieve the number of rooms.")&#125;// Prints "Unable to retrieve the number of rooms." 在residence后面添加问号之后，Swift 就会在residence不为nil的情况下访问numberOfRooms。因为访问numberOfRooms有可能失败，可选链式调用会返回Int?类型，或称为“可选的 Int”。如上例所示，当residence为nil的时候，可选的Int将会为nil，表明无法访问numberOfRooms。访问成功时，可选的Int值会通过可选绑定展开，并赋值给非可选类型的roomCount常量。要注意的是，即使numberOfRooms是非可选的Int时，这一点也成立。只要使用可选链式调用就意味着numberOfRooms会返回一个Int?而不是Int。可以将一个Residence的实例赋给john.residence，这样它就不再是nil了： 1john.residence = Residence() john.residence现在包含一个实际的Residence实例，而不再是nil。如果你试图使用先前的可选链式调用访问numberOfRooms，它现在将返回值为1的Int?类型的值： 123456if let roomCount = john.residence?.numberOfRooms &#123; print("John's residence has \(roomCount) room(s).")&#125; else &#123; print("Unable to retrieve the number of rooms.")&#125;// Prints "John's residence has 1 room(s)." 为可选链式调用定义模型类通过使用可选链式调用可以调用多层属性、方法和下标。这样可以在复杂的模型中向下访问各种子属性，并且判断能否访问子属性的属性、方法或下标。下面这段代码定义了四个模型类，这些例子包括多层可选链式调用。为了方便说明，在Person和Residence的基础上增加了Room类和Address类，以及相关的属性、方法以及下标。 12345678910111213141516171819202122class Person &#123; var residence: Residence?&#125;class Residence &#123; var rooms = [Room]() var numberOfRooms: Int &#123; return rooms.count &#125; subscript(i: Int) -&gt; Room &#123; get &#123; return rooms[i] &#125; set &#123; rooms[i] = newValue &#125; &#125; func printNumberOfRooms() &#123; print("The number of rooms is \(numberOfRooms)") &#125; var address: Address?&#125; 现在Residence有了一个存储Room实例的数组，numberOfRooms属性被实现为计算型属性，而不是存储型属性。numberOfRooms属性简单地返回rooms数组的count属性的值。 Residence还提供了访问rooms数组的快捷方式，即提供可读写的下标来访问rooms数组中指定位置的元素。此外，Residence还提供了printNumberOfRooms方法，这个方法的作用是打印numberOfRooms的值。最后，Residence还定义了一个可选属性address，其类型为Address?。Address类的定义在下面会说明。 Room类是一个简单类，其实例被存储在rooms数组中。该类只包含一个属性name，以及一个用于将该属性设置为适当的房间名的初始化函数： 1234class Room &#123; let name: String init(name: String) &#123; self.name = name &#125;&#125; 最后一个类是Address，这个类有三个String?类型的可选属性。buildingName以及buildingNumber属性分别表示某个大厦的名称和号码，第三个属性street表示大厦所在街道的名称： 1234567891011121314class Address &#123; var buildingName: String? var buildingNumber: String? var street: String? func buildingIdentifier() -&gt; String? &#123; if buildingNumber != nil &amp;&amp; street != nil &#123; return "\(buildingNumber) \(street)" &#125; else if buildingName != nil &#123; return buildingName &#125; else &#123; return nil &#125; &#125;&#125; Address类提供了buildingIdentifier()方法，返回值为String?。 如果buildingName有值则返回buildingName。或者，如果buildingNumber和street均有值则返回buildingNumber。否则，返回nil。 通过可选链式调用访问属性可以通过可选链式调用在一个可选值上访问它的属性，并判断访问是否成功。下面的代码创建了一个Person实例，然后像之前一样，尝试访问numberOfRooms属性： 1234567let john = Person()if let roomCount = john.residence?.numberOfRooms &#123; print("John's residence has \(roomCount) room(s).")&#125; else &#123; print("Unable to retrieve the number of rooms.")&#125;// Prints "Unable to retrieve the number of rooms." 因为john.residence为nil，所以这个可选链式调用依旧会像先前一样失败。还可以通过可选链式调用来设置属性值： 1234let someAddress = Address()someAddress.buildingNumber = "29"someAddress.street = "Acacia Road"john.residence?.address = someAddress 在这个例子中，通过john.residence来设定address属性也会失败，因为john.residence当前为nil。 上面代码中的赋值过程是可选链式调用的一部分，这意味着可选链式调用失败时，等号右侧的代码不会被执行。对于上面的代码来说，很难验证这一点，因为像这样赋值一个常量没有任何副作用。下面的代码完成了同样的事情，但是它使用一个函数来创建Address实例，然后将该实例返回用于赋值。该函数会在返回前打印“Function was called”，这使你能验证等号右侧的代码是否被执行。 12345678910func createAddress() -&gt; Address &#123; print("Function was called.") let someAddress = Address() someAddress.buildingNumber = "29" someAddress.street = "Acacia Road" return someAddress&#125;john.residence?.address = createAddress() 没有任何打印消息，可以看出createAddress()函数并未被执行。 通过可选链式调用调用方法可以通过可选链式调用来调用方法，并判断是否调用成功，即使这个方法没有返回值。Residence类中的printNumberOfRooms()方法打印当前的numberOfRooms值，如下所示： 123func printNumberOfRooms() &#123; print("The number of rooms is \(numberOfRooms)")&#125; 这个方法没有返回值。然而，没有返回值的方法具有隐式的返回类型Void。这意味着没有返回值的方法也会返回()，或者说空的元组。 如果在可选值上通过可选链式调用来调用这个方法，该方法的返回类型会是Void?，而不是Void，因为通过可选链式调用得到的返回值都是可选的。这样我们就可以使用if语句来判断能否成功调用printNumberOfRooms()方法，即使方法本身没有定义返回值。通过判断返回值是否为nil可以判断调用是否成功： 123456if john.residence?.printNumberOfRooms() != nil &#123; print("It was possible to print the number of rooms.")&#125; else &#123; print("It was not possible to print the number of rooms.")&#125;// Prints "It was not possible to print the number of rooms." 同样的，可以据此判断通过可选链式调用为属性赋值是否成功。在上面的通过可选链式调用访问属性的例子中，我们尝试给john.residence中的address属性赋值，即使residence为nil。通过可选链式调用给属性赋值会返回Void?，通过判断返回值是否为nil就可以知道赋值是否成功： 123456if (john.residence?.address = someAddress) != nil &#123; print("It was possible to set the address.")&#125; else &#123; print("It was not possible to set the address.")&#125;// Prints "It was not possible to set the address." 通过可选链式调用访问下标通过可选链式调用，我们可以在一个可选值上访问下标，并且判断下标调用是否成功。 通过可选链式调用访问可选值的下标时，应该将问号放在下标方括号的前面而不是后面。可选链式调用的问号一般直接跟在可选表达式的后面。 下面这个例子用下标访问john.residence属性存储的Residence实例的rooms数组中的第一个房间的名称，因为john.residence为nil，所以下标调用失败了： 123456if let firstRoomName = john.residence?[0].name &#123; print("The first room name is \(firstRoomName).")&#125; else &#123; print("Unable to retrieve the first room name.")&#125;// Prints "Unable to retrieve the first room name." 在这个例子中，问号直接放在john.residence的后面，并且在方括号的前面，因为john.residence是可选值。类似的，可以通过下标，用可选链式调用来赋值： 1john.residence?[0] = Room(name: "Bathroom") 这次赋值同样会失败，因为residence目前是nil。如果你创建一个Residence实例，并为其rooms数组添加一些Room实例，然后将Residence实例赋值给john.residence，那就可以通过可选链和下标来访问数组中的元素： 1234567891011let johnsHouse = Residence()johnsHouse.rooms.append(Room(name: "Living Room"))johnsHouse.rooms.append(Room(name: "Kitchen"))john.residence = johnsHouse if let firstRoomName = john.residence?[0].name &#123; print("The first room name is \(firstRoomName).")&#125; else &#123; print("Unable to retrieve the first room name.")&#125;// Prints "The first room name is Living Room." 访问可选类型的下标如果下标返回可选类型值，比如 Swift 中Dictionary类型的键的下标，可以在下标的结尾括号后面放一个问号来在其可选返回值上进行可选链式调用： 12345var testScores = ["Dave": [86, 82, 84], "Bev": [79, 94, 81]]testScores["Dave"]?[0] = 91testScores["Bev"]?[0] += 1testScores["Brian"]?[0] = 72// the "Dave" array is now [91, 82, 84] and the "Bev" array is now [80, 94, 81] 上面的例子中定义了一个testScores数组，包含了两个键值对，把String类型的键映射到一个Int值的数组。这个例子用可选链式调用把”Dave”数组中第一个元素设为91，把”Bev”数组的第一个元素+1，然后尝试把”Brian”数组中的第一个元素设为72。前两个调用成功，因为testScores字典中包含”Dave”和”Bev”这两个键。但是testScores字典中没有”Brian”这个键，所以第三个调用失败。 连接多层可选链式调用可以通过连接多个可选链式调用在更深的模型层级中访问属性、方法以及下标。然而，多层可选链式调用不会增加返回值的可选层级。 如果你访问的值不是可选的，可选链式调用将会返回可选值。 如果你访问的值就是可选的，可选链式调用不会让可选返回值变得“更可选”。 因此： 通过可选链式调用访问一个Int值，将会返回Int?，无论使用了多少层可选链式调用。 类似的，通过可选链式调用访问Int?值，依旧会返回Int?值，并不会返回Int??。 下面的例子尝试访问john中的residence属性中的address属性中的street属性。这里使用了两层可选链式调用，residence以及address都是可选值： 123456if let johnsStreet = john.residence?.address?.street &#123; print("John's street name is \(johnsStreet).")&#125; else &#123; print("Unable to retrieve the address.")&#125;// Prints "Unable to retrieve the address." john.residence现在包含一个有效的Residence实例。然而，john.residence.address的值当前为nil。因此，调用john.residence?.address?.street会失败。需要注意的是，上面的例子中，street的属性为String?。john.residence?.address?.street的返回值也依然是String?，即使已经使用了两层可选链式调用。 如果为john.residence.address赋值一个Address实例，并且为address中的street属性设置一个有效值，我们就能过通过可选链式调用来访问street属性： 1234567891011let johnsAddress = Address()johnsAddress.buildingName = "The Larches"johnsAddress.street = "Laurel Street"john.residence?.address = johnsAddress if let johnsStreet = john.residence?.address?.street &#123; print("John's street name is \(johnsStreet).")&#125; else &#123; print("Unable to retrieve the address.")&#125;// Prints "John's street name is Laurel Street." 在方法的可选返回值上进行可选链式调用上面的例子展示了如何在一个可选值上通过可选链式调用来获取它的属性值。我们还可以在一个可选值上通过可选链式调用来调用方法，并且可以根据需要继续在方法的可选返回值上进行可选链式调用。 在下面的例子中，通过可选链式调用来调用Address的buildingIdentifier()方法。这个方法返回String?类型的值。如上所述，通过可选链式调用来调用该方法，最终的返回值依旧会是String?类型： 1234if let buildingIdentifier = john.residence?.address?.buildingIdentifier() &#123; print("John's building identifier is \(buildingIdentifier).")&#125;// Prints "John's building identifier is The Larches." 如果要在该方法的返回值上进行可选链式调用，在方法的圆括号后面加上问号即可： 123456789if let beginsWithThe = john.residence?.address?.buildingIdentifier()?.hasPrefix("The") &#123; if beginsWithThe &#123; print("John's building identifier begins with \"The\".") &#125; else &#123; print("John's building identifier does not begin with \"The\".") &#125;&#125;// Prints "John's building identifier begins with "The"." 在上面的例子中，在方法的圆括号后面加上问号是因为你要在buildingIdentifier()方法的可选返回值上进行可选链式调用，而不是方法本身。 参照文档 OptionalChaining &gt;&gt; Copyright (c) liangtong. All rights reserved.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift ARC]]></title>
    <url>%2F2016%2F11%2F29%2FiOS_Swift_language_note_ARC%2F</url>
    <content type="text"><![CDATA[​ Swift 使用自动引用计数（ARC）机制来跟踪和管理你的应用程序的内存。通常情况下，Swift 内存管理机制会一直起作用，你无须自己来考虑内存的管理。ARC 会在类的实例不再被使用时，自动释放其占用的内存。然而在少数情况下，为了能帮助你管理内存，ARC 需要更多的，代码之间关系的信息。在 Swift 使用 ARC 与在 Obejctive-C 中使用 ARC 非常类似 引用计数仅仅应用于类的实例。结构体和枚举类型是值类型，不是引用类型，也不是通过引用的方式存储和传递。 ARC工作机制当你每次创建一个类的新的实例的时候，ARC 会分配一块内存来储存该实例信息。内存中会包含实例的类型信息，以及这个实例所有相关的存储型属性的值。当实例不再被使用时，ARC 释放实例所占用的内存，并让释放的内存能挪作他用。这确保了不再被使用的实例，不会一直占用内存空间。 然而，当 ARC 收回和释放了正在被使用中的实例，该实例的属性和方法将不能再被访问和调用。实际上，如果你试图访问这个实例，你的应用程序很可能会崩溃。为了确保使用中的实例不会被销毁，ARC 会跟踪和计算每一个实例正在被多少属性，常量和变量所引用。哪怕实例的引用数为1，ARC都不会销毁这个实例。 为了使上述成为可能，无论你将实例赋值给属性、常量或变量，它们都会创建此实例的强引用。之所以称之为“强”引用，是因为它会将实例牢牢地保持住，只要强引用还在，实例是不允许被销毁的。 ARC实践下面的例子展示了自动引用计数的工作机制。例子以一个简单的Person类开始，并定义了一个叫name的常量属性： 12345678910class Person &#123; let name: String init(name: String) &#123; self.name = name print("\(name) is being initialized") &#125; deinit &#123; print("\(name) is being deinitialized") &#125;&#125; Person类有一个构造函数，此构造函数为实例的name属性赋值，并打印一条消息以表明初始化过程生效。Person类也拥有一个析构函数，这个析构函数会在实例被销毁时打印一条消息。 接下来的代码片段定义了三个类型为Person?的变量，用来按照代码片段中的顺序，为新的Person实例建立多个引用。由于这些变量是被定义为可选类型（Person?，而不是Person），它们的值会被自动初始化为nil，目前还不会引用到Person类的实例。 123456var reference1: Person?var reference2: Person?var reference3: Person?reference1 = Person(name: "John Appleseed")// Prints "John Appleseed is being initialized" 由于Person类的新实例被赋值给了reference1变量，所以reference1到Person类的新实例之间建立了一个强引用。正是因为这一个强引用，ARC 会保证Person实例被保持在内存中不被销毁。如果你将同一个Person实例也赋值给其他两个变量，该实例又会多出两个强引用： 12reference2 = reference1reference3 = reference1 现在这一个Person实例已经有三个强引用了。如果你通过给其中两个变量赋值nil的方式断开两个强引用（包括最先的那个强引用），只留下一个强引用，Person实例不会被销毁： 12reference1 = nilreference2 = nil 在你清楚地表明不再使用这个Person实例时，即第三个也就是最后一个强引用被断开时，ARC 会销毁它： 12reference3 = nil// Prints "John Appleseed is being deinitialized" 类实例之间的循环强引用在上面的例子中，ARC 会跟踪你所新创建的Person实例的引用数量，并且会在Person实例不再被需要时销毁它。然而，我们可能会写出一个类实例的强引用数永远不能变成0的代码。如果两个类实例互相持有对方的强引用，因而每个实例都让对方一直存在，就是这种情况。这就是所谓的循环强引用。你可以通过定义类之间的关系为弱 weak 引用或无主 unowned 引用，以替代强引用，从而解决循环强引用的问题。 下面展示了一个不经意产生循环强引用的例子。例子定义了两个类：Person和Apartment，用来建模公寓和它其中的居民： 12345678910111213class Person &#123; let name: String init(name: String) &#123; self.name = name &#125; var apartment: Apartment? deinit &#123; print("\(name) is being deinitialized") &#125;&#125; class Apartment &#123; let unit: String init(unit: String) &#123; self.unit = unit &#125; var tenant: Person? deinit &#123; print("Apartment \(unit) is being deinitialized") &#125;&#125; 每一个Person实例有一个类型为String，名字为name的属性，并有一个可选的初始化为nil的apartment属性。apartment属性是可选的，因为一个人并不总是拥有公寓。类似的，每个Apartment实例有一个叫unit，类型为String的属性，并有一个可选的初始化为nil的tenant属性。tenant属性是可选的，因为一栋公寓并不总是有居民。这两个类都定义了析构函数，用以在类实例被析构的时候输出信息。这让你能够知晓Person和Apartment的实例是否像预期的那样被销毁。 接下来的代码片段定义了两个可选类型的变量john和unit4A，并分别被设定为下面的Apartment和Person的实例。这两个变量都被初始化为nil，这正是可选类型的优点： 12345var john: Person?var unit4A: Apartment?john = Person(name: "John Appleseed")unit4A = Apartment(unit: "4A") 在两个实例被创建和赋值后，下图表现了强引用的关系。变量john现在有一个指向Person实例的强引用，而变量unit4A有一个指向Apartment实例的强引用：现在你能够将这两个实例关联在一起，这样人就能有公寓住了，而公寓也有了房客。注意感叹号(!)是用来展开(解包)和访问可选变量john和unit4A中的实例，这样实例的属性才能被赋值： 12john!.apartment = unit4Aunit4A!.tenant = john 在将两个实例联系在一起之后，强引用的关系如图所示：不幸的是，这两个实例关联后会产生一个循环强引用。Person实例现在有了一个指向Apartment实例的强引用，而Apartment实例也有了一个指向Person实例的强引用。因此，当你断开john和unit4A变量所持有的强引用时，引用计数并不会降为0，实例也不会被 ARC 销毁： 12john = nilunit4A = nil 注意，当你把这两个变量设为nil时，没有任何一个析构函数被调用。循环强引用会一直阻止Person和Apartment类实例的销毁，这就在你的应用程序中造成了内存泄漏。在你将john和unit4A赋值为nil后，强引用关系如下图：Person和Apartment实例之间的强引用关系保留了下来并且不会被断开。 解决实例的循环强引用问题Swift 提供了两种办法用来解决你在使用类的属性时所遇到的循环强引用问题：弱引用（weak reference）和无主引用（unowned reference）。弱引用和无主引用允许循环引用中的一个实例引用而另外一个实例不保持强引用。这样实例能够互相引用而不产生循环强引用。 当其他的实例有更短的生命周期时，使用弱引用，也就是说，当其他实例析构在先时。在上面公寓的例子中，很显然一个公寓在它的生命周期内会在某个时间段没有它的主人，所以一个弱引用就加在公寓类里面，避免循环引用。相比之下，当其他实例有相同的或者更长生命周期时，请使用无主引用。 弱引用弱引用不会对其引用的实例保持强引用，因而不会阻止 ARC 销毁被引用的实例。这个特性阻止了引用变为循环强引用。声明属性或者变量时，在前面加上 weak 关键字表明这是一个弱引用。 因为弱引用不会保持所引用的实例，即使引用存在，实例也有可能被销毁。因此，ARC 会在引用的实例被销毁后自动将其赋值为nil。并且因为弱引用可以允许它们的值在运行时被赋值为nil，所以它们会被定义为可选类型变量，而不是常量。你可以像其他可选值一样，检查弱引用的值是否存在，你将永远不会访问已销毁的实例的引用。 当 ARC 设置弱引用为nil时，属性观察不会被触发。 下面的例子跟上面Person和Apartment的例子一致，但是有一个重要的区别。这一次，Apartment的tenant属性被声明为弱引用： 12345678910111213class Person &#123; let name: String init(name: String) &#123; self.name = name &#125; var apartment: Apartment? deinit &#123; print("\(name) is being deinitialized") &#125;&#125; class Apartment &#123; let unit: String init(unit: String) &#123; self.unit = unit &#125; weak var tenant: Person? deinit &#123; print("Apartment \(unit) is being deinitialized") &#125;&#125; 然后跟之前一样，建立两个变量（john和unit4A）之间的强引用，并关联两个实例： 12345678var john: Person?var unit4A: Apartment? john = Person(name: "John Appleseed")unit4A = Apartment(unit: "4A") john!.apartment = unit4Aunit4A!.tenant = john 现在，两个关联在一起的实例的引用关系如下图所示：Person实例依然保持对Apartment实例的强引用，但是Apartment实例只持有对Person实例的弱引用。这意味着当你断开john变量所保持的强引用时，再也没有指向Person实例的强引用了：由于再也没有指向Person实例的强引用，该实例会被销毁： 12john = nil// Prints "John Appleseed is being deinitialized" 唯一剩下的指向Apartment实例的强引用来自于变量unit4A。如果你断开这个强引用，再也没有指向Apartment实例的强引用了： 12unit4A = nil// Prints "Apartment 4A is being deinitialized" 由于再也没有指向Apartment实例的强引用，该实例也会被销毁： 在使用垃圾收集的系统里，弱指针有时用来实现简单的缓冲机制，因为没有强引用的对象只会在内存压力触发垃圾收集时才被销毁。但是在 ARC 中，一旦值的最后一个强引用被移除，就会被立即销毁，这导致弱引用并不适合上面的用途。 无主引用和弱引用类似，无主引用不会牢牢保持住引用的实例。和弱引用不同的是，无主引用在其他实例有相同或者更长的生命周期时使用。你可以在声明属性或者变量时，在前面加上关键字unowned表示这是一个无主引用。无主引用通常都被期望拥有值。不过 ARC 无法在实例被销毁后将无主引用设为nil，这意味着无主引用明确使用非可选类型 使用无主引用，你必须确保引用始终指向一个未销毁的实例。如果你试图在实例被销毁后，访问该实例的无主引用，会触发运行时错误。 下面的例子定义了两个类，Customer和CreditCard，模拟了银行客户和客户的信用卡。这两个类中，每一个都将另外一个类的实例作为自身的属性。这种关系可能会造成循环强引用。Customer和CreditCard之间的关系与前面弱引用例子中Apartment和Person的关系略微不同。在这个数据模型中，一个客户可能有或者没有信用卡，但是一张信用卡总是关联着一个客户。为了表示这种关系，Customer类有一个可选类型的card属性，但是CreditCard类有一个非可选类型的customer属性。此外，只能通过将一个number值和customer实例传递给CreditCard构造函数的方式来创建CreditCard实例。这样可以确保当创建CreditCard实例时总是有一个customer实例与之关联。由于信用卡总是关联着一个客户，因此将customer属性定义为无主引用，用以避免循环强引用： 123456789101112131415161718class Customer &#123; let name: String var card: CreditCard? init(name: String) &#123; self.name = name &#125; deinit &#123; print("\(name) is being deinitialized") &#125;&#125; class CreditCard &#123; let number: UInt64 unowned let customer: Customer init(number: UInt64, customer: Customer) &#123; self.number = number self.customer = customer &#125; deinit &#123; print("Card #\(number) is being deinitialized") &#125;&#125; 下面的代码片段定义了一个叫john的可选类型Customer变量，用来保存某个特定客户的引用。由于是可选类型，所以变量被初始化为nil： 1var john: Customer? 现在你可以创建Customer类的实例，用它初始化CreditCard实例，并将新创建的CreditCard实例赋值为客户的card属性： 12john = Customer(name: "John Appleseed")john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!) 在你关联两个实例后，它们的引用关系如下图所示： Customer实例持有对CreditCard实例的强引用，而CreditCard实例持有对Customer实例的无主引用。由于customer的无主引用，当你断开john变量持有的强引用时，再也没有指向Customer实例的强引用了：由于再也没有指向Customer实例的强引用，该实例被销毁了。其后，再也没有指向CreditCard实例的强引用，该实例也随之被销毁了： 123john = nil// Prints "John Appleseed is being deinitialized"// Prints "Card #1234567890123456 is being deinitialized" 上面的例子展示了如何使用安全的无主引用。对于需要禁用运行时的安全检查的情况（例如，出于性能方面的原因），Swift还提供了不安全的无主引用。与所有不安全的操作一样，你需要负责检查代码以确保其安全性。 你可以通过unowned(unsafe)来声明不安全无主引用。如果你试图在实例被销毁后，访问该实例的不安全无主引用，你的程序会尝试访问该实例之前所在的内存地址，这是一个不安全的操作。 无主引用以及隐式解析可选属性上面弱引用和无主引用的例子涵盖了两种常用的需要打破循环强引用的场景。 Person和Apartment的例子展示了两个属性的值都允许为nil，并会潜在的产生循环强引用。这种场景最适合用弱引用来解决。Customer和CreditCard的例子展示了一个属性的值允许为nil，而另一个属性的值不允许为nil，这也可能会产生循环强引用。这种场景最适合通过无主引用来解决。 然而，存在着第三种场景，在这种场景中，两个属性都必须有值，并且初始化完成后永远不会为nil。在这种场景中，需要一个类使用无主属性，而另外一个类使用隐式解析可选属性。这使两个属性在初始化完成后能被直接访问（不需要可选展开），同时避免了循环引用。这一节将为你展示如何建立这种关系。下面的例子定义了两个类，Country和City，每个类将另外一个类的实例保存为属性。在这个模型中，每个国家必须有首都，每个城市必须属于一个国家。为了实现这种关系，Country类拥有一个capitalCity属性，而City类有一个country属性： 1234567891011121314151617class Country &#123; let name: String var capitalCity: City! init(name: String, capitalName: String) &#123; self.name = name self.capitalCity = City(name: capitalName, country: self) &#125;&#125; class City &#123; let name: String unowned let country: Country init(name: String, country: Country) &#123; self.name = name self.country = country &#125;&#125; 为了建立两个类的依赖关系，City的构造函数接受一个Country实例作为参数，并且将实例保存到country属性。 Country的构造函数调用了City的构造函数。然而，只有Country的实例完全初始化后，Country的构造函数才能把self传给City的构造函数。在两段式构造过程中有具体描述。为了满足这种需求，通过在类型结尾处加上感叹号（City!）的方式，将Country的capitalCity属性声明为隐式解析可选类型的属性。这意味着像其他可选类型一样，capitalCity属性的默认值为nil，但是不需要展开它的值就能访问它。在隐式解析可选类型中有描述。 由于capitalCity默认值为nil，一旦Country的实例在构造函数中给name属性赋值后，整个初始化过程就完成了。这意味着一旦name属性被赋值后，Country的构造函数就能引用并传递隐式的self。Country的构造函数在赋值capitalCity时，就能将self作为参数传递给City的构造函数。 以上的意义在于你可以通过一条语句同时创建Country和City的实例，而不产生循环强引用，并且capitalCity的属性能被直接访问，而不需要通过感叹号来展开它的可选值： 123var country = Country(name: "Canada", capitalName: "Ottawa")print("\(country.name)'s capital city is called \(country.capitalCity.name)")// Prints "Canada's capital city is called Ottawa" 在上面的例子中，使用隐式解析可选值意味着满足了类的构造函数的两个构造阶段的要求。capitalCity属性在初始化完成后，能像非可选值一样使用和存取，同时还避免了循环强引用。 闭包的循环强引用前面我们看到了循环强引用是在两个类实例属性互相保持对方的强引用时产生的，还知道了如何用弱引用和无主引用来打破这些循环强引用。 循环强引用还会发生在当你将一个闭包赋值给类实例的某个属性，并且这个闭包体中又使用了这个类实例时。这个闭包体中可能访问了实例的某个属性，例如self.someProperty，或者闭包中调用了实例的某个方法，例如self.someMethod()。这两种情况都导致了闭包“捕获”self，从而产生了循环强引用。 循环强引用的产生，是因为闭包和类相似，都是引用类型。当你把一个闭包赋值给某个属性时，你是将这个闭包的引用赋值给了属性。实质上，这跟之前的问题是一样的——两个强引用让彼此一直有效。但是，和两个类实例不同，这次一个是类实例，另一个是闭包。 Swift 提供了一种优雅的方法来解决这个问题，称之为闭包捕获列表（closure capture list）。同样的，在学习如何用闭包捕获列表打破循环强引用之前，先来了解一下这里的循环强引用是如何产生的，这对我们很有帮助。 下面的例子为你展示了当一个闭包引用了self后是如何产生一个循环强引用的。例子中定义了一个叫HTMLElement的类，用一种简单的模型表示 HTML 文档中的一个单独的元素： 1234567891011121314151617181920212223class HTMLElement &#123; let name: String let text: String? lazy var asHTML: () -&gt; String = &#123; if let text = self.text &#123; return "&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;" &#125; else &#123; return "&lt;\(self.name) /&gt;" &#125; &#125; init(name: String, text: String? = nil) &#123; self.name = name self.text = text &#125; deinit &#123; print("\(name) is being deinitialized") &#125; &#125; HTMLElement类定义了一个name属性来表示这个元素的名称，例如代表头部元素的”h1”，代表段落的“p”，或者代表换行的“br”。HTMLElement还定义了一个可选属性text，用来设置 HTML 元素呈现的文本。 除了上面的两个属性，HTMLElement还定义了一个lazy属性asHTML。这个属性引用了一个将name和text组合成 HTML 字符串片段的闭包。该属性是Void -&gt; String类型，或者可以理解为“一个没有参数，返回String的函数”。 默认情况下，闭包赋值给了asHTML属性，这个闭包返回一个代表 HTML 标签的字符串。如果text值存在，该标签就包含可选值text；如果text不存在，该标签就不包含文本。对于段落元素，根据text是“some text”还是nil，闭包会返回”some text“或者”“。 可以像实例方法那样去命名、使用asHTML属性。然而，由于asHTML是闭包而不是实例方法，如果你想改变特定 HTML 元素的处理方式的话，可以用自定义的闭包来取代默认值。 例如，可以将一个闭包赋值给asHTML属性，这个闭包能在text属性是nil时使用默认文本，这是为了避免返回一个空的 HTML 标签： 1234567let heading = HTMLElement(name: "h1")let defaultText = "some default text"heading.asHTML = &#123; return "&lt;\(heading.name)&gt;\(heading.text ?? defaultText)&lt;/\(heading.name)&gt;"&#125;print(heading.asHTML())// Prints "&lt;h1&gt;some default text&lt;/h1&gt;" asHTML声明为lazy属性，因为只有当元素确实需要被处理为 HTML 输出的字符串时，才需要使用asHTML。也就是说，在默认的闭包中可以使用self，因为只有当初始化完成以及self确实存在后，才能访问lazy属性。 HTMLElement类只提供了一个构造函数，通过name和text（如果有的话）参数来初始化一个新元素。该类也定义了一个析构函数，当HTMLElement实例被销毁时，打印一条消息。 123var paragraph: HTMLElement? = HTMLElement(name: "p", text: "hello, world")print(paragraph!.asHTML())// Prints "&lt;p&gt;hello, world&lt;/p&gt;" 不幸的是，上面写的HTMLElement类产生了类实例和作为asHTML默认值的闭包之间的循环强引用。循环强引用如下图所示：实例的asHTML属性持有闭包的强引用。但是，闭包在其闭包体内使用了self（引用了self.name和self.text），因此闭包捕获了self，这意味着闭包又反过来持有了HTMLElement实例的强引用。这样两个对象就产生了循环强引用。 虽然闭包多次使用了self，它只捕获HTMLElement实例的一个强引用。 如果设置paragraph变量为nil，打破它持有的HTMLElement实例的强引用，HTMLElement实例和它的闭包都不会被销毁，HTMLElement的析构函数中的消息并没有被打印。也是因为循环强引用： 1paragraph = nil 解决闭包的循环强引用问题在定义闭包时同时定义捕获列表作为闭包的一部分，通过这种方式可以解决闭包和类实例之间的循环强引用。捕获列表定义了闭包体内捕获一个或者多个引用类型的规则。跟解决两个类实例间的循环强引用一样，声明每个捕获的引用为弱引用或无主引用，而不是强引用。应当根据代码关系来决定使用弱引用还是无主引用。 Swift 有如下要求：只要在闭包内使用self的成员，就要用self.someProperty或者self.someMethod()（而不只是someProperty或someMethod()）。这提醒你可能会一不小心就捕获了self。 定义捕获列表捕获列表中的每一项都由一对元素组成，一个元素是weak或unowned关键字，另一个元素是类实例的引用（例如self）或初始化过的变量（如delegate = self.delegate!）。这些项在方括号中用逗号分开。如果闭包有参数列表和返回类型，把捕获列表放在它们前面： 1234lazy var someClosure: (Int, String) -&gt; String = &#123; [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&gt; String in // closure body goes here&#125; 如果闭包没有指明参数列表或者返回类型，即它们会通过上下文推断，那么可以把捕获列表和关键字in放在闭包最开始的地方： 1234lazy var someClosure: () -&gt; String = &#123; [unowned self, weak delegate = self.delegate!] in // closure body goes here&#125; 弱引用和无主引用在闭包和捕获的实例总是互相引用并且总是同时销毁时，将闭包内的捕获定义为 无主引用。相反的，在被捕获的引用可能会变为nil时，将闭包内的捕获定义为 弱引用 。弱引用总是可选类型，并且当引用的实例被销毁后，弱引用的值会自动置为nil。这使我们可以在闭包体内检查它们是否存在。 如果被捕获的引用不会变为nil，应该用无主引用，而不是弱引用。 前面的HTMLElement例子中，无主引用是正确的解决循环强引用的方法。这样编写HTMLElement类来避免循环强引用： 123456789101112131415161718192021222324class HTMLElement &#123; let name: String let text: String? lazy var asHTML: () -&gt; String = &#123; [unowned self] in if let text = self.text &#123; return "&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;" &#125; else &#123; return "&lt;\(self.name) /&gt;" &#125; &#125; init(name: String, text: String? = nil) &#123; self.name = name self.text = text &#125; deinit &#123; print("\(name) is being deinitialized") &#125; &#125; 上面的HTMLElement实现和之前的实现一致，除了在asHTML闭包中多了一个捕获列表。这里，捕获列表是[unowned self]，表示“将self捕获为无主引用而不是强引用”。和之前一样，我们可以创建并打印HTMLElement实例： 123var paragraph: HTMLElement? = HTMLElement(name: "p", text: "hello, world")print(paragraph!.asHTML())// Prints "&lt;p&gt;hello, world&lt;/p&gt;" 使用捕获列表后引用关系如下图所示：此时，闭包以无主引用的形式捕获self，并不会持有HTMLElement实例的强引用。如果将paragraph赋值为nil，HTMLElement实例将会被销毁，并能看到它的析构函数打印出的消息： 12paragraph = nil// Prints "p is being deinitialized" 参照文档 AutomaticReferenceCounting &gt;&gt; Copyright (c) liangtong. All rights reserved.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift Deinitialization]]></title>
    <url>%2F2016%2F11%2F28%2FiOS_Swift_language_note_Deinitialization%2F</url>
    <content type="text"><![CDATA[​ 析构器只适用于类类型，当一个类的实例被释放之前，析构器会被立即调用。析构器用关键字deinit来标示。 析构过程Swift 会自动释放不再需要的实例以释放资源。通过自动引用计数（ARC）处理实例的内存管理。通常当你的实例被释放时不需要手动地去清理。但是，当使用自己的资源时，你可能需要进行一些额外的清理。例如，如果创建了一个自定义的类来打开一个文件，并写入一些数据，你可能需要在类实例被释放之前手动去关闭该文件。 在类的定义中，每个类最多只能有一个析构器，而且析构器不带任何参数，如下所示： 123deinit &#123; // perform the deinitialization&#125; 析构器是在实例释放发生前被自动调用。你不能主动调用析构器。子类继承了父类的析构器，并且在子类析构器实现的最后，父类的析构器会被自动调用。即使子类没有提供自己的析构器，父类的析构器也同样会被调用。 因为直到实例的析构器被调用后，实例才会被释放，所以析构器可以访问实例的所有属性，并且可以根据那些属性可以修改它的行为（比如查找一个需要被关闭的文件）。 析构实践这是一个析构器实践的例子。这个例子描述了一个简单的游戏，这里定义了两种新类型，分别是Bank和Player。Bank类管理一种虚拟硬币，确保流通的硬币数量永远不可能超过 10,000。在游戏中有且只能有一个Bank存在，因此Bank用类来实现，并使用类型属性和类型方法来存储和管理其当前状态。 1234567891011class Bank &#123; static var coinsInBank = 10_000 static func distribute(coins numberOfCoinsRequested: Int) -&gt; Int &#123; let numberOfCoinsToVend = min(numberOfCoinsRequested, coinsInBank) coinsInBank -= numberOfCoinsToVend return numberOfCoinsToVend &#125; static func receive(coins: Int) &#123; coinsInBank += coins &#125;&#125; Bank使用coinsInBank属性来跟踪它当前拥有的硬币数量。Bank还提供了两个方法，distribute(coins:)和receive(coins:)，分别用来处理硬币的分发和收集。 distribute(coins:)方法在Bank对象分发硬币之前检查是否有足够的硬币。如果硬币不足，Bank对象会返回一个比请求时小的数字（如果Bank对象中没有硬币了就返回0）。此方法返回一个整型值，表示提供的硬币的实际数量。 receive(coins:)方法只是将Bank实例接收到的硬币数目加回硬币存储中。 Player类描述了游戏中的一个玩家。每一个玩家在任意时间都有一定数量的硬币存储在他们的钱包中。这通过玩家的coinsInPurse属性来表示： 123456789101112class Player &#123; var coinsInPurse: Int init(coins: Int) &#123; coinsInPurse = Bank.distribute(coins: coins) &#125; func win(coins: Int) &#123; coinsInPurse += Bank.distribute(coins: coins) &#125; deinit &#123; Bank.receive(coins: coinsInPurse) &#125;&#125; 每个Player实例在初始化的过程中，都从Bank对象获取指定数量的硬币。如果没有足够的硬币可用，Player实例可能会收到比指定数量少的硬币. Player类定义了一个win(coins:)方法，该方法从Bank对象获取一定数量的硬币，并把它们添加到玩家的钱包。Player类还实现了一个析构器，这个析构器在Player实例释放前被调用。在这里，析构器的作用只是将玩家的所有硬币都返还给Bank对象： 12345var playerOne: Player? = Player(coins: 100)print("A new player has joined the game with \(playerOne!.coinsInPurse) coins")// Prints "A new player has joined the game with 100 coins"print("There are now \(Bank.coinsInBank) coins left in the bank")// Prints "There are now 9900 coins left in the bank" 创建一个Player实例的时候，会向Bank对象请求 100 个硬币，如果有足够的硬币可用的话。这个Player实例存储在一个名为playerOne的可选类型的变量中。这里使用了一个可选类型的变量，因为玩家可以随时离开游戏，设置为可选使你可以追踪玩家当前是否在游戏中。因为playerOne是可选的，所以访问其coinsInPurse属性来打印钱包中的硬币数量时，使用感叹号（!）来解包： 12345playerOne!.win(coins: 2_000)print("PlayerOne won 2000 coins &amp; now has \(playerOne!.coinsInPurse) coins")// Prints "PlayerOne won 2000 coins &amp; now has 2100 coins"print("The bank now only has \(Bank.coinsInBank) coins left")// Prints "The bank now only has 7900 coins left" 这里，玩家已经赢得了 2,000 枚硬币，所以玩家的钱包中现在有 2,100 枚硬币，而Bank对象只剩余 7,900 枚硬币。 12345playerOne = nilprint("PlayerOne has left the game")// Prints "PlayerOne has left the game"print("The bank now has \(Bank.coinsInBank) coins")// Prints "The bank now has 10000 coins" 玩家现在已经离开了游戏。这通过将可选类型的playerOne变量设置为nil来表示，意味着“没有Player实例”。当这一切发生时，playerOne变量对Player实例的引用被破坏了。没有其它属性或者变量引用Player实例，因此该实例会被释放，以便回收内存。在这之前，该实例的析构器被自动调用，玩家的硬币被返还给银行。 参照文档 Deinitialization &gt;&gt; Copyright (c) liangtong. All rights reserved.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift Initialization]]></title>
    <url>%2F2016%2F11%2F27%2FiOS_Swift_language_note_Initialization%2F</url>
    <content type="text"><![CDATA[​ 构造过程是使用类、结构体、枚举的实例之前的准备过程。具体操作包括设置实例中每个存储型属性的初始值和执行其他必须的设置或初始化工作。在新实例可用前必须执行这个过程。通过定义构造器来实现构造过程，这些构造器可以看做是用来创建特定类型新实例的特殊方法。与 Objective-C 中的构造器不同，Swift 的构造器无需返回值，它们的主要任务是保证新实例在第一次使用前完成正确的初始化。类的实例也可以通过定义析构器在实例释放之前执行特定的清除工作。 存储属性的初始化值类和结构体在创建实例时，必须为所有存储型属性设置合适的初始值。存储型属性的值不能处于一个未知的状态。你可以在构造器中为存储型属性赋初值，也可以在定义属性时为其设置默认值。 为存储型属性设置默认值或者在构造器中为其赋值时，它们的值是被直接设置的，不会触发任何属性观察者。 构造器构造器在创建某个特定类型的新实例时被调用。它的最简形式类似于一个不带任何参数的实例方法，以关键字 init 命名： 123init() &#123; // perform some initialization here&#125; 下面例子中定义了一个用来保存华氏温度的结构体Fahrenheit，它拥有一个Double类型的存储型属性temperature： 123456789struct Fahrenheit &#123; var temperature: Double init() &#123; temperature = 32.0 &#125;&#125;var f = Fahrenheit()print("The default temperature is \(f.temperature)° Fahrenheit")// Prints "The default temperature is 32.0° Fahrenheit" 默认属性值可以在构造器中为存储型属性设置初始值。也可以在属性声明时为其设置默认值。 如果一个属性总是使用相同的初始值，那么为其设置一个默认值比每次都在构造器中赋值要好。两种方法的效果是一样的，只不过使用默认值让属性的初始化和声明结合得更紧密。使用默认值能让你的构造器更简洁、更清晰，且能通过默认值自动推导出属性的类型；同时，它也能让你充分利用默认构造器、构造器继承等特性。 你可以使用更简单的方式在定义结构体Fahrenheit时为属性temperature设置默认值： 123struct Fahrenheit &#123; var temperature = 32.0&#125; 自定义构造函数可以通过输入参数和可选类型的属性来自定义构造过程，也可以在构造过程中修改 常量 属性。 构造参数可以在构造器定义中提供构造参数，指定所需值的类型和名字。构造参数的功能和语法跟函数和方法的参数相同。下面例子中定义了一个包含摄氏度温度的结构体Celsius。它定义了两个不同的构造器：init(fromFahrenheit:)和init(fromKelvin:)，二者分别通过接受不同温标下的温度值来创建新的实例： 12345678910111213struct Celsius &#123; var temperatureInCelsius: Double init(fromFahrenheit fahrenheit: Double) &#123; temperatureInCelsius = (fahrenheit - 32.0) / 1.8 &#125; init(fromKelvin kelvin: Double) &#123; temperatureInCelsius = kelvin - 273.15 &#125;&#125;let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)// boilingPointOfWater.temperatureInCelsius is 100.0let freezingPointOfWater = Celsius(fromKelvin: 273.15)// freezingPointOfWater.temperatureInCelsius is 0.0 参数的参数名和标签名(内部名称和外部名称)跟函数和方法参数相同，构造参数也拥有一个在构造器内部使用的参数名字和一个在调用构造器时使用的外部参数名字（标签名）。构造器并不像函数和方法那样在括号前有一个可辨别的名字（只有init）。因此在调用构造器时，主要通过构造器中的参数名和类型来确定应该被调用的构造器。正因为参数如此重要，如果你在定义构造器时没有提供参数的外部名字，Swift 会为构造器的每个参数自动生成一个跟内部名字相同的外部名。 以下例子中定义了一个结构体Color，它包含了三个常量：red、green和blue。这些属性可以存储0.0到1.0之间的值，用来指示颜色中红、绿、蓝成分的含量。Color提供了一个构造器，其中包含三个Double类型的构造参数。Color也可以提供第二个构造器，它只包含名为white的Double类型的参数，它被用于给上述三个构造参数赋予同样的值。 12345678910111213141516struct Color &#123; let red, green, blue: Double init(red: Double, green: Double, blue: Double) &#123; self.red = red self.green = green self.blue = blue &#125; init(white: Double) &#123; red = white green = white blue = white &#125;&#125;let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)let halfGray = Color(white: 0.5) 如果不通过外部参数名字传值，你是没法调用这个构造器的。只要构造器定义了某个外部参数名，你就必须使用它，忽略它将导致编译错误： 12let veryGreen = Color(0.0, 1.0, 0.0)// this reports a compile-time error - argument labels are required 不带标签（外部名）的构造器参数如果你不希望为构造器的某个参数提供外部名字，你可以使用下划线(_)来显式描述它的外部名，以此重写上面所说的默认行为。 下面是之前Celsius例子的扩展，跟之前相比添加了一个带有Double类型参数的构造器，其外部名用代替。调用Celsius(37.0)意图明确，不需要外部参数名称。因此适合使用init( celsius: Double)这样的构造器，从而可以通过提供Double类型的参数值调用构造器，而不需要加上外部名。： 1234567891011121314struct Celsius &#123; var temperatureInCelsius: Double init(fromFahrenheit fahrenheit: Double) &#123; temperatureInCelsius = (fahrenheit - 32.0) / 1.8 &#125; init(fromKelvin kelvin: Double) &#123; temperatureInCelsius = kelvin - 273.15 &#125; init(_ celsius: Double) &#123; temperatureInCelsius = celsius &#125;&#125;let bodyTemperature = Celsius(37.0)// bodyTemperature.temperatureInCelsius is 37.0 可选属性类型如果你定制的类型包含一个逻辑上允许取值为空的存储型属性，你都需要将它定义为可选类型。可选类型的属性将自动初始化为nil，表示这个属性是有意在初始化时设置为空的。 1234567891011121314class SurveyQuestion &#123; var text: String var response: String? init(text: String) &#123; self.text = text &#125; func ask() &#123; print(text) &#125;&#125;let cheeseQuestion = SurveyQuestion(text: "Do you like cheese?")cheeseQuestion.ask()// Prints "Do you like cheese?"cheeseQuestion.response = "Yes, I do like cheese." 构造过程中常量属性的修改你可以在构造过程中的任意时间点给常量属性指定一个值，只要在构造过程结束时是一个确定的值。一旦常量属性被赋值，它将永远不可更改。 对于类的实例来说，它的常量属性只能在定义它的类的构造过程中修改；不能在子类中修改。 你可以修改上面的SurveyQuestion示例，用常量属性替代变量属性text，表示问题内容text在SurveyQuestion的实例被创建之后不会再被修改。尽管text属性现在是常量，我们仍然可以在类的构造器中设置它的值： 1234567891011121314class SurveyQuestion &#123; let text: String var response: String? init(text: String) &#123; self.text = text &#125; func ask() &#123; print(text) &#125;&#125;let beetsQuestion = SurveyQuestion(text: "How about beets?")beetsQuestion.ask()// Prints "How about beets?"beetsQuestion.response = "I also like beets. (But not with cheese.)" 默认构造器如果结构体或类的所有属性都有默认值，同时没有自定义的构造器，那么 Swift 会给这些结构体或类提供一个默认构造器（default initializers）。这个默认构造器将简单地创建一个所有属性值都设置为默认值的实例。 下面例子中创建了一个类ShoppingListItem，它封装了购物清单中的某一物品的属性：名字（name）、数量（quantity）和购买状态 purchase state： 123456class ShoppingListItem &#123; var name: String? var quantity = 1 var purchased = false&#125;var item = ShoppingListItem() 结构体的逐一成员构造器除了上面提到的默认构造器，如果结构体没有提供自定义的构造器，它们将自动获得一个逐一成员构造器，即使结构体的存储型属性没有默认值。 逐一成员构造器是用来初始化结构体新实例里成员属性的快捷方法。我们在调用逐一成员构造器时，通过与成员属性名相同的参数名进行传值来完成对成员属性的初始赋值。 1234struct Size &#123; var width = 0.0, height = 0.0&#125;let twoByTwo = Size(width: 2.0, height: 2.0) 值类型的构造器代理构造器可以通过调用其它构造器来完成实例的部分构造过程。这一过程称为构造器代理，它能减少多个构造器间的代码重复。 构造器代理的实现规则和形式在值类型和类类型中有所不同。值类型（结构体和枚举类型）不支持继承，所以构造器代理的过程相对简单，因为它们只能代理给自己的其它构造器。类则不同，它可以继承自其它类，这意味着类有责任保证其所有继承的存储型属性在构造时也能正确的初始化。 对于值类型，你可以使用self.init在自定义的构造器中引用相同类型中的其它构造器。并且你只能在构造器内部调用self.init。 如果你为某个值类型定义了一个自定义的构造器，你将无法访问到默认构造器（如果是结构体，还将无法访问逐一成员构造器）。假如你希望默认构造器、逐一成员构造器以及你自己的自定义构造器都能用来创建实例，可以将自定义的构造器写到扩展（extension）中，而不是写在值类型的原始定义中。 123456789101112131415161718192021struct Size &#123; var width = 0.0, height = 0.0&#125;struct Point &#123; var x = 0.0, y = 0.0&#125;struct Rect &#123; var origin = Point() var size = Size() init() &#123;&#125; init(origin: Point, size: Size) &#123; self.origin = origin self.size = size &#125; init(center: Point, size: Size) &#123; let originX = center.x - (size.width / 2) let originY = center.y - (size.height / 2) self.init(origin: Point(x: originX, y: originY), size: size) &#125;&#125; 以上代码中，3中构造方法方式如下： 12345678910let basicRect = Rect()// basicRect's origin is (0.0, 0.0) and its size is (0.0, 0.0)let originRect = Rect(origin: Point(x: 2.0, y: 2.0), size: Size(width: 5.0, height: 5.0))// originRect's origin is (2.0, 2.0) and its size is (5.0, 5.0)let centerRect = Rect(center: Point(x: 4.0, y: 4.0), size: Size(width: 3.0, height: 3.0))// centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0) 如果你想用另外一种不需要自己定义init()和init(origin:size:)的方式来实现这个例子，可以通过扩展（Extensions）实现 类的继承和构造过程类里面的所有存储型属性都必须在构造过程中设置初始值，包括所有继承自父类的属性。Swift 为类类型提供了两种构造器来确保实例中所有存储型属性都能获得初始值，它们分别是指定构造器和便利构造器。 指定构造器和便利构造器指定构造器是类中最主要的构造器。一个指定构造器将初始化类中提供的所有属性，并根据父类链往上调用父类的构造器来实现父类的初始化。一般情况下，类通常只有一个指定构造器。每一个类都必须拥有至少一个指定构造器。在某些情况下，许多类通过继承了父类中的指定构造器而满足了这个条件。 便利构造器是类中比较次要的、辅助型的构造器。你可以定义便利构造器来调用同一个类中的指定构造器，并为其参数提供默认值。你也可以定义便利构造器来创建一个特殊用途或特定输入值的实例。便利构造器不是必需的。只在必要的时候为类提供便利构造器，比方说某种情况下通过使用便利构造器来快捷调用某个指定构造器，能够节省更多开发时间并让类的构造过程更清晰明了。 指定构造器和便利构造器的语法类的指定构造器的写法跟值类型简单构造器一样： 123init(parameters) &#123; statements&#125; 便利构造器也采用相同样式的写法，但需要在 init 关键字之前放置 convenience 关键字，并使用空格将它们俩分开： 123convenience init(parameters) &#123; statements&#125; 类的构造器代理规则为了简化指定构造器和便利构造器之间的调用关系，Swift 采用以下三条规则来限制构造器之间的代理调用： 指定构造器必须调用其直接父类的的指定构造器。 便利构造器必须调用同类中定义的其它构造器。 便利构造器必须最终导致一个指定构造器被调用。 可以通过如下方法进行记忆： 指定构造器必须总是向上代理 便利构造器必须总是横向代理 下面图例中展示了一种涉及四个类的更复杂的类层级结构。它演示了指定构造器是如何在类层级中充当“管道”的作用，在类的构造器链上简化了类之间的相互关系。 两段式构造过程Swift 中类的构造过程包含两个阶段。第一个阶段，每个存储型属性被引入它们的类指定一个初始值。当每个存储型属性的初始值被确定后，第二阶段开始，它给每个类一次机会，在新实例准备使用之前进一步定制它们的存储型属性。 两段式构造过程的使用让构造过程更安全，同时在整个类层级结构中给予了每个类完全的灵活性。两段式构造过程可以防止属性值在初始化之前被访问，也可以防止属性被另外一个构造器意外地赋予不同的值。 说明白点儿就是：第一阶段是使用内存的申请与属性的初始化，第二阶段是属性的初始化赋值。 Swift 的两段式构造过程跟 Objective-C 中的构造过程类似。最主要的区别在于阶段 1，Objective-C 给每一个属性赋值0或空值（比如说0或nil）。Swift 的构造流程则更加灵活，它允许你设置定制的初始值，并自如应对某些属性不能以0或nil作为合法默认值的情况。 Swift 编译器将执行 4 种有效的安全检查，以确保两段式构造过程能不出错地完成： 安全检查 1 指定构造器必须保证它所在类引入的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类中的构造器。如上所述，一个对象的内存只有在其所有存储型属性确定之后才能完全初始化。为了满足这一规则，指定构造器必须保证它所在类引入的属性在它往上代理之前先完成初始化。 安全检查 2 指定构造器必须先向上代理调用父类构造器，然后再为继承的属性设置新值。如果没这么做，指定构造器赋予的新值将被父类中的构造器所覆盖。 安全检查 3 指便利构造器必须先代理调用同一类中的其它构造器，然后再为任意属性赋新值。如果没这么做，便利构造器赋予的新值将被同一类中其它指定构造器所覆盖。 安全检查 4 构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用self作为一个值。 类实例在第一阶段结束以前并不是完全有效的。只有第一阶段完成后，该实例才会成为有效实例，才能访问属性和调用方法。 以下是两段式构造过程中基于上述安全检查的构造流程展示： 阶段 1 某个指定构造器或便利构造器被调用。 完成新实例内存的分配，但此时内存还没有被初始化。 指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化。 指定构造器将调用父类的构造器，完成父类属性的初始化。 这个调用父类构造器的过程沿着构造器链一直往上执行，直到到达构造器链的最顶部。 当到达了构造器链最顶部，且已确保所有实例包含的存储型属性都已经赋值，这个实例的内存被认为已经完全初始化。此时阶段 1 完成。 阶段 2 从顶部构造器链一直往下，每个构造器链中类的指定构造器都有机会进一步定制实例。构造器此时可以访问self、修改它的属性并调用实例方法等等。 最终，任意构造器链中的便利构造器可以有机会定制实例和使用self。 下图展示了在假定的子类和父类之间的构造阶段 1：在这个例子中，构造过程从对子类中一个便利构造器的调用开始。这个便利构造器此时没法修改任何属性，它把构造任务代理给同一类中的指定构造器。如安全检查 1 所示，指定构造器将确保所有子类的属性都有值。然后它将调用父类的指定构造器，并沿着构造器链一直往上完成父类的构造过程。父类中的指定构造器确保所有父类的属性都有值。由于没有更多的父类需要初始化，也就无需继续向上代理。一旦父类中所有属性都有了初始值，实例的内存被认为是完全初始化，阶段 1 完成。 以下展示了相同构造过程的阶段 2：父类中的指定构造器现在有机会进一步来定制实例（尽管这不是必须的）。一旦父类中的指定构造器完成调用，子类中的指定构造器可以执行更多的定制操作（这也不是必须的）。最终，一旦子类的指定构造器完成调用，最开始被调用的便利构造器可以执行更多的定制操作。 构造器的继承和重写跟 Objective-C 中的子类不同，Swift 中的子类默认情况下不会继承父类的构造器。Swift 的这种机制可以防止一个父类的简单构造器被一个更精细的子类继承，并被错误地用来创建子类的实例。 父类的构造器仅会在安全和适当的情况下被继承。 假如你希望自定义的子类中能提供一个或多个跟父类相同的构造器，你可以在子类中提供这些构造器的自定义实现。当你在编写一个和父类中指定构造器相匹配的子类构造器时，你实际上是在重写父类的这个指定构造器。因此，你必须在定义子类构造器时带上 override 修饰符。即使你重写的是系统自动提供的默认构造器，也需要带上override修饰符。正如重写属性，方法或者是下标，override修饰符会让编译器去检查父类中是否有相匹配的指定构造器，并验证构造器参数是否正确。 当你重写一个父类的指定构造器时，你总是需要写override修饰符，即使你的子类将父类的指定构造器重写为了便利构造器。 如果你编写了一个和父类便利构造器相匹配的子类构造器，由于子类不能直接调用父类的便利构造器（每个规则都在上文类的构造器代理规则有所描述）。因此，严格意义上来讲，你的子类并未对一个父类构造器提供重写。最后的结果就是，你在子类中“重写”一个父类便利构造器时，不需要加override前缀。 在下面的例子中定义了一个叫Vehicle的基类。基类中声明了一个存储型属性numberOfWheels，它是值为0的Int类型的存储型属性。numberOfWheels属性用于创建名为descrpiption的String类型的计算型属性： 12345678910class Vehicle &#123; var numberOfWheels = 0 var description: String &#123; return "\(numberOfWheels) wheel(s)" &#125;&#125;let vehicle = Vehicle()print("Vehicle: \(vehicle.description)")// Vehicle: 0 wheel(s) 下面例子中定义了一个Vehicle的子类Bicycle： 12345678910class Bicycle: Vehicle &#123; override init() &#123; super.init() numberOfWheels = 2 &#125;&#125;let bicycle = Bicycle()print("Bicycle: \(bicycle.description)")// Bicycle: 2 wheel(s) 子类Bicycle定义了一个自定义指定构造器init()。这个指定构造器和父类的指定构造器相匹配，所以Bicycle中的指定构造器需要带上override修饰符。Bicycle的构造器init()以调用super.init()方法开始，这个方法的作用是调用Bicycle的父类Vehicle的默认构造器。这样可以确保Bicycle在修改属性之前，它所继承的属性numberOfWheels能被Vehicle类初始化。在调用super.init()之后，属性numberOfWheels的原值被新值2替换。 子类可以在初始化时修改继承来的变量属性，但是不能修改继承来的常量属性。 构造器的自动继承如上所述，子类在默认情况下不会继承父类的构造器。但是如果满足特定条件，父类构造器是可以被自动继承的。在实践中，这意味着对于许多常见场景你不必重写父类的构造器，并且可以在安全的情况下以最小的代价继承父类的构造器。假设你为子类中引入的所有新属性都提供了默认值，以下 2 个规则适用： 规则 1 如果子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。 规则 2 如果子类提供了所有父类指定构造器的实现——无论是通过规则 1 继承过来的，还是提供了自定义实现——它将自动继承所有父类的便利构造器。 即使你在子类中添加了更多的便利构造器，这两条规则仍然适用。 对于规则 2，子类可以将父类的指定构造器实现为便利构造器。 指定构造器和便利构造器实践接下来的例子将在实践中展示指定构造器、便利构造器以及构造器的自动继承。这个例子定义了包含三个类Food、RecipeIngredient以及ShoppingListItem的类层次结构，并将演示它们的构造器是如何相互作用的。类层次中的基类是Food，它是一个简单的用来封装食物名字的类。Food类引入了一个叫做name的String类型的属性，并且提供了两个构造器来创建Food实例：123456789class Food &#123; var name: String init(name: String) &#123; self.name = name &#125; convenience init() &#123; self.init(name: "[Unnamed]") &#125;&#125; 类没有默认的逐一成员构造器，所以Food类提供了一个接受单一参数name的指定构造器。这个构造器可以使用一个特定的名字来创建新的Food实例。同样提供了一个没有参数的便利构造器init()。这个init()构造器为新食物提供了一个默认的占位名字，通过横向代理到指定构造器init(name: String)并给参数name传值[Unnamed]来实现： 12345let namedMeat = Food(name: "Bacon")// namedMeat's name is "Bacon"let mysteryMeat = Food()// mysteryMeat's name is "[Unnamed]" 类层级中的第二个类是Food的子类RecipeIngredient。RecipeIngredient类用来表示食谱中的一项原料。它引入了Int类型的属性quantity（以及从Food继承过来的name属性），并且定义了两个构造器来创建RecipeIngredient实例：12345678910class RecipeIngredient: Food &#123; var quantity: Int init(name: String, quantity: Int) &#123; self.quantity = quantity super.init(name: name) &#125; override convenience init(name: String) &#123; self.init(name: name, quantity: 1) &#125;&#125; RecipeIngredient类拥有一个指定构造器init(name: String, quantity: Int)，它可以用来填充RecipeIngredient实例的所有属性值。这个构造器一开始先将传入的quantity参数赋值给quantity属性，这个属性也是唯一在RecipeIngredient中新引入的属性。随后，构造器向上代理到父类Food的init(name: String)。这个过程满足两段式构造过程中的安全检查 1。 RecipeIngredient还定义了一个便利构造器init(name: String)，它只通过name来创建RecipeIngredient的实例。这个便利构造器假设任意RecipeIngredient实例的quantity为1，所以不需要显式指明数量即可创建出实例。这个便利构造器的定义可以更加方便和快捷地创建实例，并且避免了创建多个quantity为1的RecipeIngredient实例时的代码重复。这个便利构造器只是简单地横向代理到类中的指定构造器，并为quantity参数传递1。注意，RecipeIngredient的便利构造器init(name: String)使用了跟Food中指定构造器init(name: String)相同的参数。由于这个便利构造器重写了父类的指定构造器init(name: String)，因此必须在前面使用override修饰符 尽管RecipeIngredient将父类的指定构造器重写为了便利构造器，它依然提供了父类的所有指定构造器的实现。因此，RecipeIngredient会自动继承父类的所有便利构造器。在这个例子中，RecipeIngredient的父类是Food，它有一个便利构造器init()。这个便利构造器会被RecipeIngredient继承。这个继承版本的init()在功能上跟Food提供的版本是一样的，只是它会代理到RecipeIngredient版本的init(name: String)而不是Food提供的版本。 所有的这三种构造器都可以用来创建新的RecipeIngredient实例： 123let oneMysteryItem = RecipeIngredient()let oneBacon = RecipeIngredient(name: "Bacon")let sixEggs = RecipeIngredient(name: "Eggs", quantity: 6) 类层级中第三个也是最后一个类是RecipeIngredient的子类，叫做ShoppingListItem。这个类构建了购物单中出现的某一种食谱原料。 购物单中的每一项总是从未购买状态开始的。为了呈现这一事实，ShoppingListItem引入了一个布尔类型的属性purchased，它的默认值是false。ShoppingListItem还添加了一个计算型属性description，它提供了关于ShoppingListItem实例的一些文字描述： 12345678class ShoppingListItem: RecipeIngredient &#123; var purchased = false var description: String &#123; var output = "\(quantity) x \(name)" output += purchased ? " ✔" : " ✘" return output &#125;&#125; ShoppingListItem没有定义构造器来为purchased提供初始值，因为添加到购物单的物品的初始状态总是未购买。 由于它为自己引入的所有属性都提供了默认值，并且自己没有定义任何构造器，ShoppingListItem将自动继承所有父类中的指定构造器和便利构造器。你可以使用全部三个继承来的构造器来创建ShoppingListItem的新实例： 12345678910111213var breakfastList = [ ShoppingListItem(), ShoppingListItem(name: "Bacon"), ShoppingListItem(name: "Eggs", quantity: 6),]breakfastList[0].name = "Orange juice"breakfastList[0].purchased = truefor item in breakfastList &#123; print(item.description)&#125;// 1 x Orange juice ✔// 1 x Bacon ✘// 6 x Eggs ✘ 可失败构造器如果一个类、结构体或枚举类型的对象，在构造过程中有可能失败，则为其定义一个可失败构造器。这里所指的“失败”是指，如给构造器传入无效的参数值，或缺少某种所需的外部资源，又或是不满足某种必要的条件等。为了妥善处理这种构造过程中可能会失败的情况。你可以在一个类，结构体或是枚举类型的定义中，添加一个或多个可失败构造器。其语法为在 init 关键字后面添加问号( init? )。 可失败构造器的参数名和参数类型，不能与其它非可失败构造器的参数名，及其参数类型相同。 可失败构造器会创建一个类型为自身类型的可选类型的对象。你通过return nil语句来表明可失败构造器在何种情况下应该“失败”。 严格来说，构造器都不支持返回值。因为构造器本身的作用，只是为了确保对象能被正确构造。因此你只是用return nil表明可失败构造器构造失败，而不要用关键字return来表明构造成功。 下例中，定义了一个名为Animal的结构体，其中有一个名为species的String类型的常量属性。同时该结构体还定义了一个接受一个名为species的String类型参数的可失败构造器。这个可失败构造器检查传入的参数是否为一个空字符串。如果为空字符串，则构造失败。否则，species属性被赋值，构造成功。 1234567struct Animal &#123; let species: String init?(species: String) &#123; if species.isEmpty &#123; return nil &#125; self.species = species &#125;&#125; 你可以通过该可失败构造器来构建一个Animal的实例，并检查构造过程是否成功： 12345678910111213141516let someCreature = Animal(species: "Giraffe")// someCreature is of type Animal?, not Animal if let giraffe = someCreature &#123; print("An animal was initialized with a species of \(giraffe.species)")&#125;// Prints "An animal was initialized with a species of Giraffe"let anonymousCreature = Animal(species: "")// anonymousCreature is of type Animal?, not Animal if anonymousCreature == nil &#123; print("The anonymous creature could not be initialized")&#125;// Prints "The anonymous creature could not be initialized" 枚举类型的可失败构造器你可以通过一个带一个或多个参数的可失败构造器来获取枚举类型中特定的枚举成员。如果提供的参数无法匹配任何枚举成员，则构造失败。 下例中，定义了一个名为TemperatureUnit的枚举类型。其中包含了三个可能的枚举成员(Kelvin，Celsius，和Fahrenheit)，以及一个根据Character值找出所对应的枚举成员的可失败构造器： 123456789101112131415enum TemperatureUnit &#123; case kelvin, celsius, fahrenheit init?(symbol: Character) &#123; switch symbol &#123; case "K": self = .kelvin case "C": self = .celsius case "F": self = .fahrenheit default: return nil &#125; &#125;&#125; 你可以利用该可失败构造器在三个枚举成员中获取一个相匹配的枚举成员，当参数的值不能与任何枚举成员相匹配时，则构造失败： 1234567891011let fahrenheitUnit = TemperatureUnit(symbol: "F")if fahrenheitUnit != nil &#123; print("This is a defined temperature unit, so initialization succeeded.")&#125;// Prints "This is a defined temperature unit, so initialization succeeded." let unknownUnit = TemperatureUnit(symbol: "X")if unknownUnit == nil &#123; print("This is not a defined temperature unit, so initialization failed.")&#125;// Prints "This is not a defined temperature unit, so initialization failed." 带原始值的枚举类型的可失败构造器带原始值的枚举类型会自带一个可失败构造器init?(rawValue:)，该可失败构造器有一个名为rawValue的参数，其类型和枚举类型的原始值类型一致，如果该参数的值能够和某个枚举成员的原始值匹配，则该构造器会构造相应的枚举成员，否则构造失败。 因此上面的TemperatureUnit的例子可以重写为： 123456789101112131415enum TemperatureUnit: Character &#123; case kelvin = "K", celsius = "C", fahrenheit = "F"&#125; let fahrenheitUnit = TemperatureUnit(rawValue: "F")if fahrenheitUnit != nil &#123; print("This is a defined temperature unit, so initialization succeeded.")&#125;// Prints "This is a defined temperature unit, so initialization succeeded." let unknownUnit = TemperatureUnit(rawValue: "X")if unknownUnit == nil &#123; print("This is not a defined temperature unit, so initialization failed.")&#125;// Prints "This is not a defined temperature unit, so initialization failed." 构造失败的传递类，结构体，枚举的可失败构造器可以横向代理到类型中的其他可失败构造器。类似的，子类的可失败构造器也能向上代理到父类的可失败构造器。无论是向上代理还是横向代理，如果你代理到的其他可失败构造器触发构造失败，整个构造过程将立即终止，接下来的任何构造代码不会再被执行。 可失败构造器也可以代理到其它的非可失败构造器。通过这种方式，你可以增加一个可能的失败状态到现有的构造过程中。 下面这个例子，定义了一个名为CartItem的Product类的子类。这个类建立了一个在线购物车中的物品的模型，它有一个名为quantity的常量存储型属性，并确保该属性的值至少为1： 12345678910111213141516class Product &#123; let name: String init?(name: String) &#123; if name.isEmpty &#123; return nil &#125; self.name = name &#125;&#125; class CartItem: Product &#123; let quantity: Int init?(name: String, quantity: Int) &#123; if quantity &lt; 1 &#123; return nil &#125; self.quantity = quantity super.init(name: name) &#125;&#125; CartItem 可失败构造器首先验证接收的 quantity 值是否大于等于 1 。倘若 quantity 值无效，则立即终止整个构造过程，返回失败结果，且不再执行余下代码。同样地，Product 的可失败构造器首先检查 name 值，假如 name 值为空字符串，则构造器立即执行失败。 如果你通过传入一个非空字符串 name 以及一个值大于等于 1 的 quantity 来创建一个 CartItem 实例，那么构造方法能够成功被执行： 1234if let twoSocks = CartItem(name: "sock", quantity: 2) &#123; print("Item: \(twoSocks.name), quantity: \(twoSocks.quantity)")&#125;// Prints "Item: sock, quantity: 2" 倘若你以一个值为 0 的 quantity 来创建一个 CartItem 实例，那么将导致 CartItem 构造器失败： 123456if let zeroShirts = CartItem(name: "shirt", quantity: 0) &#123; print("Item: \(zeroShirts.name), quantity: \(zeroShirts.quantity)")&#125; else &#123; print("Unable to initialize zero shirts")&#125;// Prints "Unable to initialize zero shirts" 同样地，如果你尝试传入一个值为空字符串的 name来创建一个 CartItem 实例，那么将导致父类 Product 的构造过程失败： 123456if let oneUnnamed = CartItem(name: "", quantity: 1) &#123; print("Item: \(oneUnnamed.name), quantity: \(oneUnnamed.quantity)")&#125; else &#123; print("Unable to initialize one unnamed product")&#125;// Prints "Unable to initialize one unnamed product" 重写一个可失败构造器如同其它的构造器，你可以在子类中重写父类的可失败构造器。或者你也可以用子类的非可失败构造器重写一个父类的可失败构造器。这使你可以定义一个不会构造失败的子类，即使父类的构造器允许构造失败。当你用子类的非可失败构造器重写父类的可失败构造器时，向上代理到父类的可失败构造器的唯一方式是对父类的可失败构造器的返回值进行强制解包。 你可以用非可失败构造器重写可失败构造器，但反过来却不行。 下例定义了一个名为Document的类，name属性的值必须为一个非空字符串或nil，但不能是一个空字符串： 12345678910class Document &#123; var name: String? // this initializer creates a document with a nil name value init() &#123;&#125; // this initializer creates a document with a nonempty name value init?(name: String) &#123; if name.isEmpty &#123; return nil &#125; self.name = name &#125;&#125; 下面这个例子，定义了一个Document类的子类AutomaticallyNamedDocument。这个子类重写了父类的两个指定构造器，确保了无论是使用init()构造器，还是使用init(name:)构造器并为参数传递空字符串，生成的实例中的name属性总有初始”[Untitled]”： 1234567891011121314class AutomaticallyNamedDocument: Document &#123; override init() &#123; super.init() self.name = "[Untitled]" &#125; override init(name: String) &#123; super.init() if name.isEmpty &#123; self.name = "[Untitled]" &#125; else &#123; self.name = name &#125; &#125;&#125; AutomaticallyNamedDocument用一个非可失败构造器init(name:)重写了父类的可失败构造器init?(name:)。因为子类用另一种方式处理了空字符串的情况，所以不再需要一个可失败构造器，因此子类用一个非可失败构造器代替了父类的可失败构造器。 你可以在子类的非可失败构造器中使用强制解包来调用父类的可失败构造器。比如，下面的UntitledDocument子类的name属性的值总是”[Untitled]”，它在构造过程中使用了父类的可失败构造器init?(name:)： 12345class UntitledDocument: Document &#123; override init() &#123; super.init(name: "[Untitled]")! &#125;&#125; 可失败构造器 init!通常来说我们通过在init关键字后添加问号的方式（init?）来定义一个可失败构造器，但你也可以通过在init后面添加惊叹号的方式来定义一个可失败构造器（init!），该可失败构造器将会构建一个对应类型的隐式解包可选类型的对象。 你可以在init?中代理到init!，反之亦然。你也可以用init?重写init!，反之亦然。你还可以用init代理到init!，不过，一旦init!构造失败，则会触发一个断言。 必要构造器在类的构造器前添加 required 修饰符表明所有该类的子类都必须实现该构造器： 12345class SomeClass &#123; required init() &#123; // initializer implementation goes here &#125;&#125; 在子类重写父类的必要构造器时，必须在子类的构造器前也添加required修饰符，表明该构造器要求也应用于继承链后面的子类。在重写父类中必要的指定构造器时，不需要添加override修饰符： 12345class SomeSubclass: SomeClass &#123; required init() &#123; // subclass implementation of the required initializer goes here &#125;&#125; 如果子类继承的构造器能满足必要构造器的要求，则无须在子类中显式提供必要构造器的实现。 通过闭包或函数设置属性的默认值如果某个存储型属性的默认值需要一些定制或设置，你可以使用闭包或全局函数为其提供定制的默认值。每当某个属性所在类型的新实例被创建时，对应的闭包或函数会被调用，而它们的返回值会当做默认值赋值给这个属性。这种类型的闭包或函数通常会创建一个跟属性类型相同的临时变量，然后修改它的值以满足预期的初始状态，最后返回这个临时变量，作为属性的默认值。 下面介绍了如何用闭包为属性提供默认值： 1234567class SomeClass &#123; let someProperty: SomeType = &#123; // create a default value for someProperty inside this closure // someValue must be of the same type as SomeType return someValue &#125;()&#125; 注意闭包结尾的大括号后面接了一对空的小括号。这用来告诉 Swift 立即执行此闭包。如果你忽略了这对括号，相当于将闭包本身作为值赋值给了属性，而不是将闭包的返回值赋值给属性。 如果你使用闭包来初始化属性，请记住在闭包执行时，实例的其它部分都还没有初始化。这意味着你不能在闭包里访问其它属性，即使这些属性有默认值。同样，你也不能使用隐式的self属性，或者调用任何实例方法。 下面例子中定义了一个结构体Checkerboard，它构建了西洋跳棋游戏的棋盘：西洋跳棋游戏在一副黑白格交替的10x10的棋盘中进行。为了呈现这副游戏棋盘，Checkerboard结构体定义了一个属性boardColors，它是一个包含100个Bool值的数组。在数组中，值为true的元素表示一个黑格，值为false的元素表示一个白格。数组中第一个元素代表棋盘上左上角的格子，最后一个元素代表棋盘上右下角的格子。 boardColor数组是通过一个闭包来初始化并设置颜色值的： 1234567891011121314151617struct Chessboard &#123; let boardColors: [Bool] = &#123; var temporaryBoard = [Bool]() var isBlack = false for i in 1...8 &#123; for j in 1...8 &#123; temporaryBoard.append(isBlack) isBlack = !isBlack &#125; isBlack = !isBlack &#125; return temporaryBoard &#125;() func squareIsBlackAt(row: Int, column: Int) -&gt; Bool &#123; return boardColors[(row * 8) + column] &#125;&#125; 每当一个新的Checkerboard实例被创建时，赋值闭包会被执行，boardColors的默认值会被计算出来并返回。上面例子中描述的闭包将计算出棋盘中每个格子对应的颜色，并将这些值保存到一个临时数组temporaryBoard中，最后在构建完成时将此数组作为闭包返回值返回。这个返回的数组会保存到boardColors中，并可以通过工具函数squareIsBlackAtRow来查询： 12345let board = Chessboard()print(board.squareIsBlackAt(row: 0, column: 1))// Prints "true"print(board.squareIsBlackAt(row: 7, column: 7))// Prints "false" 参照文档 Initialization &gt;&gt; Copyright (c) liangtong. All rights reserved.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift Inheritance]]></title>
    <url>%2F2016%2F11%2F26%2FiOS_Swift_language_note_Inheritance%2F</url>
    <content type="text"><![CDATA[​ 一个类可以继承另一个类的方法，属性和其它特性。当一个类继承其它类时，继承类叫子类，被继承类叫超类（或父类）。在 Swift 中，继承是区分「类」与其它类型的一个基本特征。在 Swift 中，类可以调用和访问超类的方法，属性和下标，并且可以重写这些方法，属性和下标来优化或修改它们的行为。Swift 会检查你的重写定义在超类中是否有匹配的定义，以此确保你的重写行为是正确的。可以为类中继承来的属性添加属性观察器，这样一来，当属性值改变时，类就会被通知到。可以为任何属性添加属性观察器，无论它原本被定义为存储型属性还是计算型属性。 基类不继承于其它类的类，称之为基类。 Swift 中的类并不是从一个通用的基类继承而来。如果你不为你定义的类指定一个超类的话，这个类就自动成为基类。 下面的例子定义了一个叫Vehicle的基类。包含一个currentSpeed存储属性，一个description的只读计算属性，一个makeNoise方法，方法什么都不做，子类会重写该方法。 123456789class Vehicle &#123; var currentSpeed = 0.0 var description: String &#123; return "traveling at \(currentSpeed) miles per hour" &#125; func makeNoise() &#123; // do nothing - an arbitrary vehicle doesn't necessarily make a noise &#125;&#125; 实例化对象，并访问其属性： 1234let someVehicle = Vehicle()print("Vehicle: \(someVehicle.description)")// Vehicle: traveling at 0.0 miles per hour 子类子类是在一个已有类的基础上创建一个新的类，你可以重新定义子类继承已有类的特性，也可以为子类添加新特性来完善子类。类继承使用冒号分割，将超类写在冒号后边： 123class SomeSubclass: SomeSuperclass &#123; // subclass definition goes here&#125; 下一个例子，定义一个叫Bicycle的子类，继承成父类Vehicle： 123class Bicycle: Vehicle &#123; var hasBasket = false&#125; 新的Bicycle类自动获得Vehicle类的所有特性，Bicycle类还定义了一个默认值为false的存储型属性hasBasket（属性推断为Bool）。 123456let bicycle = Bicycle()bicycle.hasBasket = truebicycle.currentSpeed = 15.0print("Bicycle: \(bicycle.description)")// Bicycle: traveling at 15.0 miles per hour 子类还可以继续被其它类继承，下面的示例为Bicycle创建了一个名为Tandem（双人自行车）的子类： 12345678910class Tandem: Bicycle &#123; var currentNumberOfPassengers = 0&#125;let tandem = Tandem()tandem.hasBasket = truetandem.currentNumberOfPassengers = 2tandem.currentSpeed = 22.0print("Tandem: \(tandem.description)")// Tandem: traveling at 22.0 miles per hour 重写子类可以为继承来的实例方法，类方法，实例属性，或下标提供自己定制的实现。我们把这种行为叫重写。如果要重写某个特性，你需要在重写定义的前面加上 override 关键字。这么做，你就表明了你是想提供一个重写版本，而非错误地提供了一个相同的定义。任何缺少override关键字的重写都会在编译时被诊断为错误。override关键字会提醒 Swift 编译器去检查该类的超类（或其中一个父类）是否有匹配重写版本的声明。这个检查可以确保你的重写定义是正确的。 访问超类的方法，属性及下标当你在子类中重写超类的方法，属性或下标时，有时在你的重写版本中使用已经存在的超类实现会大有裨益。比如，你可以完善已有实现的行为，或在一个继承来的变量中存储一个修改过的值。你可以通过使用 super 前缀来访问超类版本的方法，属性或下标： 在方法someMethod()的重写实现中，可以通过super.someMethod()来调用超类版本的someMethod()方法。 在属性someProperty的 getter 或 setter 的重写实现中，可以通过super.someProperty来访问超类版本的someProperty属性。 在下标的重写实现中，可以通过super[someIndex]来访问超类版本中的相同下标。 重写方法在子类中，你可以重写继承来的实例方法或类方法，提供一个定制或替代的方法实现。下面的例子定义了Vehicle的一个新的子类，叫Train，它重写了从Vehicle类继承来的makeNoise()方法： 123456789class Train: Vehicle &#123; override func makeNoise() &#123; print("Choo Choo") &#125;&#125;let train = Train()train.makeNoise()// Prints "Choo Choo" 重写属性你可以重写继承来的实例属性或类型属性，提供自己定制的 getter 和 setter，或添加属性观察器使重写的属性可以观察属性值什么时候发生改变。 重写属性的 Getters 和 Setters你可以提供定制的 getter（或 setter）来重写任意继承来的属性，无论继承来的属性是存储型的还是计算型的属性。子类并不知道继承来的属性是存储型的还是计算型的，它只知道继承来的属性会有一个名字和类型。你在重写一个属性时，必需将它的名字和类型都写出来。这样才能使编译器去检查你重写的属性是与超类中同名同类型的属性相匹配的。你可以将一个继承来的只读属性重写为一个读写属性，只需要在重写版本的属性里提供 getter 和 setter 即可。但是，你不可以将一个继承来的读写属性重写为一个只读属性。 如果你在重写属性中提供了 setter，那么你也一定要提供 getter。如果你不想在重写版本中的 getter 里修改继承来的属性值，你可以直接通过super.someProperty来返回继承来的值，其中someProperty是你要重写的属性的名字。 以下的例子定义了一个新类，叫Car，它是Vehicle的子类。这个类引入了一个新的存储型属性叫做gear，默认值为整数1。Car类重写了继承自Vehicle的description属性，提供包含当前档位的自定义描述： 123456class Car: Vehicle &#123; var gear = 1 override var description: String &#123; return super.description + " in gear \(gear)" &#125;&#125; 如果你创建了Car的实例并且设置了它的gear和currentSpeed属性，你可以看到它的description返回了Car中的自定义描述： 12345let car = Car()car.currentSpeed = 25.0car.gear = 3print("Car: \(car.description)")// Car: traveling at 25.0 miles per hour in gear 3 重写属性观察器你可以通过重写属性为一个继承来的属性添加属性观察器。这样一来，当继承来的属性值发生改变时，你就会被通知到，无论那个属性原本是如何实现的。 你不可以为继承来的常量存储型属性或继承来的只读计算型属性添加属性观察器。这些属性的值是不可以被设置的，所以，为它们提供willSet或didSet实现是不恰当。此外还要注意，你不可以同时提供重写的 setter 和重写的属性观察器。如果你想观察属性值的变化，并且你已经为那个属性提供了定制的 setter，那么你在 setter 中就可以观察到任何值变化了。 下面的例子定义了一个新类叫AutomaticCar，它是Car的子类。AutomaticCar表示自动挡汽车，它可以根据当前的速度自动选择合适的挡位: 123456789101112class AutomaticCar: Car &#123; override var currentSpeed: Double &#123; didSet &#123; gear = Int(currentSpeed / 10.0) + 1 &#125; &#125;&#125;let automatic = AutomaticCar()automatic.currentSpeed = 35.0print("AutomaticCar: \(automatic.description)")// AutomaticCar: traveling at 35.0 miles per hour in gear 4 防止重写你可以通过把方法，属性或下标标记为final来防止它们被重写，只需要在声明关键字前加上 final 修饰符即可（例如：final var，final func，final class func，以及final subscript）。 如果你重写了带有 final 标记的方法，属性或下标，在编译时会报错。在类扩展中的方法，属性或下标也可以在扩展的定义里标记为 final 的。 你可以通过在关键字 class 前添加 final 修饰符（final class）来将整个类标记为 final 的。这样的类是不可被继承的，试图继承这样的类会导致编译报错。 参照文档 Inheritance &gt;&gt; Copyright (c) liangtong. All rights reserved.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift Subscripts]]></title>
    <url>%2F2016%2F11%2F26%2FiOS_Swift_language_note_Subscripts%2F</url>
    <content type="text"><![CDATA[​ 下标可以定义在类、结构体和枚举中，为访问集合，列表或序列中元素提供便捷。可以使用下标的索引，设置和获取值，而不需要再调用对应的存取方法。举例来说，用下标访问一个Array实例中的元素可以写作someArray[index]，访问Dictionary实例中的元素可以写作someDictionary[key]。 语法下标允许你通过在实例化对象后边的中括号中添加一个或多个索引值来查询或修改实例。语法类似于实例方法语法和计算型属性语法。通过关键字 subscript 定义，并指定一个或多个输入参数和返回类型；与实例方法不同的是。下标语法可以设定为读写( read-write )或只读( read-only )。这种行为由 getter 和 setter 实现，有点类似计算型属性： 12345678subscript(index: Int) -&gt; Int &#123; get &#123; // return an appropriate subscript value here &#125; set(newValue) &#123; // perform a suitable setting action here &#125;&#125; newValue的类型和下标的返回类型相同。如同计算型属性，可以不指定 setter 的参数（newValue）。如果不指定参数，setter 会提供一个名为newValue的默认参数。如同只读计算型属性，可以省略只读下标的get关键字： 123subscript(index: Int) -&gt; Int &#123; // return an appropriate subscript value here&#125; 下面代码演示了只读下标的实现： 123456789struct TimesTable &#123; let multiplier: Int subscript(index: Int) -&gt; Int &#123; return multiplier * index &#125;&#125;let threeTimesTable = TimesTable(multiplier: 3)print("six times three is \(threeTimesTable[6])")// Prints "six times three is 18" 用法下标的含义通常取决于使用场景，通常在集合、列表和序列中快速访问用。你也可以根据自己的特定类型实现下标功能。例如Swift中的字典Dictionary使用下标语法对实例中储存的值进行存取操作。 12var numberOfLegs = ["spider": 8, "ant": 6, "cat": 4]numberOfLegs["bird"] = 2 Swift 的Dictionary类型的下标接受并返回可选类型的值。因为不是每个键都有个对应的值，同时这也提供了一种通过键删除对应值的方式，只需将键对应的值赋值为nil即可。 选项下标可以接受任意数量的入参，并且这些入参可以是任意类型。下标的返回值也可以是任意类型。下标可以使用变量参数和可变参数，但不能使用输入输出参数，也不能给参数设置默认值。一个类或结构体可以根据自身需要提供多个下标实现 12345678910111213141516171819202122struct Matrix &#123; let rows: Int, columns: Int var grid: [Double] init(rows: Int, columns: Int) &#123; self.rows = rows self.columns = columns grid = Array(repeating: 0.0, count: rows * columns) &#125; func indexIsValid(row: Int, column: Int) -&gt; Bool &#123; return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns &#125; subscript(row: Int, column: Int) -&gt; Double &#123; get &#123; assert(indexIsValid(row: row, column: column), "Index out of range") return grid[(row * columns) + column] &#125; set &#123; assert(indexIsValid(row: row, column: column), "Index out of range") grid[(row * columns) + column] = newValue &#125; &#125;&#125; 你可以通过传入合适的row和column的数量来构造一个新的Matrix实例： 1var matrix = Matrix(rows: 2, columns: 2) 将row和column的值传入下标来为矩阵设值，下标的入参使用逗号分隔： 12matrix[0, 1] = 1.5matrix[1, 0] = 3.2 访问 12345let rightTopValue = matrix[0, 1]// 1.5let someValue = matrix[2, 2]// this triggers an assert, because [2, 2] is outside of the matrix bounds 参照文档 Subscripts &gt;&gt; Copyright (c) liangtong. All rights reserved.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift Methods]]></title>
    <url>%2F2016%2F11%2F25%2FiOS_Swift_language_note_Methods%2F</url>
    <content type="text"><![CDATA[​ 方法是与某些特定类型相关联的函数。类、结构体、枚举都可以定义实例方法；实例方法为给定类型的实例封装了具体的任务与功能。类、结构体、枚举也可以定义类型方法；类型方法与类型本身相关联。类型方法与 Objective-C 中的类方法（class methods）相似。结构体和枚举能够定义方法是 Swift 与 C/Objective-C 的主要区别之一。在 Objective-C 中，类是唯一能定义方法的类型。但在 Swift 中，你不仅能选择是否要定义一个类/结构体/枚举，还能灵活地在你创建的类型（类/结构体/枚举）上定义方法。 实例方法实例方法是属于某个特定类、结构体或者枚举类型实例的方法。实例方法提供访问和修改实例属性的方法或提供与实例目的相关的功能，并以此来支撑实例的功能。实例方法的语法与函数完全一致。实例方法要写在它所属的类型的前后大括号之间。实例方法能够隐式访问它所属类型的所有的其他实例方法和属性。实例方法只能被它所属的类的某个特定实例调用。实例方法只能由实例调用。下面的例子，定义一个很简单的Counter类，Counter能被用来对一个动作发生的次数进行计数： 123456789101112class Counter &#123; var count = 0 func increment() &#123; count += 1 &#125; func increment(by amount: Int) &#123; count += amount &#125; func reset() &#123; count = 0 &#125;&#125; Counter这个类定义了一个属性和3个方法，其实例可以通过点语法来调用属性和方法 12345678let counter = Counter()// the initial counter value is 0counter.increment()// the counter's value is now 1counter.increment(by: 5)// the counter's value is now 6counter.reset()// the counter's value is now 0 self属性类型的每一个实例都有一个隐含属性叫做self，self完全等同于该实例本身。你可以在一个实例的实例方法中使用这个隐含的self属性来引用当前实例。上面例子中的increment方法还可以这样写： 123func increment() &#123; self.count += 1&#125; 实际上，你不必在你的代码里面经常写self。如果你没有明确地写self，Swift 假定你是指当前实例的属性或者方法。使用这条规则的主要场景是实例方法的某个参数名称与实例的某个属性名称相同的时候。在这种情况下，参数名称享有优先权，并且在引用属性时必须使用一种更严格的方式。这时你可以使用self属性来区分参数名称和属性名称。下面的例子中，self消除方法参数x和实例属性x之间的歧义： 1234567891011struct Point &#123; var x = 0.0, y = 0.0 func isToTheRightOf(x: Double) -&gt; Bool &#123; return self.x &gt; x &#125;&#125;let somePoint = Point(x: 4.0, y: 5.0)if somePoint.isToTheRightOf(x: 1.0) &#123; print("This point is to the right of the line where x == 1.0")&#125;// Prints "This point is to the right of the line where x == 1.0" 在实例方法中修改值类型结构体和枚举是值类型。默认情况下，值类型的属性不能在它的实例方法中被修改。但是，如果你确实需要在某个特定的方法中修改结构体或者枚举的属性，你可以为这个方法选择可变(mutating)行为，然后就可以从其方法内部改变它的属性；并且这个方法做的任何改变都会在方法执行结束时写回到原始结构中。方法还可以给它隐含的self属性赋予一个全新的实例，这个新实例在方法结束时会替换现存实例。要使用可变方法，将关键字 mutating 放到方法的 func 关键字之前就可以了： 1234567891011struct Point &#123; var x = 0.0, y = 0.0 mutating func moveBy(x deltaX: Double, y deltaY: Double) &#123; x += deltaX y += deltaY &#125;&#125;var somePoint = Point(x: 1.0, y: 1.0)somePoint.moveBy(x: 2.0, y: 3.0)print("The point is now at (\(somePoint.x), \(somePoint.y))")// Prints "The point is now at (3.0, 4.0)" 注意，不能在结构体类型的常量（a constant of structure type）上调用可变方法，因为其属性不能被改变，即使属性是变量属性。 123let fixedPoint = Point(x: 3.0, y: 3.0)fixedPoint.moveBy(x: 2.0, y: 3.0)// this will report an error 在可变方法中给 self 赋值可变方法能够赋给隐含属性self一个全新的实例。上面Point的例子可以用下面的方式改写： 123456struct Point &#123; var x = 0.0, y = 0.0 mutating func moveBy(x deltaX: Double, y deltaY: Double) &#123; self = Point(x: x + deltaX, y: y + deltaY) &#125;&#125; 枚举的可变方法可以把self设置为同一枚举类型中不同的成员： 123456789101112131415161718enum TriStateSwitch &#123; case off, low, high mutating func next() &#123; switch self &#123; case .off: self = .low case .low: self = .high case .high: self = .off &#125; &#125;&#125;var ovenLight = TriStateSwitch.lowovenLight.next()// ovenLight is now equal to .highovenLight.next()// ovenLight is now equal to .off 简单的状态模式。 类型方法实例方法是被某个类型的实例调用的方法。你也可以定义在类型本身上调用的方法，这种方法就叫做类型方法。在方法的func关键字之前加上关键字 static，来指定类型方法。类还可以用关键字 class 来允许子类重写父类的方法实现。 在 Objective-C 中，你只能为 Objective-C 的类类型（classes）定义类型方法（type-level methods）。在 Swift 中，你可以为所有的类、结构体和枚举定义类型方法。每一个类型方法都被它所支持的类型显式包含。 类型方法和实例方法一样用点语法调用。但是，你是在类型上调用这个方法，而不是在实例上调用。下面是如何在SomeClass类上调用类型方法的例子： 123456class SomeClass &#123; class func someTypeMethod() &#123; // type method implementation goes here &#125;&#125;SomeClass.someTypeMethod() 在类型方法的方法体（body）中，self指向这个类型本身，而不是类型的某个实例。这意味着你可以用self来消除类型属性和类型方法参数之间的歧义（类似于我们在前面处理实例属性和实例方法参数时做的那样）。 一般而言，在一个类型中，类型方法可以调用类型方法或类型属性，不需要在被调用的类型方法或者类型属性前不需要添加类型名称。类似的，在结构体和枚举中，也能够直接通过类型属性的名称访问本类中的类型属性，而不需要前面加上类型名称。 下面的例子定义了一个名为LevelTracker结构体。它监测玩家的游戏发展情况（游戏的不同层次或阶段）。这是一个单人游戏，但也可以存储多个玩家在同一设备上的游戏信息。 游戏初始时，所有的游戏等级（除了等级 1）都被锁定。每次有玩家完成一个等级，这个等级就对这个设备上的所有玩家解锁。LevelTracker结构体用类型属性和方法监测游戏的哪个等级已经被解锁。它还监测每个玩家的当前等级。 123456789101112131415161718192021222324252627struct LevelTracker &#123;//记录最高解锁等级 static var highestUnlockedLevel = 1//记录当前玩家等级 var currentLevel = 1 //解锁新等级 static func unlock(_ level: Int) &#123; if level &gt; highestUnlockedLevel &#123; highestUnlockedLevel = level &#125; &#125; //判断某个等级是否被解锁 static func isUnlocked(_ level: Int) -&gt; Bool &#123; return level &lt;= highestUnlockedLevel &#125; //忽略调用该方法时不使用返回值的警告，更新当前玩家等级前检查是否已经解锁最新等级了 @discardableResult mutating func advance(to level: Int) -&gt; Bool &#123; if LevelTracker.isUnlocked(level) &#123; currentLevel = level return true &#125; else &#123; return false &#125; &#125;&#125; 下面，Player类使用LevelTracker来监测和更新每个玩家的发展进度： 1234567891011class Player &#123; var tracker = LevelTracker() let playerName: String func complete(level: Int) &#123; LevelTracker.unlock(level + 1) tracker.advance(to: level + 1) &#125; init(name: String) &#123; playerName = name &#125;&#125; Player类创建一个新的LevelTracker实例来监测这个用户的进度。它提供了complete(level:)方法，一旦玩家完成某个指定等级就调用它。这个方法为所有玩家解锁下一等级，并且将当前玩家的进度更新为下一等级。（我们忽略了advance(to:)返回的布尔值，因为之前调用LevelTracker.unlock(_:)时就知道了这个等级已经被解锁了）。 你还可以为一个新的玩家创建一个Player的实例，然后看这个玩家完成等级一时发生了什么： 1234var player = Player(name: "Argyrios")player.complete(level: 1)print("highest unlocked level is now \(LevelTracker.highestUnlockedLevel)")// Prints "highest unlocked level is now 2" 如果你创建了第二个玩家，并尝试让他开始一个没有被任何玩家解锁的等级，那么试图设置玩家当前等级将会失败： 1234567player = Player(name: "Beto")if player.tracker.advance(to: 6) &#123; print("player is now on level 6")&#125; else &#123; print("level 6 has not yet been unlocked")&#125;// Prints "level 6 has not yet been unlocked" 参照文档 Methods &gt;&gt; Copyright (c) liangtong. All rights reserved.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift Properties]]></title>
    <url>%2F2016%2F11%2F25%2FiOS_Swift_language_note_Properties%2F</url>
    <content type="text"><![CDATA[​ 属性将值跟特定的类、结构或枚举关联。存储属性存储常量或变量作为实例的一部分，而计算属性计算（不是存储）一个值。计算属性可以用于类、结构体和枚举，存储属性只能用于类和结构体。存储属性和计算属性通常与特定类型的实例关联。但是，属性也可以直接作用于类型本身，这种属性称为类型属性。另外，还可以定义属性观察器来监控属性值的变化，以此来触发一个自定义的操作。属性观察器可以添加到自己定义的存储属性上，也可以添加到从父类继承的属性上。 存储属性简单来说，一个存储属性就是存储在特定类或结构体实例里的一个常量(let)或变量(var)。可以在定义存储属性的时候指定默认值。也可以在构造过程中设置或修改存储属性的值，甚至修改常量存储属性的值。 下面的例子定义了一个名为 FixedLengthRange 的结构体，该结构体用于描述整数的范围，且这个范围值在被创建后不能被修改，因为它是一个常量存储属性。 12345678struct FixedLengthRange &#123; var firstValue: Int let length: Int&#125;var rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)// the range represents integer values 0, 1, and 2rangeOfThreeItems.firstValue = 6// the range now represents integer values 6, 7, and 8 常量结构体的存储属性如果创建了一个结构体的实例并将其赋值给一个常量，则无法修改该实例的任何属性，即使有属性被声明为变量也不行： 1234let rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)// this range represents integer values 0, 1, 2, and 3rangeOfFourItems.firstValue = 6// this will report an error, even though firstValue is a variable property 这种行为是由于结构体（struct）属于值类型。当值类型的实例被声明为常量的时候，它的所有属性也就成了常量。 属于引用类型的类（class）则不一样。把一个引用类型的实例赋给一个常量后，仍然可以修改该实例的变量属性。 延迟存储属性延迟存储属性是指当第一次被调用的时候才会计算其初始值的属性。在属性声明前使用 lazy 来标示一个延迟存储属性。 必须将延迟存储属性声明成变量（使用 var 关键字），因为属性的初始值可能在实例构造完成之后才会得到。而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性。 当属性的值依赖于在实例的构造过程结束后才会知道影响值的外部因素时,延迟属性会很有用；或者当获得属性的初始值需要复杂或大量计算时，可以只在需要的时候计算它时，延迟属性也会很有用。下面的例子使用了延迟存储属性来避免复杂类中不必要的初始化。例子中定义了 DataImporter 和 DataManager 两个类，下面是部分代码： 12345678910111213141516171819class DataImporter &#123; /* DataImporter is a class to import data from an external file. The class is assumed to take a non-trivial amount of time to initialize. */ var fileName = "data.txt" // the DataImporter class would provide data importing functionality here&#125; class DataManager &#123; lazy var importer = DataImporter() var data = [String]() // the DataManager class would provide data management functionality here&#125; let manager = DataManager()manager.data.append("Some data")manager.data.append("Some more data")// the DataImporter instance for the importer property has not yet been created 由于使用了 lazy ，importer 属性只有在第一次被访问的时候才被创建。比如访问它的属性 fileName 时： 123print(manager.importer.fileName)// the DataImporter instance for the importer property has now been created// Prints "data.txt" 如果一个被标记为 lazy 的属性在没有初始化时就同时被多个线程访问，则无法保证该属性只会被初始化一次。 存储属性和实例化变量如果您有过 Objective-C 经验，应该知道 Objective-C 为类实例存储值和引用提供两种方法。除了属性之外，还可以使用实例变量(.m文件中)作为属性值的后端存储。Swift 编程语言中把这些理论统一用属性来实现。Swift 中的属性没有对应的实例变量，属性的全部信息——包括命名、类型和内存管理特征——都在唯一一个地方（类型定义中）定义。 计算属性除存储属性外，类、结构体和枚举可以定义计算属性。计算属性不直接存储值，而是提供一个 getter 和一个可选的 setter，来间接获取和设置其他属性或变量的值。 123456789101112131415161718192021222324252627struct Point &#123; var x = 0.0, y = 0.0&#125;struct Size &#123; var width = 0.0, height = 0.0&#125;struct Rect &#123; var origin = Point() var size = Size() var center: Point &#123; get &#123; let centerX = origin.x + (size.width / 2) let centerY = origin.y + (size.height / 2) return Point(x: centerX, y: centerY) &#125; set(newCenter) &#123; origin.x = newCenter.x - (size.width / 2) origin.y = newCenter.y - (size.height / 2) &#125; &#125;&#125;var square = Rect(origin: Point(x: 0.0, y: 0.0), size: Size(width: 10.0, height: 10.0))let initialSquareCenter = square.centersquare.center = Point(x: 15.0, y: 15.0)print("square.origin is now at (\(square.origin.x), \(square.origin.y))")// Prints "square.origin is now at (10.0, 10.0)" 简化的Setter声明如果计算属性的 setter 没有定义表示新值的参数名，则可以使用默认名称 newValue。下面是使用了简化 setter 声明的 Rect 结构体代码： 123456789101112131415struct AlternativeRect &#123; var origin = Point() var size = Size() var center: Point &#123; get &#123; let centerX = origin.x + (size.width / 2) let centerY = origin.y + (size.height / 2) return Point(x: centerX, y: centerY) &#125; set &#123; origin.x = newValue.x - (size.width / 2) origin.y = newValue.y - (size.height / 2) &#125; &#125;&#125; 只读计算属性只有 getter 没有 setter 的计算属性就是只读计算属性。只读计算属性总是返回一个值，可以通过点运算符访问，但不能设置新的值。 必须使用 var 关键字定义计算属性，包括只读计算属性，因为它们的值不是固定的。let 关键字只用来声明常量属性，表示初始化后再也无法修改的值。 只读计算属性的声明可以去掉 get 关键字和花括号： 123456789struct Cuboid &#123; var width = 0.0, height = 0.0, depth = 0.0 var volume: Double &#123; return width * height * depth &#125;&#125;let fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)print("the volume of fourByFiveByTwo is \(fourByFiveByTwo.volume)")// Prints "the volume of fourByFiveByTwo is 40.0" 属性观察器属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，即使新值和当前值相同的时候也不例外。可以为除了延迟存储属性之外的其他存储属性添加属性观察器，也可以通过重写属性的方式为继承的属性（包括存储属性和计算属性）添加属性观察器。你不必为非重写的计算属性添加属性观察器，因为可以通过它的 setter 直接监控和响应值的变化。可以为属性添加如下的一个或全部观察器： willSet 在新的值被设置之前调用 didSet 在新的值被设置之后立即调用 willSet 观察器会将新的属性值作为常量参数传入，在 willSet 的实现代码中可以为这个参数指定一个名称，如果不指定则参数仍然可用，这时使用默认名称 newValue 表示。 同样，didSet 观察器会将旧的属性值作为参数传入，可以为该参数命名或者使用默认参数名 oldValue。如果在 didSet 方法中再次对该属性赋值，那么新值会覆盖旧的值。 父类的属性在子类的构造器中被赋值时，它在父类中的 willSet 和 didSet 观察器会被调用，随后才会调用子类的观察器。在父类初始化方法调用之前，子类给属性赋值时，观察器不会被调用。 下面是一个 willSet 和 didSet 实际运用的例子，其中定义了一个名为 StepCounter 的类，用来统计一个人步行时的总步数。这个类可以跟计步器或其他日常锻炼的统计装置的输入数据配合使用。 12345678910111213141516171819202122class StepCounter &#123; var totalSteps: Int = 0 &#123; willSet(newTotalSteps) &#123; print("About to set totalSteps to \(newTotalSteps)") &#125; didSet &#123; if totalSteps &gt; oldValue &#123; print("Added \(totalSteps - oldValue) steps") &#125; &#125; &#125;&#125;let stepCounter = StepCounter()stepCounter.totalSteps = 200// About to set totalSteps to 200// Added 200 stepsstepCounter.totalSteps = 360// About to set totalSteps to 360// Added 160 stepsstepCounter.totalSteps = 896// About to set totalSteps to 896// Added 536 steps 如果将属性通过 in-out 方式传入函数，willSet 和 didSet 也会调用。这是因为 in-out 参数采用了拷入拷出模式：即在函数内部使用的是参数的 copy，函数结束后，又对参数重新赋值。 全局变量和局部变量计算属性和属性观察器所描述的功能也可以用于全局变量和局部变量。全局变量是在函数、方法、闭包或任何类型之外定义的变量。局部变量是在函数、方法或闭包内部定义的变量。 全局的常量或变量都是延迟计算的，跟延迟存储属性相似，不同的地方在于，全局的常量或变量不需要标记lazy修饰符。局部范围的常量或变量从不延迟计算。 类型属性实例属性属于一个特定类型的实例，每创建一个实例，实例都拥有属于自己的一套属性值，实例之间的属性相互独立。也可以为类型本身定义属性，无论创建了多少个该类型的实例，这些属性都只有唯一一份。这种属性就是类型属性。 跟实例的存储型属性不同，必须给存储型类型属性指定默认值，因为类型本身没有构造器，也就无法在初始化过程中使用构造器给类型属性赋值。存储型类型属性是延迟初始化的，它们只有在第一次被访问的时候才会被初始化。即使它们被多个线程同时访问，系统也保证只会对其进行一次初始化，并且不需要对其使用 lazy 修饰符。 类属性定义语法在 C 或 Objective-C 中，与某个类型关联的静态常量和静态变量，是作为全局（global）静态变量定义的。但是在 Swift 中，类型属性是作为类型定义的一部分写在类型最外层的花括号内，因此它的作用范围也就在类型支持的范围内。使用关键字 static 来定义类型属性。在为类定义计算型类型属性时，可以改用关键字 class 来支持子类对父类的实现进行重写。下面的例子演示了存储型和计算型类型属性的语法： 12345678910111213141516171819202122struct SomeStructure &#123; static var storedTypeProperty = "Some value." static var computedTypeProperty: Int &#123; return 1 &#125;&#125;enum SomeEnumeration &#123; static var storedTypeProperty = "Some value." static var computedTypeProperty: Int &#123; return 6 &#125;&#125;class SomeClass &#123; static var storedTypeProperty = "Some value." static var computedTypeProperty: Int &#123; return 27 &#125;//本例子中的计算属性是只读的，可以定义为读写的，跟计算型属性的语法相同。用class修饰的方法，可以被子类重写 class var overrideableComputedTypeProperty: Int &#123; return 107 &#125;&#125; 注意：对于为类定义可被重写的计算属性，需要使用关键字 class 来修饰，而不是 static。原文是这样的： For computed type properties for class types, you can use the class keyword instead to allow subclasses to override the superclass’s implementation. 类型属性的获取和设置跟实例属性一样，类型属性也是通过点运算符来访问。但是，类型属性是通过类型本身来访问，而不是通过实例。比如： 123456789print(SomeStructure.storedTypeProperty)// Prints "Some value."SomeStructure.storedTypeProperty = "Another value."print(SomeStructure.storedTypeProperty)// Prints "Another value."print(SomeEnumeration.computedTypeProperty)// Prints "6"print(SomeClass.computedTypeProperty)// Prints "27" 参照文档 Properties &gt;&gt; Copyright (c) liangtong. All rights reserved.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift Classes and Structures]]></title>
    <url>%2F2016%2F11%2F24%2FiOS_Swift_language_note_Classes%20and%20Structures%2F</url>
    <content type="text"><![CDATA[​ 类和结构体是人们构建代码所用的一种通用且灵活的构造体。你可以使用几乎完全相同的语法规则给类和结构体定义属性、添加方法。与其他语言不同的是，Swift不需要你为自定义类和结构体去独立创建接口和实现文件。在Swwift中，你只需要使用一个单独的文件来定义类和结构体，系统会自动生成面向其他代码的外部接口。 通常类的实例被称为对象，Swift中类和结构体的关系比在其他语言中要密切 类和结构体的对比类和结构体在Swift中有很多共同点，例如： 定义属性用于存储值 定义方法用于提供功能 定义下标操作涌来通过下标语法来访问实例存储的值 定义构造函数用于初始化值 通过扩展来增加其功能的实现 实现协议以提供某种标准功能 与结构体相比，类还有如下额外功能： 继承允许一个类继承另一个类的特征 类型转换允许在运行时检查和解释一个类实例等类型 析构器允许一个类释放其所被分配到资源 引用计数允许一个类被多次引用。 注意：结构体通常是通过值传递，而不使用引用计数 定义语法类和结构体有相似的定义语法，通过关键字class定义类，struct定义结构体，在一对大括号中定义它们的具体内容： 123456class SomeClass &#123; // class definition goes here&#125;struct SomeStructure &#123; // structure definition goes here&#125; 当你定义了类或者结构体的时候，确切的讲是定义了一个新类型。使用UpperCamelCase这种方式来命名（如SomeClass和SomeStructure等），相反的，请使用lowerCamelCase这种方式为属性和方法命名（如framerate和incrementCount），以便和类型名区分。 以下是定义结构体和类的示例： 12345678910struct Resolution &#123; var width = 0 var height = 0&#125;class VideoMode &#123; var resolution = Resolution() var interlaced = false var frameRate = 0.0 var name: String?&#125; 类和结构体实例生成类和结构体实例等语法很相似，例如： 12let someResolution = Resolution()let someVideoMode = VideoMode() 结构体和类都使用构造器语法来生成新的实例。构造器语法的最简单形式是在结构体或者类的类型名称后跟随一对空括号，如Resolution()或VideoMode()。通过这种方式所创建的类或者结构体实例，其属性均会被初始化为默认值。 属性访问通过使用点语法，你可以访问实例的属性。其语法规则是，实例名后面紧跟属性名，两者通过点号(.)连接，不能有空格： 12345print("The width of someResolution is \(someResolution.width)")// Prints "The width of someResolution is 0"print("The width of someVideoMode is \(someVideoMode.resolution.width)")// Prints "The width of someVideoMode is 0" 也可以使用点语法为变量属性赋值，例如： 123someVideoMode.resolution.width = 1280print("The width of someVideoMode is now \(someVideoMode.resolution.width)")// Prints "The width of someVideoMode is now 1280" 与 Objective-C 语言不同的是，Swift 允许直接设置结构体属性的子属性。上面的最后一个例子，就是直接设置了someVideoMode中resolution属性的width这个子属性，以上操作并不需要重新为整个resolution属性设置新值。 结构体成员逐一构造函数所有结构体都有一个自动生成的成员逐一构造器，用于初始化新结构体实例中成员的属性。新实例中各个属性的初始值可以通过属性的名称传递到成员逐一构造器之中： 1let vga = Resolution(width: 640, height: 480) 与结构体不同的是，类实例没有默认的成员逐一构造器 结构体和枚举是值类型值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝。在Swift中，所有的基本类型：整数（Integer）、浮点数（floating-point）、布尔值（Boolean）、字符串（string)、数组（array）和字典（dictionary），都是值类型，并且在底层都是以结构体的形式所实现。在 Swift 中，所有的结构体和枚举类型都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型属性，在代码中传递的时候都会被复制。例如： 12let hd = Resolution(width: 1920, height: 1080)var cinema = hd 声明一个名为hd的常量，初始值宽高分别为1920和1080，然后声明一个名为cinema的变量，并将hd赋值给它。由于Resolution是结构体类型，所以cinema的值其实是hd的一个拷贝副本，而不是hd本身。尽管它们两个的值相同，但是是两个不同的实例。例如以下修改后，hd的值不变： 1234567cinema.width = 2048print("cinema is now \(cinema.width) pixels wide")// Prints "cinema is now 2048 pixels wide"print("hd is still \(hd.width) pixels wide")// Prints "hd is still 1920 pixels wide" 枚举也遵循相同的行为标准 12345678910enum CompassPoint &#123; case north, south, east, west&#125;var currentDirection = CompassPoint.westlet rememberedDirection = currentDirectioncurrentDirection = .eastif rememberedDirection == .west &#123; print("The remembered direction is still .west")&#125;// Prints "The remembered direction is still .west" 类是引用类型与值类型不同，引用类型在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，引用的是已存在的实例本身而不是其拷贝。例如，实例化一个类VideoMode的对象，并为其属性赋值： 12345let tenEighty = VideoMode()tenEighty.resolution = hdtenEighty.interlaced = truetenEighty.name = "1080i"tenEighty.frameRate = 25.0 然后将其赋值给一个新变量，同时对新变量进行修改 12let alsoTenEighty = tenEightyalsoTenEighty.frameRate = 30.0 因为类是引用类型，所以tenEight和alsoTenEight实际上引用的是相同的VideoMode实例。换句话说，它们是同一个实例的两种叫法。 12print("The frameRate property of tenEighty is now \(tenEighty.frameRate)")// Prints "The frameRate property of tenEighty is now 30.0" 需要注意的是tenEighty和alsoTenEighty被声明为常量而不是变量。然而你依然可以改变tenEighty.frameRate和alsoTenEighty.frameRate，因为tenEighty和alsoTenEighty这两个常量的值并未改变。它们并不“存储”这个VideoMode实例，而仅仅是对VideoMode实例的引用。所以，改变的是被引用的VideoMode的frameRate属性，而不是引用VideoMode的常量的值。 恒等运算符因为类是引用类型，有可能有多个常量和变量在幕后同时引用同一个类实例。（对于结构体和枚举来说，这并不成立。因为它们作为值类型，在被赋予到常量、变量或者传递到函数时，其值总是会被拷贝。）如果能够判定两个常量或者变量是否引用同一个类实例将会很有帮助。为了达到这个目的，Swift 内建了两个恒等运算符： === 等价于 !== 不等价于 运用这两个运算符可以检查两个变量或者常量是否引用同一个实例： 1234if tenEighty === alsoTenEighty &#123; print("tenEighty and alsoTenEighty refer to the same VideoMode instance.")&#125;// Prints "tenEighty and alsoTenEighty refer to the same VideoMode instance." 注意`=== 等价于`和`== 等于`的区别：一个是判断引用相同的类实例，一个是判断值相等 指针在C、C++、ObjC中，使用指针类引用内存中的地址，Swift中某个引用类型的常量或者变量和其他语言中的指针类似，但不是直接指向内存地址，也不要求你使用星号（*）来表明你在创建一个引用。Swift 中的这些引用与其它的常量或变量的定义方式相同。 类和结构体的选择你可以使用类或结构体来定义你自己的数据类型。但是结构体总是通过值传递，类是引用传递。这意味着两者适用不同的任务。当你在考虑一个工程项目的数据结构和功能的时候，你需要决定每个数据结构是定义成类还是结构体。 按照通用的准则，如果符合以下一条或者多条时，可以使用结构体： 该数据结构的主要目的是用来封装少量相关简单数据值。 有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。 该数据结构中储存的值类型属性，也应该被拷贝，而不是被引用。 该数据结构不需要去继承另一个既有类型的属性或者行为。 字符串、数组、和字典类型的赋值与复制行为Swift 中，许多基本类型，诸如String，Array和Dictionary类型均以结构体的形式实现。这意味着被赋值给新的常量或变量，或者被传入函数或方法中时，它们的值会被拷贝。 Objective-C 中NSString，NSArray和NSDictionary类型均以类的形式实现，而并非结构体。它们在被赋值或者被传入函数或方法时，不会发生值拷贝，而是传递现有实例的引用。 以上是对字符串、数组、字典的“拷贝”行为的描述。在你的代码中，拷贝行为看起来似乎总会发生。然而，Swift 在幕后只在绝对必要时才执行实际的拷贝。Swift 管理所有的值拷贝以确保性能最优化，所以你没必要去回避赋值来保证性能最优化。 参照文档 ClassesAndStructures &gt;&gt; Copyright (c) liangtong. All rights reserved.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift Enumerations]]></title>
    <url>%2F2016%2F11%2F23%2FiOS_Swift_language_note_Enumerations%2F</url>
    <content type="text"><![CDATA[​ 枚举为一系相关联的值定义了一个公共的组类型来保证你在类型安全的情况下去使用这些值。 C语言里边的枚举是一系列整型值；Swift中的枚举更佳灵活，而且你不需要为枚举的每个成员赋值，枚举中的原始值（raw）可以是字符串、字符、数字等。​ 就像其他语言中的联合体和变体，枚举中的成员可以被指定为不同于其他成员的可以存储的类型，你可以在一个枚举中定义一组相关的枚举成员，每一个枚举成员都可以有适当类型的关联值。​ 在Swift中，枚举是一等（first-class）类型，它们支持了很多在传统上只被类（class）所支持的特性，比如计算属性（computed properties），用于提供枚举值的附加信息，实例方法（instance methods），用于提供和枚举值相关联的功能。枚举也可以定义构造函数（initializers）来提供一个初始值；可以在原始实现的基础上扩展它们的功能；还可以遵循协议（protocols）来提供标准的功能。 枚举语法使用enum关键词来创建枚举并且把它们的整个定义放在一对大括号内： 123enum SomeEnumeration &#123; // enumeration definition goes here&#125; 例如一个指南针方向的例子： 123456enum CompassPoint &#123; case north case south case east case west&#125; 枚举中定义的值（如 north，south，east和west）是这个枚举的成员值（或成员）。你可以使用case关键字来定义一个新的枚举成员值。 与 C 和 Objective-C 不同，Swift 的枚举成员在被创建时不会被赋予一个默认的整型值。在上面的CompassPoint例子中，north，south，east和west不会被隐式地赋值为0，1，2和3。相反，这些枚举成员本身就是完备的值，这些值的类型是已经明确定义好的CompassPoint类型。 多个成员变量可以出现在一行上，用逗号隔开： 123enum Planet &#123; case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune&#125; 每个枚举定义了一个全新的类型。像 Swift 中其他类型一样，它们的名字（例如CompassPoint和Planet）应该以一个大写字母开头。给枚举类型起一个单数名字而不是复数名字，以便于读起来更加容易理解： 1var directionToHead = CompassPoint.west directionToHead的类型可以在它被CompassPoint的某个值初始化时推断出来。一旦directionToHead被声明为CompassPoint类型，你可以使用更简短的点语法将其设置为另一个CompassPoint的值： 1directionToHead = .east 使用 Switch 语句匹配枚举值可以使用switch语句来匹配枚举值，例如： 123456789101112directionToHead = .southswitch directionToHead &#123;case .north: print("Lots of planets have a north")case .south: print("Watch out for penguins")case .east: print("Where the sun rises")case .west: print("Where the skies are blue")&#125;// Prints "Watch out for penguins" 在判断一个枚举类型的值时，switch语句必须穷举所有情况。当不需要匹配每个枚举成员的时候，你可以提供一个default分支来涵盖所有未明确处理的枚举成员： 12345678let somePlanet = Planet.earthswitch somePlanet &#123;case .earth: print("Mostly harmless")default: print("Not a safe place for humans")&#125;// Prints "Mostly harmless" 关联值你可以定义 Swift 枚举来存储任意类型的关联值，如果需要的话，每个枚举成员的关联值类型可以各不相同。枚举的这种特性跟其他语言中的可识别联合（discriminated unions），标签联合（tagged unions），或者变体（variants）相似。例如，假设一个库存跟踪系统需要利用两种不同类型的条形码来跟踪商品。有些商品上标有使用0到9的数字的 UPC 格式的一维条形码。每一个条形码都有一个代表“数字系统”的数字，该数字后接五位代表“厂商代码”的数字，接下来是五位代表“产品代码”的数字。最后一个数字是“检查”位，用来验证代码是否被正确扫描：其他商品上标有 QR 码格式的二维码，它可以使用任何 ISO 8859-1 字符，并且可以编码一个最多拥有 2,953 个字符的字符串：这便于库存跟踪系统用包含四个整型值的元组存储 UPC 码，以及用任意长度的字符串储存 QR 码。 在 Swift 中，使用如下方式定义表示两种商品条形码的枚举： 1234enum Barcode &#123; case upc(Int, Int, Int, Int) case qrCode(String)&#125; 可以使用任意一种条形码类型创建新的条形码，例如，创建了一个名为productBarcode的变量，并将Barcode.upc赋值给它，关联的元组值为(8, 85909, 51226, 3)： 1var productBarcode = Barcode.upc(8, 85909, 51226, 3) 同一个商品可以被分配一个不同类型的条形码，例如，原始的Barcode.upc和其整数关联值被新的Barcode.qrCode和其字符串关联值所替代。Barcode类型的常量和变量可以存储一个.upc或者一个.qrCode（连同它们的关联值），但是在同一时间只能存储这两个值中的一个。： 1productBarcode = .qrCode("ABCDEFGHIJKLMNOP") 可以使用switch语句来匹配不同类型的枚举值，例如： 1234567switch productBarcode &#123;case .upc(let numberSystem, let manufacturer, let product, let check): print("UPC: \(numberSystem), \(manufacturer), \(product), \(check).")case .qrCode(let productCode): print("QR code: \(productCode).")&#125;// Prints "QR code: ABCDEFGHIJKLMNOP." 如果一个枚举成员的所有关联值都被提取为常量，或者都被提取为变量，为了简洁，你可以只在成员名称前标注一个let或者var： 1234567switch productBarcode &#123;case let .upc(numberSystem, manufacturer, product, check): print("UPC : \(numberSystem), \(manufacturer), \(product), \(check).")case let .qrCode(productCode): print("QR code: \(productCode).")&#125;// Prints "QR code: ABCDEFGHIJKLMNOP." 原始值raw作为关联值的替代选择，枚举成员可以被默认值（称为原始值）预填充，这些原始值的类型必须相同。例如，以下是一个使用 ASCII 码作为原始值的枚举： 12345enum ASCIIControlCharacter: Character &#123; case tab = "\t" case lineFeed = "\n" case carriageReturn = "\r"&#125; 原始值可以是字符串，字符，或者任意整型值或浮点型值。每个原始值在枚举声明中必须是唯一的。 原始值和关联值是不同的。原始值是在定义枚举时被预先填充的值，像上述三个 ASCII 码。对于一个特定的枚举成员，它的原始值始终不变。关联值是创建一个基于枚举成员的常量或变量时才设置的值，枚举成员的关联值可以变化。 原始值的隐式赋值在使用原始值为整数或者字符串类型的枚举时，不需要显式地为每一个枚举成员设置原始值，Swift 将会自动为你赋值。例如，当使用整数作为原始值时，隐式赋值的值依次递增1。如果第一个枚举成员没有设置原始值，其原始值将为0。下面的枚举是对之前Planet这个枚举的一个细化，利用整型的原始值来表示每个行星在太阳系中的顺序： 123enum Planet: Int &#123; case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune&#125; 在上面的例子中，Plant.mercury的显式原始值为1，Planet.venus的隐式原始值为2，依次类推。 当使用字符串作为枚举类型的原始值时，每个枚举成员的隐式原始值为该枚举成员的名称。下面的例子是CompassPoint枚举的细化，使用字符串类型的原始值来表示各个方向的名称： 123enum CompassPoint: String &#123; case north, south, east, west&#125; 使用枚举成员的rawValue属性可以访问该枚举成员的原始值： 12345let earthsOrder = Planet.earth.rawValue// earthsOrder is 3 let sunsetDirection = CompassPoint.west.rawValue// sunsetDirection is "west" 使用原始值初始化枚举实例如果在定义枚举类型的时候使用了原始值，那么将会自动获得一个初始化方法，这个方法接收一个叫做rawValue的参数，参数类型即为原始值类型，返回值则是枚举成员或nil。你可以使用这个初始化方法来创建一个新的枚举实例。例如 12let possiblePlanet = Planet(rawValue: 7)// possiblePlanet is of type Planet? and equals Planet.uranus 原始值构造器是一个可失败构造器，因为并不是每一个原始值都有与之对应的枚举成员。 原始值构造器总是返回一个可选的枚举成员。例如：如果你试图寻找一个位置为11的行星，通过原始值构造器返回的可选Planet值将是nil： 123456789101112let positionToFind = 11if let somePlanet = Planet(rawValue: positionToFind) &#123; switch somePlanet &#123; case .earth: print("Mostly harmless") default: print("Not a safe place for humans") &#125;&#125; else &#123; print("There isn't a planet at position \(positionToFind)")&#125;// Prints "There isn't a planet at position 11" 递归枚举递归枚举是一种枚举类型，它有一个或多个枚举成员使用该枚举类型的实例作为关联值。使用递归枚举时，编译器会插入一个间接层。你可以在枚举成员前加上indirect来表示该成员可递归。例如，下面的例子中，枚举类型存储了简单的算术表达式： 12345enum ArithmeticExpression &#123; case number(Int) indirect case addition(ArithmeticExpression, ArithmeticExpression) indirect case multiplication(ArithmeticExpression, ArithmeticExpression)&#125; 你也可以在枚举类型开头加上indirect关键字来表明它的所有成员都是可递归的： 123456enum ArithmeticExpression &#123;indirect enum ArithmeticExpression &#123; case number(Int) case addition(ArithmeticExpression, ArithmeticExpression) case multiplication(ArithmeticExpression, ArithmeticExpression)&#125; 上面定义的枚举类型可以存储三种算术表达式：纯数字、两个表达式相加、两个表达式相乘。枚举成员addition和multiplication的关联值也是算术表达式——这些关联值使得嵌套表达式成为可能。例如，表达式(5 + 4) 2，乘号右边是一个数字，左边则是另一个表达式。因为数据是嵌套的，因而用来存储数据的枚举类型也需要支持这种嵌套——这意味着枚举类型需要支持递归。下面的代码展示了使用ArithmeticExpression这个递归枚举创建表达式(5 + 4) 2 1234let five = ArithmeticExpression.number(5)let four = ArithmeticExpression.number(4)let sum = ArithmeticExpression.addition(five, four)let product = ArithmeticExpression.multiplication(sum, ArithmeticExpression.number(2)) 要操作具有递归性质的数据结构，使用递归函数是一种直截了当的方式。例如，下面是一个对算术表达式求值的函数： 12345678910111213func evaluate(_ expression: ArithmeticExpression) -&gt; Int &#123; switch expression &#123; case let .number(value): return value case let .addition(left, right): return evaluate(left) + evaluate(right) case let .multiplication(left, right): return evaluate(left) * evaluate(right) &#125;&#125; print(evaluate(product))// Prints "18" 该函数如果遇到纯数字，就直接返回该数字的值。如果遇到的是加法或乘法运算，则分别计算左边表达式和右边表达式的值，然后相加或相乘。 参照文档 Enumerations &gt;&gt; Copyright (c) liangtong. All rights reserved.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift Closures]]></title>
    <url>%2F2016%2F11%2F22%2FiOS_Swift_language_note_Closures%2F</url>
    <content type="text"><![CDATA[​ 闭包是一种可以在代码中传递和使用的自包含代码块。Swift中的闭包盒C／ObjC中的闭包与其它语言中的lambdas表达式类似。闭包可用捕获其被定义的上下文中的变量或常量。Swift会为你处理所有的通过捕获的内存管理。函数章节介绍的全局／嵌套函数，是闭包的特殊形式，闭包采取以下三种形式之一 全局函数是一个有名字且不捕获任何值的闭包 嵌套函数是一个有名字且可用捕获其封闭函数作用域内值的闭包 闭包表达式是一个利用轻量级语法所写的可用捕获所在上下文中值（变量／常量）的没有名字的闭包 Swift中的闭包表达式拥有清晰、简洁的风格，在以下常见的场景中实现闭包优化： 根据上下文怼参数和返回值进行类型推断 单表达式闭包可用省略return关键字 参数名称可用缩写 Trailing闭包语法 闭包表达式嵌套函数是一种在较复杂函数中方便进行命名和定义自包含代码模块的方式，但是有时候编写一个不需要名字和参数的简洁版本更有用，尤其是在将函数作为参数传递给另一个函数的时候。闭包表达式是一种利用简洁语法构建内联闭包的方式。闭包表达式提供了一些语法优化，使得撰写闭包变得简单明了。下面闭包表达式的例子通过使用几次迭代展示了 sort 函数定义和语法优化的方式。 每一次迭代都用更简洁的方式描述了相同的功能。 排序方法Swift标准库提供的一个排序方法sorted(by:)会根据你提供的排序闭包对已知类型的数组的值进行排序，排序完成后会返回一个同源数组大小相同的排序后的数组。例如一个原始数组如下： 1let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"] 排序方法sorted(by:)接受一个包含两个数组内值相同类型参数并返回一个Bool值来表明顺序的闭包，闭包回返回true如果要求第一个值在排序的结果中靠前，否则返回false。例子中闭包表达式类型为： 1(String, String) -&gt; Bool 可以通过普通函数，作为参数传递，例如： 12345func backward(_ s1: String, _ s2: String) -&gt; Bool &#123; return s1 &gt; s2&#125;var reversedNames = names.sorted(by: backward)// reversedNames is equal to ["Ewa", "Daniella", "Chris", "Barry", "Alex"] 闭包表达式语法闭包表达式一般语法如下： 123&#123; (parameters) -&gt; return type in statements&#125; 闭包表达式的参数可以是in-out类型，但是不能有默认值，也可以是可变参数，也支持元组类型参数或者返回值，例如上述操作可以简化为： 123reversedNames = names.sorted(by: &#123; (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2&#125;) 根据上下文推断类型因为排序闭包是作为参数传递的，Swift可以推断出闭包的参数类型和返回值类型。因为所有的类型都可以被推断，所以这里具体类型没有必要提供。返回值和参数周围的括号也可以被省略，例如： 1reversedNames = names.sorted(by: &#123; s1, s2 in return s1 &gt; s2 &#125; ) 实际上，在内连闭包表达式构造的闭包作为参数传递给函数时，都可以推断出参数和返回值类型，这意味着你几乎不需要写完整的闭包格式。然而，你仍然可以使用明确的类型来消除阅读的歧义，并且这是被建议使用的方式。 单行闭包表达式可以省略return单行表达式闭包可以通过隐藏 return 关键字来隐式返回单行表达式的结果，如上版本的例子可以改写为： 1reversed = sort(names, &#123; s1, s2 in s1 &gt; s2 &#125; ) 参数名缩写Swift自动提供了参数名称缩写功能，可以直接使用$0, $1, $2,等来引用闭包中的参数。数量和类型可以被推断，当时用参数名称缩写的时候，参数列表定义部分可以省略，in关键字也可以省略。此事闭包表达式完全由闭包函数体构成： 1reversed = sort(names, &#123; $0 &gt; $1 &#125; ) 运算符方法有一种更简洁的方法来写上述例子中的闭包表达式。Swift中的String类型定义了操作符&gt;的实现。因此可以简单的传递一个符号。例如： 1reversed = sort(names, &#123; $0 &gt; $1 &#125; ) Trailing闭包当闭包作为一个拥有很多参数函数的最后一个参数时，可以使用Trailing闭包来增强函数的可读性。Trailing闭包是一个书写在函数括号之外的闭包表达式（尽管闭包仍然是函数的参数）。当使用Trailing闭包语法时，不写闭包对应的函数参数标签。例如： 123456789101112131415func someFunctionThatTakesAClosure(closure: () -&gt; Void) &#123; // function body goes here&#125; // Here's how you call this function without using a trailing closure: someFunctionThatTakesAClosure(closure: &#123; // closure's body goes here&#125;) // Here's how you call this function with a trailing closure instead: someFunctionThatTakesAClosure() &#123; // trailing closure's body goes here&#125; 上述排序例子可以简写为： 1reversedNames = names.sorted() &#123; $0 &gt; $1 &#125; 除了闭包外无其他参数，小括号也可以省略，例如： 1reversedNames = names.sorted &#123; $0 &gt; $1 &#125; 当闭包非常长的时候，Trailing 闭包就变得非常有用。例如Swift的Array类型有一个map方法map(_:)，其接收一个闭包表达式作为唯一的参数，对于数组中的每一个元素会调用该闭包一次，并返回该元素映射的值，具体映射方式和返回值类型由闭包来指定，当提供给数组该闭包函数后，map方法将返回一个新的包含了与原数组一一对应映射关系的数组。例如以下例子讲述如何使用该闭包： 123456789101112131415161718let digitNames = [ 0: "Zero", 1: "One", 2: "Two", 3: "Three", 4: "Four", 5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"]let numbers = [16, 58, 510]let strings = numbers.map &#123; (number) -&gt; String in var number = number var output = "" repeat &#123; output = digitNames[number % 10]! + output number /= 10 &#125; while number &gt; 0 return output&#125;// strings is inferred to be of type [String]// its value is ["OneSix", "FiveEight", "FiveOneZero"] 捕获值闭包可以捕获其定义的上下文中的常量或变量，即使定义这些变量或者常量的作用域已经不存在，闭包仍然可以在闭包体内引用(和修改)这些值。在Swift中，最简单的闭包形式是嵌套函数，也就是定义在函数体内的函数。嵌套函数可以捕获外部函数的参数以及所有定义在外部函数体内的变量和常量。下边是一个嵌套函数的例子： 12345678func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int &#123; var runningTotal = 0 func incrementer() -&gt; Int &#123; runningTotal += amount return runningTotal &#125; return incrementer&#125; 注意：Swift会自动持有被截获的变量的引用，这样就可以在block内部直接修改变量。Swift会自动判断你是否在闭包中或闭包外改变了变量。如果没有改变，闭包会直接持有变量，即使你没有显式的把它卸载捕获列表中。以下摘自苹果官方文档： 1As an optimization, Swift may instead capture and store a copy of a value if that value is not mutated by a closure, and if the value is not mutated after the closure is created. 闭包是引用类型如果将闭包赋值给一个变量和常量，那么赋值后的变量和常量会引用同一个闭包，例如 12let alsoIncrementByTen = incrementByTenalsoIncrementByTen() 逃避闭包(Escaping Closures)当闭包作为函数的参数传入时，很有可能这个闭包在函数返回之后才会被执行，这就是逃逸闭包。在Swift中可以在参数名前标注 @noescape 来指明这个闭包是不允许逃逸出这个函数的。因为非逃逸闭包只能在函数体中被执行，不能脱离函数体执行，所以这使得编译器可以明确的知道运行时的上下文环境，进而做出优化。一般情况下，一些异步函数会使用逃逸闭包。这类函数会在异步操作开始之后立刻返回，但是闭包直到异步操作结束后才会被调用。比如网络请求中处理服务器返回请求的闭包。例如： 1234var completionHandlers: [() -&gt; Void] = []func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) &#123; completionHandlers.append(completionHandler)&#125; 如果需要引用自身self，因为编译器知晓非逃逸闭包的上下文环境，所以非逃逸闭包中可以不写 self (隐式的存在)。但是逃逸闭包必须明确写self。例如： 1234567class SomeClass &#123; var x = 10 func doSomething() &#123; someFunctionWithEscapingClosure &#123; self.x = 100 &#125; someFunctionWithNonescapingClosure &#123; x = 200 &#125; &#125;&#125; 自动闭包(Autoclosures)自动闭包是自动创建的包含一个语句的闭包，作为参数传递给函数。自动闭包不接受任何参数，被调用时会返回被包装在其中的表达式的值。自动闭包是延迟求值，因为闭包中的代码直到你调用闭包的时候才会执行。延迟求值对一些可能存在副作用的代码来说很有用，通过延迟求值你可以控制代码的执行时机。例如： 123456789101112var customersInLine = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]print(customersInLine.count)// Prints "5" let customerProvider = &#123; customersInLine.remove(at: 0) &#125;print(customersInLine.count)// Prints "5" print("Now serving \(customerProvider())!")// Prints "Now serving Chris!"print(customersInLine.count)// Prints "4" 即使闭包代码中将数组中的第一个元素移除了，但是闭包代码不会执行直到闭包被调用。如果闭包不被调用，那么闭包内的移除代码就不会调用。当你做微函数参数传递的时候你也是同样的道理 123456// customersInLine is ["Alex", "Ewa", "Barry", "Daniella"]func serve(customer customerProvider: () -&gt; String) &#123; print("Now serving \(customerProvider())!")&#125;serve(customer: &#123; customersInLine.remove(at: 0) &#125; )// Prints "Now serving Alex!" 以上例子中的serve函数接受一个明确的闭包（返回一个顾客的名字），下边这个例子和上边效果一样，不过是接收一个自动闭包。 123456// customersInLine is ["Ewa", "Barry", "Daniella"]func serve(customer customerProvider: @autoclosure () -&gt; String) &#123; print("Now serving \(customerProvider())!")&#125;serve(customer: customersInLine.remove(at: 0))// Prints "Now serving Ewa!" 如果一个自动闭包需要逃逸，使用两个修饰符@autoclosure和@escaping： 123456789101112131415// customersInLine is ["Barry", "Daniella"]var customerProviders: [() -&gt; String] = []func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -&gt; String) &#123; customerProviders.append(customerProvider)&#125;collectCustomerProviders(customersInLine.remove(at: 0))collectCustomerProviders(customersInLine.remove(at: 0)) print("Collected \(customerProviders.count) closures.")// Prints "Collected 2 closures."for customerProvider in customerProviders &#123; print("Now serving \(customerProvider())!")&#125;// Prints "Now serving Barry!"// Prints "Now serving Daniella!" 参照文档 Control Flow OC与Swift闭包对比总结 浅谈iOS中的闭包 &gt;&gt; Copyright (c) liangtong. All rights reserved.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift Functions]]></title>
    <url>%2F2016%2F11%2F20%2FiOS_Swift_language_note_Functions%2F</url>
    <content type="text"><![CDATA[​ 函数是执行特定功能的独立代码块，可以通过函数名字调用函数执行其功能。Swift的函数统一语法可以很灵活地表达任何东西，无论是没有参数的C风格函数还是拥有多个名字和参数的ObjC风格函数。参数可以提供默认值以简化函数调用、当参数变量需要改变的时候，参数也可以作为输入输出(in-out)参数.在Swift中，每个函数都有一个类型，包括参数类型和返回值类型。你可以像Swift中其他任何一个类型一样使用函数，这使得将函数作为函数参数、作为函数返回值变得非常简单。函数也可以写在其他函数内部以限制其作用域（内部函数）。 函数的声明和调用当定义函数的时候，可以选择性的定义一个或多个名字，定义一些输入类型值作为参数，也可以选择性的定义一类值作为输出类型。每一个函数都有一个名字，用来表明函数的功能，可以通过调用该函数的名字来使用函数，并且通过传递输入值（参数）来匹配函数的参数，调用函数时，输入参数类型必须和函数声明时类型的参数类型顺序一致。 函数以关键字func开头，返回值类型紧跟符号-&gt;。说了这么多，还是直接看例子，函数名字为：greet(person:)参数和返回值是String类型，定义及调用如下： 123456789func greet(person: String) -&gt; String &#123; let greeting = "Hello, " + person + "!" return greeting&#125;print(greet(person: "Anna"))// Prints "Hello, Anna!"print(greet(person: "Brian"))// Prints "Hello, Brian!" 函数的参数和返回值Swift中函数的参数和返回值比较灵活，无论是一个只有一个未命名参数的简单函数，还是包含不同类型参数的复杂函数，你可以随意定义。 无参函数函数参数是非必需的，例如： 12345func sayHelloWorld() -&gt; String &#123; return "hello, world"&#125;print(sayHelloWorld())// Prints "hello, world" 多参函数函数可以有多个输入参数，这些参数写在函数的括号内，用逗号隔开。例如： 123456789func greet(person: String, alreadyGreeted: Bool) -&gt; String &#123; if alreadyGreeted &#123; return greetAgain(person: person) &#125; else &#123; return greet(person: person) &#125;&#125;print(greet(person: "Tim", alreadyGreeted: true))// Prints "Hello again, Tim!" 无返回值函数函数也不需要定义返回值类型，当没有返回值的时候，返回箭头（ - &gt;）和返回类型可以省略。例如： 12345func greet(person: String) &#123; print("Hello, \(person)!")&#125;greet(person: "Dave")// Prints "Hello, Dave!" 严格的说，即使没有定义返回值，函数仍然会返回一个void类型的特殊值，他是一个简单的空的元组，可以写为()。 再调用函数时，其返回值可以被忽略，例如： 1234567891011func printAndCount(string: String) -&gt; Int &#123; print(string) return string.characters.count&#125;func printWithoutCounting(string: String) &#123; let _ = printAndCount(string: string)&#125;printAndCount(string: "hello, world")// prints "hello, world" and returns a value of 12printWithoutCounting(string: "hello, world")// prints "hello, world" but does not return a value 多返回值函数可以使用元组作为函数的返回值来一次返回多个值。例如： 123456789101112func minMax(array: [Int]) -&gt; (min: Int, max: Int) &#123; var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] &#123; if value &lt; currentMin &#123; currentMin = value &#125; else if value &gt; currentMax &#123; currentMax = value &#125; &#125; return (currentMin, currentMax)&#125; 由于元组成员的类型是函数的返回值，可以通过如下方式使用，例如： 123let bounds = minMax(array: [8, -6, 2, 109, 3, 71])print("min is \(bounds.min) and max is \(bounds.max)")// Prints "min is -6 and max is 109" 可选的元组返回类型如果一个函数的返回的元组是可选的，就可以使用一个可选的元组返回类型，例如：(Int, Int)?。 123456789101112131415161718func minMax(array: [Int]) -&gt; (min: Int, max: Int)? &#123; if array.isEmpty &#123; return nil &#125; var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] &#123; if value &lt; currentMin &#123; currentMin = value &#125; else if value &gt; currentMax &#123; currentMax = value &#125; &#125; return (currentMin, currentMax)&#125;if let bounds = minMax(array: [8, -6, 2, 109, 3, 71]) &#123; print("min is \(bounds.min) and max is \(bounds.max)")&#125;// Prints "min is -6 and max is 109" 注：可选元组类型(Int, Int)? 和包含可选值的元组(Int?, Int?)不同，对于可选的元组类型，这个元组是可选的，而不是元组中的某个组成元素可选。 函数的参数标签和参数名每个函数参数都包含一个标签名和一个参数名称，标签名在函数被调用的时候使用；函数中的每一个参数前都有一个标签名，参数名在函数体内使用，默认情况下，函数参数使用它们的参数名作为标签名。所有的参数名必须唯一，尽管参数的标签名可以不唯一，但唯一的标签名可以提高代码的易读性。 12345func someFunction(firstParameterName: Int, secondParameterName: Int) &#123; // In the function body, firstParameterName and secondParameterName // refer to the argument values for the first and second parameters.&#125;someFunction(firstParameterName: 1, secondParameterName: 2) 明确的参数标签在参数名前写一个参数标签，用空格隔开，来明确参数标签，格式如下： 1234func someFunction(argumentLabel parameterName: Int) &#123; // In the function body, parameterName refers to the argument value // for that parameter.&#125; 以下是一个使用明确标签名的例子： 12345func greet(person: String, from hometown: String) -&gt; String &#123; return "Hello \(person)! Glad you could visit from \(hometown)."&#125;print(greet(person: "Bill", from: "Cupertino"))// Prints "Hello Bill! Glad you could visit from Cupertino." 省略的参数标签如果不需要参数标签，可以使用下划线(_)来代替参数标签。如果参数前有标签的话，函数调用的时候就必须使用标签。 123456func someFunction(parameterWithoutDefault: Int, parameterWithDefault: Int = 12) &#123; // If you omit the second argument when calling this function, then // the value of parameterWithDefault is 12 inside the function body.&#125;someFunction(parameterWithoutDefault: 3, parameterWithDefault: 6) // parameterWithDefault is 6someFunction(parameterWithoutDefault: 4) // parameterWithDefault is 12 默认的参数值可以为任何参数设定默认值来作为函数的定义的一部分。如果默认值已经定义，调用函数时就可以省略该参数的传值。将使用默认值的参数放在函数列表的末尾，在函数中，没有默认值的参数通常有重要的意义。例如 12345func someFunction(_ firstParameterName: Int, secondParameterName: Int) &#123; // In the function body, firstParameterName and secondParameterName // refer to the argument values for the first and second parameters.&#125;someFunction(1, secondParameterName: 2) 可变参数一个可变参数的参数接受零个或多个指定类型的值。当函数被调用时，您可以使用一个可变参数的参数来指定该参数可以传递不同数量的输入值。写可变参数的参数时，需要参数的类型名称后加上点字符（…）。传递一个可变参数的参数的值时，函数体中是以提供适当类型的数组的形式存在。例如 1234567891011func arithmeticMean(_ numbers: Double...) -&gt; Double &#123; var total: Double = 0 for number in numbers &#123; total += number &#125; return total / Double(numbers.count)&#125;arithmeticMean(1, 2, 3, 4, 5)// returns 3.0, which is the arithmetic mean of these five numbersarithmeticMean(3, 8.25, 18.75)// returns 10.0, which is the arithmetic mean of these three numbers 一个函数最多只有一个可变参数。 输入-输出参数默认情况下，函数的参数是常量（只读）形式，在函数方法体内修改参数会导致编译错误。如果想在函数体内修改参数，则需要将参数类型设置为in-out来代替。通过在参数类型前添加关键字inout来表明输入-输出参数。一个在输入-输出参数都有一个传递给函数的值，由函数修改后，并从函数返回来替换原来的值。 输入输出参数类型必须是变量，不能有默认值。不能说常量，不能是可变参数。当你把一个变量传给输入输出参数时，在变量前添加一个连接符&amp;，表明它在函数体内可以修改 例如： 12345func swapTwoInts(_ a: inout Int, _ b: inout Int) &#123; let temporaryA = a a = b b = temporaryA&#125; 调用的时候，注意添加前缀符号&amp;，例如： 12345var someInt = 3var anotherInt = 107swapTwoInts(&amp;someInt, &amp;anotherInt)print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")// Prints "someInt is now 107, and anotherInt is now 3" 函数类型每一个函数都有一个特定的函数类型，由参数类型和返回值类型。例如，以下例子中的函数类型是：(Int, Int)-&gt;Int 123456func addTwoInts(_ a: Int, _ b: Int) -&gt; Int &#123; return a + b&#125;func multiplyTwoInts(_ a: Int, _ b: Int) -&gt; Int &#123; return a * b&#125; 使用函数类型在Swift中可以像其他类型一样使用函数类型，例如可以定义一个函数类型的常量或者变量和调用该变量： 12345var mathFunction: (Int, Int) -&gt; Int = addTwoIntsprint("Result: \(mathFunction(2, 3))")// Prints "Result: 5"&#125; 函数类型的参数可以使用函数类型（例如：(Int, Int)-&gt;Int）作为另一个函数的参数类型，例如： 12345func printMathResult(_ mathFunction: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) &#123; print("Result: \(mathFunction(a, b))")&#125;printMathResult(addTwoInts, 3, 5)// Prints "Result: 8" 函数类型的返回值可以使用函数类型作为一个函数的返回值。例如： 123456func stepForward(_ input: Int) -&gt; Int &#123; return input + 1&#125;func stepBackward(_ input: Int) -&gt; Int &#123; return input - 1&#125; 函数类型的返回值 123func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int &#123; return backward ? stepBackward : stepForward&#125; 使用 123var currentValue = 3let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)// moveNearerToZero now refers to the stepBackward() function 嵌套函数嵌套函数是定义在函数内的函数，对外是隐藏的，但是可以调用和使用其内部的函数。例如 123456789101112131415161718func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int &#123; func stepForward(input: Int) -&gt; Int &#123; return input + 1 &#125; func stepBackward(input: Int) -&gt; Int &#123; return input - 1 &#125; return backward ? stepBackward : stepForward&#125;var currentValue = -4let moveNearerToZero = chooseStepFunction(backward: currentValue &gt; 0)// moveNearerToZero now refers to the nested stepForward() functionwhile currentValue != 0 &#123; print("\(currentValue)... ") currentValue = moveNearerToZero(currentValue)&#125;print("zero!")// -4...// -3...// -2...// -1...// zero! 参照文档 Functions &gt;&gt; Copyright (c) liangtong. All rights reserved.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift Control Flow]]></title>
    <url>%2F2016%2F11%2F17%2FiOS_Swift_language_note_Control-Flow%2F</url>
    <content type="text"><![CDATA[​ Swift提供了很多流程控制语法，包括可以通过使用while循环来重复执行一个任务，可以通过if、guard和switch来进行条件判断从而执行不同代码分支，可以通过break和continue来跳转到特定代码位置。​ Swift也提供了诸如可以通过for-in循环来遍历数组，字典，区间(range)，字符串和其他一些序列(sequences)。​ Swift的switch语句相对比C语言的强大(该关键字与其他多数语言不同，至于算不算优点，意见保留)。在Swift中，该语句中的case语法不会自动流转到下一个case，这避免了像C语言中因为缺失break语句导致的错误。而Swift中的Case语句也相对比较强大，可以匹配多种包括整型、元组、转换的特殊类型等形式。在Case语句中匹配的值可以被绑定到一个临时的常量或者变量中，从而在case语句对一个的代码块(body)中使用，一些复杂的匹配可以通过使用where表达式进行。 for-in 循环可以使用for-in循环来遍历一个序列，比如一个区间(range)中的数字、数组中的元素、字符串的字符，例如： 12345678910111213141516171819202122//使用index变量来访问range中的具体值。注意操作符`...`的用法for index in 1...5 &#123; print("\(index) times 5 is \(index * 5)")&#125;//不关心range中的具体值，可以使用下划线’_’let base = 3let power = 10var answer = 1for _ in 1...power &#123; answer *= base&#125;print("\(base) to the power of \(power) is \(answer)")//遍历数组let names = ["Anna", "Alex", "Brian", "Jack"]for name in names &#123; print("Hello, \(name)!")&#125;//字典，是以元组的形式来匹配的，当然也可以使用下划线’_’let numberOfLegs = ["spider": 8, "ant": 6, "cat": 4]for (animalName, legCount) in numberOfLegs &#123; print("\(animalName)s have \(legCount) legs")&#125; while循环while的代码块会一直被执行，知道条件变为flase。这类循环主要用在不确定遍历次数的情况下，Swift提供了两种while循环语法：while和repeat-while whilewhile循环是以一个简单的bool条件式开始，当该条件为true的时，循环体会一直被执行。知道条件变为false。语法如下： 123while condition &#123; statements&#125; repeat-while与while不同的是，repeat-while循环会首先执行以下循环体，然后判断条件是否为true。和其他语言中的do-while循环类似。语法如下： 123repeat &#123; statements&#125; while condition 分支判断根据特定的条件执行对应的处理代码是很常用的，Swift提供了两种分支判断语法：if和switch，通常情况下if用在简单的分支判断，switch用在比较复杂的场合。 ifif语句包含一个条件，如果条件为true，则执行紧接着的语句集合。否则执行else (if) 对应的语句集合（如果不关心else (if) 的情况，该部分可以不写）。 switchswitch语句将一个值和多种匹配的模式进行比较，然后根据第一个合适的配结果执行对应的代码块，语法格式如下： 123456789switch some value to consider &#123;case value 1: respond to value 1case value 2, value 3: respond to value 2 or 3default: otherwise, do something else&#125; switch语句包含多个情况，每个case语句都代表一个分支。switch语句必须列举出所有情况，也就是说case分支必须能够匹配所有可能的情况，如果case不能完全匹配，则需要通过关键字default在最后位置定义一个默认的分支，例如： 123456789let someCharacter: Character = "z"switch someCharacter &#123;case "a": print("The first letter of the alphabet")case "z": print("The last letter of the alphabet")default: print("Some other character")&#125; 不存在隐式穿透(No Implicit Fallthrough)和C与ObjC语言中的Switch语法不同的是，Swift中的switch语法默认情况下在case语句执行完成后不会自动匹配下一个case语句，而是当第一个匹配case分支执行之后马上结束，你不需要像其他语言那样为每个case写上一个break关键字。（尽管break在swift中switch中是非必需的，但你可以使用它来中断一些代码的执行）。如果想自动匹配下一个，则需要使用关键字fallthrough。每一条case分支必须包含至少一个可执行语句，比如以下代码会引起编译时错误 123456789let anotherCharacter: Character = "a"switch anotherCharacter &#123;case "a": // Invalid, the case has an empty bodycase "A": print("The letter A")default: print("Not the letter A")&#125;// This will report a compile-time error. 一条case分支可以匹配多个值，用逗号,隔开，比如上述代码会引起编译时错误可以通过以下写法来解决 12345678let anotherCharacter: Character = "a"switch anotherCharacter &#123;case "a", "A": print("The letter A")default: print("Not the letter A")&#125;// Prints "The letter A" 区间匹配switch中的值可以进行区间匹配，比如： 12345678910111213141516171819let approximateCount = 62let countedThings = "moons orbiting Saturn"var naturalCount: Stringswitch approximateCount &#123;case 0: naturalCount = "no"case 1..&lt;5: naturalCount = "a few"case 5..&lt;12: naturalCount = "several"case 12..&lt;100: naturalCount = "dozens of"case 100..&lt;1000: naturalCount = "hundreds of"default: naturalCount = "many"&#125;print("There are \(naturalCount) \(countedThings).")// Prints "There are dozens of moons orbiting Saturn." 元组可以通过使用下划线_来匹配任意一个元素，如果存在多个匹配，默认情况下执行第一个匹配的case，其他case会被忽略。代码比较清楚： 1234567891011121314let somePoint = (1, 1)switch somePoint &#123;case (0, 0): print("(0, 0) is at the origin")case (_, 0): print("(\(somePoint.0), 0) is on the x-axis")case (0, _): print("(0, \(somePoint.1)) is on the y-axis")case (-2...2, -2...2): print("(\(somePoint.0), \(somePoint.1)) is inside the box")default: print("(\(somePoint.0), \(somePoint.1)) is outside of the box")&#125;// Prints "(1, 1) is inside the box" 值绑定在switch的case语句中，可以将匹配的值绑定给一个临时的常量或者变量，在case的body中使用。例如： 12345678910let anotherPoint = (2, 0)switch anotherPoint &#123;case (let x, 0): print("on the x-axis with an x value of \(x)")case (0, let y): print("on the y-axis with a y value of \(y)")case let (x, y): print("somewhere else at (\(x), \(y))")&#125;// Prints "on the x-axis with an x value of 2" where一个case语句中可以使用where语法进行额外的匹配检查，比如： 12345678910let yetAnotherPoint = (1, -1)switch yetAnotherPoint &#123;case let (x, y) where x == y: print("(\(x), \(y)) is on the line x == y")case let (x, y) where x == -y: print("(\(x), \(y)) is on the line x == -y")case let (x, y): print("(\(x), \(y)) is just some arbitrary point")&#125;// Prints "(1, -1) is on the line x == -y" 复合匹配在case中通过逗号,隔开匹配内容。复合匹配也可以包含值绑定，在复合匹配中，无论哪个部分匹配上，case的body都会被执行。例如： 12345678let stillAnotherPoint = (9, 0)switch stillAnotherPoint &#123;case (let distance, 0), (0, let distance): print("On an axis, \(distance) from the origin")default: print("Not on an axis")&#125;// Prints "On an axis, 9 from the origin" 控制转移语句swift提供了5个流程控制转移语句：continue、break、fallthrough、return、throw。除了fallthrough，其他四个关键字与C等语言中的基本相同，swift中的switch语句默认情况下不存在隐式穿透，如果想要支持，则需要在case语句后添加fallthrough，（注：该关键字不检查即将进入的case条件）例如： 1234567891011let integerToDescribe = 5var description = "The number \(integerToDescribe) is"switch integerToDescribe &#123;case 2, 3, 5, 7, 11, 13, 17, 19: description += " a prime number, and also" fallthroughdefault: description += " an integer."&#125;print(description)// Prints "The number 5 is a prime number, and also an integer." 标签语法循环或条件语句可以嵌套，可以通过break语法结束当前代码块的执行，如果有多个嵌套的循环，明确哪个循环是非常有用的，为了实现这个目标，你可以使用标签语法。标签语法是由名字和冒号:组成。例如一个while循环的标签如下： 123label name: while condition &#123; statements&#125; 提前退出和if语法类似，guard语法语句的执行取决于一个bool表达式。可以使用guard语法来确保在特定条件成立的情况下执行某些代码。和if不同的是，guard语法在条件表达式为false时会执行else块中的内容。例如： 12345guard let name = person["name"] else &#123; return &#125; print("Hello \(name)!") API有效性检查可以在if或guard语句中使用availability条件。其中平台比如：iOS, macOS, watchOS, 和 tvOS，语法格式如下 12345if #available(platform name version, ..., *) &#123; statements to execute if the APIs are available&#125; else &#123; fallback statements to execute if the APIs are unavailable&#125; 具体写法例如： 12345if #available(iOS 10, macOS 10.12, *) &#123; // Use iOS 10 APIs on iOS, and use macOS 10.12 APIs on macOS&#125; else &#123; // Fall back to earlier iOS and macOS APIs&#125; 参照文档 Control Flow &gt;&gt; Copyright (c) liangtong. All rights reserved.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift Collection Types]]></title>
    <url>%2F2016%2F11%2F06%2FiOS_Swift_language_note_Collection-Types%2F</url>
    <content type="text"><![CDATA[​ 同其他语言类型类似，Swift提供了3个集合类型Array、Set和Dictionary来存储集合值。与ObjC不同的是，Swift中的集合属于范型，不能不同类型的数据添加的同一个集合类型中，且Swift中的集合类型变量都支持修改。 Array数组类型是存储相同类型数据的有序列表，其中数组不同位置存储的数可以相同。Swift中的Array类型是Foundation框架中的NSArray类型的桥接.Swift中Array属于范型类，具体的写法是Array&lt;Element&gt;或者[Element]，两种写法相同。 数组的创建可以通过[Element](), []的形式创建空数组，可以通过Array提供方法进行创建，当然也可以通过字面值[value 1, value 2, value 3]的形式创建并初始化一个数组 12345678var someInts = [Int]()//创建一个空的Int数组someInts.append(3)//数组中添加一个元素someInts = []//数组被清空// threeDoubles is of type [Double], and equals [0.0, 0.0, 0.0]var threeDoubles = Array(repeating: 0.0, count: 3)var shoppingList: [String] = ["Eggs", "Milk”] 数组的组合可以通过操作符+将两个形同类型元素的数组合并到一起。 12345var anotherThreeDoubles = Array(repeating: 2.5, count: 3)// anotherThreeDoubles is of type [Double], and equals [2.5, 2.5, 2.5] var sixDoubles = threeDoubles + anotherThreeDoubles// sixDoubles is inferred as [Double], and equals [0.0, 0.0, 0.0, 2.5, 2.5, 2.5] 数组元素的访问和修改可以通过调用数组的方法和属性来访问和修改数组元素，或者通过下标语法，比如： 1234567891011121314151617181920212223242526272829//通过数组的count属性来确定数组的元素print("The shopping list contains \(shoppingList.count) items.")//通过数组的Bool属性isEmpty来判断数组是否为空if shoppingList.isEmpty &#123; print("The shopping list is empty.")&#125; else &#123; print("The shopping list is not empty.")&#125;//通过调用数组的append方法来给数组添加元素shoppingList.append("Flour")//当然也可以通过操作符+=给数组添加元素（合并数组）shoppingList += ["Baking Powder"]shoppingList += ["Chocolate Spread", "Cheese", "Butter"]//通过下标访问和修改数组元素：如果越界会导致运行时错误var firstItem = shoppingList[0]shoppingList[0] = "Six eggs"//当然也可以通过下标来同时修改一个范围元素，长度不相同也无所谓shoppingList[4...6] = ["Bananas", "Apples"]//可以通过insert方法向数组中插入元素shoppingList.insert("Maple Syrup", at: 0)//可以通过remove方法向移除数组特定位置的元素let mapleSyrup = shoppingList.remove(at: 0) 数组的遍历通过使用for-in循环来遍历数组，当然如果需要数组对应下标值的话，可以通过enumerated()方法（对于数组的enumerated()方法，会返回一个包含整形索引和具体值的元组）。例如： 1234567for item in shoppingList &#123; print(item)&#125;for (index, value) in shoppingList.enumerated() &#123; print("Item \(index + 1): \(value)")&#125; SetSet是用来存储不重复的相同类型元素无序列表；Swift中的Set类型是Foundation框架中的NSSet类型的桥接。 Set类型的哈希值存储在Set类型中的元素必须是hashable的（用来保证存储在Set中的元素唯一）。Swift中Set类型的创建语法格式为Set[Element]。与其他语言一样，不再赘述 注：可以通过实现Swfit中的Hashable协议来自定义存储在Set集合中的元素 Set类型的创建可以通过Set&lt;Element&gt;(), []语法创建一个Set类型对象，当然也可以通过字面值[value 1, value 2, value 3]的形式创建并初始化一个Set对象，例如： 12345678910111213//创建一个空的Character类型的Set对象var letters = Set&lt;Character&gt;()//通过调用inset方法，向Set中添加元素letters.insert("a")//Set被清空letters = []//通过字面值创建并初始化Set集合var favoriteGenres: Set&lt;String&gt; = ["Rock", "Classical", "Hip hop"]//也可以这样写，Swift存在类型推断var favoriteGenres: Set = ["Rock", "Classical", "Hip hop"] Set对象的访问和修改可以通过调用Set的方法和属性来访问和修改Set元素，例如： 123456789101112131415161718192021222324252627//通过Set的count属性来确定Set的元素print("I have \(favoriteGenres.count) favorite music genres.")//通过Set的Bool属性isEmpty来判断Set是否为空if favoriteGenres.isEmpty &#123; print("As far as music goes, I'm not picky.")&#125; else &#123; print("I have particular music preferences.")&#125;//通过调用Set的insert方法来给Set添加元素favoriteGenres.insert("Jazz")//可以通过remove方法向移除Set中的特定元素if let removedGenre = favoriteGenres.remove("Rock") &#123; print("\(removedGenre)? I'm over it.")&#125; else &#123; print("I never much cared for that.")&#125;//通过调用Set的contains方法来判断Set是否包含某个元素if favoriteGenres.contains("Funk") &#123; print("I get up on the good foot.")&#125; else &#123; print("It's too funky in here.")&#125;// Prints "It's too funky in here." Set的遍历通过使用for-in循环来遍历Set，Set对象是无序列表，如果想要顺序访问具体对象值，可以调用Set的sorted()方法。例如： 12345678910111213for genre in favoriteGenres &#123; print("\(genre)")&#125;// Jazz// Hip hop// Classicalfor genre in favoriteGenres.sorted() &#123; print("\(genre)")&#125;// Classical// Hip hop// Jazz Set常用运算常用操作如下： operator (==) 判断是非相等 isSubset(of:) 判断Set是否子集 isSuperset(of:) 判断是否超级 isStrictSubset(of:) 或 isStrictSuperset(of:) 判断是否是子集或者超集，但不相等 isDisjoint(with:) 判断两个Set是否有相同元素 再放一张图吧 DictionaryDictionary存储键值对，其中键key值必须唯一，Swift中的Dictionary类型是Foundation框架中的NSDictionary类型的桥接。 Dictionary的创建可以通过[Key:Value](), []的形式创建空Dictionary，也可以通过字面值[key 1: value 1, key 2: value 2, key 3: value 3]的形式创建。例如： 12345678910111213//创建一个空字典var namesOfIntegers = [Int: String]()//字典的赋值namesOfIntegers[16] = "sixteen"//字典的清空namesOfIntegers = [:]//通过字面值创建var airports: [String: String] = ["YYZ": "Toronto Pearson", "DUB": "Dublin"]//类型推断var airports = ["YYZ": "Toronto Pearson", "DUB": "Dublin"] Dictionary对象的访问和修改可以通过调用Dictionary的方法和属性来访问和修改Dictionary元素，或者通过下标语法，例如： 12345678910111213141516171819202122232425262728293031323334353637//通过Dictionary的count属性来确定Dictionary的元素个数print("The airports dictionary contains \(airports.count) items.")//通过Dictionary的Bool属性isEmpty来判断Dictionary是否为空if airports.isEmpty &#123; print("The airports dictionary is empty.")&#125; else &#123; print("The airports dictionary is not empty.")&#125;//通过下标语法添加或者修改Dictionary中的元素airports["LHR"] = "London"//可以通过updateValue(_:forKey:) 方法添加或者修改Dictionary中的元素。//需要注意的是如果执行更新操作，该方法会返回旧的Value值if let oldValue = airports.updateValue("Dublin Airport", forKey: "DUB") &#123; print("The old value for DUB was \(oldValue).")&#125;//可以通过下标语法来访问某个key对应的valueif let airportName = airports["DUB"] &#123; print("The name of the airport is \(airportName).")&#125; else &#123; print("That airport is not in the airports dictionary.")&#125;//可以通过下标语法来移除某个&lt;key,value&gt;元素airports["APL"] = "Apple International"airports["APL"] = nil//可以通过removeValue(forKey:) 方法移除某个&lt;key,value&gt;元素if let removedValue = airports.removeValue(forKey: "DUB") &#123; print("The removed airport's name is \(removedValue).")&#125; else &#123; print("The airports dictionary does not contain a value for DUB.")&#125; Dictionary的遍历通过使用for-in循环来遍历Dictionary，每个Dictionary元素是以(key,value)元组的形式，例如： 1234567891011121314151617for (airportCode, airportName) in airports &#123; print("\(airportCode): \(airportName)")&#125;// YYZ: Toronto Pearson// LHR: London Heathrowfor airportCode in airports.keys &#123; print("Airport code: \(airportCode)")&#125;// Airport code: YYZ// Airport code: LHR for airportName in airports.values &#123; print("Airport name: \(airportName)")&#125;// Airport name: Toronto Pearson// Airport name: London Heathrow 参照文档 CollectionTypes &gt;&gt;&gt;&gt;&gt;&gt; ​Copyright (c) liangtong. All rights reserved.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift String and Characters]]></title>
    <url>%2F2016%2F11%2F05%2FiOS_Swift_language_note_String-and-Characters%2F</url>
    <content type="text"><![CDATA[​ 字符串String是一系列字符集合，Swift提供了一种快速、Unicode的方式的字符串和字符类型。和C语言的字符串字面值语法类似，Swift的字符串的创建和操作是轻量级、可读性的。可以通过+操作符连接两个字符串。Swift的字符串中的每个字符都是由Unicode编码的字符组成，并支持以各种方式访问这些字符。 注：Swift中的String类型通过Foundation框架的NSString类型桥接，Foundation也对String类型对应扩展了NSString中定义的方法。这就意味着如果引用了Foundation，就可以不用转换直接使用NSString中的方法。 字符串的字面值​ 可以通过双引号&quot;来定义字符串字面值，Swift会根据字符串字面值将对应类型推断为字符串类型。 1let someString = "Some string literal value" 字符串操作空字符串​ 初始化，检查字符串是否为空。 123456var emptyString = "" // empty string literalvar anotherEmptyString = String() // initializer syntaxif emptyString.isEmpty &#123;print("Nothing to see here")&#125; 字符串是值类型​ 字符串是值类型，创建一个字符串后，如果在函数或者方法中使用，或者该字符串会被赋值给常量或者变量，字符串值会被复制，源字符串数据不会变化。 字符串与字符​ 可以使用for-in循环，通过使用字符串的characters属性来访问字符值，例如 12345678for character in "Dog!�".characters &#123;print(character)&#125;// D// o// g// !// � ​ 可以通过字符来创建字符串，例如： 1234let exclamationMark: Character = "!"let catCharacters: [Character] = ["C", "a", "t", "!", "�"]let catString = String(catCharacters) 字符串连接​ 可以通过操作符+、+=连接两个字符串，也可以通过使用String的append()方法给字符串追加一个字符值，例如： 1234567var welcome = "hello" + " there"var instruction = "look over"instruction += string2let exclamationMark: Character = "!"welcome.append(exclamationMark) Unicode​ 用的不多，不详细介绍 字符串访问和修改​ 不同的字符需要不同的空间来存储，所以为了确定哪个字符的特定位置，需要遍历字符串。正是这个原因，Swift字符串不能通过整型的索引来访问。可以通过startIndex属性来访问字符串的第一个字符位置，endIndex属性对应最后一个字符位置。如果一个字符串的两个属性相同，则说明是一个空字符串。另外String还提供来几个方法来确认位置：index(before:)、index(after:)、index(_:offsetBy:)。如果访问越界，则会出现运行时错误： 1greeting[greeting.endIndex] // Error 字符的插入和移除可以通过方法insert(_:at:)和remove(at:)进行 字符串比较​ Swift提供了3中方式比较文字值：字符串和字符等式、前缀等式、后缀等式 字符串和字符等式​ 可以通过操作符：==和!=，例如： 123456let quotation = "We're a lot alike, you and I."let sameQuotation = "We're a lot alike, you and I."if quotation == sameQuotation &#123;print("These two strings are considered equal")&#125;// Prints "These two strings are considered equal" 前缀、后缀等式​ Swift提供了方法：hasPrefix(_:)和hasSuffix(_:) 字符串的Unicode表示​ Swift提供了不同方式来访问不同版本的Unicode字符，你可以遍历字符串通过for-in语句，然后通过访问每个字符的Unicode编码。 通过访问字符串的utf8属性，对于UTF-8格式 通过访问字符串的utf16属性，对于UTF-16格式 通过访问字符串的unicodeScalars属性，对于UTF-32格式 举个例子，对于一个字符串，需要访问不同格式的编码： 1let dogString = "Dog‼🐶" 对于UTF-8格式表示，如下： 12345for codeUnit in dogString.utf8 &#123;print("\(codeUnit) ", terminator: "")&#125;print("")// 68 111 103 226 128 188 240 159 144 182 对于UTF-16格式表示，如下： 12345for codeUnit in dogString.utf16 &#123;print("\(codeUnit) ", terminator: "")&#125;print("")// Prints "68 111 103 8252 55357 56374 " 对于Unicode Scalar格式表示，如下： 123456789101112131415for codeUnit in dogString.utf16 &#123;for scalar in dogString.unicodeScalars &#123;print("\(scalar.value) ", terminator: "")&#125;print("")// Prints "68 111 103 8252 128054 "for scalar in dogString.unicodeScalars &#123;print("\(scalar) ")&#125;// D// o// g// ‼// 🐶 参照文档 Strings and Characters &gt;&gt;&gt;&gt;&gt;&gt; ​Copyright (c) liangtong. All rights reserved.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift Basic Operators]]></title>
    <url>%2F2016%2F11%2F04%2FiOS_Swift_language_note_Basic-Operators%2F</url>
    <content type="text"><![CDATA[​ Swift支持绝大部分的标准C语言操作符，并且增强了几个操作符的功能以消除常犯的编码错误。例如：赋值运算符(=)不再拥有返回值来阻止被错误的使用在比较运算符(==)的场合；算术运算符(+, -, *, /, % 等)会对数据进行检查，阻止数据溢出。Swift也提供了两个C语言中没有的范围运算符(a..&lt;b和a...b)，用来快捷表达一个区域范围值。 赋值运算符​ 用来初始化或者更新左值12345var a = 5 let (x, y) = (1, 2) // x is equal to 1, and y is equal to 2if x = y &#123; // 存在语法错误，因为赋值运算符没有返回值&#125; 算术运算符​ Swift支持四个标准的算术运算符+, -, *, /；与其他语言不同的是，这些运算符默认情况下不允许被重写。另外+运算符也支持字符串连接。 取模运算符​ 与其他语言一样，注意一点：a % b的符号与a相同 单目运算符​ 包括单目+运算符和单目-运算符 复合赋值运算符​ 和C相同，Swift允许使用一个运算符和赋值运算符(=)来快捷组合，比如+=, -=。复合运算符也没有返回值。 比较运算符​ Swift支持所有标准C语言的比较运算符：a == b, a != b, a &gt; b, a &lt; b, a &gt;= b, a &lt;= b。另外，Swift还提供了’=== 和 !==’运算符来判断两个对象是否引用了同一个对象。比较运算符会返回布尔Bool类型值。也可以对元组类型使用比较运算符，元组的比较从左向右，每次比较一个元素。 注：Bool类型不能比较，Swift标准库中比较运算符元组为少于7个元素的元组，如果元素个数不符合条件，则需要自己实现比较运算符。 三目运算符​ 同其它语言一样，格式为question ? answer1 : answer2。 Nil-Coalescing运算符​ 格式为：(a ?? b)，解包’可选类型’a如果a包含一个值，则返回改值；否则返回默认值b。该运算符可以更加形象地用三目运算符表示：a != nil ? a! : b。且该运算符也有短路运算的特点。使用时需要注意有两点： a必须是可选类型 b的类型必须和a解包后的类型匹配 范围运算符​ 封闭范围运算符 (a…b) 包含边界a和b，其中必须满足a &lt;= b；半封闭范围运算符(a..&lt;b)包含a，但不包含b。其中必须满足a &lt; b。 逻辑运算符​ 三个C标准的逻辑运算符!a , a &amp;&amp; b , a || b，从左至右，有短路运算的特点。为了方便阅读，多逻辑运算符组合出现的时候建议多加括号(，)。 参照文档 BasicOperators &gt;&gt;&gt;&gt;&gt;&gt; ​Copyright (c) liangtong. All rights reserved.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift The Basics]]></title>
    <url>%2F2016%2F11%2F02%2FiOS_Swift_language_note_The-Basics%2F</url>
    <content type="text"><![CDATA[​ Swift的很多地方类似C和Objective-C语言。在Swift中，用Int表示整型，用Double和Float表示浮点类型，用Bool表示布尔类型，用String表示文本类型。另外还提供有一些集合类型，比如Array，Set和Dictionary。是一种类型安全的语言。​ Swift拥有和C语言类似变量和常量。还有一些高级的类型例如元组tuples（同PL/SQL中的类似）、不仅仅用在Class上的可选类型optional types(Optionals say either “there is a value, and it equals x” or “there isn’t a value at all”.) 常量和变量​ 常量和变量在使用前必须声明，使用var来声明变量，使用let来声明常量，例如 123let maximumNumberOfLoginAttempts = 10var currentLoginAttempt = 0var x = 0.0, y = 0.0, z = 0.0 ​ 可以通过let(var) name: type来明确常量或变量的类型，例如： 12var welcomeMessage: Stringvar red, green, blue: Double ​ 变量和常量的名称可以包括绝大多数字符（包括Unicode），但不能包含空格、数学符号、箭头以及一些无效的Unicode，且不能以数字开头。变量或者常量一旦被定义，其名称不能就不能被重复使用，或者改变其类型，也不能将变量改变为常量（反之也不可以）。 12var friendlyWelcome = "Hello!"let 你好 = "你好世界" ​ 通过print函数来输出查看结果： 1print("The current value of friendlyWelcome is \(friendlyWelcome)") 注释​ 和C语言类似，可以通过//进行单行注释；使用/*和*/进行多行注释，与C语言不同的是，多行注释在Swift中可以嵌套。例如： 12345678// This is a comment./* This is also a commentbut is written over multiple lines. *//* This is the start of the first multiline comment./* This is the second, nested multiline comment. */This is the end of the first multiline comment. */ 分号​ 和其他大部分语言不同的是，Swift不需要你在每个代码语句后边添加分号(;)，尽管写上也没问题 整型​ 包括无符号整型signed和有符号整型unsigned,Swift提供的整型是以8、16、32、64位格式的，例如：UInt8、Int32。​ 可以通过min和max两个属性值来查看边界值： 12let minValue = UInt8.min // minValue is equal to 0, and is of type UInt8let maxValue = UInt8.max // maxValue is equal to 255, and is of type UInt8 ​ 默认情况下，不需要在代码中指明特定的整数，对于Int，在32位系统中，默认为Int32，64位系统中，默认为Int64；对于UInt，在32位系统中，默认为UInt32，64位系统中，默认为UInt64 浮点类型​ Swift中提供两种有符号的浮点类型：用’Double’表示64位浮点类型数据，’Float’表示32位浮点类型。根据所需精度进行选择。 类型安全和类型推断​ Swift是一个类型安全的语言，意味着对类型区分很清晰，类型检查在编译的时候能确保在你的代码中不会出现因失误导致的类型赋值错误。当你没有明确你需要的类型时，Swfit使用类型推断帮助你选择合适的类型，这样Swift会帮你减少很大的代码量。 1234let meaningOfLife = 42// meaningOfLife is inferred to be of type Int//对于浮点类型，类型推断会将其定义为Doublelet pi = 3.14159// pi is inferred to be of type Double 数值常量​ 对于整型数值常量来说：十进制没有前缀，二进制以0b开头，八进制以0o开头，十六进制以0x开头 1234let decimalInteger = 17let binaryInteger = 0b10001 // 17 in binary notationlet octalInteger = 0o21 // 17 in octal notationlet hexadecimalInteger = 0x11 // 17 in hexadecimal notation ​ 浮点数值常量可以是十进制或者十六进制。其中十进制的浮点数值常量中使用字符e，代表的是10的exp幂；十六进制数值常量中使用字符p，，代表的是2的exp幂 1.25e2 means 1.25 x 10^2, or 125.0. 1.25e-2 means 1.25 x 10^-2, or 0.0125. 0xFp2 means 15 x 2^2, or 60.0. 0xFp-2 means 15 x 2^-2, or 3.75. ​ ​ 附小常识：数值常量可以通过添加额外的0或者下划线_来帮助阅读。不会影响具体值，例如： 123let oneMillion = 1_000_000let justOverOneMillion = 1_000_000.000_000_1let paddedDouble = 000123.456 数值类型转换​ 这部分需要注意值域问题，如果转换导致越界，会出现错误。别的没啥好说的，编译器会告诉你的。如果需要的话，转换过程举例如下（显示调用类型方法，比如Double(6) ）： Int8 -&gt; Int16 -&gt; Int -&gt; Double 类型别名​ 使用关键字typealias起别名，例如： 12typealias AudioSample = UInt16//起别名var maxAmplitudeFound = AudioSample.min//使用 布尔类型​ Swift中的布尔类型为Bool，两个值true和false。布尔值在if语句中很常用。与其他语言不同的是，if语句中必须为Bool值，否则会出现编译错误。 元组​ 将多个（不同类型的）数据组合成一个数据类型，可以使用任何你喜欢类型创建元组(Int, Int, Int),或者(String, Bool)，没有任何限制，一个元组的创建例子如下： 12let http404Error = (404, "Not Found")// http404Error is of type (Int, String), and equals (404, "Not Found") ​ 可以将元组的内容分解成独立的常量或变量来单独访问；当你只需要元组中的部分值时，其它部分可以通过下划线(_)忽略；当然也可以通过下标的形式来访问(下标从0开始)。例如： 1234567891011121314let (statusCode, statusMessage) = http404Errorprint("The status code is \(statusCode)")// Prints "The status code is 404"print("The status message is \(statusMessage)")// Prints "The status message is Not Found"let (justTheStatusCode, _) = http404Errorprint("The status code is \(justTheStatusCode)")// Prints "The status code is 404"print("The status code is \(http404Error.0)")// Prints "The status code is 404"print("The status message is \(http404Error.1)")// Prints "The status message is Not Found" ​ 定义元组的时候可以给单独的元素起名字，然后可以通过元素名字来访问具体的值，例如： 123456let http200Status = (statusCode: 200, description: "OK")print("The status code is \(http200Status.statusCode)")// Prints "The status code is 200"print("The status message is \(http200Status.description)")// Prints "The status message is OK" 当函数有多个返回值时，元组显得非常适用；但元组不适合于复杂的数据结构创建。 可选类型​ 当一个值可能不存在时，使用可选类型(optionals)，可选表示两种可能：要么存在一个值，你可以解包并访问其值；要么不存在。 ​ 注：可选的概念在C或者Objective-C中是不存在的，ObjC中一个相似点是一个方法要么返回一个对象，要么返回nil，但是在ObjC中仅适用于对象，不适用于结构体、基本C类型或者枚举类型。但是Swift中的可选适用于所有类型。 123let possibleNumber = "123"let convertedNumber = Int(possibleNumber)// convertedNumber is inferred to be of type "Int?", or "optional Int" nil​ 可以将nil赋值给一个可选类型变量。对于可选类型变量，如果声明的时候没有提供初始值，则默认被设置为nil。 ​ 注：nil不能被可选类型以外的变量或者常量适用，如果代码中一个变量需要处理不存在的情况，通常将其定义为可选类型。Swift中的nil和ObjC中的nil不同：ObjC中的nil是一个指向不存在的对象的指针；Swift中的nil不是指针，它是一个特定类型不存在的值，适用于所有Swift类型 1234567var serverResponseCode: Int? = 404// serverResponseCode contains an actual Int value of 404serverResponseCode = nil// serverResponseCode now contains no valuevar surveyAnswer: String?// surveyAnswer is automatically set to nil if语句和强制解包​ 可以通过使用If语句来确定一个可选类型是一个值或者是nil(使用操作符==或!=)。如果一个可选类型存在一个值，就可以通过在参数名后边添加!来强制解包该可选类型值。 注：[重要] 使用!的时候一定要确保可选类型的值是存在的，否则会出现运行时错误，导致程序闪退。 123if convertedNumber != nil &#123; print("convertedNumber has an integer value of \(convertedNumber!).")&#125; 可选绑定​ 在if和while语句中，可以通过使用可选绑定来检查可选值。if语句中使用可选绑定格式如下 12345if let constantName = someOptional &#123;//if var constantName non-nil-statements&#125; else &#123; nil-statement&#125; 可选类型的隐式解包​ 通常情况下，对于一个可选类型，如果在设置初始值后能够确定包含一个值，就没有必要每次通过可选绑定来进行检查、解包。这时可以通过在可选类型名后边添加!来隐式解包 12345let possibleString: String? = "An optional string."let forcedString: String = possibleString! // requires an exclamation mark let assumedString: String! = "An implicitly unwrapped optional string."let implicitString: String = assumedString // no need for an exclamation mark 错误处理在程序执行过程中，可以通过错误处理来响应程序运行期间遇到的错误。当一个函数遇到错误的时候，可以抛出，函数调用者捕捉该错误并做相应的相应处理。函数通过关键字throws来表明会抛出错误。当调用该类型的函数时，使用try关键字 12345678910func canThrowAnError() throws &#123; // this function may or may not throw an error&#125;do &#123; try canThrowAnError() // no error was thrown&#125; catch &#123;//默认error，当然你也可以使用多个catch，并明确具体的错误类型 比如：catch SandwichError.outOfCleanDishes // an error was thrown&#125; 断言​ 在一些特定的情况下，代码没有必要继续执行。这时候可以通过触发断言来终止代码的执行，并告知原因。 ​ 通常情况下，断言的使用时机： 在Debug的时候使用； 使用下标访问数据时； 函数入口参数检查时； 可选类型要求非nil时； 参照文档https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html &gt;&gt;&gt;&gt;&gt;&gt; ​Copyright (c) liangtong. All rights reserved.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C 知识普及]]></title>
    <url>%2F2016%2F10%2F30%2FiOS_develop_ObjC_basic%2F</url>
    <content type="text"><![CDATA[讲述闭包、协议、常用传值方式，交流时会结合参与的项目进行 闭包​ 一种带有局部变量的匿名函数。语法结构：^ 返回值类型 参数列表 表达式 比如： 1^int(int count)&#123;return count+1;&#125; block的声明及使用 12345678910//声明int(^blk) (int) = ^(int count)&#123;return count+1;&#125;;//使用 - 作为参数void function(int(^blk)(int))//使用 - 作为返回值int (^func())(int) &#123;return ^(int count)&#123;return count+1;&#125;&#125; 使用 typedef 简化 1234567891011typedef int (^blk_t) (int);//原来的写法void func(int (^blk)(int))//新的写法void func(blk_t blk)//原来的写法int (^func()(int))//新的写法blk_t func() Objective-C代码中常用的写法举例 12345678910111213141516//点击课程更多按钮菜单的回调@property (nonatomic,copy) void(^courseMoreActionBlock)(EMoocCourseMoreActionType actionType, NSString* courseId);///#begin/** * @brief 用户提交登录请求 * * @param userName 登录名字 * @param password 登录密码 * @param complete 回调函数 *////#end+(void)loginWithName:(NSString*)userName password:(NSString*)password progress:(void (^)(NSProgress *progress))progress complete:(void (^)(id data,NSInteger stateCode))complete; 注意点block 只读block外的属性，不可修改。__block可破坏闭包，其修饰的属性可以在block内修改。使用block的时候，特别要注意循环引用的问题 协议​ 类似Java中的interface。在ObjC中使用@protocol定义一组方法规范，实现此协议的类必须实现对应的方法。例如常用的UITableViewDelegate协议格式： 123456789@protocol UITableViewDelegate&lt;NSObject, UIScrollViewDelegate&gt;//可以扩展多个协议@required //必须实现的方法- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;@optional //可选实现的方法- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;@end 注意点 协议方法的实现。 @required //必须实现的方法(或者属性) @optional //可选实现的方法(或者属性) 调用delegate（实现协议的委托对象）方法时，如果是可选方法，一定要通过@selector进行判断 常用传值方式​ 这里说的传值方式，不包括View&lt;-&gt;ViewController之间的Outlet、Target、Action等 闭包一言不合就上代码：注意__weak和__strong的使用 123456789101112131415161718192021//闭包作为属性的例子@property (nonatomic,copy) void(^didTapCallBack)(id tapedItem);//使用__weak __typeof(self) weakSelf = self;obj1.didTapCallBack = ^(NSDictionary* tapedItem)&#123; __strong __typeof(weakSelf)strongSelf = weakSelf; [strongSelf performSegueWithIdentifier:@&quot;showNextSegue” sender: tapedItem];&#125;;//闭包作为参数使用的例子：-(void)functionNameWithParamName1:(id)paramName1 completeBlock:(NSDictionary* (^)(NSString* blockParam))completeBlock//使用[obj2 functionNameWithParamName1:@“” completeBlock:^NSDictionary*(NSString* blockParam) &#123; if (blockParam)&#123; return @[]; &#125;else&#123; return nil; &#125;&#125;]; 协议​ 很常用的形式，比如UITableView、UIScrollView等UIKit框架中都是使用Protocol。 代码写起来清晰易懂 相对闭包来说代码量变大，第三者不容易理解 ​ 共有方法(属性)​ 这块没啥说的，就是直接在.h文件中写属性，方法，对象直接调用（设置）即可 KVO​ 比较常用，一般Model、ViewModel层通过发广播的形式进行消息发送(数据传输)。 &gt;&gt;&gt;&gt;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ViewController Life-Circle]]></title>
    <url>%2F2016%2F10%2F25%2FiOS_develop_viewController_life_circle%2F</url>
    <content type="text"><![CDATA[对ViewController生命周期进行介绍，同时会说一些曾经遇到过的坑及注意事项 前言​ 这部分其实没啥好说的，苹果UIViewController接口文档对各个接口的描述写的很详细。​ 在视图的生命周期中，我曾经出问题的地方包括是UI表现异常；通知监听与释放没有成对出现；异步闭包回调引起的循环引用的资源无法释放；__weak和__strong问题导致的程序闪退等。这里就是把这些坑给记下来，（如果你碰巧）遇到这类问题后不会感到莫名其妙。 UIViewController的生命周期 视图出现的时候调用顺序 - (void)viewDidLoad; // Called after the view has been loaded.just once - (void)viewWillAppear:(BOOL)animated; // Called when the view is about to made visible. Default does nothing // Called just before the view controller&apos;s view&apos;s layoutSubviews method is invoked. Subclasses can implement as necessary. The default is a nop. - (void)viewWillLayoutSubviews NS_AVAILABLE_IOS(5_0); // Called just after the view controller&apos;s view&apos;s layoutSubviews method is invoked. Subclasses can implement as necessary. The default is a nop. - (void)viewDidLayoutSubviews NS_AVAILABLE_IOS(5_0); - (void)viewDidAppear:(BOOL)animated; // Called when the view has been fully transitioned onto the screen. Default does nothing 视图离开屏幕的时候调用顺序 - (void)viewWillDisappear:(BOOL)animated; // Called when the view is dismissed, covered or otherwise hidden. Default does nothing - (void)viewDidDisappear:(BOOL)animated; // Called after the view was dismissed, covered or otherwise hidden. Default does nothing 说明及最佳实践1- (void)viewDidLoad； 很常用、很重要的方法，只是在APP页面加载的时候调用一次，以后不会再调用了。通常做一些初始化设置，但是UI相关的设置不要放在这里当然，iOS6之前早期系统上，没有AutoLayout，使用绝对布局在这里更新UI问题不大 1- (void)viewWillAppear:(BOOL)animated； 视图即将出现在屏幕上，会调用该方法。重写该方法，可以做一些UI相关设置，以及KVO监听之类操作当APP视图间进行切换的时候，也会调用该方法 1- (void)viewWillLayoutSubviews； 在viewWillAppare后调用，将要对子视图进行布局 1- (void) viewDidLayoutSubviews； 已经布局完成子视图 1- (void)viewDidAppear:(BOOL)animated； 视图出现在屏幕上，会调用该方法。重写该方法，可以做一些UI更新设置 1- (void)viewWillDisappear:(BOOL)animated； 视图变换，即将离开屏幕时，会调用该方法。重写该方法，做一些善后的处理工作，比如持久化处理、移除KVO监听之类的 1- (void)viewDidDisappear:(BOOL)animated； 视图变换，离开屏幕时，会调用该方法。重写该方法，对已消失的视图做一些操作，比如释放资源 补充 UI表示异常的话，多半是在不正确的时机调用了UI相关设置。 资源释放，尤其涉及视频、监听相关内容。 异步操作，涉及闭包，协议等操作时，要谨慎。 例如：使用__weakSelf和__strongSelf打破循环引用 例如：使用@selector前要判断 其他 ​ 后记​ 在这里遇到问题的话，一定要静下心。举个例子，比如你在viewDidLoad方法内有关于某个对象的回调处理。 123_obj.testBlock = ^()&#123; //your test block process&#125;; 但是实际开发中没有触发。可以从以下几个方向去调查： _obj对应类/结构体中是否会调用（绑定）该闭包； _obj的作用域：是全局的还是堆栈的； 该闭包是否在其他地方进行了设置； 其他。 &gt;&gt;&gt;&gt;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS移动App开发综述]]></title>
    <url>%2F2016%2F10%2F21%2FiOS_develop_overview_framework_1%2F</url>
    <content type="text"><![CDATA[对iOS端移动App使用的开发语言、框架等信息进行介绍 环境及工具 OS macOS , OSX TOOL XCode： Version 8.0+ , 早期版本 建议：鉴于苹果的习惯，如果没有特殊需求，保持最新的系统和工具版本。 开发语言选择​ 首先要对开发的应用的功能有一定的了解，结合应用需要的功能及部署系统版本选择合适的开发语言。可以使用的主要开发语言包括： Objective-C： 优点：老牌iOS开发语言，很多成熟稳定的开源代码可以使用；可以用来开发各个iOS系统上的应用。 缺点：苹果已经开始主推Swift；语言较复杂，比如虽然引入了ARC概念，但是部分内存管理还是需要自己来搞定； Swift：苹果在2014年WWDC上发布的语言（函数式编程Monad，最低支持iOS7.0系统)，建议多使用结构体。 优点：苹果主推的取代Objective-C语言，开源、易学易用、借鉴了好多主流开发语言(很多概念比如：泛型，闭包，元组，协议等)，如果熟悉数据库，JavaScript、Objective-C等的话，可以快速入手 缺点：新语言，对旧系统不支持、多语言混合编译存在一些桥接问题； 其它：C/C++​ 如果想快速开发应用，建议使用Objective-C，毕竟有很多现成的东西； 长远的看的话，建议使用Swift，新东西还是很让人兴奋的； Swift语言选择3.0以上的版本，因为XCode8.0及后续工具不兼容3.0之前的语言版本； 如果项目中必须引入C++混合编译，建议使用Objective-C，Swift调用C代码还好，调用C++目前来说不可行。 没啥想法，建议前期使用Objective-C和Swift混合开发，最终全面向Swift过渡。 程序框架选择​ 这里主要介绍两个框架MVC和MVVM，以及最终程序开发中使用的MVMCV MVC​ MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。 View：负责数据展示。 应用程序中用户可以看见的对象。在iOS应用程序开发中，所有的控件、窗口等都继承自 UIView，UIView及其子类主要负责UI的实现，而UIView所产生的事件都可以采用委托的方式，交给UIViewController实现。 Controller：处理输入输出。 View和Model之间交互的媒介，控制器对象解释在视图对象中进行的用户操作，并将新的或更改过的数据传达给模型对象。模型对象更改时，一个控制器对象会将新的模型数据传达给视图对象，以便视图对象可以显示它。对于不同的UIView，有相应的UIViewController，例如在iOS上常用的UITableView，它所对应的Controller就是UITableViewController。 Model：持有数据，比如本地数据库，本地文件。​ ​ iOS应用中，对应UIViewController其实可以理解为ViewContainer（View + Controler）；如果使用MVC框架进行移动App开发的话，ViewController会显得特别臃肿，并且如果更换Controller策略就会显得比较麻烦。对于功能复杂的页面，其ViewController结构将会非常庞大，后期维护代价明显会比较高。 MVVM​ MVVM代表的是Model View View-Model，她的出现可以理解成是给MVC的视图控制器瘦身。 View：负责数据展示。 包含实际 UI 本身(不论是 UIView 代码, storyboard 和 xib), 任何视图特定的逻辑, 和对用户输入的反馈. 在 iOS 中这不仅需要 UIView 代码和那些文件, 还包括很多需由 UIViewController 处理的工作。 View-Model ：处理输入输出。 它的职责之一就是作为一个表现视图显示自身所需数据的静态模型;但它也有收集, 解释和转换那些数据的责任. 这留给了 view (controller) 一个更加清晰明确的任务: 呈现由 view-model 提供的数据。 Model：持有数据，比如本地数据库，本地文件。​ ​ 说下View-Model：它从必要的资源(数据库, 网络服务调用, 等)中获取原始数据, 运用逻辑, 并处理成 view (controller) 的展示数据. 它(通常通过属性)暴露给视图控制器需要知道的仅关于显示视图工作的信息(理想地你不会暴漏你的 data-model 对象)。 它还负责对上游数据的修改(比如更新模型/数据库, API POST 调用)。 MVC与MVVM的对比​ 经过上边对MVC和MVVM的介绍，相信大家对两种模式简单的映射关系有了一定的了解。通过对比，我们会发现视图控制器是非常大的。 MVMCV的产生​ 如果将两者结合，会是什么样子呢​ 结果就说MVMCV产生了。 ​ view-model会在视图控制器上以一个属性的方式存在. 视图控制器知道 view-model 和它的公有属性, 但是 view-model 对视图控制器一无所知. 你早就该对这个设计感觉好多了因为我们的关注点在这儿进行更好地分离.最后我们用一个应用构建模块层级图来结束这节介绍： 第三方应用的使用 手动将别人的代码拖拽到自己工程中。 优点：随时可以修改别人的代码。 缺点：需要自己维护该代码。 通过pod引用 优点：大家一起维护，代码质量高；代码更新只要一句pod update一切都搞定 缺点：如果发现问题，修改可能会比较慢 建议：如果不涉及UI，尽量使用pod来管理；使用GitHub第三方代码的时候需要注意几点：star、watch数量，还有活跃度。别选那种没人用的，不然后期出了问题你就很可能只能靠自己了 发布相关 签名Code Sign App标识符 开发证书 发布证书 APNS 开发证书 发布证书 其他 学习建议 如果有一定的语言基础，不用看「xx从入门到精通」之类的书。因为技术更新很快，书上很多东西都过时或者被弃用了 多看看苹果开发者文档，接口文档介绍的非常详细。 多逛逛GitHub，学习GitHub上一些牛人的思想，编码风格。链接 ： Objective-C 排行 &gt;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LTxMenu]]></title>
    <url>%2F2016%2F10%2F20%2FiOS_ObjC_LTxMenu_v1.0.0%2F</url>
    <content type="text"><![CDATA[content{:toc} [ Update v1.0.0 ] Similar to Facebook News Feed , Alipay Life , QZone and other social applications . click a drop-down button to display more functions Introduction​ In Facebook News Feed , Alipay Life , QZone and other social applications , they all contain a function drop-down button which would show a list of more functions when taped . I didn’t find any on GitHub , so I wrote a similar UI controls myself using Objective-C. ： GitHub link : LTxMenu Get Start Manually add the files into your Xcode project. LTxMenu is available as LTxMenu in Cocoapods. How To Use​ Create a LTxMenuView Object: 1@property (nonatomic, strong)LTxMenuView* menuView; ​ I was too lazy to write a protocol 😄，use callback methods： 123456789101112131415161718192021_menuView = [[LTxMenuView alloc] init];//init__weak __typeof(self) weakSelf = self;_menuView.numberOfRows = ^()&#123;//row numbers return (int)weakSelf.menuItems.count;&#125;;_menuView.heightForRow = ^(NSInteger row)&#123;//height of a row return 50.f;&#125;;_menuView.rowAtIndex = ^(NSInteger row)&#123;//the content of a row NSDictionary* menuItem = [weakSelf.menuItems objectAtIndex:row]; return [LTxMenuItem menuItemWithImage:[menuItem objectForKey:@&quot;image&quot;] title:[menuItem objectForKey:@&quot;title&quot;] rightBtnItems:[menuItem objectForKey:@&quot;more&quot;]//An array contains subClass of UIView tapBlock:^(NSString *identifier) &#123; NSLog(@&quot;tap at %@&quot;,identifier); __strong __typeof(weakSelf)strongSelf = weakSelf; [strongSelf.menuView dismissMenu]; &#125;];&#125;;[_menuView showMenuInView:self.view fromRect:sender.frame]; How it works​ LTxMenu use LTxMenuItem class to config view showed in row. and LTxMenuView class with callback methods to calculate the UI performance . draw arrow and the border use UIBezierPath class . and the show/hide animation use UIKit. Reference​ https://github.com/kolyvan/kxmenu]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Menu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UISearchBar自定义]]></title>
    <url>%2F2016%2F10%2F19%2FiOS_ObjC_SearchBar%2F</url>
    <content type="text"><![CDATA[参照一些常用应用对UISearchBar进行UI展示自定义 前言​ 系统默认的搜索栏（UISearchBar）默认样子真心不好看，而平时iOS移动项目中又缺不了搜索功能，参照一些常用应用对UISearchBar进行UI展示自定义，效果图如下： UISearchBar介绍​ 如图所示，包括placeholder、textfiled、clearButton、bookmarkButton、leftView等： ① SearchBar的TextField的leftView； ② SearchBar的TextField的placeholder； ③ SearchBar的BookmarkIcon，默认不显示； ④ SearchBar的搜索Text； ⑤ SearchBar的ClearButton； 实现步骤 1、修改SearchBar背景图 12//修改SearchBar背景（透明）图片，去除默认的黑线[self setBackgroundImage:[UIImage new]]; 2、修改所搜索框背景图片，并切圆角 1234//输入框背景图片[self setSearchFieldBackgroundImage:[self searchFieldBackgroundImage] forState:UIControlStateNormal];//将输入框切圆角[self setSearchTextBackgroundCorner]; 3、显示BookmarkButton，并设置其显示图标 123//显示BookmarkButton，并设置其图标（照相机）self.showsBookmarkButton = YES;[self setImage:[UIImage imageNamed:@&quot;ic_searchbar_camera&quot;] forSearchBarIcon:UISearchBarIconBookmark state:UIControlStateNormal]; 4、设置「清空」图标图标 123//文本发生变更的时候，修改「清空」图标[self setImage:[UIImage imageNamed:@&quot;ic_searchbar_clear&quot;] forSearchBarIcon:UISearchBarIconClear state:UIControlStateNormal];[self setImage:[UIImage imageNamed:@&quot;ic_searchbar_clear&quot;] forSearchBarIcon:UISearchBarIconClear state:UIControlStateHighlighted]; 5、修改搜索框左侧的图标 12345//搜索框左侧的搜索图标修改（默认是灰色）UITextField* searchField = [self valueForKey:@&quot;_searchField&quot;];UIImageView* searchIV = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;ic_searchbar_search&quot;]];searchField.leftView = searchIV;searchField.leftViewMode = UITextFieldViewModeAlways; 6、修改输入框文本颜色 1234//改变searcher的textcolorsearchField.textColor = [UIColor whiteColor];//改变placeholder的颜色[searchField setValue:[UIColor whiteColor] forKeyPath:@&quot;_placeholderLabel.textColor&quot;]; 7、附上调用方法 123456789101112131415161718192021222324252627282930//搜索框的背景图片- (UIImage*) searchFieldBackgroundImage&#123; CGFloat height = 32.f; UIColor* bgColor = [UIColor colorWithRed:47/255.0 green:123/255.0 blue:200/255.0 alpha:0.5]; CGRect r= CGRectMake(0.0f, 0.0f, 1.0f, height); UIGraphicsBeginImageContext(r.size); CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetFillColorWithColor(context, [bgColor CGColor]); CGContextFillRect(context, r); UIImage *img = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return img;&#125;//切圆角-(void)setSearchTextBackgroundCorner&#123; for (UIView *subview in self.subviews) &#123; for(UIView* grandSonView in subview.subviews)&#123; if ([grandSonView isKindOfClass:NSClassFromString(@&quot;UISearchBarBackground&quot;)]) &#123; grandSonView.alpha = 0.0f; &#125;else if([grandSonView isKindOfClass:NSClassFromString(@&quot;UISearchBarTextField&quot;)] )&#123; grandSonView.layer.cornerRadius = 5.0f; grandSonView.layer.masksToBounds = YES; &#125;else&#123; grandSonView.alpha = 0.0f; &#125; &#125; &#125;&#125; 源码下载https://pan.baidu.com/s/1i5JiW3z 参考资料https://developer.apple.com/reference/uikit/uisearchbar http://stackoverflow.com/questions/2139115/uisearchbar-clear-background-color-or-set-background-image-iphone-sdk/5557255#5557255]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Note</tag>
      </tags>
  </entry>
</search>
